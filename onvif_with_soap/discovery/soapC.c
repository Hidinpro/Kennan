/* soapC.c
   Generated by gSOAP 2.8.131 for onvif.h

gSOAP XML Web services tools
Copyright (C) 2000-2023, Robert van Engelen, Genivia Inc. All Rights Reserved.
The soapcpp2 tool and its generated software are released under the GPL.
This program is released under the GPL with the additional exemption that
compiling, linking, and/or using OpenSSL is allowed.
--------------------------------------------------------------------------------
A commercial use license is available from Genivia Inc., contact@genivia.com
--------------------------------------------------------------------------------
*/

#if defined(__BORLANDC__)
#pragma option push -w-8060
#pragma option push -w-8004
#endif

#include "soapH.h"

SOAP_SOURCE_STAMP("@(#) soapC.c ver 2.8.131 2023-12-05 09:21:32 GMT")


#ifndef WITH_NOGLOBAL

SOAP_FMAC3 int SOAP_FMAC4 soap_getheader(struct soap *soap)
{
	soap->part = SOAP_IN_HEADER;
	soap->header = soap_in_SOAP_ENV__Header(soap, "SOAP-ENV:Header", soap->header, NULL);
	soap->part = SOAP_END_HEADER;
	return soap->header == NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_putheader(struct soap *soap)
{
	if (soap->version && soap->header)
	{	soap->part = SOAP_IN_HEADER;
		if (soap_out_SOAP_ENV__Header(soap, "SOAP-ENV:Header", 0, soap->header, ""))
			return soap->error;
		soap->part = SOAP_END_HEADER;
	}
	return SOAP_OK;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serializeheader(struct soap *soap)
{
	if (soap->version && soap->header)
		soap_serialize_SOAP_ENV__Header(soap, soap->header);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_header(struct soap *soap)
{
	if (soap->header == NULL)
	{	if ((soap->header = (struct SOAP_ENV__Header*)soap_malloc(soap, sizeof(struct SOAP_ENV__Header))))
			soap_default_SOAP_ENV__Header(soap, soap->header);
	}
}

SOAP_FMAC3 void SOAP_FMAC4 soap_fault(struct soap *soap)
{
	if (soap->fault == NULL)
	{	soap->fault = soap_new_SOAP_ENV__Fault(soap, -1);
		if (soap->fault == NULL)
			return;
	}
	if (soap->version == 2 && soap->fault->SOAP_ENV__Code == NULL)
		soap->fault->SOAP_ENV__Code = soap_new_SOAP_ENV__Code(soap, -1);
	if (soap->version == 2 && soap->fault->SOAP_ENV__Reason == NULL)
		soap->fault->SOAP_ENV__Reason = soap_new_SOAP_ENV__Reason(soap, -1);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serializefault(struct soap *soap)
{
	if (soap->fault)
		soap_serialize_SOAP_ENV__Fault(soap, soap->fault);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_putfault(struct soap *soap)
{
	if (soap->fault)
		return soap_put_SOAP_ENV__Fault(soap, soap->fault, "SOAP-ENV:Fault", "");
	return SOAP_OK;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_getfault(struct soap *soap)
{
	return (soap->fault = soap_get_SOAP_ENV__Fault(soap, NULL, "SOAP-ENV:Fault", NULL)) == NULL;
}

SOAP_FMAC3 const char ** SOAP_FMAC4 soap_faultcode(struct soap *soap)
{
	soap_fault(soap);
	if (soap->fault == NULL)
		return NULL;
	if (soap->version == 2 && soap->fault->SOAP_ENV__Code)
		return (const char**)(void*)&soap->fault->SOAP_ENV__Code->SOAP_ENV__Value;
	return (const char**)(void*)&soap->fault->faultcode;
}

SOAP_FMAC3 const char ** SOAP_FMAC4 soap_faultsubcode(struct soap *soap)
{
	soap_fault(soap);
	if (soap->fault == NULL)
		return NULL;
	if (soap->version == 2 && soap->fault->SOAP_ENV__Code)
	{	if (soap->fault->SOAP_ENV__Code->SOAP_ENV__Subcode == NULL)
		{	soap->fault->SOAP_ENV__Code->SOAP_ENV__Subcode = soap_new_SOAP_ENV__Code(soap, -1);
			if (soap->fault->SOAP_ENV__Code->SOAP_ENV__Subcode == NULL)
				return NULL;
		}
		return (const char**)(void*)&soap->fault->SOAP_ENV__Code->SOAP_ENV__Subcode->SOAP_ENV__Value;
	}
	return (const char**)(void*)&soap->fault->faultcode;
}

SOAP_FMAC3 const char * SOAP_FMAC4 soap_fault_subcode(struct soap *soap)
{
	if (!soap->fault)
		return NULL;
	if (soap->version == 2)
		return soap->fault->SOAP_ENV__Code && soap->fault->SOAP_ENV__Code->SOAP_ENV__Subcode ? soap->fault->SOAP_ENV__Code->SOAP_ENV__Subcode->SOAP_ENV__Value : NULL;
	return soap->fault->faultcode;
}

SOAP_FMAC3 const char ** SOAP_FMAC4 soap_faultstring(struct soap *soap)
{
	soap_fault(soap);
	if (soap->fault == NULL)
		return NULL;
	if (soap->version == 2 && soap->fault->SOAP_ENV__Reason)
		return (const char**)(void*)&soap->fault->SOAP_ENV__Reason->SOAP_ENV__Text;
	return (const char**)(void*)&soap->fault->faultstring;
}

SOAP_FMAC3 const char * SOAP_FMAC4 soap_fault_string(struct soap *soap)
{
	const char **s = soap_faultstring(soap);
	return s ? *s : NULL;
}

SOAP_FMAC3 const char ** SOAP_FMAC4 soap_faultdetail(struct soap *soap)
{
	soap_fault(soap);
	if (soap->fault == NULL)
		return NULL;
	if (soap->version == 2)
	{	if (soap->fault->SOAP_ENV__Detail == NULL)
			soap->fault->SOAP_ENV__Detail = soap_new_SOAP_ENV__Detail(soap, -1);
		return (const char**)(void*)&soap->fault->SOAP_ENV__Detail->__any;
	}
	if (soap->fault->detail == NULL)
		soap->fault->detail = soap_new_SOAP_ENV__Detail(soap, -1);
	return (const char**)(void*)&soap->fault->detail->__any;
}

SOAP_FMAC3 const char * SOAP_FMAC4 soap_fault_detail(struct soap *soap)
{
	const char **s = soap_faultdetail(soap);
	return s ? *s : NULL;
}

#endif

#ifndef WITH_NOIDREF
SOAP_FMAC3 int SOAP_FMAC4 soap_getindependent(struct soap *soap)
{
	int t;
	if (soap->version == 1)
	{	for (;;)
		{	if (!soap_getelement(soap, NULL, &t))
				if ((soap->error && soap->error != SOAP_TAG_MISMATCH) || soap_ignore_element(soap))
					break;
		}
	}
	if (soap->error == SOAP_NO_TAG || soap->error == SOAP_EOF)
		soap->error = SOAP_OK;
	return soap->error;
}
#endif
SOAP_FMAC3 void * SOAP_FMAC4 soap_getelement(struct soap *soap, const char *tag, int *type)
{	(void)type;
	if (soap_peek_element(soap))
		return NULL;
#ifndef WITH_NOIDREF
	if (!*soap->id || !(*type = soap_lookup_type(soap, soap->id)))
		*type = soap_lookup_type(soap, soap->href);
	switch (*type)
	{
	case SOAP_TYPE_byte:
		return soap_in_byte(soap, tag, NULL, "xsd:byte");
	case SOAP_TYPE_int:
		return soap_in_int(soap, tag, NULL, "xsd:int");
	case SOAP_TYPE_xsd__duration:
		return soap_in_xsd__duration(soap, tag, NULL, "xsd:duration");
	case SOAP_TYPE_float:
		return soap_in_float(soap, tag, NULL, "xsd:float");
	case SOAP_TYPE_unsignedInt:
		return soap_in_unsignedInt(soap, tag, NULL, "xsd:unsignedInt");
	case SOAP_TYPE_ULONG64:
		return soap_in_ULONG64(soap, tag, NULL, "xsd:unsignedLong");
	case SOAP_TYPE_dateTime:
		return soap_in_dateTime(soap, tag, NULL, "xsd:dateTime");
	case SOAP_TYPE_tt__IPType:
		return soap_in_tt__IPType(soap, tag, NULL, "tt:IPType");
	case SOAP_TYPE_tt__H264Profile:
		return soap_in_tt__H264Profile(soap, tag, NULL, "tt:H264Profile");
	case SOAP_TYPE_tt__Mpeg4Profile:
		return soap_in_tt__Mpeg4Profile(soap, tag, NULL, "tt:Mpeg4Profile");
	case SOAP_TYPE_tt__VideoEncoding:
		return soap_in_tt__VideoEncoding(soap, tag, NULL, "tt:VideoEncoding");
	case SOAP_TYPE_tt__PropertyOperation:
		return soap_in_tt__PropertyOperation(soap, tag, NULL, "tt:PropertyOperation");
	case SOAP_TYPE_tt__MoveStatus:
		return soap_in_tt__MoveStatus(soap, tag, NULL, "tt:MoveStatus");
	case SOAP_TYPE_tt__CapabilityCategory:
		return soap_in_tt__CapabilityCategory(soap, tag, NULL, "tt:CapabilityCategory");
	case SOAP_TYPE_xsd__boolean:
		return soap_in_xsd__boolean(soap, tag, NULL, "xsd:boolean");
	case SOAP_TYPE_saml2__DecisionType:
		return soap_in_saml2__DecisionType(soap, tag, NULL, "saml2:DecisionType");
	case SOAP_TYPE_saml1__DecisionType:
		return soap_in_saml1__DecisionType(soap, tag, NULL, "saml1:DecisionType");
	case SOAP_TYPE_wsc__FaultCodeType:
		return soap_in_wsc__FaultCodeType(soap, tag, NULL, "wsc:FaultCodeType");
	case SOAP_TYPE_wsse__FaultcodeEnum:
		return soap_in_wsse__FaultcodeEnum(soap, tag, NULL, "wsse:FaultcodeEnum");
	case SOAP_TYPE_wsu__tTimestampFault:
		return soap_in_wsu__tTimestampFault(soap, tag, NULL, "wsu:tTimestampFault");
	case SOAP_TYPE__wsa5__IsReferenceParameter:
		return soap_in__wsa5__IsReferenceParameter(soap, tag, NULL, "wsa5:IsReferenceParameter");
	case SOAP_TYPE_wsa5__FaultCodesType:
		return soap_in_wsa5__FaultCodesType(soap, tag, NULL, "wsa5:FaultCodesType");
	case SOAP_TYPE_wsa5__RelationshipType:
		return soap_in_wsa5__RelationshipType(soap, tag, NULL, "wsa5:RelationshipType");
	case SOAP_TYPE_wsdd__FaultCodeType:
		return soap_in_wsdd__FaultCodeType(soap, tag, NULL, "wsdd:FaultCodeType");
	case SOAP_TYPE_wsa__FaultSubcodeValues:
		return soap_in_wsa__FaultSubcodeValues(soap, tag, NULL, "wsa:FaultSubcodeValues");
	case SOAP_TYPE_wsa__RelationshipTypeValues:
		return soap_in_wsa__RelationshipTypeValues(soap, tag, NULL, "wsa:RelationshipTypeValues");
	case SOAP_TYPE_wstop__TopicType:
		return soap_in_wstop__TopicType(soap, tag, NULL, "wstop:TopicType");
	case SOAP_TYPE_wstop__TopicNamespaceType:
		return soap_in_wstop__TopicNamespaceType(soap, tag, NULL, "wstop:TopicNamespaceType");
	case SOAP_TYPE_wsnt__ResumeFailedFaultType:
		return soap_in_wsnt__ResumeFailedFaultType(soap, tag, NULL, "wsnt:ResumeFailedFaultType");
	case SOAP_TYPE_wsnt__PauseFailedFaultType:
		return soap_in_wsnt__PauseFailedFaultType(soap, tag, NULL, "wsnt:PauseFailedFaultType");
	case SOAP_TYPE_wsnt__UnableToDestroySubscriptionFaultType:
		return soap_in_wsnt__UnableToDestroySubscriptionFaultType(soap, tag, NULL, "wsnt:UnableToDestroySubscriptionFaultType");
	case SOAP_TYPE_wsnt__UnacceptableTerminationTimeFaultType:
		return soap_in_wsnt__UnacceptableTerminationTimeFaultType(soap, tag, NULL, "wsnt:UnacceptableTerminationTimeFaultType");
	case SOAP_TYPE_wsnt__UnableToCreatePullPointFaultType:
		return soap_in_wsnt__UnableToCreatePullPointFaultType(soap, tag, NULL, "wsnt:UnableToCreatePullPointFaultType");
	case SOAP_TYPE_wsnt__UnableToDestroyPullPointFaultType:
		return soap_in_wsnt__UnableToDestroyPullPointFaultType(soap, tag, NULL, "wsnt:UnableToDestroyPullPointFaultType");
	case SOAP_TYPE_wsnt__UnableToGetMessagesFaultType:
		return soap_in_wsnt__UnableToGetMessagesFaultType(soap, tag, NULL, "wsnt:UnableToGetMessagesFaultType");
	case SOAP_TYPE_wsnt__NoCurrentMessageOnTopicFaultType:
		return soap_in_wsnt__NoCurrentMessageOnTopicFaultType(soap, tag, NULL, "wsnt:NoCurrentMessageOnTopicFaultType");
	case SOAP_TYPE_wsnt__UnacceptableInitialTerminationTimeFaultType:
		return soap_in_wsnt__UnacceptableInitialTerminationTimeFaultType(soap, tag, NULL, "wsnt:UnacceptableInitialTerminationTimeFaultType");
	case SOAP_TYPE_wsnt__NotifyMessageNotSupportedFaultType:
		return soap_in_wsnt__NotifyMessageNotSupportedFaultType(soap, tag, NULL, "wsnt:NotifyMessageNotSupportedFaultType");
	case SOAP_TYPE_wsnt__UnsupportedPolicyRequestFaultType:
		return soap_in_wsnt__UnsupportedPolicyRequestFaultType(soap, tag, NULL, "wsnt:UnsupportedPolicyRequestFaultType");
	case SOAP_TYPE_wsnt__UnrecognizedPolicyRequestFaultType:
		return soap_in_wsnt__UnrecognizedPolicyRequestFaultType(soap, tag, NULL, "wsnt:UnrecognizedPolicyRequestFaultType");
	case SOAP_TYPE_wsnt__InvalidMessageContentExpressionFaultType:
		return soap_in_wsnt__InvalidMessageContentExpressionFaultType(soap, tag, NULL, "wsnt:InvalidMessageContentExpressionFaultType");
	case SOAP_TYPE_wsnt__InvalidProducerPropertiesExpressionFaultType:
		return soap_in_wsnt__InvalidProducerPropertiesExpressionFaultType(soap, tag, NULL, "wsnt:InvalidProducerPropertiesExpressionFaultType");
	case SOAP_TYPE_wsnt__MultipleTopicsSpecifiedFaultType:
		return soap_in_wsnt__MultipleTopicsSpecifiedFaultType(soap, tag, NULL, "wsnt:MultipleTopicsSpecifiedFaultType");
	case SOAP_TYPE_wsnt__TopicNotSupportedFaultType:
		return soap_in_wsnt__TopicNotSupportedFaultType(soap, tag, NULL, "wsnt:TopicNotSupportedFaultType");
	case SOAP_TYPE_wsnt__InvalidTopicExpressionFaultType:
		return soap_in_wsnt__InvalidTopicExpressionFaultType(soap, tag, NULL, "wsnt:InvalidTopicExpressionFaultType");
	case SOAP_TYPE_wsnt__TopicExpressionDialectUnknownFaultType:
		return soap_in_wsnt__TopicExpressionDialectUnknownFaultType(soap, tag, NULL, "wsnt:TopicExpressionDialectUnknownFaultType");
	case SOAP_TYPE_wsnt__InvalidFilterFaultType:
		return soap_in_wsnt__InvalidFilterFaultType(soap, tag, NULL, "wsnt:InvalidFilterFaultType");
	case SOAP_TYPE_wsnt__SubscribeCreationFailedFaultType:
		return soap_in_wsnt__SubscribeCreationFailedFaultType(soap, tag, NULL, "wsnt:SubscribeCreationFailedFaultType");
	case SOAP_TYPE_trt__ProfileCapabilities:
		return soap_in_trt__ProfileCapabilities(soap, tag, NULL, "trt:ProfileCapabilities");
	case SOAP_TYPE_trt__Capabilities:
		return soap_in_trt__Capabilities(soap, tag, NULL, "trt:Capabilities");
	case SOAP_TYPE_wstop__QueryExpressionType:
		return soap_in_wstop__QueryExpressionType(soap, tag, NULL, "wstop:QueryExpressionType");
	case SOAP_TYPE_wstop__ExtensibleDocumented:
		return soap_in_wstop__ExtensibleDocumented(soap, tag, NULL, "wstop:ExtensibleDocumented");
	case SOAP_TYPE_wstop__Documentation:
		return soap_in_wstop__Documentation(soap, tag, NULL, "wstop:Documentation");
	case SOAP_TYPE_wsrfbf__BaseFaultType:
		return soap_in_wsrfbf__BaseFaultType(soap, tag, NULL, "wsrfbf:BaseFaultType");
	case SOAP_TYPE_wstop__TopicSetType:
		return soap_in_wstop__TopicSetType(soap, tag, NULL, "wstop:TopicSetType");
	case SOAP_TYPE_wsnt__NotificationMessageHolderType:
		return soap_in_wsnt__NotificationMessageHolderType(soap, tag, NULL, "wsnt:NotificationMessageHolderType");
	case SOAP_TYPE_wsnt__SubscriptionPolicyType:
		return soap_in_wsnt__SubscriptionPolicyType(soap, tag, NULL, "wsnt:SubscriptionPolicyType");
	case SOAP_TYPE_wsnt__FilterType:
		return soap_in_wsnt__FilterType(soap, tag, NULL, "wsnt:FilterType");
	case SOAP_TYPE_wsnt__TopicExpressionType:
		return soap_in_wsnt__TopicExpressionType(soap, tag, NULL, "wsnt:TopicExpressionType");
	case SOAP_TYPE_wsnt__QueryExpressionType:
		return soap_in_wsnt__QueryExpressionType(soap, tag, NULL, "wsnt:QueryExpressionType");
	case SOAP_TYPE_tt__MediaUri:
		return soap_in_tt__MediaUri(soap, tag, NULL, "tt:MediaUri");
	case SOAP_TYPE_tt__MulticastConfiguration:
		return soap_in_tt__MulticastConfiguration(soap, tag, NULL, "tt:MulticastConfiguration");
	case SOAP_TYPE_tt__IPAddress:
		return soap_in_tt__IPAddress(soap, tag, NULL, "tt:IPAddress");
	case SOAP_TYPE_tt__VideoEncoderOptionsExtension2:
		return soap_in_tt__VideoEncoderOptionsExtension2(soap, tag, NULL, "tt:VideoEncoderOptionsExtension2");
	case SOAP_TYPE_tt__H264Options2:
		return soap_in_tt__H264Options2(soap, tag, NULL, "tt:H264Options2");
	case SOAP_TYPE_tt__Mpeg4Options2:
		return soap_in_tt__Mpeg4Options2(soap, tag, NULL, "tt:Mpeg4Options2");
	case SOAP_TYPE_tt__JpegOptions2:
		return soap_in_tt__JpegOptions2(soap, tag, NULL, "tt:JpegOptions2");
	case SOAP_TYPE_tt__VideoEncoderOptionsExtension:
		return soap_in_tt__VideoEncoderOptionsExtension(soap, tag, NULL, "tt:VideoEncoderOptionsExtension");
	case SOAP_TYPE_tt__H264Options:
		return soap_in_tt__H264Options(soap, tag, NULL, "tt:H264Options");
	case SOAP_TYPE_tt__Mpeg4Options:
		return soap_in_tt__Mpeg4Options(soap, tag, NULL, "tt:Mpeg4Options");
	case SOAP_TYPE_tt__JpegOptions:
		return soap_in_tt__JpegOptions(soap, tag, NULL, "tt:JpegOptions");
	case SOAP_TYPE_tt__VideoEncoderConfigurationOptions:
		return soap_in_tt__VideoEncoderConfigurationOptions(soap, tag, NULL, "tt:VideoEncoderConfigurationOptions");
	case SOAP_TYPE_tt__H264Configuration:
		return soap_in_tt__H264Configuration(soap, tag, NULL, "tt:H264Configuration");
	case SOAP_TYPE_tt__Mpeg4Configuration:
		return soap_in_tt__Mpeg4Configuration(soap, tag, NULL, "tt:Mpeg4Configuration");
	case SOAP_TYPE_tt__VideoRateControl:
		return soap_in_tt__VideoRateControl(soap, tag, NULL, "tt:VideoRateControl");
	case SOAP_TYPE_tt__VideoResolution:
		return soap_in_tt__VideoResolution(soap, tag, NULL, "tt:VideoResolution");
	case SOAP_TYPE_tt__ItemListDescriptionExtension:
		return soap_in_tt__ItemListDescriptionExtension(soap, tag, NULL, "tt:ItemListDescriptionExtension");
	case SOAP_TYPE_tt__MessageDescriptionExtension:
		return soap_in_tt__MessageDescriptionExtension(soap, tag, NULL, "tt:MessageDescriptionExtension");
	case SOAP_TYPE_tt__ItemListDescription:
		return soap_in_tt__ItemListDescription(soap, tag, NULL, "tt:ItemListDescription");
	case SOAP_TYPE_tt__MessageDescription:
		return soap_in_tt__MessageDescription(soap, tag, NULL, "tt:MessageDescription");
	case SOAP_TYPE_tt__ItemListExtension:
		return soap_in_tt__ItemListExtension(soap, tag, NULL, "tt:ItemListExtension");
	case SOAP_TYPE_tt__ItemList:
		return soap_in_tt__ItemList(soap, tag, NULL, "tt:ItemList");
	case SOAP_TYPE_tt__MessageExtension:
		return soap_in_tt__MessageExtension(soap, tag, NULL, "tt:MessageExtension");
	case SOAP_TYPE_tt__PTZMoveStatus:
		return soap_in_tt__PTZMoveStatus(soap, tag, NULL, "tt:PTZMoveStatus");
	case SOAP_TYPE_tt__PTZPreset:
		return soap_in_tt__PTZPreset(soap, tag, NULL, "tt:PTZPreset");
	case SOAP_TYPE_tt__PTZSpeed:
		return soap_in_tt__PTZSpeed(soap, tag, NULL, "tt:PTZSpeed");
	case SOAP_TYPE_tt__PTZVector:
		return soap_in_tt__PTZVector(soap, tag, NULL, "tt:PTZVector");
	case SOAP_TYPE_tt__Vector1D:
		return soap_in_tt__Vector1D(soap, tag, NULL, "tt:Vector1D");
	case SOAP_TYPE_tt__Vector2D:
		return soap_in_tt__Vector2D(soap, tag, NULL, "tt:Vector2D");
	case SOAP_TYPE_tt__PTZSpaces:
		return soap_in_tt__PTZSpaces(soap, tag, NULL, "tt:PTZSpaces");
	case SOAP_TYPE_tt__Space1DDescription:
		return soap_in_tt__Space1DDescription(soap, tag, NULL, "tt:Space1DDescription");
	case SOAP_TYPE_tt__ZoomLimits:
		return soap_in_tt__ZoomLimits(soap, tag, NULL, "tt:ZoomLimits");
	case SOAP_TYPE_tt__Space2DDescription:
		return soap_in_tt__Space2DDescription(soap, tag, NULL, "tt:Space2DDescription");
	case SOAP_TYPE_tt__PanTiltLimits:
		return soap_in_tt__PanTiltLimits(soap, tag, NULL, "tt:PanTiltLimits");
	case SOAP_TYPE_tt__ProfileCapabilities:
		return soap_in_tt__ProfileCapabilities(soap, tag, NULL, "tt:ProfileCapabilities");
	case SOAP_TYPE_tt__MediaCapabilitiesExtension:
		return soap_in_tt__MediaCapabilitiesExtension(soap, tag, NULL, "tt:MediaCapabilitiesExtension");
	case SOAP_TYPE_tt__RealTimeStreamingCapabilities:
		return soap_in_tt__RealTimeStreamingCapabilities(soap, tag, NULL, "tt:RealTimeStreamingCapabilities");
	case SOAP_TYPE_tt__SystemCapabilities:
		return soap_in_tt__SystemCapabilities(soap, tag, NULL, "tt:SystemCapabilities");
	case SOAP_TYPE_tt__PTZCapabilities:
		return soap_in_tt__PTZCapabilities(soap, tag, NULL, "tt:PTZCapabilities");
	case SOAP_TYPE_tt__MediaCapabilities:
		return soap_in_tt__MediaCapabilities(soap, tag, NULL, "tt:MediaCapabilities");
	case SOAP_TYPE_tt__EventCapabilities:
		return soap_in_tt__EventCapabilities(soap, tag, NULL, "tt:EventCapabilities");
	case SOAP_TYPE_tt__DeviceCapabilities:
		return soap_in_tt__DeviceCapabilities(soap, tag, NULL, "tt:DeviceCapabilities");
	case SOAP_TYPE_tt__ConfigurationEntity:
		return soap_in_tt__ConfigurationEntity(soap, tag, NULL, "tt:ConfigurationEntity");
	case SOAP_TYPE_tt__VideoEncoderConfiguration:
		return soap_in_tt__VideoEncoderConfiguration(soap, tag, NULL, "tt:VideoEncoderConfiguration");
	case SOAP_TYPE_tt__Profile:
		return soap_in_tt__Profile(soap, tag, NULL, "tt:Profile");
	case SOAP_TYPE_tt__AnyHolder:
		return soap_in_tt__AnyHolder(soap, tag, NULL, "tt:AnyHolder");
	case SOAP_TYPE_tt__FloatList:
		return soap_in_tt__FloatList(soap, tag, NULL, "tt:FloatList");
	case SOAP_TYPE_tt__IntList:
		return soap_in_tt__IntList(soap, tag, NULL, "tt:IntList");
	case SOAP_TYPE_tt__DurationRange:
		return soap_in_tt__DurationRange(soap, tag, NULL, "tt:DurationRange");
	case SOAP_TYPE_tt__FloatRange:
		return soap_in_tt__FloatRange(soap, tag, NULL, "tt:FloatRange");
	case SOAP_TYPE_tt__IntRange:
		return soap_in_tt__IntRange(soap, tag, NULL, "tt:IntRange");
	case SOAP_TYPE_tt__IntRectangleRange:
		return soap_in_tt__IntRectangleRange(soap, tag, NULL, "tt:IntRectangleRange");
	case SOAP_TYPE_tt__IntRectangle:
		return soap_in_tt__IntRectangle(soap, tag, NULL, "tt:IntRectangle");
	case SOAP_TYPE_tt__DeviceEntity:
		return soap_in_tt__DeviceEntity(soap, tag, NULL, "tt:DeviceEntity");
	case SOAP_TYPE_tt__Capabilities:
		return soap_in_tt__Capabilities(soap, tag, NULL, "tt:Capabilities");
	case SOAP_TYPE_tds__DeviceServiceCapabilities:
		return soap_in_tds__DeviceServiceCapabilities(soap, tag, NULL, "tds:DeviceServiceCapabilities");
	case SOAP_TYPE_tt__OnvifVersion:
		return soap_in_tt__OnvifVersion(soap, tag, NULL, "tt:OnvifVersion");
	case SOAP_TYPE_tds__Service:
		return soap_in_tds__Service(soap, tag, NULL, "tds:Service");
	case SOAP_TYPE_saml2__AttributeType:
		return soap_in_saml2__AttributeType(soap, tag, NULL, "saml2:AttributeType");
	case SOAP_TYPE_saml2__AttributeStatementType:
		return soap_in_saml2__AttributeStatementType(soap, tag, NULL, "saml2:AttributeStatementType");
	case SOAP_TYPE_saml2__EvidenceType:
		return soap_in_saml2__EvidenceType(soap, tag, NULL, "saml2:EvidenceType");
	case SOAP_TYPE_saml2__ActionType:
		return soap_in_saml2__ActionType(soap, tag, NULL, "saml2:ActionType");
	case SOAP_TYPE_saml2__AuthzDecisionStatementType:
		return soap_in_saml2__AuthzDecisionStatementType(soap, tag, NULL, "saml2:AuthzDecisionStatementType");
	case SOAP_TYPE_saml2__AuthnContextType:
		return soap_in_saml2__AuthnContextType(soap, tag, NULL, "saml2:AuthnContextType");
	case SOAP_TYPE_saml2__SubjectLocalityType:
		return soap_in_saml2__SubjectLocalityType(soap, tag, NULL, "saml2:SubjectLocalityType");
	case SOAP_TYPE_saml2__AuthnStatementType:
		return soap_in_saml2__AuthnStatementType(soap, tag, NULL, "saml2:AuthnStatementType");
	case SOAP_TYPE_saml2__StatementAbstractType:
		return soap_in_saml2__StatementAbstractType(soap, tag, NULL, "saml2:StatementAbstractType");
	case SOAP_TYPE_saml2__AdviceType:
		return soap_in_saml2__AdviceType(soap, tag, NULL, "saml2:AdviceType");
	case SOAP_TYPE_saml2__ProxyRestrictionType:
		return soap_in_saml2__ProxyRestrictionType(soap, tag, NULL, "saml2:ProxyRestrictionType");
	case SOAP_TYPE_saml2__OneTimeUseType:
		return soap_in_saml2__OneTimeUseType(soap, tag, NULL, "saml2:OneTimeUseType");
	case SOAP_TYPE_saml2__AudienceRestrictionType:
		return soap_in_saml2__AudienceRestrictionType(soap, tag, NULL, "saml2:AudienceRestrictionType");
	case SOAP_TYPE_saml2__ConditionAbstractType:
		return soap_in_saml2__ConditionAbstractType(soap, tag, NULL, "saml2:ConditionAbstractType");
	case SOAP_TYPE_saml2__ConditionsType:
		return soap_in_saml2__ConditionsType(soap, tag, NULL, "saml2:ConditionsType");
	case SOAP_TYPE_saml2__KeyInfoConfirmationDataType:
		return soap_in_saml2__KeyInfoConfirmationDataType(soap, tag, NULL, "saml2:KeyInfoConfirmationDataType");
	case SOAP_TYPE_saml2__SubjectConfirmationDataType:
		return soap_in_saml2__SubjectConfirmationDataType(soap, tag, NULL, "saml2:SubjectConfirmationDataType");
	case SOAP_TYPE_saml2__SubjectConfirmationType:
		return soap_in_saml2__SubjectConfirmationType(soap, tag, NULL, "saml2:SubjectConfirmationType");
	case SOAP_TYPE_saml2__SubjectType:
		return soap_in_saml2__SubjectType(soap, tag, NULL, "saml2:SubjectType");
	case SOAP_TYPE_saml2__AssertionType:
		return soap_in_saml2__AssertionType(soap, tag, NULL, "saml2:AssertionType");
	case SOAP_TYPE_saml2__EncryptedElementType:
		return soap_in_saml2__EncryptedElementType(soap, tag, NULL, "saml2:EncryptedElementType");
	case SOAP_TYPE_saml2__NameIDType:
		return soap_in_saml2__NameIDType(soap, tag, NULL, "saml2:NameIDType");
	case SOAP_TYPE_saml2__BaseIDAbstractType:
		return soap_in_saml2__BaseIDAbstractType(soap, tag, NULL, "saml2:BaseIDAbstractType");
	case SOAP_TYPE_saml1__AttributeType:
		return soap_in_saml1__AttributeType(soap, tag, NULL, "saml1:AttributeType");
	case SOAP_TYPE_saml1__AttributeDesignatorType:
		return soap_in_saml1__AttributeDesignatorType(soap, tag, NULL, "saml1:AttributeDesignatorType");
	case SOAP_TYPE_saml1__AttributeStatementType:
		return soap_in_saml1__AttributeStatementType(soap, tag, NULL, "saml1:AttributeStatementType");
	case SOAP_TYPE_saml1__EvidenceType:
		return soap_in_saml1__EvidenceType(soap, tag, NULL, "saml1:EvidenceType");
	case SOAP_TYPE_saml1__ActionType:
		return soap_in_saml1__ActionType(soap, tag, NULL, "saml1:ActionType");
	case SOAP_TYPE_saml1__AuthorizationDecisionStatementType:
		return soap_in_saml1__AuthorizationDecisionStatementType(soap, tag, NULL, "saml1:AuthorizationDecisionStatementType");
	case SOAP_TYPE_saml1__AuthorityBindingType:
		return soap_in_saml1__AuthorityBindingType(soap, tag, NULL, "saml1:AuthorityBindingType");
	case SOAP_TYPE_saml1__SubjectLocalityType:
		return soap_in_saml1__SubjectLocalityType(soap, tag, NULL, "saml1:SubjectLocalityType");
	case SOAP_TYPE_saml1__AuthenticationStatementType:
		return soap_in_saml1__AuthenticationStatementType(soap, tag, NULL, "saml1:AuthenticationStatementType");
	case SOAP_TYPE_saml1__SubjectConfirmationType:
		return soap_in_saml1__SubjectConfirmationType(soap, tag, NULL, "saml1:SubjectConfirmationType");
	case SOAP_TYPE_saml1__NameIdentifierType:
		return soap_in_saml1__NameIdentifierType(soap, tag, NULL, "saml1:NameIdentifierType");
	case SOAP_TYPE_saml1__SubjectType:
		return soap_in_saml1__SubjectType(soap, tag, NULL, "saml1:SubjectType");
	case SOAP_TYPE_saml1__SubjectStatementAbstractType:
		return soap_in_saml1__SubjectStatementAbstractType(soap, tag, NULL, "saml1:SubjectStatementAbstractType");
	case SOAP_TYPE_saml1__StatementAbstractType:
		return soap_in_saml1__StatementAbstractType(soap, tag, NULL, "saml1:StatementAbstractType");
	case SOAP_TYPE_saml1__AdviceType:
		return soap_in_saml1__AdviceType(soap, tag, NULL, "saml1:AdviceType");
	case SOAP_TYPE_saml1__DoNotCacheConditionType:
		return soap_in_saml1__DoNotCacheConditionType(soap, tag, NULL, "saml1:DoNotCacheConditionType");
	case SOAP_TYPE_saml1__AudienceRestrictionConditionType:
		return soap_in_saml1__AudienceRestrictionConditionType(soap, tag, NULL, "saml1:AudienceRestrictionConditionType");
	case SOAP_TYPE_saml1__ConditionAbstractType:
		return soap_in_saml1__ConditionAbstractType(soap, tag, NULL, "saml1:ConditionAbstractType");
	case SOAP_TYPE_saml1__ConditionsType:
		return soap_in_saml1__ConditionsType(soap, tag, NULL, "saml1:ConditionsType");
	case SOAP_TYPE_saml1__AssertionType:
		return soap_in_saml1__AssertionType(soap, tag, NULL, "saml1:AssertionType");
	case SOAP_TYPE_xsd__dateTime:
		return soap_in_xsd__dateTime(soap, tag, NULL, "xsd:dateTime");
	case SOAP_TYPE_wsc__PropertiesType:
		return soap_in_wsc__PropertiesType(soap, tag, NULL, "wsc:PropertiesType");
	case SOAP_TYPE_wsc__DerivedKeyTokenType:
		return soap_in_wsc__DerivedKeyTokenType(soap, tag, NULL, "wsc:DerivedKeyTokenType");
	case SOAP_TYPE_wsc__SecurityContextTokenType:
		return soap_in_wsc__SecurityContextTokenType(soap, tag, NULL, "wsc:SecurityContextTokenType");
	case SOAP_TYPE_xenc__EncryptionPropertyType:
		return soap_in_xenc__EncryptionPropertyType(soap, tag, NULL, "xenc:EncryptionPropertyType");
	case SOAP_TYPE_xenc__EncryptionPropertiesType:
		return soap_in_xenc__EncryptionPropertiesType(soap, tag, NULL, "xenc:EncryptionPropertiesType");
	case SOAP_TYPE_xenc__ReferenceType:
		return soap_in_xenc__ReferenceType(soap, tag, NULL, "xenc:ReferenceType");
	case SOAP_TYPE_xenc__AgreementMethodType:
		return soap_in_xenc__AgreementMethodType(soap, tag, NULL, "xenc:AgreementMethodType");
	case SOAP_TYPE_xenc__EncryptedDataType:
		return soap_in_xenc__EncryptedDataType(soap, tag, NULL, "xenc:EncryptedDataType");
	case SOAP_TYPE_xenc__TransformsType:
		return soap_in_xenc__TransformsType(soap, tag, NULL, "xenc:TransformsType");
	case SOAP_TYPE_xenc__CipherReferenceType:
		return soap_in_xenc__CipherReferenceType(soap, tag, NULL, "xenc:CipherReferenceType");
	case SOAP_TYPE_xenc__CipherDataType:
		return soap_in_xenc__CipherDataType(soap, tag, NULL, "xenc:CipherDataType");
	case SOAP_TYPE_xenc__EncryptionMethodType:
		return soap_in_xenc__EncryptionMethodType(soap, tag, NULL, "xenc:EncryptionMethodType");
	case SOAP_TYPE_xenc__EncryptedType:
		return soap_in_xenc__EncryptedType(soap, tag, NULL, "xenc:EncryptedType");
	case SOAP_TYPE_ds__RSAKeyValueType:
		return soap_in_ds__RSAKeyValueType(soap, tag, NULL, "ds:RSAKeyValueType");
	case SOAP_TYPE_ds__DSAKeyValueType:
		return soap_in_ds__DSAKeyValueType(soap, tag, NULL, "ds:DSAKeyValueType");
	case SOAP_TYPE_ds__X509IssuerSerialType:
		return soap_in_ds__X509IssuerSerialType(soap, tag, NULL, "ds:X509IssuerSerialType");
	case SOAP_TYPE_ds__RetrievalMethodType:
		return soap_in_ds__RetrievalMethodType(soap, tag, NULL, "ds:RetrievalMethodType");
	case SOAP_TYPE_ds__KeyValueType:
		return soap_in_ds__KeyValueType(soap, tag, NULL, "ds:KeyValueType");
	case SOAP_TYPE_ds__DigestMethodType:
		return soap_in_ds__DigestMethodType(soap, tag, NULL, "ds:DigestMethodType");
	case SOAP_TYPE_ds__TransformType:
		return soap_in_ds__TransformType(soap, tag, NULL, "ds:TransformType");
	case SOAP_TYPE_ds__TransformsType:
		return soap_in_ds__TransformsType(soap, tag, NULL, "ds:TransformsType");
	case SOAP_TYPE_ds__ReferenceType:
		return soap_in_ds__ReferenceType(soap, tag, NULL, "ds:ReferenceType");
	case SOAP_TYPE_ds__SignatureMethodType:
		return soap_in_ds__SignatureMethodType(soap, tag, NULL, "ds:SignatureMethodType");
	case SOAP_TYPE_ds__CanonicalizationMethodType:
		return soap_in_ds__CanonicalizationMethodType(soap, tag, NULL, "ds:CanonicalizationMethodType");
	case SOAP_TYPE_ds__SignedInfoType:
		return soap_in_ds__SignedInfoType(soap, tag, NULL, "ds:SignedInfoType");
	case SOAP_TYPE_ds__SignatureType:
		return soap_in_ds__SignatureType(soap, tag, NULL, "ds:SignatureType");
	case SOAP_TYPE_xenc__EncryptedKeyType:
		return soap_in_xenc__EncryptedKeyType(soap, tag, NULL, "xenc:EncryptedKeyType");
	case SOAP_TYPE_ds__KeyInfoType:
		return soap_in_ds__KeyInfoType(soap, tag, NULL, "ds:KeyInfoType");
	case SOAP_TYPE_ds__X509DataType:
		return soap_in_ds__X509DataType(soap, tag, NULL, "ds:X509DataType");
	case SOAP_TYPE_wsse__EncodedString:
		return soap_in_wsse__EncodedString(soap, tag, NULL, "wsse:EncodedString");
	case SOAP_TYPE_SOAP_ENV__Fault_alex:
		return soap_in_SOAP_ENV__Fault_alex(soap, tag, NULL, "SOAP-ENV:Fault-alex");
	case SOAP_TYPE_chan__ChannelInstanceType:
		return soap_in_chan__ChannelInstanceType(soap, tag, NULL, "chan:ChannelInstanceType");
	case SOAP_TYPE_wsa5__ProblemActionType:
		return soap_in_wsa5__ProblemActionType(soap, tag, NULL, "wsa5:ProblemActionType");
	case SOAP_TYPE_wsa5__RelatesToType:
		return soap_in_wsa5__RelatesToType(soap, tag, NULL, "wsa5:RelatesToType");
	case SOAP_TYPE_wsa5__MetadataType:
		return soap_in_wsa5__MetadataType(soap, tag, NULL, "wsa5:MetadataType");
	case SOAP_TYPE_wsa5__ReferenceParametersType:
		return soap_in_wsa5__ReferenceParametersType(soap, tag, NULL, "wsa5:ReferenceParametersType");
	case SOAP_TYPE_wsa5__EndpointReferenceType:
		return soap_in_wsa5__EndpointReferenceType(soap, tag, NULL, "wsa5:EndpointReferenceType");
	case SOAP_TYPE_wsdd__AppSequenceType:
		return soap_in_wsdd__AppSequenceType(soap, tag, NULL, "wsdd:AppSequenceType");
	case SOAP_TYPE_wsdd__SigType:
		return soap_in_wsdd__SigType(soap, tag, NULL, "wsdd:SigType");
	case SOAP_TYPE_wsdd__SecurityType:
		return soap_in_wsdd__SecurityType(soap, tag, NULL, "wsdd:SecurityType");
	case SOAP_TYPE_wsdd__ScopesType:
		return soap_in_wsdd__ScopesType(soap, tag, NULL, "wsdd:ScopesType");
	case SOAP_TYPE_wsdd__ResolveMatchType:
		return soap_in_wsdd__ResolveMatchType(soap, tag, NULL, "wsdd:ResolveMatchType");
	case SOAP_TYPE_wsdd__ResolveMatchesType:
		return soap_in_wsdd__ResolveMatchesType(soap, tag, NULL, "wsdd:ResolveMatchesType");
	case SOAP_TYPE_wsdd__ResolveType:
		return soap_in_wsdd__ResolveType(soap, tag, NULL, "wsdd:ResolveType");
	case SOAP_TYPE_wsdd__ProbeMatchType:
		return soap_in_wsdd__ProbeMatchType(soap, tag, NULL, "wsdd:ProbeMatchType");
	case SOAP_TYPE_wsdd__ProbeMatchesType:
		return soap_in_wsdd__ProbeMatchesType(soap, tag, NULL, "wsdd:ProbeMatchesType");
	case SOAP_TYPE_wsdd__ProbeType:
		return soap_in_wsdd__ProbeType(soap, tag, NULL, "wsdd:ProbeType");
	case SOAP_TYPE_wsdd__ByeType:
		return soap_in_wsdd__ByeType(soap, tag, NULL, "wsdd:ByeType");
	case SOAP_TYPE_wsdd__HelloType:
		return soap_in_wsdd__HelloType(soap, tag, NULL, "wsdd:HelloType");
	case SOAP_TYPE_wsa__Relationship:
		return soap_in_wsa__Relationship(soap, tag, NULL, "wsa:Relationship");
	case SOAP_TYPE_wsa__ServiceNameType:
		return soap_in_wsa__ServiceNameType(soap, tag, NULL, "wsa:ServiceNameType");
	case SOAP_TYPE_wsa__ReferenceParametersType:
		return soap_in_wsa__ReferenceParametersType(soap, tag, NULL, "wsa:ReferenceParametersType");
	case SOAP_TYPE_wsa__ReferencePropertiesType:
		return soap_in_wsa__ReferencePropertiesType(soap, tag, NULL, "wsa:ReferencePropertiesType");
	case SOAP_TYPE_wsa__EndpointReferenceType:
		return soap_in_wsa__EndpointReferenceType(soap, tag, NULL, "wsa:EndpointReferenceType");
	case SOAP_TYPE_PointerTo_trt__GetSnapshotUriResponse:
		return soap_in_PointerTo_trt__GetSnapshotUriResponse(soap, tag, NULL, "trt:GetSnapshotUriResponse");
	case SOAP_TYPE_PointerTo_trt__GetSnapshotUri:
		return soap_in_PointerTo_trt__GetSnapshotUri(soap, tag, NULL, "trt:GetSnapshotUri");
	case SOAP_TYPE_PointerTo_trt__GetProfilesResponse:
		return soap_in_PointerTo_trt__GetProfilesResponse(soap, tag, NULL, "trt:GetProfilesResponse");
	case SOAP_TYPE_PointerTo_trt__GetProfiles:
		return soap_in_PointerTo_trt__GetProfiles(soap, tag, NULL, "trt:GetProfiles");
	case SOAP_TYPE_PointerTo_trt__GetProfileResponse:
		return soap_in_PointerTo_trt__GetProfileResponse(soap, tag, NULL, "trt:GetProfileResponse");
	case SOAP_TYPE_PointerTo_trt__GetProfile:
		return soap_in_PointerTo_trt__GetProfile(soap, tag, NULL, "trt:GetProfile");
	case SOAP_TYPE_PointerTo_trt__CreateProfileResponse:
		return soap_in_PointerTo_trt__CreateProfileResponse(soap, tag, NULL, "trt:CreateProfileResponse");
	case SOAP_TYPE_PointerTo_trt__CreateProfile:
		return soap_in_PointerTo_trt__CreateProfile(soap, tag, NULL, "trt:CreateProfile");
	case SOAP_TYPE_PointerTo_trt__GetServiceCapabilitiesResponse:
		return soap_in_PointerTo_trt__GetServiceCapabilitiesResponse(soap, tag, NULL, "trt:GetServiceCapabilitiesResponse");
	case SOAP_TYPE_PointerTo_trt__GetServiceCapabilities:
		return soap_in_PointerTo_trt__GetServiceCapabilities(soap, tag, NULL, "trt:GetServiceCapabilities");
	case SOAP_TYPE_PointerTo_tds__GetCapabilitiesResponse:
		return soap_in_PointerTo_tds__GetCapabilitiesResponse(soap, tag, NULL, "tds:GetCapabilitiesResponse");
	case SOAP_TYPE_PointerTo_tds__GetCapabilities:
		return soap_in_PointerTo_tds__GetCapabilities(soap, tag, NULL, "tds:GetCapabilities");
	case SOAP_TYPE_PointerTo_tds__SystemRebootResponse:
		return soap_in_PointerTo_tds__SystemRebootResponse(soap, tag, NULL, "tds:SystemRebootResponse");
	case SOAP_TYPE_PointerTo_tds__SystemReboot:
		return soap_in_PointerTo_tds__SystemReboot(soap, tag, NULL, "tds:SystemReboot");
	case SOAP_TYPE_PointerTo_tds__GetDeviceInformationResponse:
		return soap_in_PointerTo_tds__GetDeviceInformationResponse(soap, tag, NULL, "tds:GetDeviceInformationResponse");
	case SOAP_TYPE_PointerTo_tds__GetDeviceInformation:
		return soap_in_PointerTo_tds__GetDeviceInformation(soap, tag, NULL, "tds:GetDeviceInformation");
	case SOAP_TYPE_PointerTo_tds__GetServiceCapabilitiesResponse:
		return soap_in_PointerTo_tds__GetServiceCapabilitiesResponse(soap, tag, NULL, "tds:GetServiceCapabilitiesResponse");
	case SOAP_TYPE_PointerTo_tds__GetServiceCapabilities:
		return soap_in_PointerTo_tds__GetServiceCapabilities(soap, tag, NULL, "tds:GetServiceCapabilities");
	case SOAP_TYPE_PointerTo_tds__GetServicesResponse:
		return soap_in_PointerTo_tds__GetServicesResponse(soap, tag, NULL, "tds:GetServicesResponse");
	case SOAP_TYPE_PointerTo_tds__GetServices:
		return soap_in_PointerTo_tds__GetServices(soap, tag, NULL, "tds:GetServices");
	case SOAP_TYPE_PointerTo_wstop__TopicNamespaceType_Topic:
		return soap_in_PointerTo_wstop__TopicNamespaceType_Topic(soap, tag, NULL, "wstop:TopicNamespaceType-Topic");
	case SOAP_TYPE_PointerTowstop__TopicType:
		return soap_in_PointerTowstop__TopicType(soap, tag, NULL, "wstop:TopicType");
	case SOAP_TYPE_PointerTowstop__QueryExpressionType:
		return soap_in_PointerTowstop__QueryExpressionType(soap, tag, NULL, "wstop:QueryExpressionType");
	case SOAP_TYPE_PointerTo_wsnt__ResumeFailedFaultType_FaultCause:
		return soap_in_PointerTo_wsnt__ResumeFailedFaultType_FaultCause(soap, tag, NULL, "wsnt:ResumeFailedFaultType-FaultCause");
	case SOAP_TYPE_PointerTo_wsnt__ResumeFailedFaultType_Description:
		return soap_in_PointerTo_wsnt__ResumeFailedFaultType_Description(soap, tag, NULL, "wsnt:ResumeFailedFaultType-Description");
	case SOAP_TYPE_PointerTo_wsnt__ResumeFailedFaultType_ErrorCode:
		return soap_in_PointerTo_wsnt__ResumeFailedFaultType_ErrorCode(soap, tag, NULL, "wsnt:ResumeFailedFaultType-ErrorCode");
	case SOAP_TYPE_PointerTo_wsnt__PauseFailedFaultType_FaultCause:
		return soap_in_PointerTo_wsnt__PauseFailedFaultType_FaultCause(soap, tag, NULL, "wsnt:PauseFailedFaultType-FaultCause");
	case SOAP_TYPE_PointerTo_wsnt__PauseFailedFaultType_Description:
		return soap_in_PointerTo_wsnt__PauseFailedFaultType_Description(soap, tag, NULL, "wsnt:PauseFailedFaultType-Description");
	case SOAP_TYPE_PointerTo_wsnt__PauseFailedFaultType_ErrorCode:
		return soap_in_PointerTo_wsnt__PauseFailedFaultType_ErrorCode(soap, tag, NULL, "wsnt:PauseFailedFaultType-ErrorCode");
	case SOAP_TYPE_PointerTo_wsnt__UnableToDestroySubscriptionFaultType_FaultCause:
		return soap_in_PointerTo_wsnt__UnableToDestroySubscriptionFaultType_FaultCause(soap, tag, NULL, "wsnt:UnableToDestroySubscriptionFaultType-FaultCause");
	case SOAP_TYPE_PointerTo_wsnt__UnableToDestroySubscriptionFaultType_Description:
		return soap_in_PointerTo_wsnt__UnableToDestroySubscriptionFaultType_Description(soap, tag, NULL, "wsnt:UnableToDestroySubscriptionFaultType-Description");
	case SOAP_TYPE_PointerTo_wsnt__UnableToDestroySubscriptionFaultType_ErrorCode:
		return soap_in_PointerTo_wsnt__UnableToDestroySubscriptionFaultType_ErrorCode(soap, tag, NULL, "wsnt:UnableToDestroySubscriptionFaultType-ErrorCode");
	case SOAP_TYPE_PointerTo_wsnt__UnacceptableTerminationTimeFaultType_FaultCause:
		return soap_in_PointerTo_wsnt__UnacceptableTerminationTimeFaultType_FaultCause(soap, tag, NULL, "wsnt:UnacceptableTerminationTimeFaultType-FaultCause");
	case SOAP_TYPE_PointerTo_wsnt__UnacceptableTerminationTimeFaultType_Description:
		return soap_in_PointerTo_wsnt__UnacceptableTerminationTimeFaultType_Description(soap, tag, NULL, "wsnt:UnacceptableTerminationTimeFaultType-Description");
	case SOAP_TYPE_PointerTo_wsnt__UnacceptableTerminationTimeFaultType_ErrorCode:
		return soap_in_PointerTo_wsnt__UnacceptableTerminationTimeFaultType_ErrorCode(soap, tag, NULL, "wsnt:UnacceptableTerminationTimeFaultType-ErrorCode");
	case SOAP_TYPE_PointerTo_wsnt__UnableToCreatePullPointFaultType_FaultCause:
		return soap_in_PointerTo_wsnt__UnableToCreatePullPointFaultType_FaultCause(soap, tag, NULL, "wsnt:UnableToCreatePullPointFaultType-FaultCause");
	case SOAP_TYPE_PointerTo_wsnt__UnableToCreatePullPointFaultType_Description:
		return soap_in_PointerTo_wsnt__UnableToCreatePullPointFaultType_Description(soap, tag, NULL, "wsnt:UnableToCreatePullPointFaultType-Description");
	case SOAP_TYPE_PointerTo_wsnt__UnableToCreatePullPointFaultType_ErrorCode:
		return soap_in_PointerTo_wsnt__UnableToCreatePullPointFaultType_ErrorCode(soap, tag, NULL, "wsnt:UnableToCreatePullPointFaultType-ErrorCode");
	case SOAP_TYPE_PointerTo_wsnt__UnableToDestroyPullPointFaultType_FaultCause:
		return soap_in_PointerTo_wsnt__UnableToDestroyPullPointFaultType_FaultCause(soap, tag, NULL, "wsnt:UnableToDestroyPullPointFaultType-FaultCause");
	case SOAP_TYPE_PointerTo_wsnt__UnableToDestroyPullPointFaultType_Description:
		return soap_in_PointerTo_wsnt__UnableToDestroyPullPointFaultType_Description(soap, tag, NULL, "wsnt:UnableToDestroyPullPointFaultType-Description");
	case SOAP_TYPE_PointerTo_wsnt__UnableToDestroyPullPointFaultType_ErrorCode:
		return soap_in_PointerTo_wsnt__UnableToDestroyPullPointFaultType_ErrorCode(soap, tag, NULL, "wsnt:UnableToDestroyPullPointFaultType-ErrorCode");
	case SOAP_TYPE_PointerTo_wsnt__UnableToGetMessagesFaultType_FaultCause:
		return soap_in_PointerTo_wsnt__UnableToGetMessagesFaultType_FaultCause(soap, tag, NULL, "wsnt:UnableToGetMessagesFaultType-FaultCause");
	case SOAP_TYPE_PointerTo_wsnt__UnableToGetMessagesFaultType_Description:
		return soap_in_PointerTo_wsnt__UnableToGetMessagesFaultType_Description(soap, tag, NULL, "wsnt:UnableToGetMessagesFaultType-Description");
	case SOAP_TYPE_PointerTo_wsnt__UnableToGetMessagesFaultType_ErrorCode:
		return soap_in_PointerTo_wsnt__UnableToGetMessagesFaultType_ErrorCode(soap, tag, NULL, "wsnt:UnableToGetMessagesFaultType-ErrorCode");
	case SOAP_TYPE_PointerTo_wsnt__NoCurrentMessageOnTopicFaultType_FaultCause:
		return soap_in_PointerTo_wsnt__NoCurrentMessageOnTopicFaultType_FaultCause(soap, tag, NULL, "wsnt:NoCurrentMessageOnTopicFaultType-FaultCause");
	case SOAP_TYPE_PointerTo_wsnt__NoCurrentMessageOnTopicFaultType_Description:
		return soap_in_PointerTo_wsnt__NoCurrentMessageOnTopicFaultType_Description(soap, tag, NULL, "wsnt:NoCurrentMessageOnTopicFaultType-Description");
	case SOAP_TYPE_PointerTo_wsnt__NoCurrentMessageOnTopicFaultType_ErrorCode:
		return soap_in_PointerTo_wsnt__NoCurrentMessageOnTopicFaultType_ErrorCode(soap, tag, NULL, "wsnt:NoCurrentMessageOnTopicFaultType-ErrorCode");
	case SOAP_TYPE_PointerTo_wsnt__UnacceptableInitialTerminationTimeFaultType_FaultCause:
		return soap_in_PointerTo_wsnt__UnacceptableInitialTerminationTimeFaultType_FaultCause(soap, tag, NULL, "wsnt:UnacceptableInitialTerminationTimeFaultType-FaultCause");
	case SOAP_TYPE_PointerTo_wsnt__UnacceptableInitialTerminationTimeFaultType_Description:
		return soap_in_PointerTo_wsnt__UnacceptableInitialTerminationTimeFaultType_Description(soap, tag, NULL, "wsnt:UnacceptableInitialTerminationTimeFaultType-Description");
	case SOAP_TYPE_PointerTo_wsnt__UnacceptableInitialTerminationTimeFaultType_ErrorCode:
		return soap_in_PointerTo_wsnt__UnacceptableInitialTerminationTimeFaultType_ErrorCode(soap, tag, NULL, "wsnt:UnacceptableInitialTerminationTimeFaultType-ErrorCode");
	case SOAP_TYPE_PointerTo_wsnt__NotifyMessageNotSupportedFaultType_FaultCause:
		return soap_in_PointerTo_wsnt__NotifyMessageNotSupportedFaultType_FaultCause(soap, tag, NULL, "wsnt:NotifyMessageNotSupportedFaultType-FaultCause");
	case SOAP_TYPE_PointerTo_wsnt__NotifyMessageNotSupportedFaultType_Description:
		return soap_in_PointerTo_wsnt__NotifyMessageNotSupportedFaultType_Description(soap, tag, NULL, "wsnt:NotifyMessageNotSupportedFaultType-Description");
	case SOAP_TYPE_PointerTo_wsnt__NotifyMessageNotSupportedFaultType_ErrorCode:
		return soap_in_PointerTo_wsnt__NotifyMessageNotSupportedFaultType_ErrorCode(soap, tag, NULL, "wsnt:NotifyMessageNotSupportedFaultType-ErrorCode");
	case SOAP_TYPE_PointerTo_wsnt__UnsupportedPolicyRequestFaultType_FaultCause:
		return soap_in_PointerTo_wsnt__UnsupportedPolicyRequestFaultType_FaultCause(soap, tag, NULL, "wsnt:UnsupportedPolicyRequestFaultType-FaultCause");
	case SOAP_TYPE_PointerTo_wsnt__UnsupportedPolicyRequestFaultType_Description:
		return soap_in_PointerTo_wsnt__UnsupportedPolicyRequestFaultType_Description(soap, tag, NULL, "wsnt:UnsupportedPolicyRequestFaultType-Description");
	case SOAP_TYPE_PointerTo_wsnt__UnsupportedPolicyRequestFaultType_ErrorCode:
		return soap_in_PointerTo_wsnt__UnsupportedPolicyRequestFaultType_ErrorCode(soap, tag, NULL, "wsnt:UnsupportedPolicyRequestFaultType-ErrorCode");
	case SOAP_TYPE_PointerTo_wsnt__UnrecognizedPolicyRequestFaultType_FaultCause:
		return soap_in_PointerTo_wsnt__UnrecognizedPolicyRequestFaultType_FaultCause(soap, tag, NULL, "wsnt:UnrecognizedPolicyRequestFaultType-FaultCause");
	case SOAP_TYPE_PointerTo_wsnt__UnrecognizedPolicyRequestFaultType_Description:
		return soap_in_PointerTo_wsnt__UnrecognizedPolicyRequestFaultType_Description(soap, tag, NULL, "wsnt:UnrecognizedPolicyRequestFaultType-Description");
	case SOAP_TYPE_PointerTo_wsnt__UnrecognizedPolicyRequestFaultType_ErrorCode:
		return soap_in_PointerTo_wsnt__UnrecognizedPolicyRequestFaultType_ErrorCode(soap, tag, NULL, "wsnt:UnrecognizedPolicyRequestFaultType-ErrorCode");
	case SOAP_TYPE_PointerTo_wsnt__InvalidMessageContentExpressionFaultType_FaultCause:
		return soap_in_PointerTo_wsnt__InvalidMessageContentExpressionFaultType_FaultCause(soap, tag, NULL, "wsnt:InvalidMessageContentExpressionFaultType-FaultCause");
	case SOAP_TYPE_PointerTo_wsnt__InvalidMessageContentExpressionFaultType_Description:
		return soap_in_PointerTo_wsnt__InvalidMessageContentExpressionFaultType_Description(soap, tag, NULL, "wsnt:InvalidMessageContentExpressionFaultType-Description");
	case SOAP_TYPE_PointerTo_wsnt__InvalidMessageContentExpressionFaultType_ErrorCode:
		return soap_in_PointerTo_wsnt__InvalidMessageContentExpressionFaultType_ErrorCode(soap, tag, NULL, "wsnt:InvalidMessageContentExpressionFaultType-ErrorCode");
	case SOAP_TYPE_PointerTo_wsnt__InvalidProducerPropertiesExpressionFaultType_FaultCause:
		return soap_in_PointerTo_wsnt__InvalidProducerPropertiesExpressionFaultType_FaultCause(soap, tag, NULL, "wsnt:InvalidProducerPropertiesExpressionFaultType-FaultCause");
	case SOAP_TYPE_PointerTo_wsnt__InvalidProducerPropertiesExpressionFaultType_Description:
		return soap_in_PointerTo_wsnt__InvalidProducerPropertiesExpressionFaultType_Description(soap, tag, NULL, "wsnt:InvalidProducerPropertiesExpressionFaultType-Description");
	case SOAP_TYPE_PointerTo_wsnt__InvalidProducerPropertiesExpressionFaultType_ErrorCode:
		return soap_in_PointerTo_wsnt__InvalidProducerPropertiesExpressionFaultType_ErrorCode(soap, tag, NULL, "wsnt:InvalidProducerPropertiesExpressionFaultType-ErrorCode");
	case SOAP_TYPE_PointerTo_wsnt__MultipleTopicsSpecifiedFaultType_FaultCause:
		return soap_in_PointerTo_wsnt__MultipleTopicsSpecifiedFaultType_FaultCause(soap, tag, NULL, "wsnt:MultipleTopicsSpecifiedFaultType-FaultCause");
	case SOAP_TYPE_PointerTo_wsnt__MultipleTopicsSpecifiedFaultType_Description:
		return soap_in_PointerTo_wsnt__MultipleTopicsSpecifiedFaultType_Description(soap, tag, NULL, "wsnt:MultipleTopicsSpecifiedFaultType-Description");
	case SOAP_TYPE_PointerTo_wsnt__MultipleTopicsSpecifiedFaultType_ErrorCode:
		return soap_in_PointerTo_wsnt__MultipleTopicsSpecifiedFaultType_ErrorCode(soap, tag, NULL, "wsnt:MultipleTopicsSpecifiedFaultType-ErrorCode");
	case SOAP_TYPE_PointerTo_wsnt__TopicNotSupportedFaultType_FaultCause:
		return soap_in_PointerTo_wsnt__TopicNotSupportedFaultType_FaultCause(soap, tag, NULL, "wsnt:TopicNotSupportedFaultType-FaultCause");
	case SOAP_TYPE_PointerTo_wsnt__TopicNotSupportedFaultType_Description:
		return soap_in_PointerTo_wsnt__TopicNotSupportedFaultType_Description(soap, tag, NULL, "wsnt:TopicNotSupportedFaultType-Description");
	case SOAP_TYPE_PointerTo_wsnt__TopicNotSupportedFaultType_ErrorCode:
		return soap_in_PointerTo_wsnt__TopicNotSupportedFaultType_ErrorCode(soap, tag, NULL, "wsnt:TopicNotSupportedFaultType-ErrorCode");
	case SOAP_TYPE_PointerTo_wsnt__InvalidTopicExpressionFaultType_FaultCause:
		return soap_in_PointerTo_wsnt__InvalidTopicExpressionFaultType_FaultCause(soap, tag, NULL, "wsnt:InvalidTopicExpressionFaultType-FaultCause");
	case SOAP_TYPE_PointerTo_wsnt__InvalidTopicExpressionFaultType_Description:
		return soap_in_PointerTo_wsnt__InvalidTopicExpressionFaultType_Description(soap, tag, NULL, "wsnt:InvalidTopicExpressionFaultType-Description");
	case SOAP_TYPE_PointerTo_wsnt__InvalidTopicExpressionFaultType_ErrorCode:
		return soap_in_PointerTo_wsnt__InvalidTopicExpressionFaultType_ErrorCode(soap, tag, NULL, "wsnt:InvalidTopicExpressionFaultType-ErrorCode");
	case SOAP_TYPE_PointerTo_wsnt__TopicExpressionDialectUnknownFaultType_FaultCause:
		return soap_in_PointerTo_wsnt__TopicExpressionDialectUnknownFaultType_FaultCause(soap, tag, NULL, "wsnt:TopicExpressionDialectUnknownFaultType-FaultCause");
	case SOAP_TYPE_PointerTo_wsnt__TopicExpressionDialectUnknownFaultType_Description:
		return soap_in_PointerTo_wsnt__TopicExpressionDialectUnknownFaultType_Description(soap, tag, NULL, "wsnt:TopicExpressionDialectUnknownFaultType-Description");
	case SOAP_TYPE_PointerTo_wsnt__TopicExpressionDialectUnknownFaultType_ErrorCode:
		return soap_in_PointerTo_wsnt__TopicExpressionDialectUnknownFaultType_ErrorCode(soap, tag, NULL, "wsnt:TopicExpressionDialectUnknownFaultType-ErrorCode");
	case SOAP_TYPE_PointerTo_wsnt__InvalidFilterFaultType_FaultCause:
		return soap_in_PointerTo_wsnt__InvalidFilterFaultType_FaultCause(soap, tag, NULL, "wsnt:InvalidFilterFaultType-FaultCause");
	case SOAP_TYPE_PointerTo_wsnt__InvalidFilterFaultType_Description:
		return soap_in_PointerTo_wsnt__InvalidFilterFaultType_Description(soap, tag, NULL, "wsnt:InvalidFilterFaultType-Description");
	case SOAP_TYPE_PointerTo_wsnt__InvalidFilterFaultType_ErrorCode:
		return soap_in_PointerTo_wsnt__InvalidFilterFaultType_ErrorCode(soap, tag, NULL, "wsnt:InvalidFilterFaultType-ErrorCode");
	case SOAP_TYPE_PointerTo_wsnt__SubscribeCreationFailedFaultType_FaultCause:
		return soap_in_PointerTo_wsnt__SubscribeCreationFailedFaultType_FaultCause(soap, tag, NULL, "wsnt:SubscribeCreationFailedFaultType-FaultCause");
	case SOAP_TYPE_PointerTo_wsnt__SubscribeCreationFailedFaultType_Description:
		return soap_in_PointerTo_wsnt__SubscribeCreationFailedFaultType_Description(soap, tag, NULL, "wsnt:SubscribeCreationFailedFaultType-Description");
	case SOAP_TYPE_PointerTo_wsnt__SubscribeCreationFailedFaultType_ErrorCode:
		return soap_in_PointerTo_wsnt__SubscribeCreationFailedFaultType_ErrorCode(soap, tag, NULL, "wsnt:SubscribeCreationFailedFaultType-ErrorCode");
	case SOAP_TYPE_PointerTott__MulticastConfiguration:
		return soap_in_PointerTott__MulticastConfiguration(soap, tag, NULL, "tt:MulticastConfiguration");
	case SOAP_TYPE_PointerTott__H264Configuration:
		return soap_in_PointerTott__H264Configuration(soap, tag, NULL, "tt:H264Configuration");
	case SOAP_TYPE_PointerTott__Mpeg4Configuration:
		return soap_in_PointerTott__Mpeg4Configuration(soap, tag, NULL, "tt:Mpeg4Configuration");
	case SOAP_TYPE_PointerTott__VideoRateControl:
		return soap_in_PointerTott__VideoRateControl(soap, tag, NULL, "tt:VideoRateControl");
	case SOAP_TYPE_PointerTott__MediaUri:
		return soap_in_PointerTott__MediaUri(soap, tag, NULL, "tt:MediaUri");
	case SOAP_TYPE_PointerTott__Profile:
		return soap_in_PointerTott__Profile(soap, tag, NULL, "tt:Profile");
	case SOAP_TYPE_PointerTotrt__Capabilities:
		return soap_in_PointerTotrt__Capabilities(soap, tag, NULL, "trt:Capabilities");
	case SOAP_TYPE_PointerTotrt__ProfileCapabilities:
		return soap_in_PointerTotrt__ProfileCapabilities(soap, tag, NULL, "trt:ProfileCapabilities");
	case SOAP_TYPE_PointerTowstop__Documentation:
		return soap_in_PointerTowstop__Documentation(soap, tag, NULL, "wstop:Documentation");
	case SOAP_TYPE_PointerTo_wsrfbf__BaseFaultType_FaultCause:
		return soap_in_PointerTo_wsrfbf__BaseFaultType_FaultCause(soap, tag, NULL, "wsrfbf:BaseFaultType-FaultCause");
	case SOAP_TYPE_PointerTo_wsrfbf__BaseFaultType_Description:
		return soap_in_PointerTo_wsrfbf__BaseFaultType_Description(soap, tag, NULL, "wsrfbf:BaseFaultType-Description");
	case SOAP_TYPE_PointerTo_wsrfbf__BaseFaultType_ErrorCode:
		return soap_in_PointerTo_wsrfbf__BaseFaultType_ErrorCode(soap, tag, NULL, "wsrfbf:BaseFaultType-ErrorCode");
	case SOAP_TYPE_PointerTo_wsnt__Subscribe_SubscriptionPolicy:
		return soap_in_PointerTo_wsnt__Subscribe_SubscriptionPolicy(soap, tag, NULL, "wsnt:Subscribe-SubscriptionPolicy");
	case SOAP_TYPE_PointerTowsnt__NotificationMessageHolderType:
		return soap_in_PointerTowsnt__NotificationMessageHolderType(soap, tag, NULL, "wsnt:NotificationMessageHolderType");
	case SOAP_TYPE_PointerTodateTime:
		return soap_in_PointerTodateTime(soap, tag, NULL, "xsd:dateTime");
	case SOAP_TYPE_PointerTowsnt__SubscriptionPolicyType:
		return soap_in_PointerTowsnt__SubscriptionPolicyType(soap, tag, NULL, "wsnt:SubscriptionPolicyType");
	case SOAP_TYPE_PointerTowsnt__FilterType:
		return soap_in_PointerTowsnt__FilterType(soap, tag, NULL, "wsnt:FilterType");
	case SOAP_TYPE_PointerTowstop__TopicSetType:
		return soap_in_PointerTowstop__TopicSetType(soap, tag, NULL, "wstop:TopicSetType");
	case SOAP_TYPE_PointerToxsd__anyURI:
		return soap_in_PointerToxsd__anyURI(soap, tag, NULL, "xsd:anyURI");
	case SOAP_TYPE_PointerTowsnt__TopicExpressionType:
		return soap_in_PointerTowsnt__TopicExpressionType(soap, tag, NULL, "wsnt:TopicExpressionType");
	case SOAP_TYPE_PointerTowsa5__EndpointReferenceType:
		return soap_in_PointerTowsa5__EndpointReferenceType(soap, tag, NULL, "wsa5:EndpointReferenceType");
	case SOAP_TYPE_PointerTott__PropertyOperation:
		return soap_in_PointerTott__PropertyOperation(soap, tag, NULL, "tt:PropertyOperation");
	case SOAP_TYPE_PointerTott__MessageExtension:
		return soap_in_PointerTott__MessageExtension(soap, tag, NULL, "tt:MessageExtension");
	case SOAP_TYPE_PointerTott__ItemList:
		return soap_in_PointerTott__ItemList(soap, tag, NULL, "tt:ItemList");
	case SOAP_TYPE_PointerTott__IPAddress:
		return soap_in_PointerTott__IPAddress(soap, tag, NULL, "tt:IPAddress");
	case SOAP_TYPE_PointerTott__H264Profile:
		return soap_in_PointerTott__H264Profile(soap, tag, NULL, "tt:H264Profile");
	case SOAP_TYPE_PointerTott__Mpeg4Profile:
		return soap_in_PointerTott__Mpeg4Profile(soap, tag, NULL, "tt:Mpeg4Profile");
	case SOAP_TYPE_PointerTott__VideoResolution:
		return soap_in_PointerTott__VideoResolution(soap, tag, NULL, "tt:VideoResolution");
	case SOAP_TYPE_PointerTott__VideoEncoderOptionsExtension2:
		return soap_in_PointerTott__VideoEncoderOptionsExtension2(soap, tag, NULL, "tt:VideoEncoderOptionsExtension2");
	case SOAP_TYPE_PointerTott__H264Options2:
		return soap_in_PointerTott__H264Options2(soap, tag, NULL, "tt:H264Options2");
	case SOAP_TYPE_PointerTott__Mpeg4Options2:
		return soap_in_PointerTott__Mpeg4Options2(soap, tag, NULL, "tt:Mpeg4Options2");
	case SOAP_TYPE_PointerTott__JpegOptions2:
		return soap_in_PointerTott__JpegOptions2(soap, tag, NULL, "tt:JpegOptions2");
	case SOAP_TYPE_PointerTott__VideoEncoderOptionsExtension:
		return soap_in_PointerTott__VideoEncoderOptionsExtension(soap, tag, NULL, "tt:VideoEncoderOptionsExtension");
	case SOAP_TYPE_PointerTott__H264Options:
		return soap_in_PointerTott__H264Options(soap, tag, NULL, "tt:H264Options");
	case SOAP_TYPE_PointerTott__Mpeg4Options:
		return soap_in_PointerTott__Mpeg4Options(soap, tag, NULL, "tt:Mpeg4Options");
	case SOAP_TYPE_PointerTott__JpegOptions:
		return soap_in_PointerTott__JpegOptions(soap, tag, NULL, "tt:JpegOptions");
	case SOAP_TYPE_PointerTott__ItemListDescriptionExtension:
		return soap_in_PointerTott__ItemListDescriptionExtension(soap, tag, NULL, "tt:ItemListDescriptionExtension");
	case SOAP_TYPE_PointerTo_tt__ItemListDescription_ElementItemDescription:
		return soap_in_PointerTo_tt__ItemListDescription_ElementItemDescription(soap, tag, NULL, "tt:ItemListDescription-ElementItemDescription");
	case SOAP_TYPE_PointerTo_tt__ItemListDescription_SimpleItemDescription:
		return soap_in_PointerTo_tt__ItemListDescription_SimpleItemDescription(soap, tag, NULL, "tt:ItemListDescription-SimpleItemDescription");
	case SOAP_TYPE_PointerTott__MessageDescriptionExtension:
		return soap_in_PointerTott__MessageDescriptionExtension(soap, tag, NULL, "tt:MessageDescriptionExtension");
	case SOAP_TYPE_PointerTott__ItemListDescription:
		return soap_in_PointerTott__ItemListDescription(soap, tag, NULL, "tt:ItemListDescription");
	case SOAP_TYPE_PointerTott__ItemListExtension:
		return soap_in_PointerTott__ItemListExtension(soap, tag, NULL, "tt:ItemListExtension");
	case SOAP_TYPE_PointerTo_tt__ItemList_ElementItem:
		return soap_in_PointerTo_tt__ItemList_ElementItem(soap, tag, NULL, "tt:ItemList-ElementItem");
	case SOAP_TYPE_PointerTo_tt__ItemList_SimpleItem:
		return soap_in_PointerTo_tt__ItemList_SimpleItem(soap, tag, NULL, "tt:ItemList-SimpleItem");
	case SOAP_TYPE_PointerTott__MoveStatus:
		return soap_in_PointerTott__MoveStatus(soap, tag, NULL, "tt:MoveStatus");
	case SOAP_TYPE_PointerTott__PTZVector:
		return soap_in_PointerTott__PTZVector(soap, tag, NULL, "tt:PTZVector");
	case SOAP_TYPE_PointerTott__Vector1D:
		return soap_in_PointerTott__Vector1D(soap, tag, NULL, "tt:Vector1D");
	case SOAP_TYPE_PointerTott__Vector2D:
		return soap_in_PointerTott__Vector2D(soap, tag, NULL, "tt:Vector2D");
	case SOAP_TYPE_PointerTott__FloatRange:
		return soap_in_PointerTott__FloatRange(soap, tag, NULL, "tt:FloatRange");
	case SOAP_TYPE_PointerTott__Space1DDescription:
		return soap_in_PointerTott__Space1DDescription(soap, tag, NULL, "tt:Space1DDescription");
	case SOAP_TYPE_PointerTott__Space2DDescription:
		return soap_in_PointerTott__Space2DDescription(soap, tag, NULL, "tt:Space2DDescription");
	case SOAP_TYPE_PointerTott__ProfileCapabilities:
		return soap_in_PointerTott__ProfileCapabilities(soap, tag, NULL, "tt:ProfileCapabilities");
	case SOAP_TYPE_PointerTott__MediaCapabilitiesExtension:
		return soap_in_PointerTott__MediaCapabilitiesExtension(soap, tag, NULL, "tt:MediaCapabilitiesExtension");
	case SOAP_TYPE_PointerTott__RealTimeStreamingCapabilities:
		return soap_in_PointerTott__RealTimeStreamingCapabilities(soap, tag, NULL, "tt:RealTimeStreamingCapabilities");
	case SOAP_TYPE_PointerTott__SystemCapabilities:
		return soap_in_PointerTott__SystemCapabilities(soap, tag, NULL, "tt:SystemCapabilities");
	case SOAP_TYPE_PointerTott__PTZCapabilities:
		return soap_in_PointerTott__PTZCapabilities(soap, tag, NULL, "tt:PTZCapabilities");
	case SOAP_TYPE_PointerTott__MediaCapabilities:
		return soap_in_PointerTott__MediaCapabilities(soap, tag, NULL, "tt:MediaCapabilities");
	case SOAP_TYPE_PointerTott__EventCapabilities:
		return soap_in_PointerTott__EventCapabilities(soap, tag, NULL, "tt:EventCapabilities");
	case SOAP_TYPE_PointerTott__DeviceCapabilities:
		return soap_in_PointerTott__DeviceCapabilities(soap, tag, NULL, "tt:DeviceCapabilities");
	case SOAP_TYPE_PointerToxsd__boolean:
		return soap_in_PointerToxsd__boolean(soap, tag, NULL, "xsd:boolean");
	case SOAP_TYPE_PointerTott__VideoEncoderConfiguration:
		return soap_in_PointerTott__VideoEncoderConfiguration(soap, tag, NULL, "tt:VideoEncoderConfiguration");
	case SOAP_TYPE_PointerTofloat:
		return soap_in_PointerTofloat(soap, tag, NULL, "xsd:float");
	case SOAP_TYPE_PointerTott__IntRange:
		return soap_in_PointerTott__IntRange(soap, tag, NULL, "tt:IntRange");
	case SOAP_TYPE_PointerTott__Capabilities:
		return soap_in_PointerTott__Capabilities(soap, tag, NULL, "tt:Capabilities");
	case SOAP_TYPE_PointerTott__CapabilityCategory:
		return soap_in_PointerTott__CapabilityCategory(soap, tag, NULL, "tt:CapabilityCategory");
	case SOAP_TYPE_PointerTotds__DeviceServiceCapabilities:
		return soap_in_PointerTotds__DeviceServiceCapabilities(soap, tag, NULL, "tds:DeviceServiceCapabilities");
	case SOAP_TYPE_PointerTotds__Service:
		return soap_in_PointerTotds__Service(soap, tag, NULL, "tds:Service");
	case SOAP_TYPE_PointerTott__OnvifVersion:
		return soap_in_PointerTott__OnvifVersion(soap, tag, NULL, "tt:OnvifVersion");
	case SOAP_TYPE_PointerTo_tds__Service_Capabilities:
		return soap_in_PointerTo_tds__Service_Capabilities(soap, tag, NULL, "tds:Service-Capabilities");
	case SOAP_TYPE_wstop__SimpleTopicExpression:
	{	char **s;
		s = soap_in_wstop__SimpleTopicExpression(soap, tag, NULL, "xsd:QName");
		return s ? *s : NULL;
	}
	case SOAP_TYPE_wstop__ConcreteTopicExpression:
	{	char **s;
		s = soap_in_wstop__ConcreteTopicExpression(soap, tag, NULL, "wstop:ConcreteTopicExpression");
		return s ? *s : NULL;
	}
	case SOAP_TYPE_wstop__FullTopicExpression:
	{	char **s;
		s = soap_in_wstop__FullTopicExpression(soap, tag, NULL, "wstop:FullTopicExpression");
		return s ? *s : NULL;
	}
	case SOAP_TYPE_tt__IPv6Address:
	{	char **s;
		s = soap_in_tt__IPv6Address(soap, tag, NULL, "tt:IPv6Address");
		return s ? *s : NULL;
	}
	case SOAP_TYPE_tt__IPv4Address:
	{	char **s;
		s = soap_in_tt__IPv4Address(soap, tag, NULL, "tt:IPv4Address");
		return s ? *s : NULL;
	}
	case SOAP_TYPE_tt__TopicNamespaceLocation:
	{	char **s;
		s = soap_in_tt__TopicNamespaceLocation(soap, tag, NULL, "tt:TopicNamespaceLocation");
		return s ? *s : NULL;
	}
	case SOAP_TYPE_tt__Name:
	{	char **s;
		s = soap_in_tt__Name(soap, tag, NULL, "tt:Name");
		return s ? *s : NULL;
	}
	case SOAP_TYPE_tt__ReferenceToken:
	{	char **s;
		s = soap_in_tt__ReferenceToken(soap, tag, NULL, "tt:ReferenceToken");
		return s ? *s : NULL;
	}
	case SOAP_TYPE_wsnt__AbsoluteOrRelativeTimeType:
	{	char **s;
		s = soap_in_wsnt__AbsoluteOrRelativeTimeType(soap, tag, NULL, "wsnt:AbsoluteOrRelativeTimeType");
		return s ? *s : NULL;
	}
	case SOAP_TYPE_tt__StringAttrList:
	{	char **s;
		s = soap_in_tt__StringAttrList(soap, tag, NULL, "tt:StringAttrList");
		return s ? *s : NULL;
	}
	case SOAP_TYPE_tt__FloatAttrList:
	{	char **s;
		s = soap_in_tt__FloatAttrList(soap, tag, NULL, "tt:FloatAttrList");
		return s ? *s : NULL;
	}
	case SOAP_TYPE_tt__IntAttrList:
	{	char **s;
		s = soap_in_tt__IntAttrList(soap, tag, NULL, "tt:IntAttrList");
		return s ? *s : NULL;
	}
	case SOAP_TYPE_tds__EAPMethodTypes:
	{	char **s;
		s = soap_in_tds__EAPMethodTypes(soap, tag, NULL, "tds:EAPMethodTypes");
		return s ? *s : NULL;
	}
	case SOAP_TYPE_xsd__token:
	{	char **s;
		s = soap_in_xsd__token(soap, tag, NULL, "xsd:token");
		return s ? *s : NULL;
	}
	case SOAP_TYPE_xsd__nonNegativeInteger:
	{	char **s;
		s = soap_in_xsd__nonNegativeInteger(soap, tag, NULL, "xsd:nonNegativeInteger");
		return s ? *s : NULL;
	}
	case SOAP_TYPE_xsd__anyURI:
	{	char **s;
		s = soap_in_xsd__anyURI(soap, tag, NULL, "xsd:anyURI");
		return s ? *s : NULL;
	}
	case SOAP_TYPE_xsd__anySimpleType:
	{	char **s;
		s = soap_in_xsd__anySimpleType(soap, tag, NULL, "xsd:anySimpleType");
		return s ? *s : NULL;
	}
	case SOAP_TYPE_xsd__NCName:
	{	char **s;
		s = soap_in_xsd__NCName(soap, tag, NULL, "xsd:NCName");
		return s ? *s : NULL;
	}
	case SOAP_TYPE_PointerTo_wsse__Security:
		return soap_in_PointerTo_wsse__Security(soap, tag, NULL, "wsse:Security");
	case SOAP_TYPE_PointerTods__SignatureType:
		return soap_in_PointerTods__SignatureType(soap, tag, NULL, "ds:SignatureType");
	case SOAP_TYPE_PointerTowsc__SecurityContextTokenType:
		return soap_in_PointerTowsc__SecurityContextTokenType(soap, tag, NULL, "wsc:SecurityContextTokenType");
	case SOAP_TYPE_PointerTo_wsse__BinarySecurityToken:
		return soap_in_PointerTo_wsse__BinarySecurityToken(soap, tag, NULL, "wsse:BinarySecurityToken");
	case SOAP_TYPE_PointerTo_wsse__UsernameToken:
		return soap_in_PointerTo_wsse__UsernameToken(soap, tag, NULL, "wsse:UsernameToken");
	case SOAP_TYPE_PointerTo_wsu__Timestamp:
		return soap_in_PointerTo_wsu__Timestamp(soap, tag, NULL, "wsu:Timestamp");
	case SOAP_TYPE_PointerToPointerTo_ds__KeyInfo:
		return soap_in_PointerToPointerTo_ds__KeyInfo(soap, tag, NULL, "ds:KeyInfo");
	case SOAP_TYPE_PointerTosaml2__AttributeType:
		return soap_in_PointerTosaml2__AttributeType(soap, tag, NULL, "saml2:AttributeType");
	case SOAP_TYPE_PointerTosaml2__EvidenceType:
		return soap_in_PointerTosaml2__EvidenceType(soap, tag, NULL, "saml2:EvidenceType");
	case SOAP_TYPE_PointerTosaml2__ActionType:
		return soap_in_PointerTosaml2__ActionType(soap, tag, NULL, "saml2:ActionType");
	case SOAP_TYPE_PointerTosaml2__AuthnContextType:
		return soap_in_PointerTosaml2__AuthnContextType(soap, tag, NULL, "saml2:AuthnContextType");
	case SOAP_TYPE_PointerTosaml2__SubjectLocalityType:
		return soap_in_PointerTosaml2__SubjectLocalityType(soap, tag, NULL, "saml2:SubjectLocalityType");
	case SOAP_TYPE_PointerTosaml2__AssertionType:
		return soap_in_PointerTosaml2__AssertionType(soap, tag, NULL, "saml2:AssertionType");
	case SOAP_TYPE_PointerTosaml2__ProxyRestrictionType:
		return soap_in_PointerTosaml2__ProxyRestrictionType(soap, tag, NULL, "saml2:ProxyRestrictionType");
	case SOAP_TYPE_PointerTosaml2__OneTimeUseType:
		return soap_in_PointerTosaml2__OneTimeUseType(soap, tag, NULL, "saml2:OneTimeUseType");
	case SOAP_TYPE_PointerTosaml2__AudienceRestrictionType:
		return soap_in_PointerTosaml2__AudienceRestrictionType(soap, tag, NULL, "saml2:AudienceRestrictionType");
	case SOAP_TYPE_PointerTosaml2__ConditionAbstractType:
		return soap_in_PointerTosaml2__ConditionAbstractType(soap, tag, NULL, "saml2:ConditionAbstractType");
	case SOAP_TYPE_PointerTosaml2__SubjectConfirmationDataType:
		return soap_in_PointerTosaml2__SubjectConfirmationDataType(soap, tag, NULL, "saml2:SubjectConfirmationDataType");
	case SOAP_TYPE_PointerTosaml2__SubjectConfirmationType:
		return soap_in_PointerTosaml2__SubjectConfirmationType(soap, tag, NULL, "saml2:SubjectConfirmationType");
	case SOAP_TYPE_PointerTosaml2__EncryptedElementType:
		return soap_in_PointerTosaml2__EncryptedElementType(soap, tag, NULL, "saml2:EncryptedElementType");
	case SOAP_TYPE_PointerTosaml2__BaseIDAbstractType:
		return soap_in_PointerTosaml2__BaseIDAbstractType(soap, tag, NULL, "saml2:BaseIDAbstractType");
	case SOAP_TYPE_PointerTosaml2__AttributeStatementType:
		return soap_in_PointerTosaml2__AttributeStatementType(soap, tag, NULL, "saml2:AttributeStatementType");
	case SOAP_TYPE_PointerTosaml2__AuthzDecisionStatementType:
		return soap_in_PointerTosaml2__AuthzDecisionStatementType(soap, tag, NULL, "saml2:AuthzDecisionStatementType");
	case SOAP_TYPE_PointerTosaml2__AuthnStatementType:
		return soap_in_PointerTosaml2__AuthnStatementType(soap, tag, NULL, "saml2:AuthnStatementType");
	case SOAP_TYPE_PointerTosaml2__StatementAbstractType:
		return soap_in_PointerTosaml2__StatementAbstractType(soap, tag, NULL, "saml2:StatementAbstractType");
	case SOAP_TYPE_PointerTosaml2__AdviceType:
		return soap_in_PointerTosaml2__AdviceType(soap, tag, NULL, "saml2:AdviceType");
	case SOAP_TYPE_PointerTosaml2__ConditionsType:
		return soap_in_PointerTosaml2__ConditionsType(soap, tag, NULL, "saml2:ConditionsType");
	case SOAP_TYPE_PointerTosaml2__SubjectType:
		return soap_in_PointerTosaml2__SubjectType(soap, tag, NULL, "saml2:SubjectType");
	case SOAP_TYPE_PointerTosaml2__NameIDType:
		return soap_in_PointerTosaml2__NameIDType(soap, tag, NULL, "saml2:NameIDType");
	case SOAP_TYPE_PointerToPointerToxenc__EncryptedKeyType:
		return soap_in_PointerToPointerToxenc__EncryptedKeyType(soap, tag, NULL, "xenc:EncryptedKeyType");
	case SOAP_TYPE_PointerTosaml1__AttributeType:
		return soap_in_PointerTosaml1__AttributeType(soap, tag, NULL, "saml1:AttributeType");
	case SOAP_TYPE_PointerTosaml1__EvidenceType:
		return soap_in_PointerTosaml1__EvidenceType(soap, tag, NULL, "saml1:EvidenceType");
	case SOAP_TYPE_PointerTosaml1__ActionType:
		return soap_in_PointerTosaml1__ActionType(soap, tag, NULL, "saml1:ActionType");
	case SOAP_TYPE_PointerTosaml1__AuthorityBindingType:
		return soap_in_PointerTosaml1__AuthorityBindingType(soap, tag, NULL, "saml1:AuthorityBindingType");
	case SOAP_TYPE_PointerTosaml1__SubjectLocalityType:
		return soap_in_PointerTosaml1__SubjectLocalityType(soap, tag, NULL, "saml1:SubjectLocalityType");
	case SOAP_TYPE_PointerTosaml1__SubjectType:
		return soap_in_PointerTosaml1__SubjectType(soap, tag, NULL, "saml1:SubjectType");
	case SOAP_TYPE_PointerTostring:
		return soap_in_PointerTostring(soap, tag, NULL, "xsd:string");
	case SOAP_TYPE_PointerTosaml1__SubjectConfirmationType:
		return soap_in_PointerTosaml1__SubjectConfirmationType(soap, tag, NULL, "saml1:SubjectConfirmationType");
	case SOAP_TYPE_PointerTosaml1__NameIdentifierType:
		return soap_in_PointerTosaml1__NameIdentifierType(soap, tag, NULL, "saml1:NameIdentifierType");
	case SOAP_TYPE_PointerTosaml1__AssertionType:
		return soap_in_PointerTosaml1__AssertionType(soap, tag, NULL, "saml1:AssertionType");
	case SOAP_TYPE_PointerToxsd__dateTime:
		return soap_in_PointerToxsd__dateTime(soap, tag, NULL, "xsd:dateTime");
	case SOAP_TYPE_PointerTosaml1__ConditionAbstractType:
		return soap_in_PointerTosaml1__ConditionAbstractType(soap, tag, NULL, "saml1:ConditionAbstractType");
	case SOAP_TYPE_PointerTosaml1__DoNotCacheConditionType:
		return soap_in_PointerTosaml1__DoNotCacheConditionType(soap, tag, NULL, "saml1:DoNotCacheConditionType");
	case SOAP_TYPE_PointerTosaml1__AudienceRestrictionConditionType:
		return soap_in_PointerTosaml1__AudienceRestrictionConditionType(soap, tag, NULL, "saml1:AudienceRestrictionConditionType");
	case SOAP_TYPE_PointerTo_ds__Signature:
		return soap_in_PointerTo_ds__Signature(soap, tag, NULL, "ds:Signature");
	case SOAP_TYPE_PointerTosaml1__AttributeStatementType:
		return soap_in_PointerTosaml1__AttributeStatementType(soap, tag, NULL, "saml1:AttributeStatementType");
	case SOAP_TYPE_PointerTosaml1__AuthorizationDecisionStatementType:
		return soap_in_PointerTosaml1__AuthorizationDecisionStatementType(soap, tag, NULL, "saml1:AuthorizationDecisionStatementType");
	case SOAP_TYPE_PointerTosaml1__AuthenticationStatementType:
		return soap_in_PointerTosaml1__AuthenticationStatementType(soap, tag, NULL, "saml1:AuthenticationStatementType");
	case SOAP_TYPE_PointerTosaml1__SubjectStatementAbstractType:
		return soap_in_PointerTosaml1__SubjectStatementAbstractType(soap, tag, NULL, "saml1:SubjectStatementAbstractType");
	case SOAP_TYPE_PointerTosaml1__StatementAbstractType:
		return soap_in_PointerTosaml1__StatementAbstractType(soap, tag, NULL, "saml1:StatementAbstractType");
	case SOAP_TYPE_PointerTosaml1__AdviceType:
		return soap_in_PointerTosaml1__AdviceType(soap, tag, NULL, "saml1:AdviceType");
	case SOAP_TYPE_PointerTosaml1__ConditionsType:
		return soap_in_PointerTosaml1__ConditionsType(soap, tag, NULL, "saml1:ConditionsType");
	case SOAP_TYPE_PointerToULONG64:
		return soap_in_PointerToULONG64(soap, tag, NULL, "xsd:unsignedLong");
	case SOAP_TYPE_PointerTowsc__PropertiesType:
		return soap_in_PointerTowsc__PropertiesType(soap, tag, NULL, "wsc:PropertiesType");
	case SOAP_TYPE_wsc__FaultCodeOpenEnumType:
	{	char **s;
		s = soap_in_wsc__FaultCodeOpenEnumType(soap, tag, NULL, "wsc:FaultCodeOpenEnumType");
		return s ? *s : NULL;
	}
	case SOAP_TYPE_PointerTo_xenc__ReferenceList:
		return soap_in_PointerTo_xenc__ReferenceList(soap, tag, NULL, "xenc:ReferenceList");
	case SOAP_TYPE_PointerToxenc__ReferenceType:
		return soap_in_PointerToxenc__ReferenceType(soap, tag, NULL, "xenc:ReferenceType");
	case SOAP_TYPE_PointerToxenc__EncryptionPropertyType:
		return soap_in_PointerToxenc__EncryptionPropertyType(soap, tag, NULL, "xenc:EncryptionPropertyType");
	case SOAP_TYPE_PointerToxenc__TransformsType:
		return soap_in_PointerToxenc__TransformsType(soap, tag, NULL, "xenc:TransformsType");
	case SOAP_TYPE_PointerToxenc__CipherReferenceType:
		return soap_in_PointerToxenc__CipherReferenceType(soap, tag, NULL, "xenc:CipherReferenceType");
	case SOAP_TYPE_PointerToxenc__EncryptionPropertiesType:
		return soap_in_PointerToxenc__EncryptionPropertiesType(soap, tag, NULL, "xenc:EncryptionPropertiesType");
	case SOAP_TYPE_PointerToxenc__CipherDataType:
		return soap_in_PointerToxenc__CipherDataType(soap, tag, NULL, "xenc:CipherDataType");
	case SOAP_TYPE_PointerTo_ds__KeyInfo:
		return soap_in_PointerTo_ds__KeyInfo(soap, tag, NULL, "ds:KeyInfo");
	case SOAP_TYPE_PointerToxenc__EncryptionMethodType:
		return soap_in_PointerToxenc__EncryptionMethodType(soap, tag, NULL, "xenc:EncryptionMethodType");
	case SOAP_TYPE_PointerTods__X509IssuerSerialType:
		return soap_in_PointerTods__X509IssuerSerialType(soap, tag, NULL, "ds:X509IssuerSerialType");
	case SOAP_TYPE_PointerTods__RSAKeyValueType:
		return soap_in_PointerTods__RSAKeyValueType(soap, tag, NULL, "ds:RSAKeyValueType");
	case SOAP_TYPE_PointerTods__DSAKeyValueType:
		return soap_in_PointerTods__DSAKeyValueType(soap, tag, NULL, "ds:DSAKeyValueType");
	case SOAP_TYPE_PointerTods__TransformType:
		return soap_in_PointerTods__TransformType(soap, tag, NULL, "ds:TransformType");
	case SOAP_TYPE_PointerTods__DigestMethodType:
		return soap_in_PointerTods__DigestMethodType(soap, tag, NULL, "ds:DigestMethodType");
	case SOAP_TYPE_PointerTods__TransformsType:
		return soap_in_PointerTods__TransformsType(soap, tag, NULL, "ds:TransformsType");
	case SOAP_TYPE_PointerToPointerTods__ReferenceType:
		return soap_in_PointerToPointerTods__ReferenceType(soap, tag, NULL, "ds:ReferenceType");
	case SOAP_TYPE_PointerTods__ReferenceType:
		return soap_in_PointerTods__ReferenceType(soap, tag, NULL, "ds:ReferenceType");
	case SOAP_TYPE_PointerTods__SignatureMethodType:
		return soap_in_PointerTods__SignatureMethodType(soap, tag, NULL, "ds:SignatureMethodType");
	case SOAP_TYPE_PointerTods__CanonicalizationMethodType:
		return soap_in_PointerTods__CanonicalizationMethodType(soap, tag, NULL, "ds:CanonicalizationMethodType");
	case SOAP_TYPE_PointerTo_wsse__SecurityTokenReference:
		return soap_in_PointerTo_wsse__SecurityTokenReference(soap, tag, NULL, "wsse:SecurityTokenReference");
	case SOAP_TYPE_PointerTods__RetrievalMethodType:
		return soap_in_PointerTods__RetrievalMethodType(soap, tag, NULL, "ds:RetrievalMethodType");
	case SOAP_TYPE_PointerTods__KeyValueType:
		return soap_in_PointerTods__KeyValueType(soap, tag, NULL, "ds:KeyValueType");
	case SOAP_TYPE_PointerTo_c14n__InclusiveNamespaces:
		return soap_in_PointerTo_c14n__InclusiveNamespaces(soap, tag, NULL, "c14n:InclusiveNamespaces");
	case SOAP_TYPE_PointerTods__KeyInfoType:
		return soap_in_PointerTods__KeyInfoType(soap, tag, NULL, "ds:KeyInfoType");
	case SOAP_TYPE_PointerTods__SignedInfoType:
		return soap_in_PointerTods__SignedInfoType(soap, tag, NULL, "ds:SignedInfoType");
	case SOAP_TYPE_PointerToxenc__EncryptedKeyType:
		return soap_in_PointerToxenc__EncryptedKeyType(soap, tag, NULL, "xenc:EncryptedKeyType");
	case SOAP_TYPE_PointerTods__X509DataType:
		return soap_in_PointerTods__X509DataType(soap, tag, NULL, "ds:X509DataType");
	case SOAP_TYPE_PointerTo_wsse__Embedded:
		return soap_in_PointerTo_wsse__Embedded(soap, tag, NULL, "wsse:Embedded");
	case SOAP_TYPE_PointerTo_wsse__KeyIdentifier:
		return soap_in_PointerTo_wsse__KeyIdentifier(soap, tag, NULL, "wsse:KeyIdentifier");
	case SOAP_TYPE_PointerTo_wsse__Reference:
		return soap_in_PointerTo_wsse__Reference(soap, tag, NULL, "wsse:Reference");
	case SOAP_TYPE_PointerTowsse__EncodedString:
		return soap_in_PointerTowsse__EncodedString(soap, tag, NULL, "wsse:EncodedString");
	case SOAP_TYPE_PointerTo_wsse__Password:
		return soap_in_PointerTo_wsse__Password(soap, tag, NULL, "wsse:Password");
	case SOAP_TYPE_PointerTochan__ChannelInstanceType:
		return soap_in_PointerTochan__ChannelInstanceType(soap, tag, NULL, "chan:ChannelInstanceType");
	case SOAP_TYPE_PointerTo_wsa5__FaultTo:
		return soap_in_PointerTo_wsa5__FaultTo(soap, tag, NULL, "wsa5:FaultTo");
	case SOAP_TYPE_PointerTo_wsa5__ReplyTo:
		return soap_in_PointerTo_wsa5__ReplyTo(soap, tag, NULL, "wsa5:ReplyTo");
	case SOAP_TYPE_PointerTo_wsa5__From:
		return soap_in_PointerTo_wsa5__From(soap, tag, NULL, "wsa5:From");
	case SOAP_TYPE_PointerTo_wsa5__RelatesTo:
		return soap_in_PointerTo_wsa5__RelatesTo(soap, tag, NULL, "wsa5:RelatesTo");
	case SOAP_TYPE__wsa5__ProblemHeaderQName:
	{	char **s;
		s = soap_in__wsa5__ProblemHeaderQName(soap, tag, NULL, "xsd:QName");
		return s ? *s : NULL;
	}
	case SOAP_TYPE_PointerToint:
		return soap_in_PointerToint(soap, tag, NULL, "xsd:int");
	case SOAP_TYPE_PointerTowsa5__MetadataType:
		return soap_in_PointerTowsa5__MetadataType(soap, tag, NULL, "wsa5:MetadataType");
	case SOAP_TYPE_PointerTowsa5__ReferenceParametersType:
		return soap_in_PointerTowsa5__ReferenceParametersType(soap, tag, NULL, "wsa5:ReferenceParametersType");
	case SOAP_TYPE_wsa5__FaultCodesOpenEnumType:
	{	char **s;
		s = soap_in_wsa5__FaultCodesOpenEnumType(soap, tag, NULL, "wsa5:FaultCodesOpenEnumType");
		return s ? *s : NULL;
	}
	case SOAP_TYPE_wsa5__RelationshipTypeOpenEnum:
	{	char **s;
		s = soap_in_wsa5__RelationshipTypeOpenEnum(soap, tag, NULL, "wsa5:RelationshipTypeOpenEnum");
		return s ? *s : NULL;
	}
	case SOAP_TYPE_PointerTowsdd__ResolveMatchesType:
		return soap_in_PointerTowsdd__ResolveMatchesType(soap, tag, NULL, "wsdd:ResolveMatchesType");
	case SOAP_TYPE_PointerTowsdd__ResolveType:
		return soap_in_PointerTowsdd__ResolveType(soap, tag, NULL, "wsdd:ResolveType");
	case SOAP_TYPE_PointerTowsdd__ProbeMatchesType:
		return soap_in_PointerTowsdd__ProbeMatchesType(soap, tag, NULL, "wsdd:ProbeMatchesType");
	case SOAP_TYPE_PointerTowsdd__ProbeType:
		return soap_in_PointerTowsdd__ProbeType(soap, tag, NULL, "wsdd:ProbeType");
	case SOAP_TYPE_PointerTowsdd__ByeType:
		return soap_in_PointerTowsdd__ByeType(soap, tag, NULL, "wsdd:ByeType");
	case SOAP_TYPE_PointerTowsdd__HelloType:
		return soap_in_PointerTowsdd__HelloType(soap, tag, NULL, "wsdd:HelloType");
	case SOAP_TYPE_PointerTowsdd__AppSequenceType:
		return soap_in_PointerTowsdd__AppSequenceType(soap, tag, NULL, "wsdd:AppSequenceType");
	case SOAP_TYPE__wsdd__Types:
	{	char **s;
		s = soap_in__wsdd__Types(soap, tag, NULL, "xsd:QName");
		return s ? *s : NULL;
	}
	case SOAP_TYPE_PointerTowsdd__SigType:
		return soap_in_PointerTowsdd__SigType(soap, tag, NULL, "wsdd:SigType");
	case SOAP_TYPE_PointerTowsdd__ResolveMatchType:
		return soap_in_PointerTowsdd__ResolveMatchType(soap, tag, NULL, "wsdd:ResolveMatchType");
	case SOAP_TYPE_PointerTowsdd__ProbeMatchType:
		return soap_in_PointerTowsdd__ProbeMatchType(soap, tag, NULL, "wsdd:ProbeMatchType");
	case SOAP_TYPE_PointerTounsignedInt:
		return soap_in_PointerTounsignedInt(soap, tag, NULL, "xsd:unsignedInt");
	case SOAP_TYPE_PointerTowsdd__ScopesType:
		return soap_in_PointerTowsdd__ScopesType(soap, tag, NULL, "wsdd:ScopesType");
	case SOAP_TYPE_wsdd__FaultCodeOpenType:
	{	char **s;
		s = soap_in_wsdd__FaultCodeOpenType(soap, tag, NULL, "wsdd:FaultCodeOpenType");
		return s ? *s : NULL;
	}
	case SOAP_TYPE_wsdd__UriListType:
	{	char **s;
		s = soap_in_wsdd__UriListType(soap, tag, NULL, "wsdd:UriListType");
		return s ? *s : NULL;
	}
	case SOAP_TYPE_wsdd__QNameListType:
	{	char **s;
		s = soap_in_wsdd__QNameListType(soap, tag, NULL, "xsd:QName");
		return s ? *s : NULL;
	}
	case SOAP_TYPE_PointerTo_wsa__FaultTo:
		return soap_in_PointerTo_wsa__FaultTo(soap, tag, NULL, "wsa:FaultTo");
	case SOAP_TYPE_PointerTo_wsa__ReplyTo:
		return soap_in_PointerTo_wsa__ReplyTo(soap, tag, NULL, "wsa:ReplyTo");
	case SOAP_TYPE_PointerTo_wsa__From:
		return soap_in_PointerTo_wsa__From(soap, tag, NULL, "wsa:From");
	case SOAP_TYPE_PointerTo_wsa__RelatesTo:
		return soap_in_PointerTo_wsa__RelatesTo(soap, tag, NULL, "wsa:RelatesTo");
	case SOAP_TYPE_PointerTowsa__ServiceNameType:
		return soap_in_PointerTowsa__ServiceNameType(soap, tag, NULL, "wsa:ServiceNameType");
	case SOAP_TYPE_PointerTo_QName:
		return soap_in_PointerTo_QName(soap, tag, NULL, "xsd:QName");
	case SOAP_TYPE_PointerTowsa__ReferenceParametersType:
		return soap_in_PointerTowsa__ReferenceParametersType(soap, tag, NULL, "wsa:ReferenceParametersType");
	case SOAP_TYPE_PointerTowsa__ReferencePropertiesType:
		return soap_in_PointerTowsa__ReferencePropertiesType(soap, tag, NULL, "wsa:ReferencePropertiesType");
	case SOAP_TYPE__QName:
	{	char **s;
		s = soap_in__QName(soap, tag, NULL, "xsd:QName");
		return s ? *s : NULL;
	}
	case SOAP_TYPE_string:
	{	char **s;
		s = soap_in_string(soap, tag, NULL, "xsd:string");
		return s ? *s : NULL;
	}
	default:
#else
	*type = 0;
#endif
	{	const char *t = soap->type;
		if (!*t)
			t = soap->tag;
		if (!soap_match_tag(soap, t, "xsd:byte"))
		{	*type = SOAP_TYPE_byte;
			return soap_in_byte(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:int"))
		{	*type = SOAP_TYPE_int;
			return soap_in_int(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:duration"))
		{	*type = SOAP_TYPE_xsd__duration;
			return soap_in_xsd__duration(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:float"))
		{	*type = SOAP_TYPE_float;
			return soap_in_float(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:unsignedInt"))
		{	*type = SOAP_TYPE_unsignedInt;
			return soap_in_unsignedInt(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:unsignedLong"))
		{	*type = SOAP_TYPE_ULONG64;
			return soap_in_ULONG64(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:dateTime"))
		{	*type = SOAP_TYPE_dateTime;
			return soap_in_dateTime(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tt:IPType"))
		{	*type = SOAP_TYPE_tt__IPType;
			return soap_in_tt__IPType(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tt:H264Profile"))
		{	*type = SOAP_TYPE_tt__H264Profile;
			return soap_in_tt__H264Profile(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tt:Mpeg4Profile"))
		{	*type = SOAP_TYPE_tt__Mpeg4Profile;
			return soap_in_tt__Mpeg4Profile(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tt:VideoEncoding"))
		{	*type = SOAP_TYPE_tt__VideoEncoding;
			return soap_in_tt__VideoEncoding(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tt:PropertyOperation"))
		{	*type = SOAP_TYPE_tt__PropertyOperation;
			return soap_in_tt__PropertyOperation(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tt:MoveStatus"))
		{	*type = SOAP_TYPE_tt__MoveStatus;
			return soap_in_tt__MoveStatus(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tt:CapabilityCategory"))
		{	*type = SOAP_TYPE_tt__CapabilityCategory;
			return soap_in_tt__CapabilityCategory(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:boolean"))
		{	*type = SOAP_TYPE_xsd__boolean;
			return soap_in_xsd__boolean(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "saml2:DecisionType"))
		{	*type = SOAP_TYPE_saml2__DecisionType;
			return soap_in_saml2__DecisionType(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "saml1:DecisionType"))
		{	*type = SOAP_TYPE_saml1__DecisionType;
			return soap_in_saml1__DecisionType(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wsc:FaultCodeType"))
		{	*type = SOAP_TYPE_wsc__FaultCodeType;
			return soap_in_wsc__FaultCodeType(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wsse:FaultcodeEnum"))
		{	*type = SOAP_TYPE_wsse__FaultcodeEnum;
			return soap_in_wsse__FaultcodeEnum(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wsu:tTimestampFault"))
		{	*type = SOAP_TYPE_wsu__tTimestampFault;
			return soap_in_wsu__tTimestampFault(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wsa5:IsReferenceParameter"))
		{	*type = SOAP_TYPE__wsa5__IsReferenceParameter;
			return soap_in__wsa5__IsReferenceParameter(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wsa5:FaultCodesType"))
		{	*type = SOAP_TYPE_wsa5__FaultCodesType;
			return soap_in_wsa5__FaultCodesType(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wsa5:RelationshipType"))
		{	*type = SOAP_TYPE_wsa5__RelationshipType;
			return soap_in_wsa5__RelationshipType(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wsdd:FaultCodeType"))
		{	*type = SOAP_TYPE_wsdd__FaultCodeType;
			return soap_in_wsdd__FaultCodeType(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wsa:FaultSubcodeValues"))
		{	*type = SOAP_TYPE_wsa__FaultSubcodeValues;
			return soap_in_wsa__FaultSubcodeValues(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wsa:RelationshipTypeValues"))
		{	*type = SOAP_TYPE_wsa__RelationshipTypeValues;
			return soap_in_wsa__RelationshipTypeValues(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wstop:TopicType"))
		{	*type = SOAP_TYPE_wstop__TopicType;
			return soap_in_wstop__TopicType(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wstop:TopicNamespaceType"))
		{	*type = SOAP_TYPE_wstop__TopicNamespaceType;
			return soap_in_wstop__TopicNamespaceType(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wsnt:ResumeFailedFaultType"))
		{	*type = SOAP_TYPE_wsnt__ResumeFailedFaultType;
			return soap_in_wsnt__ResumeFailedFaultType(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wsnt:PauseFailedFaultType"))
		{	*type = SOAP_TYPE_wsnt__PauseFailedFaultType;
			return soap_in_wsnt__PauseFailedFaultType(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wsnt:UnableToDestroySubscriptionFaultType"))
		{	*type = SOAP_TYPE_wsnt__UnableToDestroySubscriptionFaultType;
			return soap_in_wsnt__UnableToDestroySubscriptionFaultType(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wsnt:UnacceptableTerminationTimeFaultType"))
		{	*type = SOAP_TYPE_wsnt__UnacceptableTerminationTimeFaultType;
			return soap_in_wsnt__UnacceptableTerminationTimeFaultType(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wsnt:UnableToCreatePullPointFaultType"))
		{	*type = SOAP_TYPE_wsnt__UnableToCreatePullPointFaultType;
			return soap_in_wsnt__UnableToCreatePullPointFaultType(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wsnt:UnableToDestroyPullPointFaultType"))
		{	*type = SOAP_TYPE_wsnt__UnableToDestroyPullPointFaultType;
			return soap_in_wsnt__UnableToDestroyPullPointFaultType(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wsnt:UnableToGetMessagesFaultType"))
		{	*type = SOAP_TYPE_wsnt__UnableToGetMessagesFaultType;
			return soap_in_wsnt__UnableToGetMessagesFaultType(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wsnt:NoCurrentMessageOnTopicFaultType"))
		{	*type = SOAP_TYPE_wsnt__NoCurrentMessageOnTopicFaultType;
			return soap_in_wsnt__NoCurrentMessageOnTopicFaultType(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wsnt:UnacceptableInitialTerminationTimeFaultType"))
		{	*type = SOAP_TYPE_wsnt__UnacceptableInitialTerminationTimeFaultType;
			return soap_in_wsnt__UnacceptableInitialTerminationTimeFaultType(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wsnt:NotifyMessageNotSupportedFaultType"))
		{	*type = SOAP_TYPE_wsnt__NotifyMessageNotSupportedFaultType;
			return soap_in_wsnt__NotifyMessageNotSupportedFaultType(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wsnt:UnsupportedPolicyRequestFaultType"))
		{	*type = SOAP_TYPE_wsnt__UnsupportedPolicyRequestFaultType;
			return soap_in_wsnt__UnsupportedPolicyRequestFaultType(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wsnt:UnrecognizedPolicyRequestFaultType"))
		{	*type = SOAP_TYPE_wsnt__UnrecognizedPolicyRequestFaultType;
			return soap_in_wsnt__UnrecognizedPolicyRequestFaultType(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wsnt:InvalidMessageContentExpressionFaultType"))
		{	*type = SOAP_TYPE_wsnt__InvalidMessageContentExpressionFaultType;
			return soap_in_wsnt__InvalidMessageContentExpressionFaultType(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wsnt:InvalidProducerPropertiesExpressionFaultType"))
		{	*type = SOAP_TYPE_wsnt__InvalidProducerPropertiesExpressionFaultType;
			return soap_in_wsnt__InvalidProducerPropertiesExpressionFaultType(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wsnt:MultipleTopicsSpecifiedFaultType"))
		{	*type = SOAP_TYPE_wsnt__MultipleTopicsSpecifiedFaultType;
			return soap_in_wsnt__MultipleTopicsSpecifiedFaultType(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wsnt:TopicNotSupportedFaultType"))
		{	*type = SOAP_TYPE_wsnt__TopicNotSupportedFaultType;
			return soap_in_wsnt__TopicNotSupportedFaultType(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wsnt:InvalidTopicExpressionFaultType"))
		{	*type = SOAP_TYPE_wsnt__InvalidTopicExpressionFaultType;
			return soap_in_wsnt__InvalidTopicExpressionFaultType(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wsnt:TopicExpressionDialectUnknownFaultType"))
		{	*type = SOAP_TYPE_wsnt__TopicExpressionDialectUnknownFaultType;
			return soap_in_wsnt__TopicExpressionDialectUnknownFaultType(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wsnt:InvalidFilterFaultType"))
		{	*type = SOAP_TYPE_wsnt__InvalidFilterFaultType;
			return soap_in_wsnt__InvalidFilterFaultType(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wsnt:SubscribeCreationFailedFaultType"))
		{	*type = SOAP_TYPE_wsnt__SubscribeCreationFailedFaultType;
			return soap_in_wsnt__SubscribeCreationFailedFaultType(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "trt:ProfileCapabilities"))
		{	*type = SOAP_TYPE_trt__ProfileCapabilities;
			return soap_in_trt__ProfileCapabilities(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "trt:Capabilities"))
		{	*type = SOAP_TYPE_trt__Capabilities;
			return soap_in_trt__Capabilities(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wstop:QueryExpressionType"))
		{	*type = SOAP_TYPE_wstop__QueryExpressionType;
			return soap_in_wstop__QueryExpressionType(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wstop:ExtensibleDocumented"))
		{	*type = SOAP_TYPE_wstop__ExtensibleDocumented;
			return soap_in_wstop__ExtensibleDocumented(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wstop:Documentation"))
		{	*type = SOAP_TYPE_wstop__Documentation;
			return soap_in_wstop__Documentation(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wsrfbf:BaseFaultType"))
		{	*type = SOAP_TYPE_wsrfbf__BaseFaultType;
			return soap_in_wsrfbf__BaseFaultType(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wstop:TopicSetType"))
		{	*type = SOAP_TYPE_wstop__TopicSetType;
			return soap_in_wstop__TopicSetType(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wsnt:NotificationMessageHolderType"))
		{	*type = SOAP_TYPE_wsnt__NotificationMessageHolderType;
			return soap_in_wsnt__NotificationMessageHolderType(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wsnt:SubscriptionPolicyType"))
		{	*type = SOAP_TYPE_wsnt__SubscriptionPolicyType;
			return soap_in_wsnt__SubscriptionPolicyType(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wsnt:FilterType"))
		{	*type = SOAP_TYPE_wsnt__FilterType;
			return soap_in_wsnt__FilterType(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wsnt:TopicExpressionType"))
		{	*type = SOAP_TYPE_wsnt__TopicExpressionType;
			return soap_in_wsnt__TopicExpressionType(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wsnt:QueryExpressionType"))
		{	*type = SOAP_TYPE_wsnt__QueryExpressionType;
			return soap_in_wsnt__QueryExpressionType(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tt:MediaUri"))
		{	*type = SOAP_TYPE_tt__MediaUri;
			return soap_in_tt__MediaUri(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tt:MulticastConfiguration"))
		{	*type = SOAP_TYPE_tt__MulticastConfiguration;
			return soap_in_tt__MulticastConfiguration(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tt:IPAddress"))
		{	*type = SOAP_TYPE_tt__IPAddress;
			return soap_in_tt__IPAddress(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tt:VideoEncoderOptionsExtension2"))
		{	*type = SOAP_TYPE_tt__VideoEncoderOptionsExtension2;
			return soap_in_tt__VideoEncoderOptionsExtension2(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tt:H264Options2"))
		{	*type = SOAP_TYPE_tt__H264Options2;
			return soap_in_tt__H264Options2(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tt:Mpeg4Options2"))
		{	*type = SOAP_TYPE_tt__Mpeg4Options2;
			return soap_in_tt__Mpeg4Options2(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tt:JpegOptions2"))
		{	*type = SOAP_TYPE_tt__JpegOptions2;
			return soap_in_tt__JpegOptions2(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tt:VideoEncoderOptionsExtension"))
		{	*type = SOAP_TYPE_tt__VideoEncoderOptionsExtension;
			return soap_in_tt__VideoEncoderOptionsExtension(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tt:H264Options"))
		{	*type = SOAP_TYPE_tt__H264Options;
			return soap_in_tt__H264Options(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tt:Mpeg4Options"))
		{	*type = SOAP_TYPE_tt__Mpeg4Options;
			return soap_in_tt__Mpeg4Options(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tt:JpegOptions"))
		{	*type = SOAP_TYPE_tt__JpegOptions;
			return soap_in_tt__JpegOptions(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tt:VideoEncoderConfigurationOptions"))
		{	*type = SOAP_TYPE_tt__VideoEncoderConfigurationOptions;
			return soap_in_tt__VideoEncoderConfigurationOptions(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tt:H264Configuration"))
		{	*type = SOAP_TYPE_tt__H264Configuration;
			return soap_in_tt__H264Configuration(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tt:Mpeg4Configuration"))
		{	*type = SOAP_TYPE_tt__Mpeg4Configuration;
			return soap_in_tt__Mpeg4Configuration(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tt:VideoRateControl"))
		{	*type = SOAP_TYPE_tt__VideoRateControl;
			return soap_in_tt__VideoRateControl(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tt:VideoResolution"))
		{	*type = SOAP_TYPE_tt__VideoResolution;
			return soap_in_tt__VideoResolution(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tt:ItemListDescriptionExtension"))
		{	*type = SOAP_TYPE_tt__ItemListDescriptionExtension;
			return soap_in_tt__ItemListDescriptionExtension(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tt:MessageDescriptionExtension"))
		{	*type = SOAP_TYPE_tt__MessageDescriptionExtension;
			return soap_in_tt__MessageDescriptionExtension(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tt:ItemListDescription"))
		{	*type = SOAP_TYPE_tt__ItemListDescription;
			return soap_in_tt__ItemListDescription(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tt:MessageDescription"))
		{	*type = SOAP_TYPE_tt__MessageDescription;
			return soap_in_tt__MessageDescription(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tt:ItemListExtension"))
		{	*type = SOAP_TYPE_tt__ItemListExtension;
			return soap_in_tt__ItemListExtension(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tt:ItemList"))
		{	*type = SOAP_TYPE_tt__ItemList;
			return soap_in_tt__ItemList(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tt:MessageExtension"))
		{	*type = SOAP_TYPE_tt__MessageExtension;
			return soap_in_tt__MessageExtension(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tt:PTZMoveStatus"))
		{	*type = SOAP_TYPE_tt__PTZMoveStatus;
			return soap_in_tt__PTZMoveStatus(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tt:PTZPreset"))
		{	*type = SOAP_TYPE_tt__PTZPreset;
			return soap_in_tt__PTZPreset(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tt:PTZSpeed"))
		{	*type = SOAP_TYPE_tt__PTZSpeed;
			return soap_in_tt__PTZSpeed(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tt:PTZVector"))
		{	*type = SOAP_TYPE_tt__PTZVector;
			return soap_in_tt__PTZVector(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tt:Vector1D"))
		{	*type = SOAP_TYPE_tt__Vector1D;
			return soap_in_tt__Vector1D(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tt:Vector2D"))
		{	*type = SOAP_TYPE_tt__Vector2D;
			return soap_in_tt__Vector2D(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tt:PTZSpaces"))
		{	*type = SOAP_TYPE_tt__PTZSpaces;
			return soap_in_tt__PTZSpaces(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tt:Space1DDescription"))
		{	*type = SOAP_TYPE_tt__Space1DDescription;
			return soap_in_tt__Space1DDescription(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tt:ZoomLimits"))
		{	*type = SOAP_TYPE_tt__ZoomLimits;
			return soap_in_tt__ZoomLimits(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tt:Space2DDescription"))
		{	*type = SOAP_TYPE_tt__Space2DDescription;
			return soap_in_tt__Space2DDescription(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tt:PanTiltLimits"))
		{	*type = SOAP_TYPE_tt__PanTiltLimits;
			return soap_in_tt__PanTiltLimits(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tt:ProfileCapabilities"))
		{	*type = SOAP_TYPE_tt__ProfileCapabilities;
			return soap_in_tt__ProfileCapabilities(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tt:MediaCapabilitiesExtension"))
		{	*type = SOAP_TYPE_tt__MediaCapabilitiesExtension;
			return soap_in_tt__MediaCapabilitiesExtension(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tt:RealTimeStreamingCapabilities"))
		{	*type = SOAP_TYPE_tt__RealTimeStreamingCapabilities;
			return soap_in_tt__RealTimeStreamingCapabilities(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tt:SystemCapabilities"))
		{	*type = SOAP_TYPE_tt__SystemCapabilities;
			return soap_in_tt__SystemCapabilities(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tt:PTZCapabilities"))
		{	*type = SOAP_TYPE_tt__PTZCapabilities;
			return soap_in_tt__PTZCapabilities(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tt:MediaCapabilities"))
		{	*type = SOAP_TYPE_tt__MediaCapabilities;
			return soap_in_tt__MediaCapabilities(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tt:EventCapabilities"))
		{	*type = SOAP_TYPE_tt__EventCapabilities;
			return soap_in_tt__EventCapabilities(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tt:DeviceCapabilities"))
		{	*type = SOAP_TYPE_tt__DeviceCapabilities;
			return soap_in_tt__DeviceCapabilities(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tt:ConfigurationEntity"))
		{	*type = SOAP_TYPE_tt__ConfigurationEntity;
			return soap_in_tt__ConfigurationEntity(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tt:VideoEncoderConfiguration"))
		{	*type = SOAP_TYPE_tt__VideoEncoderConfiguration;
			return soap_in_tt__VideoEncoderConfiguration(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tt:Profile"))
		{	*type = SOAP_TYPE_tt__Profile;
			return soap_in_tt__Profile(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tt:AnyHolder"))
		{	*type = SOAP_TYPE_tt__AnyHolder;
			return soap_in_tt__AnyHolder(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tt:FloatList"))
		{	*type = SOAP_TYPE_tt__FloatList;
			return soap_in_tt__FloatList(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tt:IntList"))
		{	*type = SOAP_TYPE_tt__IntList;
			return soap_in_tt__IntList(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tt:DurationRange"))
		{	*type = SOAP_TYPE_tt__DurationRange;
			return soap_in_tt__DurationRange(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tt:FloatRange"))
		{	*type = SOAP_TYPE_tt__FloatRange;
			return soap_in_tt__FloatRange(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tt:IntRange"))
		{	*type = SOAP_TYPE_tt__IntRange;
			return soap_in_tt__IntRange(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tt:IntRectangleRange"))
		{	*type = SOAP_TYPE_tt__IntRectangleRange;
			return soap_in_tt__IntRectangleRange(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tt:IntRectangle"))
		{	*type = SOAP_TYPE_tt__IntRectangle;
			return soap_in_tt__IntRectangle(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tt:DeviceEntity"))
		{	*type = SOAP_TYPE_tt__DeviceEntity;
			return soap_in_tt__DeviceEntity(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tt:Capabilities"))
		{	*type = SOAP_TYPE_tt__Capabilities;
			return soap_in_tt__Capabilities(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tds:DeviceServiceCapabilities"))
		{	*type = SOAP_TYPE_tds__DeviceServiceCapabilities;
			return soap_in_tds__DeviceServiceCapabilities(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tt:OnvifVersion"))
		{	*type = SOAP_TYPE_tt__OnvifVersion;
			return soap_in_tt__OnvifVersion(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tds:Service"))
		{	*type = SOAP_TYPE_tds__Service;
			return soap_in_tds__Service(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "saml2:AttributeType"))
		{	*type = SOAP_TYPE_saml2__AttributeType;
			return soap_in_saml2__AttributeType(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "saml2:AttributeStatementType"))
		{	*type = SOAP_TYPE_saml2__AttributeStatementType;
			return soap_in_saml2__AttributeStatementType(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "saml2:EvidenceType"))
		{	*type = SOAP_TYPE_saml2__EvidenceType;
			return soap_in_saml2__EvidenceType(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "saml2:ActionType"))
		{	*type = SOAP_TYPE_saml2__ActionType;
			return soap_in_saml2__ActionType(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "saml2:AuthzDecisionStatementType"))
		{	*type = SOAP_TYPE_saml2__AuthzDecisionStatementType;
			return soap_in_saml2__AuthzDecisionStatementType(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "saml2:AuthnContextType"))
		{	*type = SOAP_TYPE_saml2__AuthnContextType;
			return soap_in_saml2__AuthnContextType(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "saml2:SubjectLocalityType"))
		{	*type = SOAP_TYPE_saml2__SubjectLocalityType;
			return soap_in_saml2__SubjectLocalityType(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "saml2:AuthnStatementType"))
		{	*type = SOAP_TYPE_saml2__AuthnStatementType;
			return soap_in_saml2__AuthnStatementType(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "saml2:StatementAbstractType"))
		{	*type = SOAP_TYPE_saml2__StatementAbstractType;
			return soap_in_saml2__StatementAbstractType(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "saml2:AdviceType"))
		{	*type = SOAP_TYPE_saml2__AdviceType;
			return soap_in_saml2__AdviceType(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "saml2:ProxyRestrictionType"))
		{	*type = SOAP_TYPE_saml2__ProxyRestrictionType;
			return soap_in_saml2__ProxyRestrictionType(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "saml2:OneTimeUseType"))
		{	*type = SOAP_TYPE_saml2__OneTimeUseType;
			return soap_in_saml2__OneTimeUseType(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "saml2:AudienceRestrictionType"))
		{	*type = SOAP_TYPE_saml2__AudienceRestrictionType;
			return soap_in_saml2__AudienceRestrictionType(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "saml2:ConditionAbstractType"))
		{	*type = SOAP_TYPE_saml2__ConditionAbstractType;
			return soap_in_saml2__ConditionAbstractType(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "saml2:ConditionsType"))
		{	*type = SOAP_TYPE_saml2__ConditionsType;
			return soap_in_saml2__ConditionsType(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "saml2:KeyInfoConfirmationDataType"))
		{	*type = SOAP_TYPE_saml2__KeyInfoConfirmationDataType;
			return soap_in_saml2__KeyInfoConfirmationDataType(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "saml2:SubjectConfirmationDataType"))
		{	*type = SOAP_TYPE_saml2__SubjectConfirmationDataType;
			return soap_in_saml2__SubjectConfirmationDataType(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "saml2:SubjectConfirmationType"))
		{	*type = SOAP_TYPE_saml2__SubjectConfirmationType;
			return soap_in_saml2__SubjectConfirmationType(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "saml2:SubjectType"))
		{	*type = SOAP_TYPE_saml2__SubjectType;
			return soap_in_saml2__SubjectType(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "saml2:AssertionType"))
		{	*type = SOAP_TYPE_saml2__AssertionType;
			return soap_in_saml2__AssertionType(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "saml2:EncryptedElementType"))
		{	*type = SOAP_TYPE_saml2__EncryptedElementType;
			return soap_in_saml2__EncryptedElementType(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "saml2:NameIDType"))
		{	*type = SOAP_TYPE_saml2__NameIDType;
			return soap_in_saml2__NameIDType(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "saml2:BaseIDAbstractType"))
		{	*type = SOAP_TYPE_saml2__BaseIDAbstractType;
			return soap_in_saml2__BaseIDAbstractType(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "saml1:AttributeType"))
		{	*type = SOAP_TYPE_saml1__AttributeType;
			return soap_in_saml1__AttributeType(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "saml1:AttributeDesignatorType"))
		{	*type = SOAP_TYPE_saml1__AttributeDesignatorType;
			return soap_in_saml1__AttributeDesignatorType(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "saml1:AttributeStatementType"))
		{	*type = SOAP_TYPE_saml1__AttributeStatementType;
			return soap_in_saml1__AttributeStatementType(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "saml1:EvidenceType"))
		{	*type = SOAP_TYPE_saml1__EvidenceType;
			return soap_in_saml1__EvidenceType(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "saml1:ActionType"))
		{	*type = SOAP_TYPE_saml1__ActionType;
			return soap_in_saml1__ActionType(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "saml1:AuthorizationDecisionStatementType"))
		{	*type = SOAP_TYPE_saml1__AuthorizationDecisionStatementType;
			return soap_in_saml1__AuthorizationDecisionStatementType(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "saml1:AuthorityBindingType"))
		{	*type = SOAP_TYPE_saml1__AuthorityBindingType;
			return soap_in_saml1__AuthorityBindingType(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "saml1:SubjectLocalityType"))
		{	*type = SOAP_TYPE_saml1__SubjectLocalityType;
			return soap_in_saml1__SubjectLocalityType(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "saml1:AuthenticationStatementType"))
		{	*type = SOAP_TYPE_saml1__AuthenticationStatementType;
			return soap_in_saml1__AuthenticationStatementType(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "saml1:SubjectConfirmationType"))
		{	*type = SOAP_TYPE_saml1__SubjectConfirmationType;
			return soap_in_saml1__SubjectConfirmationType(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "saml1:NameIdentifierType"))
		{	*type = SOAP_TYPE_saml1__NameIdentifierType;
			return soap_in_saml1__NameIdentifierType(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "saml1:SubjectType"))
		{	*type = SOAP_TYPE_saml1__SubjectType;
			return soap_in_saml1__SubjectType(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "saml1:SubjectStatementAbstractType"))
		{	*type = SOAP_TYPE_saml1__SubjectStatementAbstractType;
			return soap_in_saml1__SubjectStatementAbstractType(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "saml1:StatementAbstractType"))
		{	*type = SOAP_TYPE_saml1__StatementAbstractType;
			return soap_in_saml1__StatementAbstractType(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "saml1:AdviceType"))
		{	*type = SOAP_TYPE_saml1__AdviceType;
			return soap_in_saml1__AdviceType(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "saml1:DoNotCacheConditionType"))
		{	*type = SOAP_TYPE_saml1__DoNotCacheConditionType;
			return soap_in_saml1__DoNotCacheConditionType(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "saml1:AudienceRestrictionConditionType"))
		{	*type = SOAP_TYPE_saml1__AudienceRestrictionConditionType;
			return soap_in_saml1__AudienceRestrictionConditionType(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "saml1:ConditionAbstractType"))
		{	*type = SOAP_TYPE_saml1__ConditionAbstractType;
			return soap_in_saml1__ConditionAbstractType(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "saml1:ConditionsType"))
		{	*type = SOAP_TYPE_saml1__ConditionsType;
			return soap_in_saml1__ConditionsType(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "saml1:AssertionType"))
		{	*type = SOAP_TYPE_saml1__AssertionType;
			return soap_in_saml1__AssertionType(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:dateTime"))
		{	*type = SOAP_TYPE_xsd__dateTime;
			return soap_in_xsd__dateTime(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wsc:PropertiesType"))
		{	*type = SOAP_TYPE_wsc__PropertiesType;
			return soap_in_wsc__PropertiesType(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wsc:DerivedKeyTokenType"))
		{	*type = SOAP_TYPE_wsc__DerivedKeyTokenType;
			return soap_in_wsc__DerivedKeyTokenType(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wsc:SecurityContextTokenType"))
		{	*type = SOAP_TYPE_wsc__SecurityContextTokenType;
			return soap_in_wsc__SecurityContextTokenType(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xenc:EncryptionPropertyType"))
		{	*type = SOAP_TYPE_xenc__EncryptionPropertyType;
			return soap_in_xenc__EncryptionPropertyType(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xenc:EncryptionPropertiesType"))
		{	*type = SOAP_TYPE_xenc__EncryptionPropertiesType;
			return soap_in_xenc__EncryptionPropertiesType(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xenc:ReferenceType"))
		{	*type = SOAP_TYPE_xenc__ReferenceType;
			return soap_in_xenc__ReferenceType(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xenc:AgreementMethodType"))
		{	*type = SOAP_TYPE_xenc__AgreementMethodType;
			return soap_in_xenc__AgreementMethodType(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xenc:EncryptedDataType"))
		{	*type = SOAP_TYPE_xenc__EncryptedDataType;
			return soap_in_xenc__EncryptedDataType(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xenc:TransformsType"))
		{	*type = SOAP_TYPE_xenc__TransformsType;
			return soap_in_xenc__TransformsType(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xenc:CipherReferenceType"))
		{	*type = SOAP_TYPE_xenc__CipherReferenceType;
			return soap_in_xenc__CipherReferenceType(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xenc:CipherDataType"))
		{	*type = SOAP_TYPE_xenc__CipherDataType;
			return soap_in_xenc__CipherDataType(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xenc:EncryptionMethodType"))
		{	*type = SOAP_TYPE_xenc__EncryptionMethodType;
			return soap_in_xenc__EncryptionMethodType(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xenc:EncryptedType"))
		{	*type = SOAP_TYPE_xenc__EncryptedType;
			return soap_in_xenc__EncryptedType(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ds:RSAKeyValueType"))
		{	*type = SOAP_TYPE_ds__RSAKeyValueType;
			return soap_in_ds__RSAKeyValueType(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ds:DSAKeyValueType"))
		{	*type = SOAP_TYPE_ds__DSAKeyValueType;
			return soap_in_ds__DSAKeyValueType(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ds:X509IssuerSerialType"))
		{	*type = SOAP_TYPE_ds__X509IssuerSerialType;
			return soap_in_ds__X509IssuerSerialType(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ds:RetrievalMethodType"))
		{	*type = SOAP_TYPE_ds__RetrievalMethodType;
			return soap_in_ds__RetrievalMethodType(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ds:KeyValueType"))
		{	*type = SOAP_TYPE_ds__KeyValueType;
			return soap_in_ds__KeyValueType(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ds:DigestMethodType"))
		{	*type = SOAP_TYPE_ds__DigestMethodType;
			return soap_in_ds__DigestMethodType(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ds:TransformType"))
		{	*type = SOAP_TYPE_ds__TransformType;
			return soap_in_ds__TransformType(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ds:TransformsType"))
		{	*type = SOAP_TYPE_ds__TransformsType;
			return soap_in_ds__TransformsType(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ds:ReferenceType"))
		{	*type = SOAP_TYPE_ds__ReferenceType;
			return soap_in_ds__ReferenceType(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ds:SignatureMethodType"))
		{	*type = SOAP_TYPE_ds__SignatureMethodType;
			return soap_in_ds__SignatureMethodType(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ds:CanonicalizationMethodType"))
		{	*type = SOAP_TYPE_ds__CanonicalizationMethodType;
			return soap_in_ds__CanonicalizationMethodType(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ds:SignedInfoType"))
		{	*type = SOAP_TYPE_ds__SignedInfoType;
			return soap_in_ds__SignedInfoType(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ds:SignatureType"))
		{	*type = SOAP_TYPE_ds__SignatureType;
			return soap_in_ds__SignatureType(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xenc:EncryptedKeyType"))
		{	*type = SOAP_TYPE_xenc__EncryptedKeyType;
			return soap_in_xenc__EncryptedKeyType(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ds:KeyInfoType"))
		{	*type = SOAP_TYPE_ds__KeyInfoType;
			return soap_in_ds__KeyInfoType(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ds:X509DataType"))
		{	*type = SOAP_TYPE_ds__X509DataType;
			return soap_in_ds__X509DataType(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wsse:EncodedString"))
		{	*type = SOAP_TYPE_wsse__EncodedString;
			return soap_in_wsse__EncodedString(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "SOAP-ENV:Fault-alex"))
		{	*type = SOAP_TYPE_SOAP_ENV__Fault_alex;
			return soap_in_SOAP_ENV__Fault_alex(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "chan:ChannelInstanceType"))
		{	*type = SOAP_TYPE_chan__ChannelInstanceType;
			return soap_in_chan__ChannelInstanceType(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wsa5:ProblemActionType"))
		{	*type = SOAP_TYPE_wsa5__ProblemActionType;
			return soap_in_wsa5__ProblemActionType(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wsa5:RelatesToType"))
		{	*type = SOAP_TYPE_wsa5__RelatesToType;
			return soap_in_wsa5__RelatesToType(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wsa5:MetadataType"))
		{	*type = SOAP_TYPE_wsa5__MetadataType;
			return soap_in_wsa5__MetadataType(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wsa5:ReferenceParametersType"))
		{	*type = SOAP_TYPE_wsa5__ReferenceParametersType;
			return soap_in_wsa5__ReferenceParametersType(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wsa5:EndpointReferenceType"))
		{	*type = SOAP_TYPE_wsa5__EndpointReferenceType;
			return soap_in_wsa5__EndpointReferenceType(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wsdd:AppSequenceType"))
		{	*type = SOAP_TYPE_wsdd__AppSequenceType;
			return soap_in_wsdd__AppSequenceType(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wsdd:SigType"))
		{	*type = SOAP_TYPE_wsdd__SigType;
			return soap_in_wsdd__SigType(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wsdd:SecurityType"))
		{	*type = SOAP_TYPE_wsdd__SecurityType;
			return soap_in_wsdd__SecurityType(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wsdd:ScopesType"))
		{	*type = SOAP_TYPE_wsdd__ScopesType;
			return soap_in_wsdd__ScopesType(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wsdd:ResolveMatchType"))
		{	*type = SOAP_TYPE_wsdd__ResolveMatchType;
			return soap_in_wsdd__ResolveMatchType(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wsdd:ResolveMatchesType"))
		{	*type = SOAP_TYPE_wsdd__ResolveMatchesType;
			return soap_in_wsdd__ResolveMatchesType(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wsdd:ResolveType"))
		{	*type = SOAP_TYPE_wsdd__ResolveType;
			return soap_in_wsdd__ResolveType(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wsdd:ProbeMatchType"))
		{	*type = SOAP_TYPE_wsdd__ProbeMatchType;
			return soap_in_wsdd__ProbeMatchType(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wsdd:ProbeMatchesType"))
		{	*type = SOAP_TYPE_wsdd__ProbeMatchesType;
			return soap_in_wsdd__ProbeMatchesType(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wsdd:ProbeType"))
		{	*type = SOAP_TYPE_wsdd__ProbeType;
			return soap_in_wsdd__ProbeType(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wsdd:ByeType"))
		{	*type = SOAP_TYPE_wsdd__ByeType;
			return soap_in_wsdd__ByeType(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wsdd:HelloType"))
		{	*type = SOAP_TYPE_wsdd__HelloType;
			return soap_in_wsdd__HelloType(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wsa:Relationship"))
		{	*type = SOAP_TYPE_wsa__Relationship;
			return soap_in_wsa__Relationship(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wsa:ServiceNameType"))
		{	*type = SOAP_TYPE_wsa__ServiceNameType;
			return soap_in_wsa__ServiceNameType(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wsa:ReferenceParametersType"))
		{	*type = SOAP_TYPE_wsa__ReferenceParametersType;
			return soap_in_wsa__ReferenceParametersType(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wsa:ReferencePropertiesType"))
		{	*type = SOAP_TYPE_wsa__ReferencePropertiesType;
			return soap_in_wsa__ReferencePropertiesType(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wsa:EndpointReferenceType"))
		{	*type = SOAP_TYPE_wsa__EndpointReferenceType;
			return soap_in_wsa__EndpointReferenceType(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:QName"))
		{	char **s;
			*type = SOAP_TYPE_wstop__SimpleTopicExpression;
			s = soap_in_wstop__SimpleTopicExpression(soap, tag, NULL, NULL);
			return s ? *s : NULL;
		}
		if (!soap_match_tag(soap, t, "wstop:ConcreteTopicExpression"))
		{	char **s;
			*type = SOAP_TYPE_wstop__ConcreteTopicExpression;
			s = soap_in_wstop__ConcreteTopicExpression(soap, tag, NULL, NULL);
			return s ? *s : NULL;
		}
		if (!soap_match_tag(soap, t, "wstop:FullTopicExpression"))
		{	char **s;
			*type = SOAP_TYPE_wstop__FullTopicExpression;
			s = soap_in_wstop__FullTopicExpression(soap, tag, NULL, NULL);
			return s ? *s : NULL;
		}
		if (!soap_match_tag(soap, t, "tt:IPv6Address"))
		{	char **s;
			*type = SOAP_TYPE_tt__IPv6Address;
			s = soap_in_tt__IPv6Address(soap, tag, NULL, NULL);
			return s ? *s : NULL;
		}
		if (!soap_match_tag(soap, t, "tt:IPv4Address"))
		{	char **s;
			*type = SOAP_TYPE_tt__IPv4Address;
			s = soap_in_tt__IPv4Address(soap, tag, NULL, NULL);
			return s ? *s : NULL;
		}
		if (!soap_match_tag(soap, t, "tt:TopicNamespaceLocation"))
		{	char **s;
			*type = SOAP_TYPE_tt__TopicNamespaceLocation;
			s = soap_in_tt__TopicNamespaceLocation(soap, tag, NULL, NULL);
			return s ? *s : NULL;
		}
		if (!soap_match_tag(soap, t, "tt:Name"))
		{	char **s;
			*type = SOAP_TYPE_tt__Name;
			s = soap_in_tt__Name(soap, tag, NULL, NULL);
			return s ? *s : NULL;
		}
		if (!soap_match_tag(soap, t, "tt:ReferenceToken"))
		{	char **s;
			*type = SOAP_TYPE_tt__ReferenceToken;
			s = soap_in_tt__ReferenceToken(soap, tag, NULL, NULL);
			return s ? *s : NULL;
		}
		if (!soap_match_tag(soap, t, "wsnt:AbsoluteOrRelativeTimeType"))
		{	char **s;
			*type = SOAP_TYPE_wsnt__AbsoluteOrRelativeTimeType;
			s = soap_in_wsnt__AbsoluteOrRelativeTimeType(soap, tag, NULL, NULL);
			return s ? *s : NULL;
		}
		if (!soap_match_tag(soap, t, "tt:StringAttrList"))
		{	char **s;
			*type = SOAP_TYPE_tt__StringAttrList;
			s = soap_in_tt__StringAttrList(soap, tag, NULL, NULL);
			return s ? *s : NULL;
		}
		if (!soap_match_tag(soap, t, "tt:FloatAttrList"))
		{	char **s;
			*type = SOAP_TYPE_tt__FloatAttrList;
			s = soap_in_tt__FloatAttrList(soap, tag, NULL, NULL);
			return s ? *s : NULL;
		}
		if (!soap_match_tag(soap, t, "tt:IntAttrList"))
		{	char **s;
			*type = SOAP_TYPE_tt__IntAttrList;
			s = soap_in_tt__IntAttrList(soap, tag, NULL, NULL);
			return s ? *s : NULL;
		}
		if (!soap_match_tag(soap, t, "tds:EAPMethodTypes"))
		{	char **s;
			*type = SOAP_TYPE_tds__EAPMethodTypes;
			s = soap_in_tds__EAPMethodTypes(soap, tag, NULL, NULL);
			return s ? *s : NULL;
		}
		if (!soap_match_tag(soap, t, "xsd:token"))
		{	char **s;
			*type = SOAP_TYPE_xsd__token;
			s = soap_in_xsd__token(soap, tag, NULL, NULL);
			return s ? *s : NULL;
		}
		if (!soap_match_tag(soap, t, "xsd:nonNegativeInteger"))
		{	char **s;
			*type = SOAP_TYPE_xsd__nonNegativeInteger;
			s = soap_in_xsd__nonNegativeInteger(soap, tag, NULL, NULL);
			return s ? *s : NULL;
		}
		if (!soap_match_tag(soap, t, "xsd:anyURI"))
		{	char **s;
			*type = SOAP_TYPE_xsd__anyURI;
			s = soap_in_xsd__anyURI(soap, tag, NULL, NULL);
			return s ? *s : NULL;
		}
		if (!soap_match_tag(soap, t, "xsd:anySimpleType"))
		{	char **s;
			*type = SOAP_TYPE_xsd__anySimpleType;
			s = soap_in_xsd__anySimpleType(soap, tag, NULL, NULL);
			return s ? *s : NULL;
		}
		if (!soap_match_tag(soap, t, "xsd:NCName"))
		{	char **s;
			*type = SOAP_TYPE_xsd__NCName;
			s = soap_in_xsd__NCName(soap, tag, NULL, NULL);
			return s ? *s : NULL;
		}
		if (!soap_match_tag(soap, t, "wsc:FaultCodeOpenEnumType"))
		{	char **s;
			*type = SOAP_TYPE_wsc__FaultCodeOpenEnumType;
			s = soap_in_wsc__FaultCodeOpenEnumType(soap, tag, NULL, NULL);
			return s ? *s : NULL;
		}
		if (!soap_match_tag(soap, t, "xsd:QName"))
		{	char **s;
			*type = SOAP_TYPE__wsa5__ProblemHeaderQName;
			s = soap_in__wsa5__ProblemHeaderQName(soap, tag, NULL, NULL);
			return s ? *s : NULL;
		}
		if (!soap_match_tag(soap, t, "wsa5:FaultCodesOpenEnumType"))
		{	char **s;
			*type = SOAP_TYPE_wsa5__FaultCodesOpenEnumType;
			s = soap_in_wsa5__FaultCodesOpenEnumType(soap, tag, NULL, NULL);
			return s ? *s : NULL;
		}
		if (!soap_match_tag(soap, t, "wsa5:RelationshipTypeOpenEnum"))
		{	char **s;
			*type = SOAP_TYPE_wsa5__RelationshipTypeOpenEnum;
			s = soap_in_wsa5__RelationshipTypeOpenEnum(soap, tag, NULL, NULL);
			return s ? *s : NULL;
		}
		if (!soap_match_tag(soap, t, "xsd:QName"))
		{	char **s;
			*type = SOAP_TYPE__wsdd__Types;
			s = soap_in__wsdd__Types(soap, tag, NULL, NULL);
			return s ? *s : NULL;
		}
		if (!soap_match_tag(soap, t, "wsdd:FaultCodeOpenType"))
		{	char **s;
			*type = SOAP_TYPE_wsdd__FaultCodeOpenType;
			s = soap_in_wsdd__FaultCodeOpenType(soap, tag, NULL, NULL);
			return s ? *s : NULL;
		}
		if (!soap_match_tag(soap, t, "wsdd:UriListType"))
		{	char **s;
			*type = SOAP_TYPE_wsdd__UriListType;
			s = soap_in_wsdd__UriListType(soap, tag, NULL, NULL);
			return s ? *s : NULL;
		}
		if (!soap_match_tag(soap, t, "xsd:QName"))
		{	char **s;
			*type = SOAP_TYPE_wsdd__QNameListType;
			s = soap_in_wsdd__QNameListType(soap, tag, NULL, NULL);
			return s ? *s : NULL;
		}
		if (!soap_match_tag(soap, t, "xsd:QName"))
		{	char **s;
			*type = SOAP_TYPE__QName;
			s = soap_in__QName(soap, tag, NULL, NULL);
			return s ? *s : NULL;
		}
		if (!soap_match_tag(soap, t, "xsd:string"))
		{	char **s;
			*type = SOAP_TYPE_string;
			s = soap_in_string(soap, tag, NULL, NULL);
			return s ? *s : NULL;
		}
		t = soap->tag;
		if (!soap_match_tag(soap, t, "wsdd:MetadataVersion"))
		{	*type = SOAP_TYPE__wsdd__MetadataVersion;
			return soap_in__wsdd__MetadataVersion(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wsa:ReplyAfter"))
		{	*type = SOAP_TYPE__wsa__ReplyAfter;
			return soap_in__wsa__ReplyAfter(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wsa5:RetryAfter"))
		{	*type = SOAP_TYPE__wsa5__RetryAfter;
			return soap_in__wsa5__RetryAfter(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wstop:TopicNamespaceType-Topic"))
		{	*type = SOAP_TYPE__wstop__TopicNamespaceType_Topic;
			return soap_in__wstop__TopicNamespaceType_Topic(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wsnt:ResumeFailedFaultType-FaultCause"))
		{	*type = SOAP_TYPE__wsnt__ResumeFailedFaultType_FaultCause;
			return soap_in__wsnt__ResumeFailedFaultType_FaultCause(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wsnt:ResumeFailedFaultType-Description"))
		{	*type = SOAP_TYPE__wsnt__ResumeFailedFaultType_Description;
			return soap_in__wsnt__ResumeFailedFaultType_Description(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wsnt:ResumeFailedFaultType-ErrorCode"))
		{	*type = SOAP_TYPE__wsnt__ResumeFailedFaultType_ErrorCode;
			return soap_in__wsnt__ResumeFailedFaultType_ErrorCode(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wsnt:PauseFailedFaultType-FaultCause"))
		{	*type = SOAP_TYPE__wsnt__PauseFailedFaultType_FaultCause;
			return soap_in__wsnt__PauseFailedFaultType_FaultCause(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wsnt:PauseFailedFaultType-Description"))
		{	*type = SOAP_TYPE__wsnt__PauseFailedFaultType_Description;
			return soap_in__wsnt__PauseFailedFaultType_Description(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wsnt:PauseFailedFaultType-ErrorCode"))
		{	*type = SOAP_TYPE__wsnt__PauseFailedFaultType_ErrorCode;
			return soap_in__wsnt__PauseFailedFaultType_ErrorCode(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wsnt:UnableToDestroySubscriptionFaultType-FaultCause"))
		{	*type = SOAP_TYPE__wsnt__UnableToDestroySubscriptionFaultType_FaultCause;
			return soap_in__wsnt__UnableToDestroySubscriptionFaultType_FaultCause(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wsnt:UnableToDestroySubscriptionFaultType-Description"))
		{	*type = SOAP_TYPE__wsnt__UnableToDestroySubscriptionFaultType_Description;
			return soap_in__wsnt__UnableToDestroySubscriptionFaultType_Description(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wsnt:UnableToDestroySubscriptionFaultType-ErrorCode"))
		{	*type = SOAP_TYPE__wsnt__UnableToDestroySubscriptionFaultType_ErrorCode;
			return soap_in__wsnt__UnableToDestroySubscriptionFaultType_ErrorCode(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wsnt:UnacceptableTerminationTimeFaultType-FaultCause"))
		{	*type = SOAP_TYPE__wsnt__UnacceptableTerminationTimeFaultType_FaultCause;
			return soap_in__wsnt__UnacceptableTerminationTimeFaultType_FaultCause(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wsnt:UnacceptableTerminationTimeFaultType-Description"))
		{	*type = SOAP_TYPE__wsnt__UnacceptableTerminationTimeFaultType_Description;
			return soap_in__wsnt__UnacceptableTerminationTimeFaultType_Description(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wsnt:UnacceptableTerminationTimeFaultType-ErrorCode"))
		{	*type = SOAP_TYPE__wsnt__UnacceptableTerminationTimeFaultType_ErrorCode;
			return soap_in__wsnt__UnacceptableTerminationTimeFaultType_ErrorCode(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wsnt:UnableToCreatePullPointFaultType-FaultCause"))
		{	*type = SOAP_TYPE__wsnt__UnableToCreatePullPointFaultType_FaultCause;
			return soap_in__wsnt__UnableToCreatePullPointFaultType_FaultCause(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wsnt:UnableToCreatePullPointFaultType-Description"))
		{	*type = SOAP_TYPE__wsnt__UnableToCreatePullPointFaultType_Description;
			return soap_in__wsnt__UnableToCreatePullPointFaultType_Description(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wsnt:UnableToCreatePullPointFaultType-ErrorCode"))
		{	*type = SOAP_TYPE__wsnt__UnableToCreatePullPointFaultType_ErrorCode;
			return soap_in__wsnt__UnableToCreatePullPointFaultType_ErrorCode(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wsnt:UnableToDestroyPullPointFaultType-FaultCause"))
		{	*type = SOAP_TYPE__wsnt__UnableToDestroyPullPointFaultType_FaultCause;
			return soap_in__wsnt__UnableToDestroyPullPointFaultType_FaultCause(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wsnt:UnableToDestroyPullPointFaultType-Description"))
		{	*type = SOAP_TYPE__wsnt__UnableToDestroyPullPointFaultType_Description;
			return soap_in__wsnt__UnableToDestroyPullPointFaultType_Description(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wsnt:UnableToDestroyPullPointFaultType-ErrorCode"))
		{	*type = SOAP_TYPE__wsnt__UnableToDestroyPullPointFaultType_ErrorCode;
			return soap_in__wsnt__UnableToDestroyPullPointFaultType_ErrorCode(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wsnt:UnableToGetMessagesFaultType-FaultCause"))
		{	*type = SOAP_TYPE__wsnt__UnableToGetMessagesFaultType_FaultCause;
			return soap_in__wsnt__UnableToGetMessagesFaultType_FaultCause(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wsnt:UnableToGetMessagesFaultType-Description"))
		{	*type = SOAP_TYPE__wsnt__UnableToGetMessagesFaultType_Description;
			return soap_in__wsnt__UnableToGetMessagesFaultType_Description(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wsnt:UnableToGetMessagesFaultType-ErrorCode"))
		{	*type = SOAP_TYPE__wsnt__UnableToGetMessagesFaultType_ErrorCode;
			return soap_in__wsnt__UnableToGetMessagesFaultType_ErrorCode(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wsnt:NoCurrentMessageOnTopicFaultType-FaultCause"))
		{	*type = SOAP_TYPE__wsnt__NoCurrentMessageOnTopicFaultType_FaultCause;
			return soap_in__wsnt__NoCurrentMessageOnTopicFaultType_FaultCause(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wsnt:NoCurrentMessageOnTopicFaultType-Description"))
		{	*type = SOAP_TYPE__wsnt__NoCurrentMessageOnTopicFaultType_Description;
			return soap_in__wsnt__NoCurrentMessageOnTopicFaultType_Description(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wsnt:NoCurrentMessageOnTopicFaultType-ErrorCode"))
		{	*type = SOAP_TYPE__wsnt__NoCurrentMessageOnTopicFaultType_ErrorCode;
			return soap_in__wsnt__NoCurrentMessageOnTopicFaultType_ErrorCode(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wsnt:UnacceptableInitialTerminationTimeFaultType-FaultCause"))
		{	*type = SOAP_TYPE__wsnt__UnacceptableInitialTerminationTimeFaultType_FaultCause;
			return soap_in__wsnt__UnacceptableInitialTerminationTimeFaultType_FaultCause(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wsnt:UnacceptableInitialTerminationTimeFaultType-Description"))
		{	*type = SOAP_TYPE__wsnt__UnacceptableInitialTerminationTimeFaultType_Description;
			return soap_in__wsnt__UnacceptableInitialTerminationTimeFaultType_Description(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wsnt:UnacceptableInitialTerminationTimeFaultType-ErrorCode"))
		{	*type = SOAP_TYPE__wsnt__UnacceptableInitialTerminationTimeFaultType_ErrorCode;
			return soap_in__wsnt__UnacceptableInitialTerminationTimeFaultType_ErrorCode(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wsnt:NotifyMessageNotSupportedFaultType-FaultCause"))
		{	*type = SOAP_TYPE__wsnt__NotifyMessageNotSupportedFaultType_FaultCause;
			return soap_in__wsnt__NotifyMessageNotSupportedFaultType_FaultCause(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wsnt:NotifyMessageNotSupportedFaultType-Description"))
		{	*type = SOAP_TYPE__wsnt__NotifyMessageNotSupportedFaultType_Description;
			return soap_in__wsnt__NotifyMessageNotSupportedFaultType_Description(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wsnt:NotifyMessageNotSupportedFaultType-ErrorCode"))
		{	*type = SOAP_TYPE__wsnt__NotifyMessageNotSupportedFaultType_ErrorCode;
			return soap_in__wsnt__NotifyMessageNotSupportedFaultType_ErrorCode(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wsnt:UnsupportedPolicyRequestFaultType-FaultCause"))
		{	*type = SOAP_TYPE__wsnt__UnsupportedPolicyRequestFaultType_FaultCause;
			return soap_in__wsnt__UnsupportedPolicyRequestFaultType_FaultCause(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wsnt:UnsupportedPolicyRequestFaultType-Description"))
		{	*type = SOAP_TYPE__wsnt__UnsupportedPolicyRequestFaultType_Description;
			return soap_in__wsnt__UnsupportedPolicyRequestFaultType_Description(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wsnt:UnsupportedPolicyRequestFaultType-ErrorCode"))
		{	*type = SOAP_TYPE__wsnt__UnsupportedPolicyRequestFaultType_ErrorCode;
			return soap_in__wsnt__UnsupportedPolicyRequestFaultType_ErrorCode(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wsnt:UnrecognizedPolicyRequestFaultType-FaultCause"))
		{	*type = SOAP_TYPE__wsnt__UnrecognizedPolicyRequestFaultType_FaultCause;
			return soap_in__wsnt__UnrecognizedPolicyRequestFaultType_FaultCause(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wsnt:UnrecognizedPolicyRequestFaultType-Description"))
		{	*type = SOAP_TYPE__wsnt__UnrecognizedPolicyRequestFaultType_Description;
			return soap_in__wsnt__UnrecognizedPolicyRequestFaultType_Description(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wsnt:UnrecognizedPolicyRequestFaultType-ErrorCode"))
		{	*type = SOAP_TYPE__wsnt__UnrecognizedPolicyRequestFaultType_ErrorCode;
			return soap_in__wsnt__UnrecognizedPolicyRequestFaultType_ErrorCode(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wsnt:InvalidMessageContentExpressionFaultType-FaultCause"))
		{	*type = SOAP_TYPE__wsnt__InvalidMessageContentExpressionFaultType_FaultCause;
			return soap_in__wsnt__InvalidMessageContentExpressionFaultType_FaultCause(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wsnt:InvalidMessageContentExpressionFaultType-Description"))
		{	*type = SOAP_TYPE__wsnt__InvalidMessageContentExpressionFaultType_Description;
			return soap_in__wsnt__InvalidMessageContentExpressionFaultType_Description(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wsnt:InvalidMessageContentExpressionFaultType-ErrorCode"))
		{	*type = SOAP_TYPE__wsnt__InvalidMessageContentExpressionFaultType_ErrorCode;
			return soap_in__wsnt__InvalidMessageContentExpressionFaultType_ErrorCode(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wsnt:InvalidProducerPropertiesExpressionFaultType-FaultCause"))
		{	*type = SOAP_TYPE__wsnt__InvalidProducerPropertiesExpressionFaultType_FaultCause;
			return soap_in__wsnt__InvalidProducerPropertiesExpressionFaultType_FaultCause(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wsnt:InvalidProducerPropertiesExpressionFaultType-Description"))
		{	*type = SOAP_TYPE__wsnt__InvalidProducerPropertiesExpressionFaultType_Description;
			return soap_in__wsnt__InvalidProducerPropertiesExpressionFaultType_Description(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wsnt:InvalidProducerPropertiesExpressionFaultType-ErrorCode"))
		{	*type = SOAP_TYPE__wsnt__InvalidProducerPropertiesExpressionFaultType_ErrorCode;
			return soap_in__wsnt__InvalidProducerPropertiesExpressionFaultType_ErrorCode(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wsnt:MultipleTopicsSpecifiedFaultType-FaultCause"))
		{	*type = SOAP_TYPE__wsnt__MultipleTopicsSpecifiedFaultType_FaultCause;
			return soap_in__wsnt__MultipleTopicsSpecifiedFaultType_FaultCause(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wsnt:MultipleTopicsSpecifiedFaultType-Description"))
		{	*type = SOAP_TYPE__wsnt__MultipleTopicsSpecifiedFaultType_Description;
			return soap_in__wsnt__MultipleTopicsSpecifiedFaultType_Description(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wsnt:MultipleTopicsSpecifiedFaultType-ErrorCode"))
		{	*type = SOAP_TYPE__wsnt__MultipleTopicsSpecifiedFaultType_ErrorCode;
			return soap_in__wsnt__MultipleTopicsSpecifiedFaultType_ErrorCode(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wsnt:TopicNotSupportedFaultType-FaultCause"))
		{	*type = SOAP_TYPE__wsnt__TopicNotSupportedFaultType_FaultCause;
			return soap_in__wsnt__TopicNotSupportedFaultType_FaultCause(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wsnt:TopicNotSupportedFaultType-Description"))
		{	*type = SOAP_TYPE__wsnt__TopicNotSupportedFaultType_Description;
			return soap_in__wsnt__TopicNotSupportedFaultType_Description(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wsnt:TopicNotSupportedFaultType-ErrorCode"))
		{	*type = SOAP_TYPE__wsnt__TopicNotSupportedFaultType_ErrorCode;
			return soap_in__wsnt__TopicNotSupportedFaultType_ErrorCode(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wsnt:InvalidTopicExpressionFaultType-FaultCause"))
		{	*type = SOAP_TYPE__wsnt__InvalidTopicExpressionFaultType_FaultCause;
			return soap_in__wsnt__InvalidTopicExpressionFaultType_FaultCause(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wsnt:InvalidTopicExpressionFaultType-Description"))
		{	*type = SOAP_TYPE__wsnt__InvalidTopicExpressionFaultType_Description;
			return soap_in__wsnt__InvalidTopicExpressionFaultType_Description(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wsnt:InvalidTopicExpressionFaultType-ErrorCode"))
		{	*type = SOAP_TYPE__wsnt__InvalidTopicExpressionFaultType_ErrorCode;
			return soap_in__wsnt__InvalidTopicExpressionFaultType_ErrorCode(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wsnt:TopicExpressionDialectUnknownFaultType-FaultCause"))
		{	*type = SOAP_TYPE__wsnt__TopicExpressionDialectUnknownFaultType_FaultCause;
			return soap_in__wsnt__TopicExpressionDialectUnknownFaultType_FaultCause(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wsnt:TopicExpressionDialectUnknownFaultType-Description"))
		{	*type = SOAP_TYPE__wsnt__TopicExpressionDialectUnknownFaultType_Description;
			return soap_in__wsnt__TopicExpressionDialectUnknownFaultType_Description(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wsnt:TopicExpressionDialectUnknownFaultType-ErrorCode"))
		{	*type = SOAP_TYPE__wsnt__TopicExpressionDialectUnknownFaultType_ErrorCode;
			return soap_in__wsnt__TopicExpressionDialectUnknownFaultType_ErrorCode(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wsnt:InvalidFilterFaultType-FaultCause"))
		{	*type = SOAP_TYPE__wsnt__InvalidFilterFaultType_FaultCause;
			return soap_in__wsnt__InvalidFilterFaultType_FaultCause(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wsnt:InvalidFilterFaultType-Description"))
		{	*type = SOAP_TYPE__wsnt__InvalidFilterFaultType_Description;
			return soap_in__wsnt__InvalidFilterFaultType_Description(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wsnt:InvalidFilterFaultType-ErrorCode"))
		{	*type = SOAP_TYPE__wsnt__InvalidFilterFaultType_ErrorCode;
			return soap_in__wsnt__InvalidFilterFaultType_ErrorCode(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wsnt:SubscribeCreationFailedFaultType-FaultCause"))
		{	*type = SOAP_TYPE__wsnt__SubscribeCreationFailedFaultType_FaultCause;
			return soap_in__wsnt__SubscribeCreationFailedFaultType_FaultCause(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wsnt:SubscribeCreationFailedFaultType-Description"))
		{	*type = SOAP_TYPE__wsnt__SubscribeCreationFailedFaultType_Description;
			return soap_in__wsnt__SubscribeCreationFailedFaultType_Description(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wsnt:SubscribeCreationFailedFaultType-ErrorCode"))
		{	*type = SOAP_TYPE__wsnt__SubscribeCreationFailedFaultType_ErrorCode;
			return soap_in__wsnt__SubscribeCreationFailedFaultType_ErrorCode(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "trt:GetSnapshotUriResponse"))
		{	*type = SOAP_TYPE__trt__GetSnapshotUriResponse;
			return soap_in__trt__GetSnapshotUriResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "trt:GetSnapshotUri"))
		{	*type = SOAP_TYPE__trt__GetSnapshotUri;
			return soap_in__trt__GetSnapshotUri(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "trt:DeleteProfileResponse"))
		{	*type = SOAP_TYPE__trt__DeleteProfileResponse;
			return soap_in__trt__DeleteProfileResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "trt:DeleteProfile"))
		{	*type = SOAP_TYPE__trt__DeleteProfile;
			return soap_in__trt__DeleteProfile(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "trt:GetProfilesResponse"))
		{	*type = SOAP_TYPE__trt__GetProfilesResponse;
			return soap_in__trt__GetProfilesResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "trt:GetProfiles"))
		{	*type = SOAP_TYPE__trt__GetProfiles;
			return soap_in__trt__GetProfiles(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "trt:GetProfileResponse"))
		{	*type = SOAP_TYPE__trt__GetProfileResponse;
			return soap_in__trt__GetProfileResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "trt:GetProfile"))
		{	*type = SOAP_TYPE__trt__GetProfile;
			return soap_in__trt__GetProfile(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "trt:CreateProfileResponse"))
		{	*type = SOAP_TYPE__trt__CreateProfileResponse;
			return soap_in__trt__CreateProfileResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "trt:CreateProfile"))
		{	*type = SOAP_TYPE__trt__CreateProfile;
			return soap_in__trt__CreateProfile(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "trt:GetServiceCapabilitiesResponse"))
		{	*type = SOAP_TYPE__trt__GetServiceCapabilitiesResponse;
			return soap_in__trt__GetServiceCapabilitiesResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "trt:GetServiceCapabilities"))
		{	*type = SOAP_TYPE__trt__GetServiceCapabilities;
			return soap_in__trt__GetServiceCapabilities(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wsrfbf:BaseFaultType-FaultCause"))
		{	*type = SOAP_TYPE__wsrfbf__BaseFaultType_FaultCause;
			return soap_in__wsrfbf__BaseFaultType_FaultCause(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wsrfbf:BaseFaultType-Description"))
		{	*type = SOAP_TYPE__wsrfbf__BaseFaultType_Description;
			return soap_in__wsrfbf__BaseFaultType_Description(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wsrfbf:BaseFaultType-ErrorCode"))
		{	*type = SOAP_TYPE__wsrfbf__BaseFaultType_ErrorCode;
			return soap_in__wsrfbf__BaseFaultType_ErrorCode(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wsnt:ResumeSubscriptionResponse"))
		{	*type = SOAP_TYPE__wsnt__ResumeSubscriptionResponse;
			return soap_in__wsnt__ResumeSubscriptionResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wsnt:ResumeSubscription"))
		{	*type = SOAP_TYPE__wsnt__ResumeSubscription;
			return soap_in__wsnt__ResumeSubscription(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wsnt:PauseSubscriptionResponse"))
		{	*type = SOAP_TYPE__wsnt__PauseSubscriptionResponse;
			return soap_in__wsnt__PauseSubscriptionResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wsnt:PauseSubscription"))
		{	*type = SOAP_TYPE__wsnt__PauseSubscription;
			return soap_in__wsnt__PauseSubscription(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wsnt:UnsubscribeResponse"))
		{	*type = SOAP_TYPE__wsnt__UnsubscribeResponse;
			return soap_in__wsnt__UnsubscribeResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wsnt:Unsubscribe"))
		{	*type = SOAP_TYPE__wsnt__Unsubscribe;
			return soap_in__wsnt__Unsubscribe(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wsnt:RenewResponse"))
		{	*type = SOAP_TYPE__wsnt__RenewResponse;
			return soap_in__wsnt__RenewResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wsnt:Renew"))
		{	*type = SOAP_TYPE__wsnt__Renew;
			return soap_in__wsnt__Renew(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wsnt:CreatePullPointResponse"))
		{	*type = SOAP_TYPE__wsnt__CreatePullPointResponse;
			return soap_in__wsnt__CreatePullPointResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wsnt:CreatePullPoint"))
		{	*type = SOAP_TYPE__wsnt__CreatePullPoint;
			return soap_in__wsnt__CreatePullPoint(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wsnt:DestroyPullPointResponse"))
		{	*type = SOAP_TYPE__wsnt__DestroyPullPointResponse;
			return soap_in__wsnt__DestroyPullPointResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wsnt:DestroyPullPoint"))
		{	*type = SOAP_TYPE__wsnt__DestroyPullPoint;
			return soap_in__wsnt__DestroyPullPoint(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wsnt:GetMessagesResponse"))
		{	*type = SOAP_TYPE__wsnt__GetMessagesResponse;
			return soap_in__wsnt__GetMessagesResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wsnt:GetMessages"))
		{	*type = SOAP_TYPE__wsnt__GetMessages;
			return soap_in__wsnt__GetMessages(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wsnt:GetCurrentMessageResponse"))
		{	*type = SOAP_TYPE__wsnt__GetCurrentMessageResponse;
			return soap_in__wsnt__GetCurrentMessageResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wsnt:GetCurrentMessage"))
		{	*type = SOAP_TYPE__wsnt__GetCurrentMessage;
			return soap_in__wsnt__GetCurrentMessage(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wsnt:SubscribeResponse"))
		{	*type = SOAP_TYPE__wsnt__SubscribeResponse;
			return soap_in__wsnt__SubscribeResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wsnt:Subscribe-SubscriptionPolicy"))
		{	*type = SOAP_TYPE__wsnt__Subscribe_SubscriptionPolicy;
			return soap_in__wsnt__Subscribe_SubscriptionPolicy(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wsnt:Subscribe"))
		{	*type = SOAP_TYPE__wsnt__Subscribe;
			return soap_in__wsnt__Subscribe(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wsnt:UseRaw"))
		{	*type = SOAP_TYPE__wsnt__UseRaw;
			return soap_in__wsnt__UseRaw(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wsnt:Notify"))
		{	*type = SOAP_TYPE__wsnt__Notify;
			return soap_in__wsnt__Notify(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wsnt:SubscriptionManagerRP"))
		{	*type = SOAP_TYPE__wsnt__SubscriptionManagerRP;
			return soap_in__wsnt__SubscriptionManagerRP(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wsnt:NotificationProducerRP"))
		{	*type = SOAP_TYPE__wsnt__NotificationProducerRP;
			return soap_in__wsnt__NotificationProducerRP(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wsnt:NotificationMessageHolderType-Message"))
		{	*type = SOAP_TYPE__wsnt__NotificationMessageHolderType_Message;
			return soap_in__wsnt__NotificationMessageHolderType_Message(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tt:Message"))
		{	*type = SOAP_TYPE__tt__Message;
			return soap_in__tt__Message(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tt:ItemListDescription-ElementItemDescription"))
		{	*type = SOAP_TYPE__tt__ItemListDescription_ElementItemDescription;
			return soap_in__tt__ItemListDescription_ElementItemDescription(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tt:ItemListDescription-SimpleItemDescription"))
		{	*type = SOAP_TYPE__tt__ItemListDescription_SimpleItemDescription;
			return soap_in__tt__ItemListDescription_SimpleItemDescription(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tt:ItemList-ElementItem"))
		{	*type = SOAP_TYPE__tt__ItemList_ElementItem;
			return soap_in__tt__ItemList_ElementItem(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tt:ItemList-SimpleItem"))
		{	*type = SOAP_TYPE__tt__ItemList_SimpleItem;
			return soap_in__tt__ItemList_SimpleItem(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tds:GetCapabilitiesResponse"))
		{	*type = SOAP_TYPE__tds__GetCapabilitiesResponse;
			return soap_in__tds__GetCapabilitiesResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tds:GetCapabilities"))
		{	*type = SOAP_TYPE__tds__GetCapabilities;
			return soap_in__tds__GetCapabilities(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tds:SystemRebootResponse"))
		{	*type = SOAP_TYPE__tds__SystemRebootResponse;
			return soap_in__tds__SystemRebootResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tds:SystemReboot"))
		{	*type = SOAP_TYPE__tds__SystemReboot;
			return soap_in__tds__SystemReboot(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tds:GetDeviceInformationResponse"))
		{	*type = SOAP_TYPE__tds__GetDeviceInformationResponse;
			return soap_in__tds__GetDeviceInformationResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tds:GetDeviceInformation"))
		{	*type = SOAP_TYPE__tds__GetDeviceInformation;
			return soap_in__tds__GetDeviceInformation(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tds:GetServiceCapabilitiesResponse"))
		{	*type = SOAP_TYPE__tds__GetServiceCapabilitiesResponse;
			return soap_in__tds__GetServiceCapabilitiesResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tds:GetServiceCapabilities"))
		{	*type = SOAP_TYPE__tds__GetServiceCapabilities;
			return soap_in__tds__GetServiceCapabilities(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tds:GetServicesResponse"))
		{	*type = SOAP_TYPE__tds__GetServicesResponse;
			return soap_in__tds__GetServicesResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tds:GetServices"))
		{	*type = SOAP_TYPE__tds__GetServices;
			return soap_in__tds__GetServices(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tds:Service-Capabilities"))
		{	*type = SOAP_TYPE__tds__Service_Capabilities;
			return soap_in__tds__Service_Capabilities(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wsse:Security"))
		{	*type = SOAP_TYPE__wsse__Security;
			return soap_in__wsse__Security(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "saml2:EncryptedAttribute"))
		{	*type = SOAP_TYPE__saml2__EncryptedAttribute;
			return soap_in__saml2__EncryptedAttribute(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "saml2:Attribute"))
		{	*type = SOAP_TYPE__saml2__Attribute;
			return soap_in__saml2__Attribute(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "saml2:AttributeStatement"))
		{	*type = SOAP_TYPE__saml2__AttributeStatement;
			return soap_in__saml2__AttributeStatement(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "saml2:Evidence"))
		{	*type = SOAP_TYPE__saml2__Evidence;
			return soap_in__saml2__Evidence(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "saml2:Action"))
		{	*type = SOAP_TYPE__saml2__Action;
			return soap_in__saml2__Action(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "saml2:AuthzDecisionStatement"))
		{	*type = SOAP_TYPE__saml2__AuthzDecisionStatement;
			return soap_in__saml2__AuthzDecisionStatement(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "saml2:AuthnContext"))
		{	*type = SOAP_TYPE__saml2__AuthnContext;
			return soap_in__saml2__AuthnContext(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "saml2:SubjectLocality"))
		{	*type = SOAP_TYPE__saml2__SubjectLocality;
			return soap_in__saml2__SubjectLocality(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "saml2:AuthnStatement"))
		{	*type = SOAP_TYPE__saml2__AuthnStatement;
			return soap_in__saml2__AuthnStatement(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "saml2:Statement"))
		{	*type = SOAP_TYPE__saml2__Statement;
			return soap_in__saml2__Statement(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "saml2:EncryptedAssertion"))
		{	*type = SOAP_TYPE__saml2__EncryptedAssertion;
			return soap_in__saml2__EncryptedAssertion(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "saml2:Advice"))
		{	*type = SOAP_TYPE__saml2__Advice;
			return soap_in__saml2__Advice(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "saml2:ProxyRestriction"))
		{	*type = SOAP_TYPE__saml2__ProxyRestriction;
			return soap_in__saml2__ProxyRestriction(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "saml2:OneTimeUse"))
		{	*type = SOAP_TYPE__saml2__OneTimeUse;
			return soap_in__saml2__OneTimeUse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "saml2:AudienceRestriction"))
		{	*type = SOAP_TYPE__saml2__AudienceRestriction;
			return soap_in__saml2__AudienceRestriction(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "saml2:Condition"))
		{	*type = SOAP_TYPE__saml2__Condition;
			return soap_in__saml2__Condition(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "saml2:Conditions"))
		{	*type = SOAP_TYPE__saml2__Conditions;
			return soap_in__saml2__Conditions(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "saml2:SubjectConfirmationData"))
		{	*type = SOAP_TYPE__saml2__SubjectConfirmationData;
			return soap_in__saml2__SubjectConfirmationData(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "saml2:SubjectConfirmation"))
		{	*type = SOAP_TYPE__saml2__SubjectConfirmation;
			return soap_in__saml2__SubjectConfirmation(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "saml2:Subject"))
		{	*type = SOAP_TYPE__saml2__Subject;
			return soap_in__saml2__Subject(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "saml2:Assertion"))
		{	*type = SOAP_TYPE__saml2__Assertion;
			return soap_in__saml2__Assertion(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "saml2:Issuer"))
		{	*type = SOAP_TYPE__saml2__Issuer;
			return soap_in__saml2__Issuer(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "saml2:EncryptedID"))
		{	*type = SOAP_TYPE__saml2__EncryptedID;
			return soap_in__saml2__EncryptedID(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "saml2:NameID"))
		{	*type = SOAP_TYPE__saml2__NameID;
			return soap_in__saml2__NameID(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "saml2:BaseID"))
		{	*type = SOAP_TYPE__saml2__BaseID;
			return soap_in__saml2__BaseID(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "saml1:Attribute"))
		{	*type = SOAP_TYPE__saml1__Attribute;
			return soap_in__saml1__Attribute(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "saml1:AttributeDesignator"))
		{	*type = SOAP_TYPE__saml1__AttributeDesignator;
			return soap_in__saml1__AttributeDesignator(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "saml1:AttributeStatement"))
		{	*type = SOAP_TYPE__saml1__AttributeStatement;
			return soap_in__saml1__AttributeStatement(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "saml1:Evidence"))
		{	*type = SOAP_TYPE__saml1__Evidence;
			return soap_in__saml1__Evidence(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "saml1:Action"))
		{	*type = SOAP_TYPE__saml1__Action;
			return soap_in__saml1__Action(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "saml1:AuthorizationDecisionStatement"))
		{	*type = SOAP_TYPE__saml1__AuthorizationDecisionStatement;
			return soap_in__saml1__AuthorizationDecisionStatement(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "saml1:AuthorityBinding"))
		{	*type = SOAP_TYPE__saml1__AuthorityBinding;
			return soap_in__saml1__AuthorityBinding(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "saml1:SubjectLocality"))
		{	*type = SOAP_TYPE__saml1__SubjectLocality;
			return soap_in__saml1__SubjectLocality(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "saml1:AuthenticationStatement"))
		{	*type = SOAP_TYPE__saml1__AuthenticationStatement;
			return soap_in__saml1__AuthenticationStatement(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "saml1:SubjectConfirmation"))
		{	*type = SOAP_TYPE__saml1__SubjectConfirmation;
			return soap_in__saml1__SubjectConfirmation(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "saml1:NameIdentifier"))
		{	*type = SOAP_TYPE__saml1__NameIdentifier;
			return soap_in__saml1__NameIdentifier(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "saml1:Subject"))
		{	*type = SOAP_TYPE__saml1__Subject;
			return soap_in__saml1__Subject(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "saml1:SubjectStatement"))
		{	*type = SOAP_TYPE__saml1__SubjectStatement;
			return soap_in__saml1__SubjectStatement(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "saml1:Statement"))
		{	*type = SOAP_TYPE__saml1__Statement;
			return soap_in__saml1__Statement(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "saml1:Advice"))
		{	*type = SOAP_TYPE__saml1__Advice;
			return soap_in__saml1__Advice(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "saml1:DoNotCacheCondition"))
		{	*type = SOAP_TYPE__saml1__DoNotCacheCondition;
			return soap_in__saml1__DoNotCacheCondition(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "saml1:AudienceRestrictionCondition"))
		{	*type = SOAP_TYPE__saml1__AudienceRestrictionCondition;
			return soap_in__saml1__AudienceRestrictionCondition(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "saml1:Condition"))
		{	*type = SOAP_TYPE__saml1__Condition;
			return soap_in__saml1__Condition(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "saml1:Conditions"))
		{	*type = SOAP_TYPE__saml1__Conditions;
			return soap_in__saml1__Conditions(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "saml1:Assertion"))
		{	*type = SOAP_TYPE__saml1__Assertion;
			return soap_in__saml1__Assertion(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xenc:ReferenceList"))
		{	*type = SOAP_TYPE__xenc__ReferenceList;
			return soap_in__xenc__ReferenceList(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ds:KeyInfo"))
		{	*type = SOAP_TYPE__ds__KeyInfo;
			return soap_in__ds__KeyInfo(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ds:Transform"))
		{	*type = SOAP_TYPE__ds__Transform;
			return soap_in__ds__Transform(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "c14n:InclusiveNamespaces"))
		{	*type = SOAP_TYPE__c14n__InclusiveNamespaces;
			return soap_in__c14n__InclusiveNamespaces(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ds:Signature"))
		{	*type = SOAP_TYPE__ds__Signature;
			return soap_in__ds__Signature(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wsse:SecurityTokenReference"))
		{	*type = SOAP_TYPE__wsse__SecurityTokenReference;
			return soap_in__wsse__SecurityTokenReference(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wsse:KeyIdentifier"))
		{	*type = SOAP_TYPE__wsse__KeyIdentifier;
			return soap_in__wsse__KeyIdentifier(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wsse:Embedded"))
		{	*type = SOAP_TYPE__wsse__Embedded;
			return soap_in__wsse__Embedded(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wsse:Reference"))
		{	*type = SOAP_TYPE__wsse__Reference;
			return soap_in__wsse__Reference(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wsse:BinarySecurityToken"))
		{	*type = SOAP_TYPE__wsse__BinarySecurityToken;
			return soap_in__wsse__BinarySecurityToken(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wsse:Password"))
		{	*type = SOAP_TYPE__wsse__Password;
			return soap_in__wsse__Password(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wsse:UsernameToken"))
		{	*type = SOAP_TYPE__wsse__UsernameToken;
			return soap_in__wsse__UsernameToken(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wsu:Timestamp"))
		{	*type = SOAP_TYPE__wsu__Timestamp;
			return soap_in__wsu__Timestamp(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wsa5:ProblemAction"))
		{	*type = SOAP_TYPE__wsa5__ProblemAction;
			return soap_in__wsa5__ProblemAction(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wsa5:FaultTo"))
		{	*type = SOAP_TYPE__wsa5__FaultTo;
			return soap_in__wsa5__FaultTo(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wsa5:From"))
		{	*type = SOAP_TYPE__wsa5__From;
			return soap_in__wsa5__From(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wsa5:ReplyTo"))
		{	*type = SOAP_TYPE__wsa5__ReplyTo;
			return soap_in__wsa5__ReplyTo(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wsa5:RelatesTo"))
		{	*type = SOAP_TYPE__wsa5__RelatesTo;
			return soap_in__wsa5__RelatesTo(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wsa5:Metadata"))
		{	*type = SOAP_TYPE__wsa5__Metadata;
			return soap_in__wsa5__Metadata(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wsa5:ReferenceParameters"))
		{	*type = SOAP_TYPE__wsa5__ReferenceParameters;
			return soap_in__wsa5__ReferenceParameters(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wsa5:EndpointReference"))
		{	*type = SOAP_TYPE__wsa5__EndpointReference;
			return soap_in__wsa5__EndpointReference(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wsdd:AppSequence"))
		{	*type = SOAP_TYPE__wsdd__AppSequence;
			return soap_in__wsdd__AppSequence(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wsdd:Sig"))
		{	*type = SOAP_TYPE__wsdd__Sig;
			return soap_in__wsdd__Sig(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wsdd:Security"))
		{	*type = SOAP_TYPE__wsdd__Security;
			return soap_in__wsdd__Security(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wsdd:Scopes"))
		{	*type = SOAP_TYPE__wsdd__Scopes;
			return soap_in__wsdd__Scopes(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wsdd:ResolveMatches"))
		{	*type = SOAP_TYPE__wsdd__ResolveMatches;
			return soap_in__wsdd__ResolveMatches(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wsdd:Resolve"))
		{	*type = SOAP_TYPE__wsdd__Resolve;
			return soap_in__wsdd__Resolve(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wsdd:ProbeMatches"))
		{	*type = SOAP_TYPE__wsdd__ProbeMatches;
			return soap_in__wsdd__ProbeMatches(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wsdd:Probe"))
		{	*type = SOAP_TYPE__wsdd__Probe;
			return soap_in__wsdd__Probe(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wsdd:Bye"))
		{	*type = SOAP_TYPE__wsdd__Bye;
			return soap_in__wsdd__Bye(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wsdd:Hello"))
		{	*type = SOAP_TYPE__wsdd__Hello;
			return soap_in__wsdd__Hello(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wsa:FaultTo"))
		{	*type = SOAP_TYPE__wsa__FaultTo;
			return soap_in__wsa__FaultTo(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wsa:ReplyTo"))
		{	*type = SOAP_TYPE__wsa__ReplyTo;
			return soap_in__wsa__ReplyTo(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wsa:From"))
		{	*type = SOAP_TYPE__wsa__From;
			return soap_in__wsa__From(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wsa:RelatesTo"))
		{	*type = SOAP_TYPE__wsa__RelatesTo;
			return soap_in__wsa__RelatesTo(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wsa:EndpointReference"))
		{	*type = SOAP_TYPE__wsa__EndpointReference;
			return soap_in__wsa__EndpointReference(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xml:lang"))
		{	char **s;
			*type = SOAP_TYPE__xml__lang;
			s = soap_in__xml__lang(soap, NULL, NULL, NULL);
			return s ? *s : NULL;
		}
		if (!soap_match_tag(soap, t, "saml2:AuthenticatingAuthority"))
		{	char **s;
			*type = SOAP_TYPE__saml2__AuthenticatingAuthority;
			s = soap_in__saml2__AuthenticatingAuthority(soap, NULL, NULL, NULL);
			return s ? *s : NULL;
		}
		if (!soap_match_tag(soap, t, "saml2:AuthnContextDeclRef"))
		{	char **s;
			*type = SOAP_TYPE__saml2__AuthnContextDeclRef;
			s = soap_in__saml2__AuthnContextDeclRef(soap, NULL, NULL, NULL);
			return s ? *s : NULL;
		}
		if (!soap_match_tag(soap, t, "saml2:AuthnContextClassRef"))
		{	char **s;
			*type = SOAP_TYPE__saml2__AuthnContextClassRef;
			s = soap_in__saml2__AuthnContextClassRef(soap, NULL, NULL, NULL);
			return s ? *s : NULL;
		}
		if (!soap_match_tag(soap, t, "saml2:Audience"))
		{	char **s;
			*type = SOAP_TYPE__saml2__Audience;
			s = soap_in__saml2__Audience(soap, NULL, NULL, NULL);
			return s ? *s : NULL;
		}
		if (!soap_match_tag(soap, t, "saml2:AssertionURIRef"))
		{	char **s;
			*type = SOAP_TYPE__saml2__AssertionURIRef;
			s = soap_in__saml2__AssertionURIRef(soap, NULL, NULL, NULL);
			return s ? *s : NULL;
		}
		if (!soap_match_tag(soap, t, "saml2:AssertionIDRef"))
		{	char **s;
			*type = SOAP_TYPE__saml2__AssertionIDRef;
			s = soap_in__saml2__AssertionIDRef(soap, NULL, NULL, NULL);
			return s ? *s : NULL;
		}
		if (!soap_match_tag(soap, t, "saml1:ConfirmationMethod"))
		{	char **s;
			*type = SOAP_TYPE__saml1__ConfirmationMethod;
			s = soap_in__saml1__ConfirmationMethod(soap, NULL, NULL, NULL);
			return s ? *s : NULL;
		}
		if (!soap_match_tag(soap, t, "saml1:Audience"))
		{	char **s;
			*type = SOAP_TYPE__saml1__Audience;
			s = soap_in__saml1__Audience(soap, NULL, NULL, NULL);
			return s ? *s : NULL;
		}
		if (!soap_match_tag(soap, t, "saml1:AssertionIDReference"))
		{	char **s;
			*type = SOAP_TYPE__saml1__AssertionIDReference;
			s = soap_in__saml1__AssertionIDReference(soap, NULL, NULL, NULL);
			return s ? *s : NULL;
		}
		if (!soap_match_tag(soap, t, "ds:SignatureValue"))
		{	char **s;
			*type = SOAP_TYPE__ds__SignatureValue;
			s = soap_in__ds__SignatureValue(soap, NULL, NULL, NULL);
			return s ? *s : NULL;
		}
		if (!soap_match_tag(soap, t, "wsa5:ProblemIRI"))
		{	char **s;
			*type = SOAP_TYPE__wsa5__ProblemIRI;
			s = soap_in__wsa5__ProblemIRI(soap, NULL, NULL, NULL);
			return s ? *s : NULL;
		}
		if (!soap_match_tag(soap, t, "wsa5:Action"))
		{	char **s;
			*type = SOAP_TYPE__wsa5__Action;
			s = soap_in__wsa5__Action(soap, NULL, NULL, NULL);
			return s ? *s : NULL;
		}
		if (!soap_match_tag(soap, t, "wsa5:To"))
		{	char **s;
			*type = SOAP_TYPE__wsa5__To;
			s = soap_in__wsa5__To(soap, NULL, NULL, NULL);
			return s ? *s : NULL;
		}
		if (!soap_match_tag(soap, t, "wsa5:MessageID"))
		{	char **s;
			*type = SOAP_TYPE__wsa5__MessageID;
			s = soap_in__wsa5__MessageID(soap, NULL, NULL, NULL);
			return s ? *s : NULL;
		}
		if (!soap_match_tag(soap, t, "wsdd:Id"))
		{	char **s;
			*type = SOAP_TYPE__wsdd__Id;
			s = soap_in__wsdd__Id(soap, NULL, NULL, NULL);
			return s ? *s : NULL;
		}
		if (!soap_match_tag(soap, t, "wsdd:SupportedMatchingRules"))
		{	char **s;
			*type = SOAP_TYPE__wsdd__SupportedMatchingRules;
			s = soap_in__wsdd__SupportedMatchingRules(soap, NULL, NULL, NULL);
			return s ? *s : NULL;
		}
		if (!soap_match_tag(soap, t, "wsdd:XAddrs"))
		{	char **s;
			*type = SOAP_TYPE__wsdd__XAddrs;
			s = soap_in__wsdd__XAddrs(soap, NULL, NULL, NULL);
			return s ? *s : NULL;
		}
		if (!soap_match_tag(soap, t, "wsa:Action"))
		{	char **s;
			*type = SOAP_TYPE__wsa__Action;
			s = soap_in__wsa__Action(soap, NULL, NULL, NULL);
			return s ? *s : NULL;
		}
		if (!soap_match_tag(soap, t, "wsa:To"))
		{	char **s;
			*type = SOAP_TYPE__wsa__To;
			s = soap_in__wsa__To(soap, NULL, NULL, NULL);
			return s ? *s : NULL;
		}
		if (!soap_match_tag(soap, t, "wsa:MessageID"))
		{	char **s;
			*type = SOAP_TYPE__wsa__MessageID;
			s = soap_in__wsa__MessageID(soap, NULL, NULL, NULL);
			return s ? *s : NULL;
		}
#ifndef WITH_NOIDREF
	}
#endif
	}
	soap->error = SOAP_TAG_MISMATCH;
	return NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_ignore_element(struct soap *soap)
{
	if (!soap_peek_element(soap))
	{	int t;
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Unexpected element '%s' in input at level = %u body = %d)\n", soap->tag, soap->level, soap->body));
		if (soap->mustUnderstand && !soap->other && !soap->fignore)
			return soap->error = SOAP_MUSTUNDERSTAND;
		if (((soap->mode & SOAP_XML_STRICT) && !soap->fignore && soap->part != SOAP_IN_HEADER) || !soap_match_tag(soap, soap->tag, "SOAP-ENV:"))
		{	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "REJECTING element '%s'\n", soap->tag));
			return soap->error = SOAP_TAG_MISMATCH;
		}
		if (!*soap->id || !soap_getelement(soap, NULL, &t))
		{	soap->peeked = 0;
			if (soap->fignore)
				soap->error = soap->fignore(soap, soap->tag);
			else
				soap->error = SOAP_OK;
			DBGLOG(TEST, if (!soap->error) SOAP_MESSAGE(fdebug, "IGNORING element '%s'\n", soap->tag));
			if (!soap->error && soap->body && soap_ignore(soap))
				return soap->error;
		}
	}
	return soap->error;
}

#ifndef WITH_NOIDREF
SOAP_FMAC3 int SOAP_FMAC4 soap_putindependent(struct soap *soap)
{
	int i;
	struct soap_plist *pp;
	if (soap->version == 1 && soap->encodingStyle && !(soap->mode & (SOAP_XML_TREE | SOAP_XML_GRAPH)))
		for (i = 0; i < SOAP_PTRHASH; i++)
			for (pp = soap->pht[i]; pp; pp = pp->next)
				if (pp->mark1 == 2 || pp->mark2 == 2)
					if (soap_putelement(soap, pp->ptr, SOAP_MULTIREFTAG, pp->id, pp->type))
						return soap->error;
	return SOAP_OK;
}
#endif
SOAP_FMAC3 int SOAP_FMAC4 soap_putelement(struct soap *soap, const void *ptr, const char *tag, int id, int type)
{	(void)tag;
	switch (type)
	{
	case SOAP_TYPE_byte:
		return soap_out_byte(soap, tag, id, (const char *)ptr, "xsd:byte");
	case SOAP_TYPE_int:
		return soap_out_int(soap, tag, id, (const int *)ptr, "xsd:int");
	case SOAP_TYPE_xsd__duration:
		return soap_out_xsd__duration(soap, tag, id, (const LONG64 *)ptr, "xsd:duration");
	case SOAP_TYPE_float:
		return soap_out_float(soap, tag, id, (const float *)ptr, "xsd:float");
	case SOAP_TYPE__wsdd__MetadataVersion:
		return soap_out__wsdd__MetadataVersion(soap, "wsdd:MetadataVersion", id, (const unsigned int *)ptr, "");
	case SOAP_TYPE__wsa__ReplyAfter:
		return soap_out__wsa__ReplyAfter(soap, "wsa:ReplyAfter", id, (const unsigned int *)ptr, "");
	case SOAP_TYPE_unsignedInt:
		return soap_out_unsignedInt(soap, tag, id, (const unsigned int *)ptr, "xsd:unsignedInt");
	case SOAP_TYPE__wsa5__RetryAfter:
		return soap_out__wsa5__RetryAfter(soap, "wsa5:RetryAfter", id, (const ULONG64 *)ptr, "");
	case SOAP_TYPE_ULONG64:
		return soap_out_ULONG64(soap, tag, id, (const ULONG64 *)ptr, "xsd:unsignedLong");
	case SOAP_TYPE_dateTime:
		return soap_out_dateTime(soap, tag, id, (const time_t *)ptr, "xsd:dateTime");
	case SOAP_TYPE_tt__IPType:
		return soap_out_tt__IPType(soap, tag, id, (const enum tt__IPType *)ptr, "tt:IPType");
	case SOAP_TYPE_tt__H264Profile:
		return soap_out_tt__H264Profile(soap, tag, id, (const enum tt__H264Profile *)ptr, "tt:H264Profile");
	case SOAP_TYPE_tt__Mpeg4Profile:
		return soap_out_tt__Mpeg4Profile(soap, tag, id, (const enum tt__Mpeg4Profile *)ptr, "tt:Mpeg4Profile");
	case SOAP_TYPE_tt__VideoEncoding:
		return soap_out_tt__VideoEncoding(soap, tag, id, (const enum tt__VideoEncoding *)ptr, "tt:VideoEncoding");
	case SOAP_TYPE_tt__PropertyOperation:
		return soap_out_tt__PropertyOperation(soap, tag, id, (const enum tt__PropertyOperation *)ptr, "tt:PropertyOperation");
	case SOAP_TYPE_tt__MoveStatus:
		return soap_out_tt__MoveStatus(soap, tag, id, (const enum tt__MoveStatus *)ptr, "tt:MoveStatus");
	case SOAP_TYPE_tt__CapabilityCategory:
		return soap_out_tt__CapabilityCategory(soap, tag, id, (const enum tt__CapabilityCategory *)ptr, "tt:CapabilityCategory");
	case SOAP_TYPE_xsd__boolean:
		return soap_out_xsd__boolean(soap, tag, id, (const enum xsd__boolean *)ptr, "xsd:boolean");
	case SOAP_TYPE_saml2__DecisionType:
		return soap_out_saml2__DecisionType(soap, tag, id, (const enum saml2__DecisionType *)ptr, "saml2:DecisionType");
	case SOAP_TYPE_saml1__DecisionType:
		return soap_out_saml1__DecisionType(soap, tag, id, (const enum saml1__DecisionType *)ptr, "saml1:DecisionType");
	case SOAP_TYPE_wsc__FaultCodeType:
		return soap_out_wsc__FaultCodeType(soap, tag, id, (const enum wsc__FaultCodeType *)ptr, "wsc:FaultCodeType");
	case SOAP_TYPE_wsse__FaultcodeEnum:
		return soap_out_wsse__FaultcodeEnum(soap, tag, id, (const enum wsse__FaultcodeEnum *)ptr, "wsse:FaultcodeEnum");
	case SOAP_TYPE_wsu__tTimestampFault:
		return soap_out_wsu__tTimestampFault(soap, tag, id, (const enum wsu__tTimestampFault *)ptr, "wsu:tTimestampFault");
	case SOAP_TYPE__wsa5__IsReferenceParameter:
		return soap_out__wsa5__IsReferenceParameter(soap, tag, id, (const enum _wsa5__IsReferenceParameter *)ptr, "wsa5:IsReferenceParameter");
	case SOAP_TYPE_wsa5__FaultCodesType:
		return soap_out_wsa5__FaultCodesType(soap, tag, id, (const enum wsa5__FaultCodesType *)ptr, "wsa5:FaultCodesType");
	case SOAP_TYPE_wsa5__RelationshipType:
		return soap_out_wsa5__RelationshipType(soap, tag, id, (const enum wsa5__RelationshipType *)ptr, "wsa5:RelationshipType");
	case SOAP_TYPE_wsdd__FaultCodeType:
		return soap_out_wsdd__FaultCodeType(soap, tag, id, (const enum wsdd__FaultCodeType *)ptr, "wsdd:FaultCodeType");
	case SOAP_TYPE_wsa__FaultSubcodeValues:
		return soap_out_wsa__FaultSubcodeValues(soap, tag, id, (const enum wsa__FaultSubcodeValues *)ptr, "wsa:FaultSubcodeValues");
	case SOAP_TYPE_wsa__RelationshipTypeValues:
		return soap_out_wsa__RelationshipTypeValues(soap, tag, id, (const enum wsa__RelationshipTypeValues *)ptr, "wsa:RelationshipTypeValues");
	case SOAP_TYPE_wstop__TopicType:
		return soap_out_wstop__TopicType(soap, tag, id, (const struct wstop__TopicType *)ptr, "wstop:TopicType");
	case SOAP_TYPE__wstop__TopicNamespaceType_Topic:
		return soap_out__wstop__TopicNamespaceType_Topic(soap, "wstop:TopicNamespaceType-Topic", id, (const struct _wstop__TopicNamespaceType_Topic *)ptr, "");
	case SOAP_TYPE_wstop__TopicNamespaceType:
		return soap_out_wstop__TopicNamespaceType(soap, tag, id, (const struct wstop__TopicNamespaceType *)ptr, "wstop:TopicNamespaceType");
	case SOAP_TYPE__wsnt__ResumeFailedFaultType_FaultCause:
		return soap_out__wsnt__ResumeFailedFaultType_FaultCause(soap, "wsnt:ResumeFailedFaultType-FaultCause", id, (const struct _wsnt__ResumeFailedFaultType_FaultCause *)ptr, "");
	case SOAP_TYPE__wsnt__ResumeFailedFaultType_Description:
		return soap_out__wsnt__ResumeFailedFaultType_Description(soap, "wsnt:ResumeFailedFaultType-Description", id, (const struct _wsnt__ResumeFailedFaultType_Description *)ptr, "");
	case SOAP_TYPE__wsnt__ResumeFailedFaultType_ErrorCode:
		return soap_out__wsnt__ResumeFailedFaultType_ErrorCode(soap, "wsnt:ResumeFailedFaultType-ErrorCode", id, (const struct _wsnt__ResumeFailedFaultType_ErrorCode *)ptr, "");
	case SOAP_TYPE_wsnt__ResumeFailedFaultType:
		return soap_out_wsnt__ResumeFailedFaultType(soap, tag, id, (const struct wsnt__ResumeFailedFaultType *)ptr, "wsnt:ResumeFailedFaultType");
	case SOAP_TYPE__wsnt__PauseFailedFaultType_FaultCause:
		return soap_out__wsnt__PauseFailedFaultType_FaultCause(soap, "wsnt:PauseFailedFaultType-FaultCause", id, (const struct _wsnt__PauseFailedFaultType_FaultCause *)ptr, "");
	case SOAP_TYPE__wsnt__PauseFailedFaultType_Description:
		return soap_out__wsnt__PauseFailedFaultType_Description(soap, "wsnt:PauseFailedFaultType-Description", id, (const struct _wsnt__PauseFailedFaultType_Description *)ptr, "");
	case SOAP_TYPE__wsnt__PauseFailedFaultType_ErrorCode:
		return soap_out__wsnt__PauseFailedFaultType_ErrorCode(soap, "wsnt:PauseFailedFaultType-ErrorCode", id, (const struct _wsnt__PauseFailedFaultType_ErrorCode *)ptr, "");
	case SOAP_TYPE_wsnt__PauseFailedFaultType:
		return soap_out_wsnt__PauseFailedFaultType(soap, tag, id, (const struct wsnt__PauseFailedFaultType *)ptr, "wsnt:PauseFailedFaultType");
	case SOAP_TYPE__wsnt__UnableToDestroySubscriptionFaultType_FaultCause:
		return soap_out__wsnt__UnableToDestroySubscriptionFaultType_FaultCause(soap, "wsnt:UnableToDestroySubscriptionFaultType-FaultCause", id, (const struct _wsnt__UnableToDestroySubscriptionFaultType_FaultCause *)ptr, "");
	case SOAP_TYPE__wsnt__UnableToDestroySubscriptionFaultType_Description:
		return soap_out__wsnt__UnableToDestroySubscriptionFaultType_Description(soap, "wsnt:UnableToDestroySubscriptionFaultType-Description", id, (const struct _wsnt__UnableToDestroySubscriptionFaultType_Description *)ptr, "");
	case SOAP_TYPE__wsnt__UnableToDestroySubscriptionFaultType_ErrorCode:
		return soap_out__wsnt__UnableToDestroySubscriptionFaultType_ErrorCode(soap, "wsnt:UnableToDestroySubscriptionFaultType-ErrorCode", id, (const struct _wsnt__UnableToDestroySubscriptionFaultType_ErrorCode *)ptr, "");
	case SOAP_TYPE_wsnt__UnableToDestroySubscriptionFaultType:
		return soap_out_wsnt__UnableToDestroySubscriptionFaultType(soap, tag, id, (const struct wsnt__UnableToDestroySubscriptionFaultType *)ptr, "wsnt:UnableToDestroySubscriptionFaultType");
	case SOAP_TYPE__wsnt__UnacceptableTerminationTimeFaultType_FaultCause:
		return soap_out__wsnt__UnacceptableTerminationTimeFaultType_FaultCause(soap, "wsnt:UnacceptableTerminationTimeFaultType-FaultCause", id, (const struct _wsnt__UnacceptableTerminationTimeFaultType_FaultCause *)ptr, "");
	case SOAP_TYPE__wsnt__UnacceptableTerminationTimeFaultType_Description:
		return soap_out__wsnt__UnacceptableTerminationTimeFaultType_Description(soap, "wsnt:UnacceptableTerminationTimeFaultType-Description", id, (const struct _wsnt__UnacceptableTerminationTimeFaultType_Description *)ptr, "");
	case SOAP_TYPE__wsnt__UnacceptableTerminationTimeFaultType_ErrorCode:
		return soap_out__wsnt__UnacceptableTerminationTimeFaultType_ErrorCode(soap, "wsnt:UnacceptableTerminationTimeFaultType-ErrorCode", id, (const struct _wsnt__UnacceptableTerminationTimeFaultType_ErrorCode *)ptr, "");
	case SOAP_TYPE_wsnt__UnacceptableTerminationTimeFaultType:
		return soap_out_wsnt__UnacceptableTerminationTimeFaultType(soap, tag, id, (const struct wsnt__UnacceptableTerminationTimeFaultType *)ptr, "wsnt:UnacceptableTerminationTimeFaultType");
	case SOAP_TYPE__wsnt__UnableToCreatePullPointFaultType_FaultCause:
		return soap_out__wsnt__UnableToCreatePullPointFaultType_FaultCause(soap, "wsnt:UnableToCreatePullPointFaultType-FaultCause", id, (const struct _wsnt__UnableToCreatePullPointFaultType_FaultCause *)ptr, "");
	case SOAP_TYPE__wsnt__UnableToCreatePullPointFaultType_Description:
		return soap_out__wsnt__UnableToCreatePullPointFaultType_Description(soap, "wsnt:UnableToCreatePullPointFaultType-Description", id, (const struct _wsnt__UnableToCreatePullPointFaultType_Description *)ptr, "");
	case SOAP_TYPE__wsnt__UnableToCreatePullPointFaultType_ErrorCode:
		return soap_out__wsnt__UnableToCreatePullPointFaultType_ErrorCode(soap, "wsnt:UnableToCreatePullPointFaultType-ErrorCode", id, (const struct _wsnt__UnableToCreatePullPointFaultType_ErrorCode *)ptr, "");
	case SOAP_TYPE_wsnt__UnableToCreatePullPointFaultType:
		return soap_out_wsnt__UnableToCreatePullPointFaultType(soap, tag, id, (const struct wsnt__UnableToCreatePullPointFaultType *)ptr, "wsnt:UnableToCreatePullPointFaultType");
	case SOAP_TYPE__wsnt__UnableToDestroyPullPointFaultType_FaultCause:
		return soap_out__wsnt__UnableToDestroyPullPointFaultType_FaultCause(soap, "wsnt:UnableToDestroyPullPointFaultType-FaultCause", id, (const struct _wsnt__UnableToDestroyPullPointFaultType_FaultCause *)ptr, "");
	case SOAP_TYPE__wsnt__UnableToDestroyPullPointFaultType_Description:
		return soap_out__wsnt__UnableToDestroyPullPointFaultType_Description(soap, "wsnt:UnableToDestroyPullPointFaultType-Description", id, (const struct _wsnt__UnableToDestroyPullPointFaultType_Description *)ptr, "");
	case SOAP_TYPE__wsnt__UnableToDestroyPullPointFaultType_ErrorCode:
		return soap_out__wsnt__UnableToDestroyPullPointFaultType_ErrorCode(soap, "wsnt:UnableToDestroyPullPointFaultType-ErrorCode", id, (const struct _wsnt__UnableToDestroyPullPointFaultType_ErrorCode *)ptr, "");
	case SOAP_TYPE_wsnt__UnableToDestroyPullPointFaultType:
		return soap_out_wsnt__UnableToDestroyPullPointFaultType(soap, tag, id, (const struct wsnt__UnableToDestroyPullPointFaultType *)ptr, "wsnt:UnableToDestroyPullPointFaultType");
	case SOAP_TYPE__wsnt__UnableToGetMessagesFaultType_FaultCause:
		return soap_out__wsnt__UnableToGetMessagesFaultType_FaultCause(soap, "wsnt:UnableToGetMessagesFaultType-FaultCause", id, (const struct _wsnt__UnableToGetMessagesFaultType_FaultCause *)ptr, "");
	case SOAP_TYPE__wsnt__UnableToGetMessagesFaultType_Description:
		return soap_out__wsnt__UnableToGetMessagesFaultType_Description(soap, "wsnt:UnableToGetMessagesFaultType-Description", id, (const struct _wsnt__UnableToGetMessagesFaultType_Description *)ptr, "");
	case SOAP_TYPE__wsnt__UnableToGetMessagesFaultType_ErrorCode:
		return soap_out__wsnt__UnableToGetMessagesFaultType_ErrorCode(soap, "wsnt:UnableToGetMessagesFaultType-ErrorCode", id, (const struct _wsnt__UnableToGetMessagesFaultType_ErrorCode *)ptr, "");
	case SOAP_TYPE_wsnt__UnableToGetMessagesFaultType:
		return soap_out_wsnt__UnableToGetMessagesFaultType(soap, tag, id, (const struct wsnt__UnableToGetMessagesFaultType *)ptr, "wsnt:UnableToGetMessagesFaultType");
	case SOAP_TYPE__wsnt__NoCurrentMessageOnTopicFaultType_FaultCause:
		return soap_out__wsnt__NoCurrentMessageOnTopicFaultType_FaultCause(soap, "wsnt:NoCurrentMessageOnTopicFaultType-FaultCause", id, (const struct _wsnt__NoCurrentMessageOnTopicFaultType_FaultCause *)ptr, "");
	case SOAP_TYPE__wsnt__NoCurrentMessageOnTopicFaultType_Description:
		return soap_out__wsnt__NoCurrentMessageOnTopicFaultType_Description(soap, "wsnt:NoCurrentMessageOnTopicFaultType-Description", id, (const struct _wsnt__NoCurrentMessageOnTopicFaultType_Description *)ptr, "");
	case SOAP_TYPE__wsnt__NoCurrentMessageOnTopicFaultType_ErrorCode:
		return soap_out__wsnt__NoCurrentMessageOnTopicFaultType_ErrorCode(soap, "wsnt:NoCurrentMessageOnTopicFaultType-ErrorCode", id, (const struct _wsnt__NoCurrentMessageOnTopicFaultType_ErrorCode *)ptr, "");
	case SOAP_TYPE_wsnt__NoCurrentMessageOnTopicFaultType:
		return soap_out_wsnt__NoCurrentMessageOnTopicFaultType(soap, tag, id, (const struct wsnt__NoCurrentMessageOnTopicFaultType *)ptr, "wsnt:NoCurrentMessageOnTopicFaultType");
	case SOAP_TYPE__wsnt__UnacceptableInitialTerminationTimeFaultType_FaultCause:
		return soap_out__wsnt__UnacceptableInitialTerminationTimeFaultType_FaultCause(soap, "wsnt:UnacceptableInitialTerminationTimeFaultType-FaultCause", id, (const struct _wsnt__UnacceptableInitialTerminationTimeFaultType_FaultCause *)ptr, "");
	case SOAP_TYPE__wsnt__UnacceptableInitialTerminationTimeFaultType_Description:
		return soap_out__wsnt__UnacceptableInitialTerminationTimeFaultType_Description(soap, "wsnt:UnacceptableInitialTerminationTimeFaultType-Description", id, (const struct _wsnt__UnacceptableInitialTerminationTimeFaultType_Description *)ptr, "");
	case SOAP_TYPE__wsnt__UnacceptableInitialTerminationTimeFaultType_ErrorCode:
		return soap_out__wsnt__UnacceptableInitialTerminationTimeFaultType_ErrorCode(soap, "wsnt:UnacceptableInitialTerminationTimeFaultType-ErrorCode", id, (const struct _wsnt__UnacceptableInitialTerminationTimeFaultType_ErrorCode *)ptr, "");
	case SOAP_TYPE_wsnt__UnacceptableInitialTerminationTimeFaultType:
		return soap_out_wsnt__UnacceptableInitialTerminationTimeFaultType(soap, tag, id, (const struct wsnt__UnacceptableInitialTerminationTimeFaultType *)ptr, "wsnt:UnacceptableInitialTerminationTimeFaultType");
	case SOAP_TYPE__wsnt__NotifyMessageNotSupportedFaultType_FaultCause:
		return soap_out__wsnt__NotifyMessageNotSupportedFaultType_FaultCause(soap, "wsnt:NotifyMessageNotSupportedFaultType-FaultCause", id, (const struct _wsnt__NotifyMessageNotSupportedFaultType_FaultCause *)ptr, "");
	case SOAP_TYPE__wsnt__NotifyMessageNotSupportedFaultType_Description:
		return soap_out__wsnt__NotifyMessageNotSupportedFaultType_Description(soap, "wsnt:NotifyMessageNotSupportedFaultType-Description", id, (const struct _wsnt__NotifyMessageNotSupportedFaultType_Description *)ptr, "");
	case SOAP_TYPE__wsnt__NotifyMessageNotSupportedFaultType_ErrorCode:
		return soap_out__wsnt__NotifyMessageNotSupportedFaultType_ErrorCode(soap, "wsnt:NotifyMessageNotSupportedFaultType-ErrorCode", id, (const struct _wsnt__NotifyMessageNotSupportedFaultType_ErrorCode *)ptr, "");
	case SOAP_TYPE_wsnt__NotifyMessageNotSupportedFaultType:
		return soap_out_wsnt__NotifyMessageNotSupportedFaultType(soap, tag, id, (const struct wsnt__NotifyMessageNotSupportedFaultType *)ptr, "wsnt:NotifyMessageNotSupportedFaultType");
	case SOAP_TYPE__wsnt__UnsupportedPolicyRequestFaultType_FaultCause:
		return soap_out__wsnt__UnsupportedPolicyRequestFaultType_FaultCause(soap, "wsnt:UnsupportedPolicyRequestFaultType-FaultCause", id, (const struct _wsnt__UnsupportedPolicyRequestFaultType_FaultCause *)ptr, "");
	case SOAP_TYPE__wsnt__UnsupportedPolicyRequestFaultType_Description:
		return soap_out__wsnt__UnsupportedPolicyRequestFaultType_Description(soap, "wsnt:UnsupportedPolicyRequestFaultType-Description", id, (const struct _wsnt__UnsupportedPolicyRequestFaultType_Description *)ptr, "");
	case SOAP_TYPE__wsnt__UnsupportedPolicyRequestFaultType_ErrorCode:
		return soap_out__wsnt__UnsupportedPolicyRequestFaultType_ErrorCode(soap, "wsnt:UnsupportedPolicyRequestFaultType-ErrorCode", id, (const struct _wsnt__UnsupportedPolicyRequestFaultType_ErrorCode *)ptr, "");
	case SOAP_TYPE_wsnt__UnsupportedPolicyRequestFaultType:
		return soap_out_wsnt__UnsupportedPolicyRequestFaultType(soap, tag, id, (const struct wsnt__UnsupportedPolicyRequestFaultType *)ptr, "wsnt:UnsupportedPolicyRequestFaultType");
	case SOAP_TYPE__wsnt__UnrecognizedPolicyRequestFaultType_FaultCause:
		return soap_out__wsnt__UnrecognizedPolicyRequestFaultType_FaultCause(soap, "wsnt:UnrecognizedPolicyRequestFaultType-FaultCause", id, (const struct _wsnt__UnrecognizedPolicyRequestFaultType_FaultCause *)ptr, "");
	case SOAP_TYPE__wsnt__UnrecognizedPolicyRequestFaultType_Description:
		return soap_out__wsnt__UnrecognizedPolicyRequestFaultType_Description(soap, "wsnt:UnrecognizedPolicyRequestFaultType-Description", id, (const struct _wsnt__UnrecognizedPolicyRequestFaultType_Description *)ptr, "");
	case SOAP_TYPE__wsnt__UnrecognizedPolicyRequestFaultType_ErrorCode:
		return soap_out__wsnt__UnrecognizedPolicyRequestFaultType_ErrorCode(soap, "wsnt:UnrecognizedPolicyRequestFaultType-ErrorCode", id, (const struct _wsnt__UnrecognizedPolicyRequestFaultType_ErrorCode *)ptr, "");
	case SOAP_TYPE_wsnt__UnrecognizedPolicyRequestFaultType:
		return soap_out_wsnt__UnrecognizedPolicyRequestFaultType(soap, tag, id, (const struct wsnt__UnrecognizedPolicyRequestFaultType *)ptr, "wsnt:UnrecognizedPolicyRequestFaultType");
	case SOAP_TYPE__wsnt__InvalidMessageContentExpressionFaultType_FaultCause:
		return soap_out__wsnt__InvalidMessageContentExpressionFaultType_FaultCause(soap, "wsnt:InvalidMessageContentExpressionFaultType-FaultCause", id, (const struct _wsnt__InvalidMessageContentExpressionFaultType_FaultCause *)ptr, "");
	case SOAP_TYPE__wsnt__InvalidMessageContentExpressionFaultType_Description:
		return soap_out__wsnt__InvalidMessageContentExpressionFaultType_Description(soap, "wsnt:InvalidMessageContentExpressionFaultType-Description", id, (const struct _wsnt__InvalidMessageContentExpressionFaultType_Description *)ptr, "");
	case SOAP_TYPE__wsnt__InvalidMessageContentExpressionFaultType_ErrorCode:
		return soap_out__wsnt__InvalidMessageContentExpressionFaultType_ErrorCode(soap, "wsnt:InvalidMessageContentExpressionFaultType-ErrorCode", id, (const struct _wsnt__InvalidMessageContentExpressionFaultType_ErrorCode *)ptr, "");
	case SOAP_TYPE_wsnt__InvalidMessageContentExpressionFaultType:
		return soap_out_wsnt__InvalidMessageContentExpressionFaultType(soap, tag, id, (const struct wsnt__InvalidMessageContentExpressionFaultType *)ptr, "wsnt:InvalidMessageContentExpressionFaultType");
	case SOAP_TYPE__wsnt__InvalidProducerPropertiesExpressionFaultType_FaultCause:
		return soap_out__wsnt__InvalidProducerPropertiesExpressionFaultType_FaultCause(soap, "wsnt:InvalidProducerPropertiesExpressionFaultType-FaultCause", id, (const struct _wsnt__InvalidProducerPropertiesExpressionFaultType_FaultCause *)ptr, "");
	case SOAP_TYPE__wsnt__InvalidProducerPropertiesExpressionFaultType_Description:
		return soap_out__wsnt__InvalidProducerPropertiesExpressionFaultType_Description(soap, "wsnt:InvalidProducerPropertiesExpressionFaultType-Description", id, (const struct _wsnt__InvalidProducerPropertiesExpressionFaultType_Description *)ptr, "");
	case SOAP_TYPE__wsnt__InvalidProducerPropertiesExpressionFaultType_ErrorCode:
		return soap_out__wsnt__InvalidProducerPropertiesExpressionFaultType_ErrorCode(soap, "wsnt:InvalidProducerPropertiesExpressionFaultType-ErrorCode", id, (const struct _wsnt__InvalidProducerPropertiesExpressionFaultType_ErrorCode *)ptr, "");
	case SOAP_TYPE_wsnt__InvalidProducerPropertiesExpressionFaultType:
		return soap_out_wsnt__InvalidProducerPropertiesExpressionFaultType(soap, tag, id, (const struct wsnt__InvalidProducerPropertiesExpressionFaultType *)ptr, "wsnt:InvalidProducerPropertiesExpressionFaultType");
	case SOAP_TYPE__wsnt__MultipleTopicsSpecifiedFaultType_FaultCause:
		return soap_out__wsnt__MultipleTopicsSpecifiedFaultType_FaultCause(soap, "wsnt:MultipleTopicsSpecifiedFaultType-FaultCause", id, (const struct _wsnt__MultipleTopicsSpecifiedFaultType_FaultCause *)ptr, "");
	case SOAP_TYPE__wsnt__MultipleTopicsSpecifiedFaultType_Description:
		return soap_out__wsnt__MultipleTopicsSpecifiedFaultType_Description(soap, "wsnt:MultipleTopicsSpecifiedFaultType-Description", id, (const struct _wsnt__MultipleTopicsSpecifiedFaultType_Description *)ptr, "");
	case SOAP_TYPE__wsnt__MultipleTopicsSpecifiedFaultType_ErrorCode:
		return soap_out__wsnt__MultipleTopicsSpecifiedFaultType_ErrorCode(soap, "wsnt:MultipleTopicsSpecifiedFaultType-ErrorCode", id, (const struct _wsnt__MultipleTopicsSpecifiedFaultType_ErrorCode *)ptr, "");
	case SOAP_TYPE_wsnt__MultipleTopicsSpecifiedFaultType:
		return soap_out_wsnt__MultipleTopicsSpecifiedFaultType(soap, tag, id, (const struct wsnt__MultipleTopicsSpecifiedFaultType *)ptr, "wsnt:MultipleTopicsSpecifiedFaultType");
	case SOAP_TYPE__wsnt__TopicNotSupportedFaultType_FaultCause:
		return soap_out__wsnt__TopicNotSupportedFaultType_FaultCause(soap, "wsnt:TopicNotSupportedFaultType-FaultCause", id, (const struct _wsnt__TopicNotSupportedFaultType_FaultCause *)ptr, "");
	case SOAP_TYPE__wsnt__TopicNotSupportedFaultType_Description:
		return soap_out__wsnt__TopicNotSupportedFaultType_Description(soap, "wsnt:TopicNotSupportedFaultType-Description", id, (const struct _wsnt__TopicNotSupportedFaultType_Description *)ptr, "");
	case SOAP_TYPE__wsnt__TopicNotSupportedFaultType_ErrorCode:
		return soap_out__wsnt__TopicNotSupportedFaultType_ErrorCode(soap, "wsnt:TopicNotSupportedFaultType-ErrorCode", id, (const struct _wsnt__TopicNotSupportedFaultType_ErrorCode *)ptr, "");
	case SOAP_TYPE_wsnt__TopicNotSupportedFaultType:
		return soap_out_wsnt__TopicNotSupportedFaultType(soap, tag, id, (const struct wsnt__TopicNotSupportedFaultType *)ptr, "wsnt:TopicNotSupportedFaultType");
	case SOAP_TYPE__wsnt__InvalidTopicExpressionFaultType_FaultCause:
		return soap_out__wsnt__InvalidTopicExpressionFaultType_FaultCause(soap, "wsnt:InvalidTopicExpressionFaultType-FaultCause", id, (const struct _wsnt__InvalidTopicExpressionFaultType_FaultCause *)ptr, "");
	case SOAP_TYPE__wsnt__InvalidTopicExpressionFaultType_Description:
		return soap_out__wsnt__InvalidTopicExpressionFaultType_Description(soap, "wsnt:InvalidTopicExpressionFaultType-Description", id, (const struct _wsnt__InvalidTopicExpressionFaultType_Description *)ptr, "");
	case SOAP_TYPE__wsnt__InvalidTopicExpressionFaultType_ErrorCode:
		return soap_out__wsnt__InvalidTopicExpressionFaultType_ErrorCode(soap, "wsnt:InvalidTopicExpressionFaultType-ErrorCode", id, (const struct _wsnt__InvalidTopicExpressionFaultType_ErrorCode *)ptr, "");
	case SOAP_TYPE_wsnt__InvalidTopicExpressionFaultType:
		return soap_out_wsnt__InvalidTopicExpressionFaultType(soap, tag, id, (const struct wsnt__InvalidTopicExpressionFaultType *)ptr, "wsnt:InvalidTopicExpressionFaultType");
	case SOAP_TYPE__wsnt__TopicExpressionDialectUnknownFaultType_FaultCause:
		return soap_out__wsnt__TopicExpressionDialectUnknownFaultType_FaultCause(soap, "wsnt:TopicExpressionDialectUnknownFaultType-FaultCause", id, (const struct _wsnt__TopicExpressionDialectUnknownFaultType_FaultCause *)ptr, "");
	case SOAP_TYPE__wsnt__TopicExpressionDialectUnknownFaultType_Description:
		return soap_out__wsnt__TopicExpressionDialectUnknownFaultType_Description(soap, "wsnt:TopicExpressionDialectUnknownFaultType-Description", id, (const struct _wsnt__TopicExpressionDialectUnknownFaultType_Description *)ptr, "");
	case SOAP_TYPE__wsnt__TopicExpressionDialectUnknownFaultType_ErrorCode:
		return soap_out__wsnt__TopicExpressionDialectUnknownFaultType_ErrorCode(soap, "wsnt:TopicExpressionDialectUnknownFaultType-ErrorCode", id, (const struct _wsnt__TopicExpressionDialectUnknownFaultType_ErrorCode *)ptr, "");
	case SOAP_TYPE_wsnt__TopicExpressionDialectUnknownFaultType:
		return soap_out_wsnt__TopicExpressionDialectUnknownFaultType(soap, tag, id, (const struct wsnt__TopicExpressionDialectUnknownFaultType *)ptr, "wsnt:TopicExpressionDialectUnknownFaultType");
	case SOAP_TYPE__wsnt__InvalidFilterFaultType_FaultCause:
		return soap_out__wsnt__InvalidFilterFaultType_FaultCause(soap, "wsnt:InvalidFilterFaultType-FaultCause", id, (const struct _wsnt__InvalidFilterFaultType_FaultCause *)ptr, "");
	case SOAP_TYPE__wsnt__InvalidFilterFaultType_Description:
		return soap_out__wsnt__InvalidFilterFaultType_Description(soap, "wsnt:InvalidFilterFaultType-Description", id, (const struct _wsnt__InvalidFilterFaultType_Description *)ptr, "");
	case SOAP_TYPE__wsnt__InvalidFilterFaultType_ErrorCode:
		return soap_out__wsnt__InvalidFilterFaultType_ErrorCode(soap, "wsnt:InvalidFilterFaultType-ErrorCode", id, (const struct _wsnt__InvalidFilterFaultType_ErrorCode *)ptr, "");
	case SOAP_TYPE_wsnt__InvalidFilterFaultType:
		return soap_out_wsnt__InvalidFilterFaultType(soap, tag, id, (const struct wsnt__InvalidFilterFaultType *)ptr, "wsnt:InvalidFilterFaultType");
	case SOAP_TYPE__wsnt__SubscribeCreationFailedFaultType_FaultCause:
		return soap_out__wsnt__SubscribeCreationFailedFaultType_FaultCause(soap, "wsnt:SubscribeCreationFailedFaultType-FaultCause", id, (const struct _wsnt__SubscribeCreationFailedFaultType_FaultCause *)ptr, "");
	case SOAP_TYPE__wsnt__SubscribeCreationFailedFaultType_Description:
		return soap_out__wsnt__SubscribeCreationFailedFaultType_Description(soap, "wsnt:SubscribeCreationFailedFaultType-Description", id, (const struct _wsnt__SubscribeCreationFailedFaultType_Description *)ptr, "");
	case SOAP_TYPE__wsnt__SubscribeCreationFailedFaultType_ErrorCode:
		return soap_out__wsnt__SubscribeCreationFailedFaultType_ErrorCode(soap, "wsnt:SubscribeCreationFailedFaultType-ErrorCode", id, (const struct _wsnt__SubscribeCreationFailedFaultType_ErrorCode *)ptr, "");
	case SOAP_TYPE_wsnt__SubscribeCreationFailedFaultType:
		return soap_out_wsnt__SubscribeCreationFailedFaultType(soap, tag, id, (const struct wsnt__SubscribeCreationFailedFaultType *)ptr, "wsnt:SubscribeCreationFailedFaultType");
	case SOAP_TYPE__trt__GetSnapshotUriResponse:
		return soap_out__trt__GetSnapshotUriResponse(soap, "trt:GetSnapshotUriResponse", id, (const struct _trt__GetSnapshotUriResponse *)ptr, "");
	case SOAP_TYPE__trt__GetSnapshotUri:
		return soap_out__trt__GetSnapshotUri(soap, "trt:GetSnapshotUri", id, (const struct _trt__GetSnapshotUri *)ptr, "");
	case SOAP_TYPE__trt__DeleteProfileResponse:
		return soap_out__trt__DeleteProfileResponse(soap, "trt:DeleteProfileResponse", id, (const struct _trt__DeleteProfileResponse *)ptr, "");
	case SOAP_TYPE__trt__DeleteProfile:
		return soap_out__trt__DeleteProfile(soap, "trt:DeleteProfile", id, (const struct _trt__DeleteProfile *)ptr, "");
	case SOAP_TYPE__trt__GetProfilesResponse:
		return soap_out__trt__GetProfilesResponse(soap, "trt:GetProfilesResponse", id, (const struct _trt__GetProfilesResponse *)ptr, "");
	case SOAP_TYPE__trt__GetProfiles:
		return soap_out__trt__GetProfiles(soap, "trt:GetProfiles", id, (const struct _trt__GetProfiles *)ptr, "");
	case SOAP_TYPE__trt__GetProfileResponse:
		return soap_out__trt__GetProfileResponse(soap, "trt:GetProfileResponse", id, (const struct _trt__GetProfileResponse *)ptr, "");
	case SOAP_TYPE__trt__GetProfile:
		return soap_out__trt__GetProfile(soap, "trt:GetProfile", id, (const struct _trt__GetProfile *)ptr, "");
	case SOAP_TYPE__trt__CreateProfileResponse:
		return soap_out__trt__CreateProfileResponse(soap, "trt:CreateProfileResponse", id, (const struct _trt__CreateProfileResponse *)ptr, "");
	case SOAP_TYPE__trt__CreateProfile:
		return soap_out__trt__CreateProfile(soap, "trt:CreateProfile", id, (const struct _trt__CreateProfile *)ptr, "");
	case SOAP_TYPE__trt__GetServiceCapabilitiesResponse:
		return soap_out__trt__GetServiceCapabilitiesResponse(soap, "trt:GetServiceCapabilitiesResponse", id, (const struct _trt__GetServiceCapabilitiesResponse *)ptr, "");
	case SOAP_TYPE__trt__GetServiceCapabilities:
		return soap_out__trt__GetServiceCapabilities(soap, "trt:GetServiceCapabilities", id, (const struct _trt__GetServiceCapabilities *)ptr, "");
	case SOAP_TYPE_trt__ProfileCapabilities:
		return soap_out_trt__ProfileCapabilities(soap, tag, id, (const struct trt__ProfileCapabilities *)ptr, "trt:ProfileCapabilities");
	case SOAP_TYPE_trt__Capabilities:
		return soap_out_trt__Capabilities(soap, tag, id, (const struct trt__Capabilities *)ptr, "trt:Capabilities");
	case SOAP_TYPE_wstop__QueryExpressionType:
		return soap_out_wstop__QueryExpressionType(soap, tag, id, (const struct wstop__QueryExpressionType *)ptr, "wstop:QueryExpressionType");
	case SOAP_TYPE_wstop__ExtensibleDocumented:
		return soap_out_wstop__ExtensibleDocumented(soap, tag, id, (const struct wstop__ExtensibleDocumented *)ptr, "wstop:ExtensibleDocumented");
	case SOAP_TYPE_wstop__Documentation:
		return soap_out_wstop__Documentation(soap, tag, id, (const struct wstop__Documentation *)ptr, "wstop:Documentation");
	case SOAP_TYPE__wsrfbf__BaseFaultType_FaultCause:
		return soap_out__wsrfbf__BaseFaultType_FaultCause(soap, "wsrfbf:BaseFaultType-FaultCause", id, (const struct _wsrfbf__BaseFaultType_FaultCause *)ptr, "");
	case SOAP_TYPE__wsrfbf__BaseFaultType_Description:
		return soap_out__wsrfbf__BaseFaultType_Description(soap, "wsrfbf:BaseFaultType-Description", id, (const struct _wsrfbf__BaseFaultType_Description *)ptr, "");
	case SOAP_TYPE__wsrfbf__BaseFaultType_ErrorCode:
		return soap_out__wsrfbf__BaseFaultType_ErrorCode(soap, "wsrfbf:BaseFaultType-ErrorCode", id, (const struct _wsrfbf__BaseFaultType_ErrorCode *)ptr, "");
	case SOAP_TYPE_wsrfbf__BaseFaultType:
		return soap_out_wsrfbf__BaseFaultType(soap, tag, id, (const struct wsrfbf__BaseFaultType *)ptr, "wsrfbf:BaseFaultType");
	case SOAP_TYPE__wsnt__ResumeSubscriptionResponse:
		return soap_out__wsnt__ResumeSubscriptionResponse(soap, "wsnt:ResumeSubscriptionResponse", id, (const struct _wsnt__ResumeSubscriptionResponse *)ptr, "");
	case SOAP_TYPE__wsnt__ResumeSubscription:
		return soap_out__wsnt__ResumeSubscription(soap, "wsnt:ResumeSubscription", id, (const struct _wsnt__ResumeSubscription *)ptr, "");
	case SOAP_TYPE__wsnt__PauseSubscriptionResponse:
		return soap_out__wsnt__PauseSubscriptionResponse(soap, "wsnt:PauseSubscriptionResponse", id, (const struct _wsnt__PauseSubscriptionResponse *)ptr, "");
	case SOAP_TYPE__wsnt__PauseSubscription:
		return soap_out__wsnt__PauseSubscription(soap, "wsnt:PauseSubscription", id, (const struct _wsnt__PauseSubscription *)ptr, "");
	case SOAP_TYPE__wsnt__UnsubscribeResponse:
		return soap_out__wsnt__UnsubscribeResponse(soap, "wsnt:UnsubscribeResponse", id, (const struct _wsnt__UnsubscribeResponse *)ptr, "");
	case SOAP_TYPE__wsnt__Unsubscribe:
		return soap_out__wsnt__Unsubscribe(soap, "wsnt:Unsubscribe", id, (const struct _wsnt__Unsubscribe *)ptr, "");
	case SOAP_TYPE__wsnt__RenewResponse:
		return soap_out__wsnt__RenewResponse(soap, "wsnt:RenewResponse", id, (const struct _wsnt__RenewResponse *)ptr, "");
	case SOAP_TYPE__wsnt__Renew:
		return soap_out__wsnt__Renew(soap, "wsnt:Renew", id, (const struct _wsnt__Renew *)ptr, "");
	case SOAP_TYPE__wsnt__CreatePullPointResponse:
		return soap_out__wsnt__CreatePullPointResponse(soap, "wsnt:CreatePullPointResponse", id, (const struct _wsnt__CreatePullPointResponse *)ptr, "");
	case SOAP_TYPE__wsnt__CreatePullPoint:
		return soap_out__wsnt__CreatePullPoint(soap, "wsnt:CreatePullPoint", id, (const struct _wsnt__CreatePullPoint *)ptr, "");
	case SOAP_TYPE__wsnt__DestroyPullPointResponse:
		return soap_out__wsnt__DestroyPullPointResponse(soap, "wsnt:DestroyPullPointResponse", id, (const struct _wsnt__DestroyPullPointResponse *)ptr, "");
	case SOAP_TYPE__wsnt__DestroyPullPoint:
		return soap_out__wsnt__DestroyPullPoint(soap, "wsnt:DestroyPullPoint", id, (const struct _wsnt__DestroyPullPoint *)ptr, "");
	case SOAP_TYPE__wsnt__GetMessagesResponse:
		return soap_out__wsnt__GetMessagesResponse(soap, "wsnt:GetMessagesResponse", id, (const struct _wsnt__GetMessagesResponse *)ptr, "");
	case SOAP_TYPE__wsnt__GetMessages:
		return soap_out__wsnt__GetMessages(soap, "wsnt:GetMessages", id, (const struct _wsnt__GetMessages *)ptr, "");
	case SOAP_TYPE__wsnt__GetCurrentMessageResponse:
		return soap_out__wsnt__GetCurrentMessageResponse(soap, "wsnt:GetCurrentMessageResponse", id, (const struct _wsnt__GetCurrentMessageResponse *)ptr, "");
	case SOAP_TYPE__wsnt__GetCurrentMessage:
		return soap_out__wsnt__GetCurrentMessage(soap, "wsnt:GetCurrentMessage", id, (const struct _wsnt__GetCurrentMessage *)ptr, "");
	case SOAP_TYPE__wsnt__SubscribeResponse:
		return soap_out__wsnt__SubscribeResponse(soap, "wsnt:SubscribeResponse", id, (const struct _wsnt__SubscribeResponse *)ptr, "");
	case SOAP_TYPE__wsnt__Subscribe_SubscriptionPolicy:
		return soap_out__wsnt__Subscribe_SubscriptionPolicy(soap, "wsnt:Subscribe-SubscriptionPolicy", id, (const struct _wsnt__Subscribe_SubscriptionPolicy *)ptr, "");
	case SOAP_TYPE__wsnt__Subscribe:
		return soap_out__wsnt__Subscribe(soap, "wsnt:Subscribe", id, (const struct _wsnt__Subscribe *)ptr, "");
	case SOAP_TYPE__wsnt__UseRaw:
		return soap_out__wsnt__UseRaw(soap, "wsnt:UseRaw", id, (const struct _wsnt__UseRaw *)ptr, "");
	case SOAP_TYPE__wsnt__Notify:
		return soap_out__wsnt__Notify(soap, "wsnt:Notify", id, (const struct _wsnt__Notify *)ptr, "");
	case SOAP_TYPE__wsnt__SubscriptionManagerRP:
		return soap_out__wsnt__SubscriptionManagerRP(soap, "wsnt:SubscriptionManagerRP", id, (const struct _wsnt__SubscriptionManagerRP *)ptr, "");
	case SOAP_TYPE_wstop__TopicSetType:
		return soap_out_wstop__TopicSetType(soap, tag, id, (const struct wstop__TopicSetType *)ptr, "wstop:TopicSetType");
	case SOAP_TYPE__wsnt__NotificationProducerRP:
		return soap_out__wsnt__NotificationProducerRP(soap, "wsnt:NotificationProducerRP", id, (const struct _wsnt__NotificationProducerRP *)ptr, "");
	case SOAP_TYPE__wsnt__NotificationMessageHolderType_Message:
		return soap_out__wsnt__NotificationMessageHolderType_Message(soap, "wsnt:NotificationMessageHolderType-Message", id, (const struct _wsnt__NotificationMessageHolderType_Message *)ptr, "");
	case SOAP_TYPE_wsnt__NotificationMessageHolderType:
		return soap_out_wsnt__NotificationMessageHolderType(soap, tag, id, (const struct wsnt__NotificationMessageHolderType *)ptr, "wsnt:NotificationMessageHolderType");
	case SOAP_TYPE_wsnt__SubscriptionPolicyType:
		return soap_out_wsnt__SubscriptionPolicyType(soap, tag, id, (const struct wsnt__SubscriptionPolicyType *)ptr, "wsnt:SubscriptionPolicyType");
	case SOAP_TYPE_wsnt__FilterType:
		return soap_out_wsnt__FilterType(soap, tag, id, (const struct wsnt__FilterType *)ptr, "wsnt:FilterType");
	case SOAP_TYPE_wsnt__TopicExpressionType:
		return soap_out_wsnt__TopicExpressionType(soap, tag, id, (const struct wsnt__TopicExpressionType *)ptr, "wsnt:TopicExpressionType");
	case SOAP_TYPE_wsnt__QueryExpressionType:
		return soap_out_wsnt__QueryExpressionType(soap, tag, id, (const struct wsnt__QueryExpressionType *)ptr, "wsnt:QueryExpressionType");
	case SOAP_TYPE__tt__Message:
		return soap_out__tt__Message(soap, "tt:Message", id, (const struct _tt__Message *)ptr, "");
	case SOAP_TYPE_tt__MediaUri:
		return soap_out_tt__MediaUri(soap, tag, id, (const struct tt__MediaUri *)ptr, "tt:MediaUri");
	case SOAP_TYPE_tt__MulticastConfiguration:
		return soap_out_tt__MulticastConfiguration(soap, tag, id, (const struct tt__MulticastConfiguration *)ptr, "tt:MulticastConfiguration");
	case SOAP_TYPE_tt__IPAddress:
		return soap_out_tt__IPAddress(soap, tag, id, (const struct tt__IPAddress *)ptr, "tt:IPAddress");
	case SOAP_TYPE_tt__VideoEncoderOptionsExtension2:
		return soap_out_tt__VideoEncoderOptionsExtension2(soap, tag, id, (const struct tt__VideoEncoderOptionsExtension2 *)ptr, "tt:VideoEncoderOptionsExtension2");
	case SOAP_TYPE_tt__H264Options2:
		return soap_out_tt__H264Options2(soap, tag, id, (const struct tt__H264Options2 *)ptr, "tt:H264Options2");
	case SOAP_TYPE_tt__Mpeg4Options2:
		return soap_out_tt__Mpeg4Options2(soap, tag, id, (const struct tt__Mpeg4Options2 *)ptr, "tt:Mpeg4Options2");
	case SOAP_TYPE_tt__JpegOptions2:
		return soap_out_tt__JpegOptions2(soap, tag, id, (const struct tt__JpegOptions2 *)ptr, "tt:JpegOptions2");
	case SOAP_TYPE_tt__VideoEncoderOptionsExtension:
		return soap_out_tt__VideoEncoderOptionsExtension(soap, tag, id, (const struct tt__VideoEncoderOptionsExtension *)ptr, "tt:VideoEncoderOptionsExtension");
	case SOAP_TYPE_tt__H264Options:
		return soap_out_tt__H264Options(soap, tag, id, (const struct tt__H264Options *)ptr, "tt:H264Options");
	case SOAP_TYPE_tt__Mpeg4Options:
		return soap_out_tt__Mpeg4Options(soap, tag, id, (const struct tt__Mpeg4Options *)ptr, "tt:Mpeg4Options");
	case SOAP_TYPE_tt__JpegOptions:
		return soap_out_tt__JpegOptions(soap, tag, id, (const struct tt__JpegOptions *)ptr, "tt:JpegOptions");
	case SOAP_TYPE_tt__VideoEncoderConfigurationOptions:
		return soap_out_tt__VideoEncoderConfigurationOptions(soap, tag, id, (const struct tt__VideoEncoderConfigurationOptions *)ptr, "tt:VideoEncoderConfigurationOptions");
	case SOAP_TYPE_tt__H264Configuration:
		return soap_out_tt__H264Configuration(soap, tag, id, (const struct tt__H264Configuration *)ptr, "tt:H264Configuration");
	case SOAP_TYPE_tt__Mpeg4Configuration:
		return soap_out_tt__Mpeg4Configuration(soap, tag, id, (const struct tt__Mpeg4Configuration *)ptr, "tt:Mpeg4Configuration");
	case SOAP_TYPE_tt__VideoRateControl:
		return soap_out_tt__VideoRateControl(soap, tag, id, (const struct tt__VideoRateControl *)ptr, "tt:VideoRateControl");
	case SOAP_TYPE_tt__VideoResolution:
		return soap_out_tt__VideoResolution(soap, tag, id, (const struct tt__VideoResolution *)ptr, "tt:VideoResolution");
	case SOAP_TYPE_tt__ItemListDescriptionExtension:
		return soap_out_tt__ItemListDescriptionExtension(soap, tag, id, (const struct tt__ItemListDescriptionExtension *)ptr, "tt:ItemListDescriptionExtension");
	case SOAP_TYPE__tt__ItemListDescription_ElementItemDescription:
		return soap_out__tt__ItemListDescription_ElementItemDescription(soap, "tt:ItemListDescription-ElementItemDescription", id, (const struct _tt__ItemListDescription_ElementItemDescription *)ptr, "");
	case SOAP_TYPE__tt__ItemListDescription_SimpleItemDescription:
		return soap_out__tt__ItemListDescription_SimpleItemDescription(soap, "tt:ItemListDescription-SimpleItemDescription", id, (const struct _tt__ItemListDescription_SimpleItemDescription *)ptr, "");
	case SOAP_TYPE_tt__MessageDescriptionExtension:
		return soap_out_tt__MessageDescriptionExtension(soap, tag, id, (const struct tt__MessageDescriptionExtension *)ptr, "tt:MessageDescriptionExtension");
	case SOAP_TYPE_tt__ItemListDescription:
		return soap_out_tt__ItemListDescription(soap, tag, id, (const struct tt__ItemListDescription *)ptr, "tt:ItemListDescription");
	case SOAP_TYPE_tt__MessageDescription:
		return soap_out_tt__MessageDescription(soap, tag, id, (const struct tt__MessageDescription *)ptr, "tt:MessageDescription");
	case SOAP_TYPE_tt__ItemListExtension:
		return soap_out_tt__ItemListExtension(soap, tag, id, (const struct tt__ItemListExtension *)ptr, "tt:ItemListExtension");
	case SOAP_TYPE__tt__ItemList_ElementItem:
		return soap_out__tt__ItemList_ElementItem(soap, "tt:ItemList-ElementItem", id, (const struct _tt__ItemList_ElementItem *)ptr, "");
	case SOAP_TYPE__tt__ItemList_SimpleItem:
		return soap_out__tt__ItemList_SimpleItem(soap, "tt:ItemList-SimpleItem", id, (const struct _tt__ItemList_SimpleItem *)ptr, "");
	case SOAP_TYPE_tt__ItemList:
		return soap_out_tt__ItemList(soap, tag, id, (const struct tt__ItemList *)ptr, "tt:ItemList");
	case SOAP_TYPE_tt__MessageExtension:
		return soap_out_tt__MessageExtension(soap, tag, id, (const struct tt__MessageExtension *)ptr, "tt:MessageExtension");
	case SOAP_TYPE_tt__PTZMoveStatus:
		return soap_out_tt__PTZMoveStatus(soap, tag, id, (const struct tt__PTZMoveStatus *)ptr, "tt:PTZMoveStatus");
	case SOAP_TYPE_tt__PTZPreset:
		return soap_out_tt__PTZPreset(soap, tag, id, (const struct tt__PTZPreset *)ptr, "tt:PTZPreset");
	case SOAP_TYPE_tt__PTZSpeed:
		return soap_out_tt__PTZSpeed(soap, tag, id, (const struct tt__PTZSpeed *)ptr, "tt:PTZSpeed");
	case SOAP_TYPE_tt__PTZVector:
		return soap_out_tt__PTZVector(soap, tag, id, (const struct tt__PTZVector *)ptr, "tt:PTZVector");
	case SOAP_TYPE_tt__Vector1D:
		return soap_out_tt__Vector1D(soap, tag, id, (const struct tt__Vector1D *)ptr, "tt:Vector1D");
	case SOAP_TYPE_tt__Vector2D:
		return soap_out_tt__Vector2D(soap, tag, id, (const struct tt__Vector2D *)ptr, "tt:Vector2D");
	case SOAP_TYPE_tt__PTZSpaces:
		return soap_out_tt__PTZSpaces(soap, tag, id, (const struct tt__PTZSpaces *)ptr, "tt:PTZSpaces");
	case SOAP_TYPE_tt__Space1DDescription:
		return soap_out_tt__Space1DDescription(soap, tag, id, (const struct tt__Space1DDescription *)ptr, "tt:Space1DDescription");
	case SOAP_TYPE_tt__ZoomLimits:
		return soap_out_tt__ZoomLimits(soap, tag, id, (const struct tt__ZoomLimits *)ptr, "tt:ZoomLimits");
	case SOAP_TYPE_tt__Space2DDescription:
		return soap_out_tt__Space2DDescription(soap, tag, id, (const struct tt__Space2DDescription *)ptr, "tt:Space2DDescription");
	case SOAP_TYPE_tt__PanTiltLimits:
		return soap_out_tt__PanTiltLimits(soap, tag, id, (const struct tt__PanTiltLimits *)ptr, "tt:PanTiltLimits");
	case SOAP_TYPE_tt__ProfileCapabilities:
		return soap_out_tt__ProfileCapabilities(soap, tag, id, (const struct tt__ProfileCapabilities *)ptr, "tt:ProfileCapabilities");
	case SOAP_TYPE_tt__MediaCapabilitiesExtension:
		return soap_out_tt__MediaCapabilitiesExtension(soap, tag, id, (const struct tt__MediaCapabilitiesExtension *)ptr, "tt:MediaCapabilitiesExtension");
	case SOAP_TYPE_tt__RealTimeStreamingCapabilities:
		return soap_out_tt__RealTimeStreamingCapabilities(soap, tag, id, (const struct tt__RealTimeStreamingCapabilities *)ptr, "tt:RealTimeStreamingCapabilities");
	case SOAP_TYPE_tt__SystemCapabilities:
		return soap_out_tt__SystemCapabilities(soap, tag, id, (const struct tt__SystemCapabilities *)ptr, "tt:SystemCapabilities");
	case SOAP_TYPE_tt__PTZCapabilities:
		return soap_out_tt__PTZCapabilities(soap, tag, id, (const struct tt__PTZCapabilities *)ptr, "tt:PTZCapabilities");
	case SOAP_TYPE_tt__MediaCapabilities:
		return soap_out_tt__MediaCapabilities(soap, tag, id, (const struct tt__MediaCapabilities *)ptr, "tt:MediaCapabilities");
	case SOAP_TYPE_tt__EventCapabilities:
		return soap_out_tt__EventCapabilities(soap, tag, id, (const struct tt__EventCapabilities *)ptr, "tt:EventCapabilities");
	case SOAP_TYPE_tt__DeviceCapabilities:
		return soap_out_tt__DeviceCapabilities(soap, tag, id, (const struct tt__DeviceCapabilities *)ptr, "tt:DeviceCapabilities");
	case SOAP_TYPE_tt__ConfigurationEntity:
		return soap_out_tt__ConfigurationEntity(soap, tag, id, (const struct tt__ConfigurationEntity *)ptr, "tt:ConfigurationEntity");
	case SOAP_TYPE_tt__VideoEncoderConfiguration:
		return soap_out_tt__VideoEncoderConfiguration(soap, tag, id, (const struct tt__VideoEncoderConfiguration *)ptr, "tt:VideoEncoderConfiguration");
	case SOAP_TYPE_tt__Profile:
		return soap_out_tt__Profile(soap, tag, id, (const struct tt__Profile *)ptr, "tt:Profile");
	case SOAP_TYPE_tt__AnyHolder:
		return soap_out_tt__AnyHolder(soap, tag, id, (const struct tt__AnyHolder *)ptr, "tt:AnyHolder");
	case SOAP_TYPE_tt__FloatList:
		return soap_out_tt__FloatList(soap, tag, id, (const struct tt__FloatList *)ptr, "tt:FloatList");
	case SOAP_TYPE_tt__IntList:
		return soap_out_tt__IntList(soap, tag, id, (const struct tt__IntList *)ptr, "tt:IntList");
	case SOAP_TYPE_tt__DurationRange:
		return soap_out_tt__DurationRange(soap, tag, id, (const struct tt__DurationRange *)ptr, "tt:DurationRange");
	case SOAP_TYPE_tt__FloatRange:
		return soap_out_tt__FloatRange(soap, tag, id, (const struct tt__FloatRange *)ptr, "tt:FloatRange");
	case SOAP_TYPE_tt__IntRange:
		return soap_out_tt__IntRange(soap, tag, id, (const struct tt__IntRange *)ptr, "tt:IntRange");
	case SOAP_TYPE_tt__IntRectangleRange:
		return soap_out_tt__IntRectangleRange(soap, tag, id, (const struct tt__IntRectangleRange *)ptr, "tt:IntRectangleRange");
	case SOAP_TYPE_tt__IntRectangle:
		return soap_out_tt__IntRectangle(soap, tag, id, (const struct tt__IntRectangle *)ptr, "tt:IntRectangle");
	case SOAP_TYPE_tt__DeviceEntity:
		return soap_out_tt__DeviceEntity(soap, tag, id, (const struct tt__DeviceEntity *)ptr, "tt:DeviceEntity");
	case SOAP_TYPE_tt__Capabilities:
		return soap_out_tt__Capabilities(soap, tag, id, (const struct tt__Capabilities *)ptr, "tt:Capabilities");
	case SOAP_TYPE__tds__GetCapabilitiesResponse:
		return soap_out__tds__GetCapabilitiesResponse(soap, "tds:GetCapabilitiesResponse", id, (const struct _tds__GetCapabilitiesResponse *)ptr, "");
	case SOAP_TYPE__tds__GetCapabilities:
		return soap_out__tds__GetCapabilities(soap, "tds:GetCapabilities", id, (const struct _tds__GetCapabilities *)ptr, "");
	case SOAP_TYPE__tds__SystemRebootResponse:
		return soap_out__tds__SystemRebootResponse(soap, "tds:SystemRebootResponse", id, (const struct _tds__SystemRebootResponse *)ptr, "");
	case SOAP_TYPE__tds__SystemReboot:
		return soap_out__tds__SystemReboot(soap, "tds:SystemReboot", id, (const struct _tds__SystemReboot *)ptr, "");
	case SOAP_TYPE__tds__GetDeviceInformationResponse:
		return soap_out__tds__GetDeviceInformationResponse(soap, "tds:GetDeviceInformationResponse", id, (const struct _tds__GetDeviceInformationResponse *)ptr, "");
	case SOAP_TYPE__tds__GetDeviceInformation:
		return soap_out__tds__GetDeviceInformation(soap, "tds:GetDeviceInformation", id, (const struct _tds__GetDeviceInformation *)ptr, "");
	case SOAP_TYPE__tds__GetServiceCapabilitiesResponse:
		return soap_out__tds__GetServiceCapabilitiesResponse(soap, "tds:GetServiceCapabilitiesResponse", id, (const struct _tds__GetServiceCapabilitiesResponse *)ptr, "");
	case SOAP_TYPE__tds__GetServiceCapabilities:
		return soap_out__tds__GetServiceCapabilities(soap, "tds:GetServiceCapabilities", id, (const struct _tds__GetServiceCapabilities *)ptr, "");
	case SOAP_TYPE__tds__GetServicesResponse:
		return soap_out__tds__GetServicesResponse(soap, "tds:GetServicesResponse", id, (const struct _tds__GetServicesResponse *)ptr, "");
	case SOAP_TYPE__tds__GetServices:
		return soap_out__tds__GetServices(soap, "tds:GetServices", id, (const struct _tds__GetServices *)ptr, "");
	case SOAP_TYPE_tds__DeviceServiceCapabilities:
		return soap_out_tds__DeviceServiceCapabilities(soap, tag, id, (const struct tds__DeviceServiceCapabilities *)ptr, "tds:DeviceServiceCapabilities");
	case SOAP_TYPE_tt__OnvifVersion:
		return soap_out_tt__OnvifVersion(soap, tag, id, (const struct tt__OnvifVersion *)ptr, "tt:OnvifVersion");
	case SOAP_TYPE__tds__Service_Capabilities:
		return soap_out__tds__Service_Capabilities(soap, "tds:Service-Capabilities", id, (const struct _tds__Service_Capabilities *)ptr, "");
	case SOAP_TYPE_tds__Service:
		return soap_out_tds__Service(soap, tag, id, (const struct tds__Service *)ptr, "tds:Service");
	case SOAP_TYPE__wsse__Security:
		return soap_out__wsse__Security(soap, "wsse:Security", id, (const struct _wsse__Security *)ptr, "");
	case SOAP_TYPE__saml2__EncryptedAttribute:
		return soap_out__saml2__EncryptedAttribute(soap, "saml2:EncryptedAttribute", id, (const struct saml2__EncryptedElementType *)ptr, "");
	case SOAP_TYPE__saml2__Attribute:
		return soap_out__saml2__Attribute(soap, "saml2:Attribute", id, (const struct saml2__AttributeType *)ptr, "");
	case SOAP_TYPE__saml2__AttributeStatement:
		return soap_out__saml2__AttributeStatement(soap, "saml2:AttributeStatement", id, (const struct saml2__AttributeStatementType *)ptr, "");
	case SOAP_TYPE__saml2__Evidence:
		return soap_out__saml2__Evidence(soap, "saml2:Evidence", id, (const struct saml2__EvidenceType *)ptr, "");
	case SOAP_TYPE__saml2__Action:
		return soap_out__saml2__Action(soap, "saml2:Action", id, (const struct saml2__ActionType *)ptr, "");
	case SOAP_TYPE__saml2__AuthzDecisionStatement:
		return soap_out__saml2__AuthzDecisionStatement(soap, "saml2:AuthzDecisionStatement", id, (const struct saml2__AuthzDecisionStatementType *)ptr, "");
	case SOAP_TYPE__saml2__AuthnContext:
		return soap_out__saml2__AuthnContext(soap, "saml2:AuthnContext", id, (const struct saml2__AuthnContextType *)ptr, "");
	case SOAP_TYPE__saml2__SubjectLocality:
		return soap_out__saml2__SubjectLocality(soap, "saml2:SubjectLocality", id, (const struct saml2__SubjectLocalityType *)ptr, "");
	case SOAP_TYPE__saml2__AuthnStatement:
		return soap_out__saml2__AuthnStatement(soap, "saml2:AuthnStatement", id, (const struct saml2__AuthnStatementType *)ptr, "");
	case SOAP_TYPE__saml2__Statement:
		return soap_out__saml2__Statement(soap, "saml2:Statement", id, (const struct saml2__StatementAbstractType *)ptr, "");
	case SOAP_TYPE__saml2__EncryptedAssertion:
		return soap_out__saml2__EncryptedAssertion(soap, "saml2:EncryptedAssertion", id, (const struct saml2__EncryptedElementType *)ptr, "");
	case SOAP_TYPE__saml2__Advice:
		return soap_out__saml2__Advice(soap, "saml2:Advice", id, (const struct saml2__AdviceType *)ptr, "");
	case SOAP_TYPE__saml2__ProxyRestriction:
		return soap_out__saml2__ProxyRestriction(soap, "saml2:ProxyRestriction", id, (const struct saml2__ProxyRestrictionType *)ptr, "");
	case SOAP_TYPE__saml2__OneTimeUse:
		return soap_out__saml2__OneTimeUse(soap, "saml2:OneTimeUse", id, (const struct saml2__OneTimeUseType *)ptr, "");
	case SOAP_TYPE__saml2__AudienceRestriction:
		return soap_out__saml2__AudienceRestriction(soap, "saml2:AudienceRestriction", id, (const struct saml2__AudienceRestrictionType *)ptr, "");
	case SOAP_TYPE__saml2__Condition:
		return soap_out__saml2__Condition(soap, "saml2:Condition", id, (const struct saml2__ConditionAbstractType *)ptr, "");
	case SOAP_TYPE__saml2__Conditions:
		return soap_out__saml2__Conditions(soap, "saml2:Conditions", id, (const struct saml2__ConditionsType *)ptr, "");
	case SOAP_TYPE__saml2__SubjectConfirmationData:
		return soap_out__saml2__SubjectConfirmationData(soap, "saml2:SubjectConfirmationData", id, (const struct saml2__SubjectConfirmationDataType *)ptr, "");
	case SOAP_TYPE__saml2__SubjectConfirmation:
		return soap_out__saml2__SubjectConfirmation(soap, "saml2:SubjectConfirmation", id, (const struct saml2__SubjectConfirmationType *)ptr, "");
	case SOAP_TYPE__saml2__Subject:
		return soap_out__saml2__Subject(soap, "saml2:Subject", id, (const struct saml2__SubjectType *)ptr, "");
	case SOAP_TYPE__saml2__Assertion:
		return soap_out__saml2__Assertion(soap, "saml2:Assertion", id, (const struct saml2__AssertionType *)ptr, "");
	case SOAP_TYPE__saml2__Issuer:
		return soap_out__saml2__Issuer(soap, "saml2:Issuer", id, (const struct saml2__NameIDType *)ptr, "");
	case SOAP_TYPE__saml2__EncryptedID:
		return soap_out__saml2__EncryptedID(soap, "saml2:EncryptedID", id, (const struct saml2__EncryptedElementType *)ptr, "");
	case SOAP_TYPE__saml2__NameID:
		return soap_out__saml2__NameID(soap, "saml2:NameID", id, (const struct saml2__NameIDType *)ptr, "");
	case SOAP_TYPE__saml2__BaseID:
		return soap_out__saml2__BaseID(soap, "saml2:BaseID", id, (const struct saml2__BaseIDAbstractType *)ptr, "");
	case SOAP_TYPE_saml2__AttributeType:
		return soap_out_saml2__AttributeType(soap, tag, id, (const struct saml2__AttributeType *)ptr, "saml2:AttributeType");
	case SOAP_TYPE_saml2__AttributeStatementType:
		return soap_out_saml2__AttributeStatementType(soap, tag, id, (const struct saml2__AttributeStatementType *)ptr, "saml2:AttributeStatementType");
	case SOAP_TYPE_saml2__EvidenceType:
		return soap_out_saml2__EvidenceType(soap, tag, id, (const struct saml2__EvidenceType *)ptr, "saml2:EvidenceType");
	case SOAP_TYPE_saml2__ActionType:
		return soap_out_saml2__ActionType(soap, tag, id, (const struct saml2__ActionType *)ptr, "saml2:ActionType");
	case SOAP_TYPE_saml2__AuthzDecisionStatementType:
		return soap_out_saml2__AuthzDecisionStatementType(soap, tag, id, (const struct saml2__AuthzDecisionStatementType *)ptr, "saml2:AuthzDecisionStatementType");
	case SOAP_TYPE_saml2__AuthnContextType:
		return soap_out_saml2__AuthnContextType(soap, tag, id, (const struct saml2__AuthnContextType *)ptr, "saml2:AuthnContextType");
	case SOAP_TYPE_saml2__SubjectLocalityType:
		return soap_out_saml2__SubjectLocalityType(soap, tag, id, (const struct saml2__SubjectLocalityType *)ptr, "saml2:SubjectLocalityType");
	case SOAP_TYPE_saml2__AuthnStatementType:
		return soap_out_saml2__AuthnStatementType(soap, tag, id, (const struct saml2__AuthnStatementType *)ptr, "saml2:AuthnStatementType");
	case SOAP_TYPE_saml2__StatementAbstractType:
		return soap_out_saml2__StatementAbstractType(soap, tag, id, (const struct saml2__StatementAbstractType *)ptr, "saml2:StatementAbstractType");
	case SOAP_TYPE_saml2__AdviceType:
		return soap_out_saml2__AdviceType(soap, tag, id, (const struct saml2__AdviceType *)ptr, "saml2:AdviceType");
	case SOAP_TYPE_saml2__ProxyRestrictionType:
		return soap_out_saml2__ProxyRestrictionType(soap, tag, id, (const struct saml2__ProxyRestrictionType *)ptr, "saml2:ProxyRestrictionType");
	case SOAP_TYPE_saml2__OneTimeUseType:
		return soap_out_saml2__OneTimeUseType(soap, tag, id, (const struct saml2__OneTimeUseType *)ptr, "saml2:OneTimeUseType");
	case SOAP_TYPE_saml2__AudienceRestrictionType:
		return soap_out_saml2__AudienceRestrictionType(soap, tag, id, (const struct saml2__AudienceRestrictionType *)ptr, "saml2:AudienceRestrictionType");
	case SOAP_TYPE_saml2__ConditionAbstractType:
		return soap_out_saml2__ConditionAbstractType(soap, tag, id, (const struct saml2__ConditionAbstractType *)ptr, "saml2:ConditionAbstractType");
	case SOAP_TYPE_saml2__ConditionsType:
		return soap_out_saml2__ConditionsType(soap, tag, id, (const struct saml2__ConditionsType *)ptr, "saml2:ConditionsType");
	case SOAP_TYPE_saml2__KeyInfoConfirmationDataType:
		return soap_out_saml2__KeyInfoConfirmationDataType(soap, tag, id, (const struct saml2__KeyInfoConfirmationDataType *)ptr, "saml2:KeyInfoConfirmationDataType");
	case SOAP_TYPE_saml2__SubjectConfirmationDataType:
		return soap_out_saml2__SubjectConfirmationDataType(soap, tag, id, (const struct saml2__SubjectConfirmationDataType *)ptr, "saml2:SubjectConfirmationDataType");
	case SOAP_TYPE_saml2__SubjectConfirmationType:
		return soap_out_saml2__SubjectConfirmationType(soap, tag, id, (const struct saml2__SubjectConfirmationType *)ptr, "saml2:SubjectConfirmationType");
	case SOAP_TYPE_saml2__SubjectType:
		return soap_out_saml2__SubjectType(soap, tag, id, (const struct saml2__SubjectType *)ptr, "saml2:SubjectType");
	case SOAP_TYPE_saml2__AssertionType:
		return soap_out_saml2__AssertionType(soap, tag, id, (const struct saml2__AssertionType *)ptr, "saml2:AssertionType");
	case SOAP_TYPE_saml2__EncryptedElementType:
		return soap_out_saml2__EncryptedElementType(soap, tag, id, (const struct saml2__EncryptedElementType *)ptr, "saml2:EncryptedElementType");
	case SOAP_TYPE_saml2__NameIDType:
		return soap_out_saml2__NameIDType(soap, tag, id, (const struct saml2__NameIDType *)ptr, "saml2:NameIDType");
	case SOAP_TYPE_saml2__BaseIDAbstractType:
		return soap_out_saml2__BaseIDAbstractType(soap, tag, id, (const struct saml2__BaseIDAbstractType *)ptr, "saml2:BaseIDAbstractType");
	case SOAP_TYPE__saml1__Attribute:
		return soap_out__saml1__Attribute(soap, "saml1:Attribute", id, (const struct saml1__AttributeType *)ptr, "");
	case SOAP_TYPE__saml1__AttributeDesignator:
		return soap_out__saml1__AttributeDesignator(soap, "saml1:AttributeDesignator", id, (const struct saml1__AttributeDesignatorType *)ptr, "");
	case SOAP_TYPE__saml1__AttributeStatement:
		return soap_out__saml1__AttributeStatement(soap, "saml1:AttributeStatement", id, (const struct saml1__AttributeStatementType *)ptr, "");
	case SOAP_TYPE__saml1__Evidence:
		return soap_out__saml1__Evidence(soap, "saml1:Evidence", id, (const struct saml1__EvidenceType *)ptr, "");
	case SOAP_TYPE__saml1__Action:
		return soap_out__saml1__Action(soap, "saml1:Action", id, (const struct saml1__ActionType *)ptr, "");
	case SOAP_TYPE__saml1__AuthorizationDecisionStatement:
		return soap_out__saml1__AuthorizationDecisionStatement(soap, "saml1:AuthorizationDecisionStatement", id, (const struct saml1__AuthorizationDecisionStatementType *)ptr, "");
	case SOAP_TYPE__saml1__AuthorityBinding:
		return soap_out__saml1__AuthorityBinding(soap, "saml1:AuthorityBinding", id, (const struct saml1__AuthorityBindingType *)ptr, "");
	case SOAP_TYPE__saml1__SubjectLocality:
		return soap_out__saml1__SubjectLocality(soap, "saml1:SubjectLocality", id, (const struct saml1__SubjectLocalityType *)ptr, "");
	case SOAP_TYPE__saml1__AuthenticationStatement:
		return soap_out__saml1__AuthenticationStatement(soap, "saml1:AuthenticationStatement", id, (const struct saml1__AuthenticationStatementType *)ptr, "");
	case SOAP_TYPE__saml1__SubjectConfirmation:
		return soap_out__saml1__SubjectConfirmation(soap, "saml1:SubjectConfirmation", id, (const struct saml1__SubjectConfirmationType *)ptr, "");
	case SOAP_TYPE__saml1__NameIdentifier:
		return soap_out__saml1__NameIdentifier(soap, "saml1:NameIdentifier", id, (const struct saml1__NameIdentifierType *)ptr, "");
	case SOAP_TYPE__saml1__Subject:
		return soap_out__saml1__Subject(soap, "saml1:Subject", id, (const struct saml1__SubjectType *)ptr, "");
	case SOAP_TYPE__saml1__SubjectStatement:
		return soap_out__saml1__SubjectStatement(soap, "saml1:SubjectStatement", id, (const struct saml1__SubjectStatementAbstractType *)ptr, "");
	case SOAP_TYPE__saml1__Statement:
		return soap_out__saml1__Statement(soap, "saml1:Statement", id, (const struct saml1__StatementAbstractType *)ptr, "");
	case SOAP_TYPE__saml1__Advice:
		return soap_out__saml1__Advice(soap, "saml1:Advice", id, (const struct saml1__AdviceType *)ptr, "");
	case SOAP_TYPE__saml1__DoNotCacheCondition:
		return soap_out__saml1__DoNotCacheCondition(soap, "saml1:DoNotCacheCondition", id, (const struct saml1__DoNotCacheConditionType *)ptr, "");
	case SOAP_TYPE__saml1__AudienceRestrictionCondition:
		return soap_out__saml1__AudienceRestrictionCondition(soap, "saml1:AudienceRestrictionCondition", id, (const struct saml1__AudienceRestrictionConditionType *)ptr, "");
	case SOAP_TYPE__saml1__Condition:
		return soap_out__saml1__Condition(soap, "saml1:Condition", id, (const struct saml1__ConditionAbstractType *)ptr, "");
	case SOAP_TYPE__saml1__Conditions:
		return soap_out__saml1__Conditions(soap, "saml1:Conditions", id, (const struct saml1__ConditionsType *)ptr, "");
	case SOAP_TYPE__saml1__Assertion:
		return soap_out__saml1__Assertion(soap, "saml1:Assertion", id, (const struct saml1__AssertionType *)ptr, "");
	case SOAP_TYPE_saml1__AttributeType:
		return soap_out_saml1__AttributeType(soap, tag, id, (const struct saml1__AttributeType *)ptr, "saml1:AttributeType");
	case SOAP_TYPE_saml1__AttributeDesignatorType:
		return soap_out_saml1__AttributeDesignatorType(soap, tag, id, (const struct saml1__AttributeDesignatorType *)ptr, "saml1:AttributeDesignatorType");
	case SOAP_TYPE_saml1__AttributeStatementType:
		return soap_out_saml1__AttributeStatementType(soap, tag, id, (const struct saml1__AttributeStatementType *)ptr, "saml1:AttributeStatementType");
	case SOAP_TYPE_saml1__EvidenceType:
		return soap_out_saml1__EvidenceType(soap, tag, id, (const struct saml1__EvidenceType *)ptr, "saml1:EvidenceType");
	case SOAP_TYPE_saml1__ActionType:
		return soap_out_saml1__ActionType(soap, tag, id, (const struct saml1__ActionType *)ptr, "saml1:ActionType");
	case SOAP_TYPE_saml1__AuthorizationDecisionStatementType:
		return soap_out_saml1__AuthorizationDecisionStatementType(soap, tag, id, (const struct saml1__AuthorizationDecisionStatementType *)ptr, "saml1:AuthorizationDecisionStatementType");
	case SOAP_TYPE_saml1__AuthorityBindingType:
		return soap_out_saml1__AuthorityBindingType(soap, tag, id, (const struct saml1__AuthorityBindingType *)ptr, "saml1:AuthorityBindingType");
	case SOAP_TYPE_saml1__SubjectLocalityType:
		return soap_out_saml1__SubjectLocalityType(soap, tag, id, (const struct saml1__SubjectLocalityType *)ptr, "saml1:SubjectLocalityType");
	case SOAP_TYPE_saml1__AuthenticationStatementType:
		return soap_out_saml1__AuthenticationStatementType(soap, tag, id, (const struct saml1__AuthenticationStatementType *)ptr, "saml1:AuthenticationStatementType");
	case SOAP_TYPE_saml1__SubjectConfirmationType:
		return soap_out_saml1__SubjectConfirmationType(soap, tag, id, (const struct saml1__SubjectConfirmationType *)ptr, "saml1:SubjectConfirmationType");
	case SOAP_TYPE_saml1__NameIdentifierType:
		return soap_out_saml1__NameIdentifierType(soap, tag, id, (const struct saml1__NameIdentifierType *)ptr, "saml1:NameIdentifierType");
	case SOAP_TYPE_saml1__SubjectType:
		return soap_out_saml1__SubjectType(soap, tag, id, (const struct saml1__SubjectType *)ptr, "saml1:SubjectType");
	case SOAP_TYPE_saml1__SubjectStatementAbstractType:
		return soap_out_saml1__SubjectStatementAbstractType(soap, tag, id, (const struct saml1__SubjectStatementAbstractType *)ptr, "saml1:SubjectStatementAbstractType");
	case SOAP_TYPE_saml1__StatementAbstractType:
		return soap_out_saml1__StatementAbstractType(soap, tag, id, (const struct saml1__StatementAbstractType *)ptr, "saml1:StatementAbstractType");
	case SOAP_TYPE_saml1__AdviceType:
		return soap_out_saml1__AdviceType(soap, tag, id, (const struct saml1__AdviceType *)ptr, "saml1:AdviceType");
	case SOAP_TYPE_saml1__DoNotCacheConditionType:
		return soap_out_saml1__DoNotCacheConditionType(soap, tag, id, (const struct saml1__DoNotCacheConditionType *)ptr, "saml1:DoNotCacheConditionType");
	case SOAP_TYPE_saml1__AudienceRestrictionConditionType:
		return soap_out_saml1__AudienceRestrictionConditionType(soap, tag, id, (const struct saml1__AudienceRestrictionConditionType *)ptr, "saml1:AudienceRestrictionConditionType");
	case SOAP_TYPE_saml1__ConditionAbstractType:
		return soap_out_saml1__ConditionAbstractType(soap, tag, id, (const struct saml1__ConditionAbstractType *)ptr, "saml1:ConditionAbstractType");
	case SOAP_TYPE_saml1__ConditionsType:
		return soap_out_saml1__ConditionsType(soap, tag, id, (const struct saml1__ConditionsType *)ptr, "saml1:ConditionsType");
	case SOAP_TYPE_saml1__AssertionType:
		return soap_out_saml1__AssertionType(soap, tag, id, (const struct saml1__AssertionType *)ptr, "saml1:AssertionType");
	case SOAP_TYPE_xsd__dateTime:
		return soap_out_xsd__dateTime(soap, tag, id, (const struct timeval *)ptr, "xsd:dateTime");
	case SOAP_TYPE_wsc__PropertiesType:
		return soap_out_wsc__PropertiesType(soap, tag, id, (const struct wsc__PropertiesType *)ptr, "wsc:PropertiesType");
	case SOAP_TYPE_wsc__DerivedKeyTokenType:
		return soap_out_wsc__DerivedKeyTokenType(soap, tag, id, (const struct wsc__DerivedKeyTokenType *)ptr, "wsc:DerivedKeyTokenType");
	case SOAP_TYPE_wsc__SecurityContextTokenType:
		return soap_out_wsc__SecurityContextTokenType(soap, tag, id, (const struct wsc__SecurityContextTokenType *)ptr, "wsc:SecurityContextTokenType");
	case SOAP_TYPE__xenc__ReferenceList:
		return soap_out__xenc__ReferenceList(soap, "xenc:ReferenceList", id, (const struct _xenc__ReferenceList *)ptr, "");
	case SOAP_TYPE_xenc__EncryptionPropertyType:
		return soap_out_xenc__EncryptionPropertyType(soap, tag, id, (const struct xenc__EncryptionPropertyType *)ptr, "xenc:EncryptionPropertyType");
	case SOAP_TYPE_xenc__EncryptionPropertiesType:
		return soap_out_xenc__EncryptionPropertiesType(soap, tag, id, (const struct xenc__EncryptionPropertiesType *)ptr, "xenc:EncryptionPropertiesType");
	case SOAP_TYPE_xenc__ReferenceType:
		return soap_out_xenc__ReferenceType(soap, tag, id, (const struct xenc__ReferenceType *)ptr, "xenc:ReferenceType");
	case SOAP_TYPE_xenc__AgreementMethodType:
		return soap_out_xenc__AgreementMethodType(soap, tag, id, (const struct xenc__AgreementMethodType *)ptr, "xenc:AgreementMethodType");
	case SOAP_TYPE_xenc__EncryptedDataType:
		return soap_out_xenc__EncryptedDataType(soap, tag, id, (const struct xenc__EncryptedDataType *)ptr, "xenc:EncryptedDataType");
	case SOAP_TYPE_xenc__TransformsType:
		return soap_out_xenc__TransformsType(soap, tag, id, (const struct xenc__TransformsType *)ptr, "xenc:TransformsType");
	case SOAP_TYPE_xenc__CipherReferenceType:
		return soap_out_xenc__CipherReferenceType(soap, tag, id, (const struct xenc__CipherReferenceType *)ptr, "xenc:CipherReferenceType");
	case SOAP_TYPE_xenc__CipherDataType:
		return soap_out_xenc__CipherDataType(soap, tag, id, (const struct xenc__CipherDataType *)ptr, "xenc:CipherDataType");
	case SOAP_TYPE_xenc__EncryptionMethodType:
		return soap_out_xenc__EncryptionMethodType(soap, tag, id, (const struct xenc__EncryptionMethodType *)ptr, "xenc:EncryptionMethodType");
	case SOAP_TYPE_xenc__EncryptedType:
		return soap_out_xenc__EncryptedType(soap, tag, id, (const struct xenc__EncryptedType *)ptr, "xenc:EncryptedType");
	case SOAP_TYPE_ds__RSAKeyValueType:
		return soap_out_ds__RSAKeyValueType(soap, tag, id, (const struct ds__RSAKeyValueType *)ptr, "ds:RSAKeyValueType");
	case SOAP_TYPE_ds__DSAKeyValueType:
		return soap_out_ds__DSAKeyValueType(soap, tag, id, (const struct ds__DSAKeyValueType *)ptr, "ds:DSAKeyValueType");
	case SOAP_TYPE_ds__X509IssuerSerialType:
		return soap_out_ds__X509IssuerSerialType(soap, tag, id, (const struct ds__X509IssuerSerialType *)ptr, "ds:X509IssuerSerialType");
	case SOAP_TYPE__ds__KeyInfo:
		return soap_out__ds__KeyInfo(soap, "ds:KeyInfo", id, (const struct ds__KeyInfoType *)ptr, "");
	case SOAP_TYPE_ds__RetrievalMethodType:
		return soap_out_ds__RetrievalMethodType(soap, tag, id, (const struct ds__RetrievalMethodType *)ptr, "ds:RetrievalMethodType");
	case SOAP_TYPE_ds__KeyValueType:
		return soap_out_ds__KeyValueType(soap, tag, id, (const struct ds__KeyValueType *)ptr, "ds:KeyValueType");
	case SOAP_TYPE_ds__DigestMethodType:
		return soap_out_ds__DigestMethodType(soap, tag, id, (const struct ds__DigestMethodType *)ptr, "ds:DigestMethodType");
	case SOAP_TYPE__ds__Transform:
		return soap_out__ds__Transform(soap, "ds:Transform", id, (const struct ds__TransformType *)ptr, "");
	case SOAP_TYPE_ds__TransformType:
		return soap_out_ds__TransformType(soap, tag, id, (const struct ds__TransformType *)ptr, "ds:TransformType");
	case SOAP_TYPE__c14n__InclusiveNamespaces:
		return soap_out__c14n__InclusiveNamespaces(soap, "c14n:InclusiveNamespaces", id, (const struct _c14n__InclusiveNamespaces *)ptr, "");
	case SOAP_TYPE_ds__TransformsType:
		return soap_out_ds__TransformsType(soap, tag, id, (const struct ds__TransformsType *)ptr, "ds:TransformsType");
	case SOAP_TYPE_ds__ReferenceType:
		return soap_out_ds__ReferenceType(soap, tag, id, (const struct ds__ReferenceType *)ptr, "ds:ReferenceType");
	case SOAP_TYPE_ds__SignatureMethodType:
		return soap_out_ds__SignatureMethodType(soap, tag, id, (const struct ds__SignatureMethodType *)ptr, "ds:SignatureMethodType");
	case SOAP_TYPE_ds__CanonicalizationMethodType:
		return soap_out_ds__CanonicalizationMethodType(soap, tag, id, (const struct ds__CanonicalizationMethodType *)ptr, "ds:CanonicalizationMethodType");
	case SOAP_TYPE__ds__Signature:
		return soap_out__ds__Signature(soap, "ds:Signature", id, (const struct ds__SignatureType *)ptr, "");
	case SOAP_TYPE_ds__SignedInfoType:
		return soap_out_ds__SignedInfoType(soap, tag, id, (const struct ds__SignedInfoType *)ptr, "ds:SignedInfoType");
	case SOAP_TYPE_ds__SignatureType:
		return soap_out_ds__SignatureType(soap, tag, id, (const struct ds__SignatureType *)ptr, "ds:SignatureType");
	case SOAP_TYPE_xenc__EncryptedKeyType:
		return soap_out_xenc__EncryptedKeyType(soap, tag, id, (const struct xenc__EncryptedKeyType *)ptr, "xenc:EncryptedKeyType");
	case SOAP_TYPE_ds__KeyInfoType:
		return soap_out_ds__KeyInfoType(soap, tag, id, (const struct ds__KeyInfoType *)ptr, "ds:KeyInfoType");
	case SOAP_TYPE_ds__X509DataType:
		return soap_out_ds__X509DataType(soap, tag, id, (const struct ds__X509DataType *)ptr, "ds:X509DataType");
	case SOAP_TYPE__wsse__SecurityTokenReference:
		return soap_out__wsse__SecurityTokenReference(soap, "wsse:SecurityTokenReference", id, (const struct _wsse__SecurityTokenReference *)ptr, "");
	case SOAP_TYPE__wsse__KeyIdentifier:
		return soap_out__wsse__KeyIdentifier(soap, "wsse:KeyIdentifier", id, (const struct _wsse__KeyIdentifier *)ptr, "");
	case SOAP_TYPE__wsse__Embedded:
		return soap_out__wsse__Embedded(soap, "wsse:Embedded", id, (const struct _wsse__Embedded *)ptr, "");
	case SOAP_TYPE__wsse__Reference:
		return soap_out__wsse__Reference(soap, "wsse:Reference", id, (const struct _wsse__Reference *)ptr, "");
	case SOAP_TYPE__wsse__BinarySecurityToken:
		return soap_out__wsse__BinarySecurityToken(soap, "wsse:BinarySecurityToken", id, (const struct _wsse__BinarySecurityToken *)ptr, "");
	case SOAP_TYPE__wsse__Password:
		return soap_out__wsse__Password(soap, "wsse:Password", id, (const struct _wsse__Password *)ptr, "");
	case SOAP_TYPE__wsse__UsernameToken:
		return soap_out__wsse__UsernameToken(soap, "wsse:UsernameToken", id, (const struct _wsse__UsernameToken *)ptr, "");
	case SOAP_TYPE_wsse__EncodedString:
		return soap_out_wsse__EncodedString(soap, tag, id, (const struct wsse__EncodedString *)ptr, "wsse:EncodedString");
	case SOAP_TYPE__wsu__Timestamp:
		return soap_out__wsu__Timestamp(soap, "wsu:Timestamp", id, (const struct _wsu__Timestamp *)ptr, "");
	case SOAP_TYPE_SOAP_ENV__Fault_alex:
		return soap_out_SOAP_ENV__Fault_alex(soap, tag, id, (const struct SOAP_ENV__Fault_alex *)ptr, "SOAP-ENV:Fault-alex");
	case SOAP_TYPE_chan__ChannelInstanceType:
		return soap_out_chan__ChannelInstanceType(soap, tag, id, (const struct chan__ChannelInstanceType *)ptr, "chan:ChannelInstanceType");
	case SOAP_TYPE__wsa5__ProblemAction:
		return soap_out__wsa5__ProblemAction(soap, "wsa5:ProblemAction", id, (const struct wsa5__ProblemActionType *)ptr, "");
	case SOAP_TYPE__wsa5__FaultTo:
		return soap_out__wsa5__FaultTo(soap, "wsa5:FaultTo", id, (const struct wsa5__EndpointReferenceType *)ptr, "");
	case SOAP_TYPE__wsa5__From:
		return soap_out__wsa5__From(soap, "wsa5:From", id, (const struct wsa5__EndpointReferenceType *)ptr, "");
	case SOAP_TYPE__wsa5__ReplyTo:
		return soap_out__wsa5__ReplyTo(soap, "wsa5:ReplyTo", id, (const struct wsa5__EndpointReferenceType *)ptr, "");
	case SOAP_TYPE__wsa5__RelatesTo:
		return soap_out__wsa5__RelatesTo(soap, "wsa5:RelatesTo", id, (const struct wsa5__RelatesToType *)ptr, "");
	case SOAP_TYPE__wsa5__Metadata:
		return soap_out__wsa5__Metadata(soap, "wsa5:Metadata", id, (const struct wsa5__MetadataType *)ptr, "");
	case SOAP_TYPE__wsa5__ReferenceParameters:
		return soap_out__wsa5__ReferenceParameters(soap, "wsa5:ReferenceParameters", id, (const struct wsa5__ReferenceParametersType *)ptr, "");
	case SOAP_TYPE__wsa5__EndpointReference:
		return soap_out__wsa5__EndpointReference(soap, "wsa5:EndpointReference", id, (const struct wsa5__EndpointReferenceType *)ptr, "");
	case SOAP_TYPE_wsa5__ProblemActionType:
		return soap_out_wsa5__ProblemActionType(soap, tag, id, (const struct wsa5__ProblemActionType *)ptr, "wsa5:ProblemActionType");
	case SOAP_TYPE_wsa5__RelatesToType:
		return soap_out_wsa5__RelatesToType(soap, tag, id, (const struct wsa5__RelatesToType *)ptr, "wsa5:RelatesToType");
	case SOAP_TYPE_wsa5__MetadataType:
		return soap_out_wsa5__MetadataType(soap, tag, id, (const struct wsa5__MetadataType *)ptr, "wsa5:MetadataType");
	case SOAP_TYPE_wsa5__ReferenceParametersType:
		return soap_out_wsa5__ReferenceParametersType(soap, tag, id, (const struct wsa5__ReferenceParametersType *)ptr, "wsa5:ReferenceParametersType");
	case SOAP_TYPE_wsa5__EndpointReferenceType:
		return soap_out_wsa5__EndpointReferenceType(soap, tag, id, (const struct wsa5__EndpointReferenceType *)ptr, "wsa5:EndpointReferenceType");
	case SOAP_TYPE__wsdd__AppSequence:
		return soap_out__wsdd__AppSequence(soap, "wsdd:AppSequence", id, (const struct wsdd__AppSequenceType *)ptr, "");
	case SOAP_TYPE__wsdd__Sig:
		return soap_out__wsdd__Sig(soap, "wsdd:Sig", id, (const struct wsdd__SigType *)ptr, "");
	case SOAP_TYPE__wsdd__Security:
		return soap_out__wsdd__Security(soap, "wsdd:Security", id, (const struct wsdd__SecurityType *)ptr, "");
	case SOAP_TYPE__wsdd__Scopes:
		return soap_out__wsdd__Scopes(soap, "wsdd:Scopes", id, (const struct wsdd__ScopesType *)ptr, "");
	case SOAP_TYPE__wsdd__ResolveMatches:
		return soap_out__wsdd__ResolveMatches(soap, "wsdd:ResolveMatches", id, (const struct wsdd__ResolveMatchesType *)ptr, "");
	case SOAP_TYPE__wsdd__Resolve:
		return soap_out__wsdd__Resolve(soap, "wsdd:Resolve", id, (const struct wsdd__ResolveType *)ptr, "");
	case SOAP_TYPE__wsdd__ProbeMatches:
		return soap_out__wsdd__ProbeMatches(soap, "wsdd:ProbeMatches", id, (const struct wsdd__ProbeMatchesType *)ptr, "");
	case SOAP_TYPE__wsdd__Probe:
		return soap_out__wsdd__Probe(soap, "wsdd:Probe", id, (const struct wsdd__ProbeType *)ptr, "");
	case SOAP_TYPE__wsdd__Bye:
		return soap_out__wsdd__Bye(soap, "wsdd:Bye", id, (const struct wsdd__ByeType *)ptr, "");
	case SOAP_TYPE__wsdd__Hello:
		return soap_out__wsdd__Hello(soap, "wsdd:Hello", id, (const struct wsdd__HelloType *)ptr, "");
	case SOAP_TYPE_wsdd__AppSequenceType:
		return soap_out_wsdd__AppSequenceType(soap, tag, id, (const struct wsdd__AppSequenceType *)ptr, "wsdd:AppSequenceType");
	case SOAP_TYPE_wsdd__SigType:
		return soap_out_wsdd__SigType(soap, tag, id, (const struct wsdd__SigType *)ptr, "wsdd:SigType");
	case SOAP_TYPE_wsdd__SecurityType:
		return soap_out_wsdd__SecurityType(soap, tag, id, (const struct wsdd__SecurityType *)ptr, "wsdd:SecurityType");
	case SOAP_TYPE_wsdd__ScopesType:
		return soap_out_wsdd__ScopesType(soap, tag, id, (const struct wsdd__ScopesType *)ptr, "wsdd:ScopesType");
	case SOAP_TYPE_wsdd__ResolveMatchType:
		return soap_out_wsdd__ResolveMatchType(soap, tag, id, (const struct wsdd__ResolveMatchType *)ptr, "wsdd:ResolveMatchType");
	case SOAP_TYPE_wsdd__ResolveMatchesType:
		return soap_out_wsdd__ResolveMatchesType(soap, tag, id, (const struct wsdd__ResolveMatchesType *)ptr, "wsdd:ResolveMatchesType");
	case SOAP_TYPE_wsdd__ResolveType:
		return soap_out_wsdd__ResolveType(soap, tag, id, (const struct wsdd__ResolveType *)ptr, "wsdd:ResolveType");
	case SOAP_TYPE_wsdd__ProbeMatchType:
		return soap_out_wsdd__ProbeMatchType(soap, tag, id, (const struct wsdd__ProbeMatchType *)ptr, "wsdd:ProbeMatchType");
	case SOAP_TYPE_wsdd__ProbeMatchesType:
		return soap_out_wsdd__ProbeMatchesType(soap, tag, id, (const struct wsdd__ProbeMatchesType *)ptr, "wsdd:ProbeMatchesType");
	case SOAP_TYPE_wsdd__ProbeType:
		return soap_out_wsdd__ProbeType(soap, tag, id, (const struct wsdd__ProbeType *)ptr, "wsdd:ProbeType");
	case SOAP_TYPE_wsdd__ByeType:
		return soap_out_wsdd__ByeType(soap, tag, id, (const struct wsdd__ByeType *)ptr, "wsdd:ByeType");
	case SOAP_TYPE_wsdd__HelloType:
		return soap_out_wsdd__HelloType(soap, tag, id, (const struct wsdd__HelloType *)ptr, "wsdd:HelloType");
	case SOAP_TYPE__wsa__FaultTo:
		return soap_out__wsa__FaultTo(soap, "wsa:FaultTo", id, (const struct wsa__EndpointReferenceType *)ptr, "");
	case SOAP_TYPE__wsa__ReplyTo:
		return soap_out__wsa__ReplyTo(soap, "wsa:ReplyTo", id, (const struct wsa__EndpointReferenceType *)ptr, "");
	case SOAP_TYPE__wsa__From:
		return soap_out__wsa__From(soap, "wsa:From", id, (const struct wsa__EndpointReferenceType *)ptr, "");
	case SOAP_TYPE__wsa__RelatesTo:
		return soap_out__wsa__RelatesTo(soap, "wsa:RelatesTo", id, (const struct wsa__Relationship *)ptr, "");
	case SOAP_TYPE__wsa__EndpointReference:
		return soap_out__wsa__EndpointReference(soap, "wsa:EndpointReference", id, (const struct wsa__EndpointReferenceType *)ptr, "");
	case SOAP_TYPE_wsa__Relationship:
		return soap_out_wsa__Relationship(soap, tag, id, (const struct wsa__Relationship *)ptr, "wsa:Relationship");
	case SOAP_TYPE_wsa__ServiceNameType:
		return soap_out_wsa__ServiceNameType(soap, tag, id, (const struct wsa__ServiceNameType *)ptr, "wsa:ServiceNameType");
	case SOAP_TYPE_wsa__ReferenceParametersType:
		return soap_out_wsa__ReferenceParametersType(soap, tag, id, (const struct wsa__ReferenceParametersType *)ptr, "wsa:ReferenceParametersType");
	case SOAP_TYPE_wsa__ReferencePropertiesType:
		return soap_out_wsa__ReferencePropertiesType(soap, tag, id, (const struct wsa__ReferencePropertiesType *)ptr, "wsa:ReferencePropertiesType");
	case SOAP_TYPE_wsa__EndpointReferenceType:
		return soap_out_wsa__EndpointReferenceType(soap, tag, id, (const struct wsa__EndpointReferenceType *)ptr, "wsa:EndpointReferenceType");
	case SOAP_TYPE_PointerTo_trt__GetSnapshotUriResponse:
		return soap_out_PointerTo_trt__GetSnapshotUriResponse(soap, tag, id, (struct _trt__GetSnapshotUriResponse *const*)ptr, "trt:GetSnapshotUriResponse");
	case SOAP_TYPE_PointerTo_trt__GetSnapshotUri:
		return soap_out_PointerTo_trt__GetSnapshotUri(soap, tag, id, (struct _trt__GetSnapshotUri *const*)ptr, "trt:GetSnapshotUri");
	case SOAP_TYPE_PointerTo_trt__GetProfilesResponse:
		return soap_out_PointerTo_trt__GetProfilesResponse(soap, tag, id, (struct _trt__GetProfilesResponse *const*)ptr, "trt:GetProfilesResponse");
	case SOAP_TYPE_PointerTo_trt__GetProfiles:
		return soap_out_PointerTo_trt__GetProfiles(soap, tag, id, (struct _trt__GetProfiles *const*)ptr, "trt:GetProfiles");
	case SOAP_TYPE_PointerTo_trt__GetProfileResponse:
		return soap_out_PointerTo_trt__GetProfileResponse(soap, tag, id, (struct _trt__GetProfileResponse *const*)ptr, "trt:GetProfileResponse");
	case SOAP_TYPE_PointerTo_trt__GetProfile:
		return soap_out_PointerTo_trt__GetProfile(soap, tag, id, (struct _trt__GetProfile *const*)ptr, "trt:GetProfile");
	case SOAP_TYPE_PointerTo_trt__CreateProfileResponse:
		return soap_out_PointerTo_trt__CreateProfileResponse(soap, tag, id, (struct _trt__CreateProfileResponse *const*)ptr, "trt:CreateProfileResponse");
	case SOAP_TYPE_PointerTo_trt__CreateProfile:
		return soap_out_PointerTo_trt__CreateProfile(soap, tag, id, (struct _trt__CreateProfile *const*)ptr, "trt:CreateProfile");
	case SOAP_TYPE_PointerTo_trt__GetServiceCapabilitiesResponse:
		return soap_out_PointerTo_trt__GetServiceCapabilitiesResponse(soap, tag, id, (struct _trt__GetServiceCapabilitiesResponse *const*)ptr, "trt:GetServiceCapabilitiesResponse");
	case SOAP_TYPE_PointerTo_trt__GetServiceCapabilities:
		return soap_out_PointerTo_trt__GetServiceCapabilities(soap, tag, id, (struct _trt__GetServiceCapabilities *const*)ptr, "trt:GetServiceCapabilities");
	case SOAP_TYPE_PointerTo_tds__GetCapabilitiesResponse:
		return soap_out_PointerTo_tds__GetCapabilitiesResponse(soap, tag, id, (struct _tds__GetCapabilitiesResponse *const*)ptr, "tds:GetCapabilitiesResponse");
	case SOAP_TYPE_PointerTo_tds__GetCapabilities:
		return soap_out_PointerTo_tds__GetCapabilities(soap, tag, id, (struct _tds__GetCapabilities *const*)ptr, "tds:GetCapabilities");
	case SOAP_TYPE_PointerTo_tds__SystemRebootResponse:
		return soap_out_PointerTo_tds__SystemRebootResponse(soap, tag, id, (struct _tds__SystemRebootResponse *const*)ptr, "tds:SystemRebootResponse");
	case SOAP_TYPE_PointerTo_tds__SystemReboot:
		return soap_out_PointerTo_tds__SystemReboot(soap, tag, id, (struct _tds__SystemReboot *const*)ptr, "tds:SystemReboot");
	case SOAP_TYPE_PointerTo_tds__GetDeviceInformationResponse:
		return soap_out_PointerTo_tds__GetDeviceInformationResponse(soap, tag, id, (struct _tds__GetDeviceInformationResponse *const*)ptr, "tds:GetDeviceInformationResponse");
	case SOAP_TYPE_PointerTo_tds__GetDeviceInformation:
		return soap_out_PointerTo_tds__GetDeviceInformation(soap, tag, id, (struct _tds__GetDeviceInformation *const*)ptr, "tds:GetDeviceInformation");
	case SOAP_TYPE_PointerTo_tds__GetServiceCapabilitiesResponse:
		return soap_out_PointerTo_tds__GetServiceCapabilitiesResponse(soap, tag, id, (struct _tds__GetServiceCapabilitiesResponse *const*)ptr, "tds:GetServiceCapabilitiesResponse");
	case SOAP_TYPE_PointerTo_tds__GetServiceCapabilities:
		return soap_out_PointerTo_tds__GetServiceCapabilities(soap, tag, id, (struct _tds__GetServiceCapabilities *const*)ptr, "tds:GetServiceCapabilities");
	case SOAP_TYPE_PointerTo_tds__GetServicesResponse:
		return soap_out_PointerTo_tds__GetServicesResponse(soap, tag, id, (struct _tds__GetServicesResponse *const*)ptr, "tds:GetServicesResponse");
	case SOAP_TYPE_PointerTo_tds__GetServices:
		return soap_out_PointerTo_tds__GetServices(soap, tag, id, (struct _tds__GetServices *const*)ptr, "tds:GetServices");
	case SOAP_TYPE_PointerTo_wstop__TopicNamespaceType_Topic:
		return soap_out_PointerTo_wstop__TopicNamespaceType_Topic(soap, tag, id, (struct _wstop__TopicNamespaceType_Topic *const*)ptr, "wstop:TopicNamespaceType-Topic");
	case SOAP_TYPE_PointerTowstop__TopicType:
		return soap_out_PointerTowstop__TopicType(soap, tag, id, (struct wstop__TopicType *const*)ptr, "wstop:TopicType");
	case SOAP_TYPE_PointerTowstop__QueryExpressionType:
		return soap_out_PointerTowstop__QueryExpressionType(soap, tag, id, (struct wstop__QueryExpressionType *const*)ptr, "wstop:QueryExpressionType");
	case SOAP_TYPE_PointerTo_wsnt__ResumeFailedFaultType_FaultCause:
		return soap_out_PointerTo_wsnt__ResumeFailedFaultType_FaultCause(soap, tag, id, (struct _wsnt__ResumeFailedFaultType_FaultCause *const*)ptr, "wsnt:ResumeFailedFaultType-FaultCause");
	case SOAP_TYPE_PointerTo_wsnt__ResumeFailedFaultType_Description:
		return soap_out_PointerTo_wsnt__ResumeFailedFaultType_Description(soap, tag, id, (struct _wsnt__ResumeFailedFaultType_Description *const*)ptr, "wsnt:ResumeFailedFaultType-Description");
	case SOAP_TYPE_PointerTo_wsnt__ResumeFailedFaultType_ErrorCode:
		return soap_out_PointerTo_wsnt__ResumeFailedFaultType_ErrorCode(soap, tag, id, (struct _wsnt__ResumeFailedFaultType_ErrorCode *const*)ptr, "wsnt:ResumeFailedFaultType-ErrorCode");
	case SOAP_TYPE_PointerTo_wsnt__PauseFailedFaultType_FaultCause:
		return soap_out_PointerTo_wsnt__PauseFailedFaultType_FaultCause(soap, tag, id, (struct _wsnt__PauseFailedFaultType_FaultCause *const*)ptr, "wsnt:PauseFailedFaultType-FaultCause");
	case SOAP_TYPE_PointerTo_wsnt__PauseFailedFaultType_Description:
		return soap_out_PointerTo_wsnt__PauseFailedFaultType_Description(soap, tag, id, (struct _wsnt__PauseFailedFaultType_Description *const*)ptr, "wsnt:PauseFailedFaultType-Description");
	case SOAP_TYPE_PointerTo_wsnt__PauseFailedFaultType_ErrorCode:
		return soap_out_PointerTo_wsnt__PauseFailedFaultType_ErrorCode(soap, tag, id, (struct _wsnt__PauseFailedFaultType_ErrorCode *const*)ptr, "wsnt:PauseFailedFaultType-ErrorCode");
	case SOAP_TYPE_PointerTo_wsnt__UnableToDestroySubscriptionFaultType_FaultCause:
		return soap_out_PointerTo_wsnt__UnableToDestroySubscriptionFaultType_FaultCause(soap, tag, id, (struct _wsnt__UnableToDestroySubscriptionFaultType_FaultCause *const*)ptr, "wsnt:UnableToDestroySubscriptionFaultType-FaultCause");
	case SOAP_TYPE_PointerTo_wsnt__UnableToDestroySubscriptionFaultType_Description:
		return soap_out_PointerTo_wsnt__UnableToDestroySubscriptionFaultType_Description(soap, tag, id, (struct _wsnt__UnableToDestroySubscriptionFaultType_Description *const*)ptr, "wsnt:UnableToDestroySubscriptionFaultType-Description");
	case SOAP_TYPE_PointerTo_wsnt__UnableToDestroySubscriptionFaultType_ErrorCode:
		return soap_out_PointerTo_wsnt__UnableToDestroySubscriptionFaultType_ErrorCode(soap, tag, id, (struct _wsnt__UnableToDestroySubscriptionFaultType_ErrorCode *const*)ptr, "wsnt:UnableToDestroySubscriptionFaultType-ErrorCode");
	case SOAP_TYPE_PointerTo_wsnt__UnacceptableTerminationTimeFaultType_FaultCause:
		return soap_out_PointerTo_wsnt__UnacceptableTerminationTimeFaultType_FaultCause(soap, tag, id, (struct _wsnt__UnacceptableTerminationTimeFaultType_FaultCause *const*)ptr, "wsnt:UnacceptableTerminationTimeFaultType-FaultCause");
	case SOAP_TYPE_PointerTo_wsnt__UnacceptableTerminationTimeFaultType_Description:
		return soap_out_PointerTo_wsnt__UnacceptableTerminationTimeFaultType_Description(soap, tag, id, (struct _wsnt__UnacceptableTerminationTimeFaultType_Description *const*)ptr, "wsnt:UnacceptableTerminationTimeFaultType-Description");
	case SOAP_TYPE_PointerTo_wsnt__UnacceptableTerminationTimeFaultType_ErrorCode:
		return soap_out_PointerTo_wsnt__UnacceptableTerminationTimeFaultType_ErrorCode(soap, tag, id, (struct _wsnt__UnacceptableTerminationTimeFaultType_ErrorCode *const*)ptr, "wsnt:UnacceptableTerminationTimeFaultType-ErrorCode");
	case SOAP_TYPE_PointerTo_wsnt__UnableToCreatePullPointFaultType_FaultCause:
		return soap_out_PointerTo_wsnt__UnableToCreatePullPointFaultType_FaultCause(soap, tag, id, (struct _wsnt__UnableToCreatePullPointFaultType_FaultCause *const*)ptr, "wsnt:UnableToCreatePullPointFaultType-FaultCause");
	case SOAP_TYPE_PointerTo_wsnt__UnableToCreatePullPointFaultType_Description:
		return soap_out_PointerTo_wsnt__UnableToCreatePullPointFaultType_Description(soap, tag, id, (struct _wsnt__UnableToCreatePullPointFaultType_Description *const*)ptr, "wsnt:UnableToCreatePullPointFaultType-Description");
	case SOAP_TYPE_PointerTo_wsnt__UnableToCreatePullPointFaultType_ErrorCode:
		return soap_out_PointerTo_wsnt__UnableToCreatePullPointFaultType_ErrorCode(soap, tag, id, (struct _wsnt__UnableToCreatePullPointFaultType_ErrorCode *const*)ptr, "wsnt:UnableToCreatePullPointFaultType-ErrorCode");
	case SOAP_TYPE_PointerTo_wsnt__UnableToDestroyPullPointFaultType_FaultCause:
		return soap_out_PointerTo_wsnt__UnableToDestroyPullPointFaultType_FaultCause(soap, tag, id, (struct _wsnt__UnableToDestroyPullPointFaultType_FaultCause *const*)ptr, "wsnt:UnableToDestroyPullPointFaultType-FaultCause");
	case SOAP_TYPE_PointerTo_wsnt__UnableToDestroyPullPointFaultType_Description:
		return soap_out_PointerTo_wsnt__UnableToDestroyPullPointFaultType_Description(soap, tag, id, (struct _wsnt__UnableToDestroyPullPointFaultType_Description *const*)ptr, "wsnt:UnableToDestroyPullPointFaultType-Description");
	case SOAP_TYPE_PointerTo_wsnt__UnableToDestroyPullPointFaultType_ErrorCode:
		return soap_out_PointerTo_wsnt__UnableToDestroyPullPointFaultType_ErrorCode(soap, tag, id, (struct _wsnt__UnableToDestroyPullPointFaultType_ErrorCode *const*)ptr, "wsnt:UnableToDestroyPullPointFaultType-ErrorCode");
	case SOAP_TYPE_PointerTo_wsnt__UnableToGetMessagesFaultType_FaultCause:
		return soap_out_PointerTo_wsnt__UnableToGetMessagesFaultType_FaultCause(soap, tag, id, (struct _wsnt__UnableToGetMessagesFaultType_FaultCause *const*)ptr, "wsnt:UnableToGetMessagesFaultType-FaultCause");
	case SOAP_TYPE_PointerTo_wsnt__UnableToGetMessagesFaultType_Description:
		return soap_out_PointerTo_wsnt__UnableToGetMessagesFaultType_Description(soap, tag, id, (struct _wsnt__UnableToGetMessagesFaultType_Description *const*)ptr, "wsnt:UnableToGetMessagesFaultType-Description");
	case SOAP_TYPE_PointerTo_wsnt__UnableToGetMessagesFaultType_ErrorCode:
		return soap_out_PointerTo_wsnt__UnableToGetMessagesFaultType_ErrorCode(soap, tag, id, (struct _wsnt__UnableToGetMessagesFaultType_ErrorCode *const*)ptr, "wsnt:UnableToGetMessagesFaultType-ErrorCode");
	case SOAP_TYPE_PointerTo_wsnt__NoCurrentMessageOnTopicFaultType_FaultCause:
		return soap_out_PointerTo_wsnt__NoCurrentMessageOnTopicFaultType_FaultCause(soap, tag, id, (struct _wsnt__NoCurrentMessageOnTopicFaultType_FaultCause *const*)ptr, "wsnt:NoCurrentMessageOnTopicFaultType-FaultCause");
	case SOAP_TYPE_PointerTo_wsnt__NoCurrentMessageOnTopicFaultType_Description:
		return soap_out_PointerTo_wsnt__NoCurrentMessageOnTopicFaultType_Description(soap, tag, id, (struct _wsnt__NoCurrentMessageOnTopicFaultType_Description *const*)ptr, "wsnt:NoCurrentMessageOnTopicFaultType-Description");
	case SOAP_TYPE_PointerTo_wsnt__NoCurrentMessageOnTopicFaultType_ErrorCode:
		return soap_out_PointerTo_wsnt__NoCurrentMessageOnTopicFaultType_ErrorCode(soap, tag, id, (struct _wsnt__NoCurrentMessageOnTopicFaultType_ErrorCode *const*)ptr, "wsnt:NoCurrentMessageOnTopicFaultType-ErrorCode");
	case SOAP_TYPE_PointerTo_wsnt__UnacceptableInitialTerminationTimeFaultType_FaultCause:
		return soap_out_PointerTo_wsnt__UnacceptableInitialTerminationTimeFaultType_FaultCause(soap, tag, id, (struct _wsnt__UnacceptableInitialTerminationTimeFaultType_FaultCause *const*)ptr, "wsnt:UnacceptableInitialTerminationTimeFaultType-FaultCause");
	case SOAP_TYPE_PointerTo_wsnt__UnacceptableInitialTerminationTimeFaultType_Description:
		return soap_out_PointerTo_wsnt__UnacceptableInitialTerminationTimeFaultType_Description(soap, tag, id, (struct _wsnt__UnacceptableInitialTerminationTimeFaultType_Description *const*)ptr, "wsnt:UnacceptableInitialTerminationTimeFaultType-Description");
	case SOAP_TYPE_PointerTo_wsnt__UnacceptableInitialTerminationTimeFaultType_ErrorCode:
		return soap_out_PointerTo_wsnt__UnacceptableInitialTerminationTimeFaultType_ErrorCode(soap, tag, id, (struct _wsnt__UnacceptableInitialTerminationTimeFaultType_ErrorCode *const*)ptr, "wsnt:UnacceptableInitialTerminationTimeFaultType-ErrorCode");
	case SOAP_TYPE_PointerTo_wsnt__NotifyMessageNotSupportedFaultType_FaultCause:
		return soap_out_PointerTo_wsnt__NotifyMessageNotSupportedFaultType_FaultCause(soap, tag, id, (struct _wsnt__NotifyMessageNotSupportedFaultType_FaultCause *const*)ptr, "wsnt:NotifyMessageNotSupportedFaultType-FaultCause");
	case SOAP_TYPE_PointerTo_wsnt__NotifyMessageNotSupportedFaultType_Description:
		return soap_out_PointerTo_wsnt__NotifyMessageNotSupportedFaultType_Description(soap, tag, id, (struct _wsnt__NotifyMessageNotSupportedFaultType_Description *const*)ptr, "wsnt:NotifyMessageNotSupportedFaultType-Description");
	case SOAP_TYPE_PointerTo_wsnt__NotifyMessageNotSupportedFaultType_ErrorCode:
		return soap_out_PointerTo_wsnt__NotifyMessageNotSupportedFaultType_ErrorCode(soap, tag, id, (struct _wsnt__NotifyMessageNotSupportedFaultType_ErrorCode *const*)ptr, "wsnt:NotifyMessageNotSupportedFaultType-ErrorCode");
	case SOAP_TYPE_PointerTo_wsnt__UnsupportedPolicyRequestFaultType_FaultCause:
		return soap_out_PointerTo_wsnt__UnsupportedPolicyRequestFaultType_FaultCause(soap, tag, id, (struct _wsnt__UnsupportedPolicyRequestFaultType_FaultCause *const*)ptr, "wsnt:UnsupportedPolicyRequestFaultType-FaultCause");
	case SOAP_TYPE_PointerTo_wsnt__UnsupportedPolicyRequestFaultType_Description:
		return soap_out_PointerTo_wsnt__UnsupportedPolicyRequestFaultType_Description(soap, tag, id, (struct _wsnt__UnsupportedPolicyRequestFaultType_Description *const*)ptr, "wsnt:UnsupportedPolicyRequestFaultType-Description");
	case SOAP_TYPE_PointerTo_wsnt__UnsupportedPolicyRequestFaultType_ErrorCode:
		return soap_out_PointerTo_wsnt__UnsupportedPolicyRequestFaultType_ErrorCode(soap, tag, id, (struct _wsnt__UnsupportedPolicyRequestFaultType_ErrorCode *const*)ptr, "wsnt:UnsupportedPolicyRequestFaultType-ErrorCode");
	case SOAP_TYPE_PointerTo_wsnt__UnrecognizedPolicyRequestFaultType_FaultCause:
		return soap_out_PointerTo_wsnt__UnrecognizedPolicyRequestFaultType_FaultCause(soap, tag, id, (struct _wsnt__UnrecognizedPolicyRequestFaultType_FaultCause *const*)ptr, "wsnt:UnrecognizedPolicyRequestFaultType-FaultCause");
	case SOAP_TYPE_PointerTo_wsnt__UnrecognizedPolicyRequestFaultType_Description:
		return soap_out_PointerTo_wsnt__UnrecognizedPolicyRequestFaultType_Description(soap, tag, id, (struct _wsnt__UnrecognizedPolicyRequestFaultType_Description *const*)ptr, "wsnt:UnrecognizedPolicyRequestFaultType-Description");
	case SOAP_TYPE_PointerTo_wsnt__UnrecognizedPolicyRequestFaultType_ErrorCode:
		return soap_out_PointerTo_wsnt__UnrecognizedPolicyRequestFaultType_ErrorCode(soap, tag, id, (struct _wsnt__UnrecognizedPolicyRequestFaultType_ErrorCode *const*)ptr, "wsnt:UnrecognizedPolicyRequestFaultType-ErrorCode");
	case SOAP_TYPE_PointerTo_wsnt__InvalidMessageContentExpressionFaultType_FaultCause:
		return soap_out_PointerTo_wsnt__InvalidMessageContentExpressionFaultType_FaultCause(soap, tag, id, (struct _wsnt__InvalidMessageContentExpressionFaultType_FaultCause *const*)ptr, "wsnt:InvalidMessageContentExpressionFaultType-FaultCause");
	case SOAP_TYPE_PointerTo_wsnt__InvalidMessageContentExpressionFaultType_Description:
		return soap_out_PointerTo_wsnt__InvalidMessageContentExpressionFaultType_Description(soap, tag, id, (struct _wsnt__InvalidMessageContentExpressionFaultType_Description *const*)ptr, "wsnt:InvalidMessageContentExpressionFaultType-Description");
	case SOAP_TYPE_PointerTo_wsnt__InvalidMessageContentExpressionFaultType_ErrorCode:
		return soap_out_PointerTo_wsnt__InvalidMessageContentExpressionFaultType_ErrorCode(soap, tag, id, (struct _wsnt__InvalidMessageContentExpressionFaultType_ErrorCode *const*)ptr, "wsnt:InvalidMessageContentExpressionFaultType-ErrorCode");
	case SOAP_TYPE_PointerTo_wsnt__InvalidProducerPropertiesExpressionFaultType_FaultCause:
		return soap_out_PointerTo_wsnt__InvalidProducerPropertiesExpressionFaultType_FaultCause(soap, tag, id, (struct _wsnt__InvalidProducerPropertiesExpressionFaultType_FaultCause *const*)ptr, "wsnt:InvalidProducerPropertiesExpressionFaultType-FaultCause");
	case SOAP_TYPE_PointerTo_wsnt__InvalidProducerPropertiesExpressionFaultType_Description:
		return soap_out_PointerTo_wsnt__InvalidProducerPropertiesExpressionFaultType_Description(soap, tag, id, (struct _wsnt__InvalidProducerPropertiesExpressionFaultType_Description *const*)ptr, "wsnt:InvalidProducerPropertiesExpressionFaultType-Description");
	case SOAP_TYPE_PointerTo_wsnt__InvalidProducerPropertiesExpressionFaultType_ErrorCode:
		return soap_out_PointerTo_wsnt__InvalidProducerPropertiesExpressionFaultType_ErrorCode(soap, tag, id, (struct _wsnt__InvalidProducerPropertiesExpressionFaultType_ErrorCode *const*)ptr, "wsnt:InvalidProducerPropertiesExpressionFaultType-ErrorCode");
	case SOAP_TYPE_PointerTo_wsnt__MultipleTopicsSpecifiedFaultType_FaultCause:
		return soap_out_PointerTo_wsnt__MultipleTopicsSpecifiedFaultType_FaultCause(soap, tag, id, (struct _wsnt__MultipleTopicsSpecifiedFaultType_FaultCause *const*)ptr, "wsnt:MultipleTopicsSpecifiedFaultType-FaultCause");
	case SOAP_TYPE_PointerTo_wsnt__MultipleTopicsSpecifiedFaultType_Description:
		return soap_out_PointerTo_wsnt__MultipleTopicsSpecifiedFaultType_Description(soap, tag, id, (struct _wsnt__MultipleTopicsSpecifiedFaultType_Description *const*)ptr, "wsnt:MultipleTopicsSpecifiedFaultType-Description");
	case SOAP_TYPE_PointerTo_wsnt__MultipleTopicsSpecifiedFaultType_ErrorCode:
		return soap_out_PointerTo_wsnt__MultipleTopicsSpecifiedFaultType_ErrorCode(soap, tag, id, (struct _wsnt__MultipleTopicsSpecifiedFaultType_ErrorCode *const*)ptr, "wsnt:MultipleTopicsSpecifiedFaultType-ErrorCode");
	case SOAP_TYPE_PointerTo_wsnt__TopicNotSupportedFaultType_FaultCause:
		return soap_out_PointerTo_wsnt__TopicNotSupportedFaultType_FaultCause(soap, tag, id, (struct _wsnt__TopicNotSupportedFaultType_FaultCause *const*)ptr, "wsnt:TopicNotSupportedFaultType-FaultCause");
	case SOAP_TYPE_PointerTo_wsnt__TopicNotSupportedFaultType_Description:
		return soap_out_PointerTo_wsnt__TopicNotSupportedFaultType_Description(soap, tag, id, (struct _wsnt__TopicNotSupportedFaultType_Description *const*)ptr, "wsnt:TopicNotSupportedFaultType-Description");
	case SOAP_TYPE_PointerTo_wsnt__TopicNotSupportedFaultType_ErrorCode:
		return soap_out_PointerTo_wsnt__TopicNotSupportedFaultType_ErrorCode(soap, tag, id, (struct _wsnt__TopicNotSupportedFaultType_ErrorCode *const*)ptr, "wsnt:TopicNotSupportedFaultType-ErrorCode");
	case SOAP_TYPE_PointerTo_wsnt__InvalidTopicExpressionFaultType_FaultCause:
		return soap_out_PointerTo_wsnt__InvalidTopicExpressionFaultType_FaultCause(soap, tag, id, (struct _wsnt__InvalidTopicExpressionFaultType_FaultCause *const*)ptr, "wsnt:InvalidTopicExpressionFaultType-FaultCause");
	case SOAP_TYPE_PointerTo_wsnt__InvalidTopicExpressionFaultType_Description:
		return soap_out_PointerTo_wsnt__InvalidTopicExpressionFaultType_Description(soap, tag, id, (struct _wsnt__InvalidTopicExpressionFaultType_Description *const*)ptr, "wsnt:InvalidTopicExpressionFaultType-Description");
	case SOAP_TYPE_PointerTo_wsnt__InvalidTopicExpressionFaultType_ErrorCode:
		return soap_out_PointerTo_wsnt__InvalidTopicExpressionFaultType_ErrorCode(soap, tag, id, (struct _wsnt__InvalidTopicExpressionFaultType_ErrorCode *const*)ptr, "wsnt:InvalidTopicExpressionFaultType-ErrorCode");
	case SOAP_TYPE_PointerTo_wsnt__TopicExpressionDialectUnknownFaultType_FaultCause:
		return soap_out_PointerTo_wsnt__TopicExpressionDialectUnknownFaultType_FaultCause(soap, tag, id, (struct _wsnt__TopicExpressionDialectUnknownFaultType_FaultCause *const*)ptr, "wsnt:TopicExpressionDialectUnknownFaultType-FaultCause");
	case SOAP_TYPE_PointerTo_wsnt__TopicExpressionDialectUnknownFaultType_Description:
		return soap_out_PointerTo_wsnt__TopicExpressionDialectUnknownFaultType_Description(soap, tag, id, (struct _wsnt__TopicExpressionDialectUnknownFaultType_Description *const*)ptr, "wsnt:TopicExpressionDialectUnknownFaultType-Description");
	case SOAP_TYPE_PointerTo_wsnt__TopicExpressionDialectUnknownFaultType_ErrorCode:
		return soap_out_PointerTo_wsnt__TopicExpressionDialectUnknownFaultType_ErrorCode(soap, tag, id, (struct _wsnt__TopicExpressionDialectUnknownFaultType_ErrorCode *const*)ptr, "wsnt:TopicExpressionDialectUnknownFaultType-ErrorCode");
	case SOAP_TYPE_PointerTo_wsnt__InvalidFilterFaultType_FaultCause:
		return soap_out_PointerTo_wsnt__InvalidFilterFaultType_FaultCause(soap, tag, id, (struct _wsnt__InvalidFilterFaultType_FaultCause *const*)ptr, "wsnt:InvalidFilterFaultType-FaultCause");
	case SOAP_TYPE_PointerTo_wsnt__InvalidFilterFaultType_Description:
		return soap_out_PointerTo_wsnt__InvalidFilterFaultType_Description(soap, tag, id, (struct _wsnt__InvalidFilterFaultType_Description *const*)ptr, "wsnt:InvalidFilterFaultType-Description");
	case SOAP_TYPE_PointerTo_wsnt__InvalidFilterFaultType_ErrorCode:
		return soap_out_PointerTo_wsnt__InvalidFilterFaultType_ErrorCode(soap, tag, id, (struct _wsnt__InvalidFilterFaultType_ErrorCode *const*)ptr, "wsnt:InvalidFilterFaultType-ErrorCode");
	case SOAP_TYPE_PointerTo_wsnt__SubscribeCreationFailedFaultType_FaultCause:
		return soap_out_PointerTo_wsnt__SubscribeCreationFailedFaultType_FaultCause(soap, tag, id, (struct _wsnt__SubscribeCreationFailedFaultType_FaultCause *const*)ptr, "wsnt:SubscribeCreationFailedFaultType-FaultCause");
	case SOAP_TYPE_PointerTo_wsnt__SubscribeCreationFailedFaultType_Description:
		return soap_out_PointerTo_wsnt__SubscribeCreationFailedFaultType_Description(soap, tag, id, (struct _wsnt__SubscribeCreationFailedFaultType_Description *const*)ptr, "wsnt:SubscribeCreationFailedFaultType-Description");
	case SOAP_TYPE_PointerTo_wsnt__SubscribeCreationFailedFaultType_ErrorCode:
		return soap_out_PointerTo_wsnt__SubscribeCreationFailedFaultType_ErrorCode(soap, tag, id, (struct _wsnt__SubscribeCreationFailedFaultType_ErrorCode *const*)ptr, "wsnt:SubscribeCreationFailedFaultType-ErrorCode");
	case SOAP_TYPE_PointerTott__MulticastConfiguration:
		return soap_out_PointerTott__MulticastConfiguration(soap, tag, id, (struct tt__MulticastConfiguration *const*)ptr, "tt:MulticastConfiguration");
	case SOAP_TYPE_PointerTott__H264Configuration:
		return soap_out_PointerTott__H264Configuration(soap, tag, id, (struct tt__H264Configuration *const*)ptr, "tt:H264Configuration");
	case SOAP_TYPE_PointerTott__Mpeg4Configuration:
		return soap_out_PointerTott__Mpeg4Configuration(soap, tag, id, (struct tt__Mpeg4Configuration *const*)ptr, "tt:Mpeg4Configuration");
	case SOAP_TYPE_PointerTott__VideoRateControl:
		return soap_out_PointerTott__VideoRateControl(soap, tag, id, (struct tt__VideoRateControl *const*)ptr, "tt:VideoRateControl");
	case SOAP_TYPE_PointerTott__MediaUri:
		return soap_out_PointerTott__MediaUri(soap, tag, id, (struct tt__MediaUri *const*)ptr, "tt:MediaUri");
	case SOAP_TYPE_PointerTott__Profile:
		return soap_out_PointerTott__Profile(soap, tag, id, (struct tt__Profile *const*)ptr, "tt:Profile");
	case SOAP_TYPE_PointerTotrt__Capabilities:
		return soap_out_PointerTotrt__Capabilities(soap, tag, id, (struct trt__Capabilities *const*)ptr, "trt:Capabilities");
	case SOAP_TYPE_PointerTotrt__ProfileCapabilities:
		return soap_out_PointerTotrt__ProfileCapabilities(soap, tag, id, (struct trt__ProfileCapabilities *const*)ptr, "trt:ProfileCapabilities");
	case SOAP_TYPE_PointerTowstop__Documentation:
		return soap_out_PointerTowstop__Documentation(soap, tag, id, (struct wstop__Documentation *const*)ptr, "wstop:Documentation");
	case SOAP_TYPE_PointerTo_wsrfbf__BaseFaultType_FaultCause:
		return soap_out_PointerTo_wsrfbf__BaseFaultType_FaultCause(soap, tag, id, (struct _wsrfbf__BaseFaultType_FaultCause *const*)ptr, "wsrfbf:BaseFaultType-FaultCause");
	case SOAP_TYPE_PointerTo_wsrfbf__BaseFaultType_Description:
		return soap_out_PointerTo_wsrfbf__BaseFaultType_Description(soap, tag, id, (struct _wsrfbf__BaseFaultType_Description *const*)ptr, "wsrfbf:BaseFaultType-Description");
	case SOAP_TYPE_PointerTo_wsrfbf__BaseFaultType_ErrorCode:
		return soap_out_PointerTo_wsrfbf__BaseFaultType_ErrorCode(soap, tag, id, (struct _wsrfbf__BaseFaultType_ErrorCode *const*)ptr, "wsrfbf:BaseFaultType-ErrorCode");
	case SOAP_TYPE_PointerTo_wsnt__Subscribe_SubscriptionPolicy:
		return soap_out_PointerTo_wsnt__Subscribe_SubscriptionPolicy(soap, tag, id, (struct _wsnt__Subscribe_SubscriptionPolicy *const*)ptr, "wsnt:Subscribe-SubscriptionPolicy");
	case SOAP_TYPE_PointerTowsnt__NotificationMessageHolderType:
		return soap_out_PointerTowsnt__NotificationMessageHolderType(soap, tag, id, (struct wsnt__NotificationMessageHolderType *const*)ptr, "wsnt:NotificationMessageHolderType");
	case SOAP_TYPE_PointerTodateTime:
		return soap_out_PointerTodateTime(soap, tag, id, (time_t *const*)ptr, "xsd:dateTime");
	case SOAP_TYPE_PointerTowsnt__SubscriptionPolicyType:
		return soap_out_PointerTowsnt__SubscriptionPolicyType(soap, tag, id, (struct wsnt__SubscriptionPolicyType *const*)ptr, "wsnt:SubscriptionPolicyType");
	case SOAP_TYPE_PointerTowsnt__FilterType:
		return soap_out_PointerTowsnt__FilterType(soap, tag, id, (struct wsnt__FilterType *const*)ptr, "wsnt:FilterType");
	case SOAP_TYPE_PointerTowstop__TopicSetType:
		return soap_out_PointerTowstop__TopicSetType(soap, tag, id, (struct wstop__TopicSetType *const*)ptr, "wstop:TopicSetType");
	case SOAP_TYPE_PointerToxsd__anyURI:
		return soap_out_PointerToxsd__anyURI(soap, tag, id, (char **const*)ptr, "xsd:anyURI");
	case SOAP_TYPE_PointerTowsnt__TopicExpressionType:
		return soap_out_PointerTowsnt__TopicExpressionType(soap, tag, id, (struct wsnt__TopicExpressionType *const*)ptr, "wsnt:TopicExpressionType");
	case SOAP_TYPE_PointerTowsa5__EndpointReferenceType:
		return soap_out_PointerTowsa5__EndpointReferenceType(soap, tag, id, (struct wsa5__EndpointReferenceType *const*)ptr, "wsa5:EndpointReferenceType");
	case SOAP_TYPE_PointerTott__PropertyOperation:
		return soap_out_PointerTott__PropertyOperation(soap, tag, id, (enum tt__PropertyOperation *const*)ptr, "tt:PropertyOperation");
	case SOAP_TYPE_PointerTott__MessageExtension:
		return soap_out_PointerTott__MessageExtension(soap, tag, id, (struct tt__MessageExtension *const*)ptr, "tt:MessageExtension");
	case SOAP_TYPE_PointerTott__ItemList:
		return soap_out_PointerTott__ItemList(soap, tag, id, (struct tt__ItemList *const*)ptr, "tt:ItemList");
	case SOAP_TYPE_PointerTott__IPAddress:
		return soap_out_PointerTott__IPAddress(soap, tag, id, (struct tt__IPAddress *const*)ptr, "tt:IPAddress");
	case SOAP_TYPE_PointerTott__H264Profile:
		return soap_out_PointerTott__H264Profile(soap, tag, id, (enum tt__H264Profile *const*)ptr, "tt:H264Profile");
	case SOAP_TYPE_PointerTott__Mpeg4Profile:
		return soap_out_PointerTott__Mpeg4Profile(soap, tag, id, (enum tt__Mpeg4Profile *const*)ptr, "tt:Mpeg4Profile");
	case SOAP_TYPE_PointerTott__VideoResolution:
		return soap_out_PointerTott__VideoResolution(soap, tag, id, (struct tt__VideoResolution *const*)ptr, "tt:VideoResolution");
	case SOAP_TYPE_PointerTott__VideoEncoderOptionsExtension2:
		return soap_out_PointerTott__VideoEncoderOptionsExtension2(soap, tag, id, (struct tt__VideoEncoderOptionsExtension2 *const*)ptr, "tt:VideoEncoderOptionsExtension2");
	case SOAP_TYPE_PointerTott__H264Options2:
		return soap_out_PointerTott__H264Options2(soap, tag, id, (struct tt__H264Options2 *const*)ptr, "tt:H264Options2");
	case SOAP_TYPE_PointerTott__Mpeg4Options2:
		return soap_out_PointerTott__Mpeg4Options2(soap, tag, id, (struct tt__Mpeg4Options2 *const*)ptr, "tt:Mpeg4Options2");
	case SOAP_TYPE_PointerTott__JpegOptions2:
		return soap_out_PointerTott__JpegOptions2(soap, tag, id, (struct tt__JpegOptions2 *const*)ptr, "tt:JpegOptions2");
	case SOAP_TYPE_PointerTott__VideoEncoderOptionsExtension:
		return soap_out_PointerTott__VideoEncoderOptionsExtension(soap, tag, id, (struct tt__VideoEncoderOptionsExtension *const*)ptr, "tt:VideoEncoderOptionsExtension");
	case SOAP_TYPE_PointerTott__H264Options:
		return soap_out_PointerTott__H264Options(soap, tag, id, (struct tt__H264Options *const*)ptr, "tt:H264Options");
	case SOAP_TYPE_PointerTott__Mpeg4Options:
		return soap_out_PointerTott__Mpeg4Options(soap, tag, id, (struct tt__Mpeg4Options *const*)ptr, "tt:Mpeg4Options");
	case SOAP_TYPE_PointerTott__JpegOptions:
		return soap_out_PointerTott__JpegOptions(soap, tag, id, (struct tt__JpegOptions *const*)ptr, "tt:JpegOptions");
	case SOAP_TYPE_PointerTott__ItemListDescriptionExtension:
		return soap_out_PointerTott__ItemListDescriptionExtension(soap, tag, id, (struct tt__ItemListDescriptionExtension *const*)ptr, "tt:ItemListDescriptionExtension");
	case SOAP_TYPE_PointerTo_tt__ItemListDescription_ElementItemDescription:
		return soap_out_PointerTo_tt__ItemListDescription_ElementItemDescription(soap, tag, id, (struct _tt__ItemListDescription_ElementItemDescription *const*)ptr, "tt:ItemListDescription-ElementItemDescription");
	case SOAP_TYPE_PointerTo_tt__ItemListDescription_SimpleItemDescription:
		return soap_out_PointerTo_tt__ItemListDescription_SimpleItemDescription(soap, tag, id, (struct _tt__ItemListDescription_SimpleItemDescription *const*)ptr, "tt:ItemListDescription-SimpleItemDescription");
	case SOAP_TYPE_PointerTott__MessageDescriptionExtension:
		return soap_out_PointerTott__MessageDescriptionExtension(soap, tag, id, (struct tt__MessageDescriptionExtension *const*)ptr, "tt:MessageDescriptionExtension");
	case SOAP_TYPE_PointerTott__ItemListDescription:
		return soap_out_PointerTott__ItemListDescription(soap, tag, id, (struct tt__ItemListDescription *const*)ptr, "tt:ItemListDescription");
	case SOAP_TYPE_PointerTott__ItemListExtension:
		return soap_out_PointerTott__ItemListExtension(soap, tag, id, (struct tt__ItemListExtension *const*)ptr, "tt:ItemListExtension");
	case SOAP_TYPE_PointerTo_tt__ItemList_ElementItem:
		return soap_out_PointerTo_tt__ItemList_ElementItem(soap, tag, id, (struct _tt__ItemList_ElementItem *const*)ptr, "tt:ItemList-ElementItem");
	case SOAP_TYPE_PointerTo_tt__ItemList_SimpleItem:
		return soap_out_PointerTo_tt__ItemList_SimpleItem(soap, tag, id, (struct _tt__ItemList_SimpleItem *const*)ptr, "tt:ItemList-SimpleItem");
	case SOAP_TYPE_PointerTott__MoveStatus:
		return soap_out_PointerTott__MoveStatus(soap, tag, id, (enum tt__MoveStatus *const*)ptr, "tt:MoveStatus");
	case SOAP_TYPE_PointerTott__PTZVector:
		return soap_out_PointerTott__PTZVector(soap, tag, id, (struct tt__PTZVector *const*)ptr, "tt:PTZVector");
	case SOAP_TYPE_PointerTott__Vector1D:
		return soap_out_PointerTott__Vector1D(soap, tag, id, (struct tt__Vector1D *const*)ptr, "tt:Vector1D");
	case SOAP_TYPE_PointerTott__Vector2D:
		return soap_out_PointerTott__Vector2D(soap, tag, id, (struct tt__Vector2D *const*)ptr, "tt:Vector2D");
	case SOAP_TYPE_PointerTott__FloatRange:
		return soap_out_PointerTott__FloatRange(soap, tag, id, (struct tt__FloatRange *const*)ptr, "tt:FloatRange");
	case SOAP_TYPE_PointerTott__Space1DDescription:
		return soap_out_PointerTott__Space1DDescription(soap, tag, id, (struct tt__Space1DDescription *const*)ptr, "tt:Space1DDescription");
	case SOAP_TYPE_PointerTott__Space2DDescription:
		return soap_out_PointerTott__Space2DDescription(soap, tag, id, (struct tt__Space2DDescription *const*)ptr, "tt:Space2DDescription");
	case SOAP_TYPE_PointerTott__ProfileCapabilities:
		return soap_out_PointerTott__ProfileCapabilities(soap, tag, id, (struct tt__ProfileCapabilities *const*)ptr, "tt:ProfileCapabilities");
	case SOAP_TYPE_PointerTott__MediaCapabilitiesExtension:
		return soap_out_PointerTott__MediaCapabilitiesExtension(soap, tag, id, (struct tt__MediaCapabilitiesExtension *const*)ptr, "tt:MediaCapabilitiesExtension");
	case SOAP_TYPE_PointerTott__RealTimeStreamingCapabilities:
		return soap_out_PointerTott__RealTimeStreamingCapabilities(soap, tag, id, (struct tt__RealTimeStreamingCapabilities *const*)ptr, "tt:RealTimeStreamingCapabilities");
	case SOAP_TYPE_PointerTott__SystemCapabilities:
		return soap_out_PointerTott__SystemCapabilities(soap, tag, id, (struct tt__SystemCapabilities *const*)ptr, "tt:SystemCapabilities");
	case SOAP_TYPE_PointerTott__PTZCapabilities:
		return soap_out_PointerTott__PTZCapabilities(soap, tag, id, (struct tt__PTZCapabilities *const*)ptr, "tt:PTZCapabilities");
	case SOAP_TYPE_PointerTott__MediaCapabilities:
		return soap_out_PointerTott__MediaCapabilities(soap, tag, id, (struct tt__MediaCapabilities *const*)ptr, "tt:MediaCapabilities");
	case SOAP_TYPE_PointerTott__EventCapabilities:
		return soap_out_PointerTott__EventCapabilities(soap, tag, id, (struct tt__EventCapabilities *const*)ptr, "tt:EventCapabilities");
	case SOAP_TYPE_PointerTott__DeviceCapabilities:
		return soap_out_PointerTott__DeviceCapabilities(soap, tag, id, (struct tt__DeviceCapabilities *const*)ptr, "tt:DeviceCapabilities");
	case SOAP_TYPE_PointerToxsd__boolean:
		return soap_out_PointerToxsd__boolean(soap, tag, id, (enum xsd__boolean *const*)ptr, "xsd:boolean");
	case SOAP_TYPE_PointerTott__VideoEncoderConfiguration:
		return soap_out_PointerTott__VideoEncoderConfiguration(soap, tag, id, (struct tt__VideoEncoderConfiguration *const*)ptr, "tt:VideoEncoderConfiguration");
	case SOAP_TYPE_PointerTofloat:
		return soap_out_PointerTofloat(soap, tag, id, (float *const*)ptr, "xsd:float");
	case SOAP_TYPE_PointerTott__IntRange:
		return soap_out_PointerTott__IntRange(soap, tag, id, (struct tt__IntRange *const*)ptr, "tt:IntRange");
	case SOAP_TYPE_PointerTott__Capabilities:
		return soap_out_PointerTott__Capabilities(soap, tag, id, (struct tt__Capabilities *const*)ptr, "tt:Capabilities");
	case SOAP_TYPE_PointerTott__CapabilityCategory:
		return soap_out_PointerTott__CapabilityCategory(soap, tag, id, (enum tt__CapabilityCategory *const*)ptr, "tt:CapabilityCategory");
	case SOAP_TYPE_PointerTotds__DeviceServiceCapabilities:
		return soap_out_PointerTotds__DeviceServiceCapabilities(soap, tag, id, (struct tds__DeviceServiceCapabilities *const*)ptr, "tds:DeviceServiceCapabilities");
	case SOAP_TYPE_PointerTotds__Service:
		return soap_out_PointerTotds__Service(soap, tag, id, (struct tds__Service *const*)ptr, "tds:Service");
	case SOAP_TYPE_PointerTott__OnvifVersion:
		return soap_out_PointerTott__OnvifVersion(soap, tag, id, (struct tt__OnvifVersion *const*)ptr, "tt:OnvifVersion");
	case SOAP_TYPE_PointerTo_tds__Service_Capabilities:
		return soap_out_PointerTo_tds__Service_Capabilities(soap, tag, id, (struct _tds__Service_Capabilities *const*)ptr, "tds:Service-Capabilities");
	case SOAP_TYPE_wstop__SimpleTopicExpression:
		return soap_out_string(soap, tag, id, (char*const*)(void*)&ptr, "xsd:QName");
	case SOAP_TYPE_wstop__ConcreteTopicExpression:
		return soap_out_string(soap, tag, id, (char*const*)(void*)&ptr, "wstop:ConcreteTopicExpression");
	case SOAP_TYPE_wstop__FullTopicExpression:
		return soap_out_string(soap, tag, id, (char*const*)(void*)&ptr, "wstop:FullTopicExpression");
	case SOAP_TYPE_tt__IPv6Address:
		return soap_out_string(soap, tag, id, (char*const*)(void*)&ptr, "tt:IPv6Address");
	case SOAP_TYPE_tt__IPv4Address:
		return soap_out_string(soap, tag, id, (char*const*)(void*)&ptr, "tt:IPv4Address");
	case SOAP_TYPE_tt__TopicNamespaceLocation:
		return soap_out_string(soap, tag, id, (char*const*)(void*)&ptr, "tt:TopicNamespaceLocation");
	case SOAP_TYPE_tt__Name:
		return soap_out_string(soap, tag, id, (char*const*)(void*)&ptr, "tt:Name");
	case SOAP_TYPE_tt__ReferenceToken:
		return soap_out_string(soap, tag, id, (char*const*)(void*)&ptr, "tt:ReferenceToken");
	case SOAP_TYPE_wsnt__AbsoluteOrRelativeTimeType:
		return soap_out_string(soap, tag, id, (char*const*)(void*)&ptr, "wsnt:AbsoluteOrRelativeTimeType");
	case SOAP_TYPE_tt__StringAttrList:
		return soap_out_string(soap, tag, id, (char*const*)(void*)&ptr, "tt:StringAttrList");
	case SOAP_TYPE_tt__FloatAttrList:
		return soap_out_string(soap, tag, id, (char*const*)(void*)&ptr, "tt:FloatAttrList");
	case SOAP_TYPE_tt__IntAttrList:
		return soap_out_string(soap, tag, id, (char*const*)(void*)&ptr, "tt:IntAttrList");
	case SOAP_TYPE_tds__EAPMethodTypes:
		return soap_out_string(soap, tag, id, (char*const*)(void*)&ptr, "tds:EAPMethodTypes");
	case SOAP_TYPE__xml__lang:
		return soap_out_string(soap, "xml:lang", id, (char*const*)(void*)&ptr, "");
	case SOAP_TYPE_xsd__token:
		return soap_out_string(soap, tag, id, (char*const*)(void*)&ptr, "xsd:token");
	case SOAP_TYPE_xsd__nonNegativeInteger:
		return soap_out_string(soap, tag, id, (char*const*)(void*)&ptr, "xsd:nonNegativeInteger");
	case SOAP_TYPE_xsd__anyURI:
		return soap_out_string(soap, tag, id, (char*const*)(void*)&ptr, "xsd:anyURI");
	case SOAP_TYPE_xsd__anySimpleType:
		return soap_out_string(soap, tag, id, (char*const*)(void*)&ptr, "xsd:anySimpleType");
	case SOAP_TYPE_xsd__NCName:
		return soap_out_string(soap, tag, id, (char*const*)(void*)&ptr, "xsd:NCName");
	case SOAP_TYPE_PointerTo_wsse__Security:
		return soap_out_PointerTo_wsse__Security(soap, tag, id, (struct _wsse__Security *const*)ptr, "wsse:Security");
	case SOAP_TYPE_PointerTods__SignatureType:
		return soap_out_PointerTods__SignatureType(soap, tag, id, (struct ds__SignatureType *const*)ptr, "ds:SignatureType");
	case SOAP_TYPE_PointerTowsc__SecurityContextTokenType:
		return soap_out_PointerTowsc__SecurityContextTokenType(soap, tag, id, (struct wsc__SecurityContextTokenType *const*)ptr, "wsc:SecurityContextTokenType");
	case SOAP_TYPE_PointerTo_wsse__BinarySecurityToken:
		return soap_out_PointerTo_wsse__BinarySecurityToken(soap, tag, id, (struct _wsse__BinarySecurityToken *const*)ptr, "wsse:BinarySecurityToken");
	case SOAP_TYPE_PointerTo_wsse__UsernameToken:
		return soap_out_PointerTo_wsse__UsernameToken(soap, tag, id, (struct _wsse__UsernameToken *const*)ptr, "wsse:UsernameToken");
	case SOAP_TYPE_PointerTo_wsu__Timestamp:
		return soap_out_PointerTo_wsu__Timestamp(soap, tag, id, (struct _wsu__Timestamp *const*)ptr, "wsu:Timestamp");
	case SOAP_TYPE__saml2__AuthenticatingAuthority:
		return soap_out_string(soap, "saml2:AuthenticatingAuthority", id, (char*const*)(void*)&ptr, "");
	case SOAP_TYPE__saml2__AuthnContextDeclRef:
		return soap_out_string(soap, "saml2:AuthnContextDeclRef", id, (char*const*)(void*)&ptr, "");
	case SOAP_TYPE__saml2__AuthnContextClassRef:
		return soap_out_string(soap, "saml2:AuthnContextClassRef", id, (char*const*)(void*)&ptr, "");
	case SOAP_TYPE__saml2__Audience:
		return soap_out_string(soap, "saml2:Audience", id, (char*const*)(void*)&ptr, "");
	case SOAP_TYPE__saml2__AssertionURIRef:
		return soap_out_string(soap, "saml2:AssertionURIRef", id, (char*const*)(void*)&ptr, "");
	case SOAP_TYPE__saml2__AssertionIDRef:
		return soap_out_string(soap, "saml2:AssertionIDRef", id, (char*const*)(void*)&ptr, "");
	case SOAP_TYPE_PointerToPointerTo_ds__KeyInfo:
		return soap_out_PointerToPointerTo_ds__KeyInfo(soap, tag, id, (struct ds__KeyInfoType **const*)ptr, "ds:KeyInfo");
	case SOAP_TYPE_PointerTosaml2__AttributeType:
		return soap_out_PointerTosaml2__AttributeType(soap, tag, id, (struct saml2__AttributeType *const*)ptr, "saml2:AttributeType");
	case SOAP_TYPE_PointerTosaml2__EvidenceType:
		return soap_out_PointerTosaml2__EvidenceType(soap, tag, id, (struct saml2__EvidenceType *const*)ptr, "saml2:EvidenceType");
	case SOAP_TYPE_PointerTosaml2__ActionType:
		return soap_out_PointerTosaml2__ActionType(soap, tag, id, (struct saml2__ActionType *const*)ptr, "saml2:ActionType");
	case SOAP_TYPE_PointerTosaml2__AuthnContextType:
		return soap_out_PointerTosaml2__AuthnContextType(soap, tag, id, (struct saml2__AuthnContextType *const*)ptr, "saml2:AuthnContextType");
	case SOAP_TYPE_PointerTosaml2__SubjectLocalityType:
		return soap_out_PointerTosaml2__SubjectLocalityType(soap, tag, id, (struct saml2__SubjectLocalityType *const*)ptr, "saml2:SubjectLocalityType");
	case SOAP_TYPE_PointerTosaml2__AssertionType:
		return soap_out_PointerTosaml2__AssertionType(soap, tag, id, (struct saml2__AssertionType *const*)ptr, "saml2:AssertionType");
	case SOAP_TYPE_PointerTosaml2__ProxyRestrictionType:
		return soap_out_PointerTosaml2__ProxyRestrictionType(soap, tag, id, (struct saml2__ProxyRestrictionType *const*)ptr, "saml2:ProxyRestrictionType");
	case SOAP_TYPE_PointerTosaml2__OneTimeUseType:
		return soap_out_PointerTosaml2__OneTimeUseType(soap, tag, id, (struct saml2__OneTimeUseType *const*)ptr, "saml2:OneTimeUseType");
	case SOAP_TYPE_PointerTosaml2__AudienceRestrictionType:
		return soap_out_PointerTosaml2__AudienceRestrictionType(soap, tag, id, (struct saml2__AudienceRestrictionType *const*)ptr, "saml2:AudienceRestrictionType");
	case SOAP_TYPE_PointerTosaml2__ConditionAbstractType:
		return soap_out_PointerTosaml2__ConditionAbstractType(soap, tag, id, (struct saml2__ConditionAbstractType *const*)ptr, "saml2:ConditionAbstractType");
	case SOAP_TYPE_PointerTosaml2__SubjectConfirmationDataType:
		return soap_out_PointerTosaml2__SubjectConfirmationDataType(soap, tag, id, (struct saml2__SubjectConfirmationDataType *const*)ptr, "saml2:SubjectConfirmationDataType");
	case SOAP_TYPE_PointerTosaml2__SubjectConfirmationType:
		return soap_out_PointerTosaml2__SubjectConfirmationType(soap, tag, id, (struct saml2__SubjectConfirmationType *const*)ptr, "saml2:SubjectConfirmationType");
	case SOAP_TYPE_PointerTosaml2__EncryptedElementType:
		return soap_out_PointerTosaml2__EncryptedElementType(soap, tag, id, (struct saml2__EncryptedElementType *const*)ptr, "saml2:EncryptedElementType");
	case SOAP_TYPE_PointerTosaml2__BaseIDAbstractType:
		return soap_out_PointerTosaml2__BaseIDAbstractType(soap, tag, id, (struct saml2__BaseIDAbstractType *const*)ptr, "saml2:BaseIDAbstractType");
	case SOAP_TYPE_PointerTosaml2__AttributeStatementType:
		return soap_out_PointerTosaml2__AttributeStatementType(soap, tag, id, (struct saml2__AttributeStatementType *const*)ptr, "saml2:AttributeStatementType");
	case SOAP_TYPE_PointerTosaml2__AuthzDecisionStatementType:
		return soap_out_PointerTosaml2__AuthzDecisionStatementType(soap, tag, id, (struct saml2__AuthzDecisionStatementType *const*)ptr, "saml2:AuthzDecisionStatementType");
	case SOAP_TYPE_PointerTosaml2__AuthnStatementType:
		return soap_out_PointerTosaml2__AuthnStatementType(soap, tag, id, (struct saml2__AuthnStatementType *const*)ptr, "saml2:AuthnStatementType");
	case SOAP_TYPE_PointerTosaml2__StatementAbstractType:
		return soap_out_PointerTosaml2__StatementAbstractType(soap, tag, id, (struct saml2__StatementAbstractType *const*)ptr, "saml2:StatementAbstractType");
	case SOAP_TYPE_PointerTosaml2__AdviceType:
		return soap_out_PointerTosaml2__AdviceType(soap, tag, id, (struct saml2__AdviceType *const*)ptr, "saml2:AdviceType");
	case SOAP_TYPE_PointerTosaml2__ConditionsType:
		return soap_out_PointerTosaml2__ConditionsType(soap, tag, id, (struct saml2__ConditionsType *const*)ptr, "saml2:ConditionsType");
	case SOAP_TYPE_PointerTosaml2__SubjectType:
		return soap_out_PointerTosaml2__SubjectType(soap, tag, id, (struct saml2__SubjectType *const*)ptr, "saml2:SubjectType");
	case SOAP_TYPE_PointerTosaml2__NameIDType:
		return soap_out_PointerTosaml2__NameIDType(soap, tag, id, (struct saml2__NameIDType *const*)ptr, "saml2:NameIDType");
	case SOAP_TYPE_PointerToPointerToxenc__EncryptedKeyType:
		return soap_out_PointerToPointerToxenc__EncryptedKeyType(soap, tag, id, (struct xenc__EncryptedKeyType **const*)ptr, "xenc:EncryptedKeyType");
	case SOAP_TYPE__saml1__ConfirmationMethod:
		return soap_out_string(soap, "saml1:ConfirmationMethod", id, (char*const*)(void*)&ptr, "");
	case SOAP_TYPE__saml1__Audience:
		return soap_out_string(soap, "saml1:Audience", id, (char*const*)(void*)&ptr, "");
	case SOAP_TYPE__saml1__AssertionIDReference:
		return soap_out_string(soap, "saml1:AssertionIDReference", id, (char*const*)(void*)&ptr, "");
	case SOAP_TYPE_PointerTosaml1__AttributeType:
		return soap_out_PointerTosaml1__AttributeType(soap, tag, id, (struct saml1__AttributeType *const*)ptr, "saml1:AttributeType");
	case SOAP_TYPE_PointerTosaml1__EvidenceType:
		return soap_out_PointerTosaml1__EvidenceType(soap, tag, id, (struct saml1__EvidenceType *const*)ptr, "saml1:EvidenceType");
	case SOAP_TYPE_PointerTosaml1__ActionType:
		return soap_out_PointerTosaml1__ActionType(soap, tag, id, (struct saml1__ActionType *const*)ptr, "saml1:ActionType");
	case SOAP_TYPE_PointerTosaml1__AuthorityBindingType:
		return soap_out_PointerTosaml1__AuthorityBindingType(soap, tag, id, (struct saml1__AuthorityBindingType *const*)ptr, "saml1:AuthorityBindingType");
	case SOAP_TYPE_PointerTosaml1__SubjectLocalityType:
		return soap_out_PointerTosaml1__SubjectLocalityType(soap, tag, id, (struct saml1__SubjectLocalityType *const*)ptr, "saml1:SubjectLocalityType");
	case SOAP_TYPE_PointerTosaml1__SubjectType:
		return soap_out_PointerTosaml1__SubjectType(soap, tag, id, (struct saml1__SubjectType *const*)ptr, "saml1:SubjectType");
	case SOAP_TYPE_PointerTostring:
		return soap_out_PointerTostring(soap, tag, id, (char **const*)ptr, "xsd:string");
	case SOAP_TYPE_PointerTosaml1__SubjectConfirmationType:
		return soap_out_PointerTosaml1__SubjectConfirmationType(soap, tag, id, (struct saml1__SubjectConfirmationType *const*)ptr, "saml1:SubjectConfirmationType");
	case SOAP_TYPE_PointerTosaml1__NameIdentifierType:
		return soap_out_PointerTosaml1__NameIdentifierType(soap, tag, id, (struct saml1__NameIdentifierType *const*)ptr, "saml1:NameIdentifierType");
	case SOAP_TYPE_PointerTosaml1__AssertionType:
		return soap_out_PointerTosaml1__AssertionType(soap, tag, id, (struct saml1__AssertionType *const*)ptr, "saml1:AssertionType");
	case SOAP_TYPE_PointerToxsd__dateTime:
		return soap_out_PointerToxsd__dateTime(soap, tag, id, (struct timeval *const*)ptr, "xsd:dateTime");
	case SOAP_TYPE_PointerTosaml1__ConditionAbstractType:
		return soap_out_PointerTosaml1__ConditionAbstractType(soap, tag, id, (struct saml1__ConditionAbstractType *const*)ptr, "saml1:ConditionAbstractType");
	case SOAP_TYPE_PointerTosaml1__DoNotCacheConditionType:
		return soap_out_PointerTosaml1__DoNotCacheConditionType(soap, tag, id, (struct saml1__DoNotCacheConditionType *const*)ptr, "saml1:DoNotCacheConditionType");
	case SOAP_TYPE_PointerTosaml1__AudienceRestrictionConditionType:
		return soap_out_PointerTosaml1__AudienceRestrictionConditionType(soap, tag, id, (struct saml1__AudienceRestrictionConditionType *const*)ptr, "saml1:AudienceRestrictionConditionType");
	case SOAP_TYPE_PointerTo_ds__Signature:
		return soap_out_PointerTo_ds__Signature(soap, tag, id, (struct ds__SignatureType *const*)ptr, "ds:Signature");
	case SOAP_TYPE_PointerTosaml1__AttributeStatementType:
		return soap_out_PointerTosaml1__AttributeStatementType(soap, tag, id, (struct saml1__AttributeStatementType *const*)ptr, "saml1:AttributeStatementType");
	case SOAP_TYPE_PointerTosaml1__AuthorizationDecisionStatementType:
		return soap_out_PointerTosaml1__AuthorizationDecisionStatementType(soap, tag, id, (struct saml1__AuthorizationDecisionStatementType *const*)ptr, "saml1:AuthorizationDecisionStatementType");
	case SOAP_TYPE_PointerTosaml1__AuthenticationStatementType:
		return soap_out_PointerTosaml1__AuthenticationStatementType(soap, tag, id, (struct saml1__AuthenticationStatementType *const*)ptr, "saml1:AuthenticationStatementType");
	case SOAP_TYPE_PointerTosaml1__SubjectStatementAbstractType:
		return soap_out_PointerTosaml1__SubjectStatementAbstractType(soap, tag, id, (struct saml1__SubjectStatementAbstractType *const*)ptr, "saml1:SubjectStatementAbstractType");
	case SOAP_TYPE_PointerTosaml1__StatementAbstractType:
		return soap_out_PointerTosaml1__StatementAbstractType(soap, tag, id, (struct saml1__StatementAbstractType *const*)ptr, "saml1:StatementAbstractType");
	case SOAP_TYPE_PointerTosaml1__AdviceType:
		return soap_out_PointerTosaml1__AdviceType(soap, tag, id, (struct saml1__AdviceType *const*)ptr, "saml1:AdviceType");
	case SOAP_TYPE_PointerTosaml1__ConditionsType:
		return soap_out_PointerTosaml1__ConditionsType(soap, tag, id, (struct saml1__ConditionsType *const*)ptr, "saml1:ConditionsType");
	case SOAP_TYPE_PointerToULONG64:
		return soap_out_PointerToULONG64(soap, tag, id, (ULONG64 *const*)ptr, "xsd:unsignedLong");
	case SOAP_TYPE_PointerTowsc__PropertiesType:
		return soap_out_PointerTowsc__PropertiesType(soap, tag, id, (struct wsc__PropertiesType *const*)ptr, "wsc:PropertiesType");
	case SOAP_TYPE_wsc__FaultCodeOpenEnumType:
		return soap_out_string(soap, tag, id, (char*const*)(void*)&ptr, "wsc:FaultCodeOpenEnumType");
	case SOAP_TYPE_PointerTo_xenc__ReferenceList:
		return soap_out_PointerTo_xenc__ReferenceList(soap, tag, id, (struct _xenc__ReferenceList *const*)ptr, "xenc:ReferenceList");
	case SOAP_TYPE_PointerToxenc__ReferenceType:
		return soap_out_PointerToxenc__ReferenceType(soap, tag, id, (struct xenc__ReferenceType *const*)ptr, "xenc:ReferenceType");
	case SOAP_TYPE_PointerToxenc__EncryptionPropertyType:
		return soap_out_PointerToxenc__EncryptionPropertyType(soap, tag, id, (struct xenc__EncryptionPropertyType *const*)ptr, "xenc:EncryptionPropertyType");
	case SOAP_TYPE_PointerToxenc__TransformsType:
		return soap_out_PointerToxenc__TransformsType(soap, tag, id, (struct xenc__TransformsType *const*)ptr, "xenc:TransformsType");
	case SOAP_TYPE_PointerToxenc__CipherReferenceType:
		return soap_out_PointerToxenc__CipherReferenceType(soap, tag, id, (struct xenc__CipherReferenceType *const*)ptr, "xenc:CipherReferenceType");
	case SOAP_TYPE_PointerToxenc__EncryptionPropertiesType:
		return soap_out_PointerToxenc__EncryptionPropertiesType(soap, tag, id, (struct xenc__EncryptionPropertiesType *const*)ptr, "xenc:EncryptionPropertiesType");
	case SOAP_TYPE_PointerToxenc__CipherDataType:
		return soap_out_PointerToxenc__CipherDataType(soap, tag, id, (struct xenc__CipherDataType *const*)ptr, "xenc:CipherDataType");
	case SOAP_TYPE_PointerTo_ds__KeyInfo:
		return soap_out_PointerTo_ds__KeyInfo(soap, tag, id, (struct ds__KeyInfoType *const*)ptr, "ds:KeyInfo");
	case SOAP_TYPE_PointerToxenc__EncryptionMethodType:
		return soap_out_PointerToxenc__EncryptionMethodType(soap, tag, id, (struct xenc__EncryptionMethodType *const*)ptr, "xenc:EncryptionMethodType");
	case SOAP_TYPE_PointerTods__X509IssuerSerialType:
		return soap_out_PointerTods__X509IssuerSerialType(soap, tag, id, (struct ds__X509IssuerSerialType *const*)ptr, "ds:X509IssuerSerialType");
	case SOAP_TYPE_PointerTods__RSAKeyValueType:
		return soap_out_PointerTods__RSAKeyValueType(soap, tag, id, (struct ds__RSAKeyValueType *const*)ptr, "ds:RSAKeyValueType");
	case SOAP_TYPE_PointerTods__DSAKeyValueType:
		return soap_out_PointerTods__DSAKeyValueType(soap, tag, id, (struct ds__DSAKeyValueType *const*)ptr, "ds:DSAKeyValueType");
	case SOAP_TYPE_PointerTods__TransformType:
		return soap_out_PointerTods__TransformType(soap, tag, id, (struct ds__TransformType *const*)ptr, "ds:TransformType");
	case SOAP_TYPE_PointerTods__DigestMethodType:
		return soap_out_PointerTods__DigestMethodType(soap, tag, id, (struct ds__DigestMethodType *const*)ptr, "ds:DigestMethodType");
	case SOAP_TYPE_PointerTods__TransformsType:
		return soap_out_PointerTods__TransformsType(soap, tag, id, (struct ds__TransformsType *const*)ptr, "ds:TransformsType");
	case SOAP_TYPE_PointerToPointerTods__ReferenceType:
		return soap_out_PointerToPointerTods__ReferenceType(soap, tag, id, (struct ds__ReferenceType **const*)ptr, "ds:ReferenceType");
	case SOAP_TYPE_PointerTods__ReferenceType:
		return soap_out_PointerTods__ReferenceType(soap, tag, id, (struct ds__ReferenceType *const*)ptr, "ds:ReferenceType");
	case SOAP_TYPE_PointerTods__SignatureMethodType:
		return soap_out_PointerTods__SignatureMethodType(soap, tag, id, (struct ds__SignatureMethodType *const*)ptr, "ds:SignatureMethodType");
	case SOAP_TYPE_PointerTods__CanonicalizationMethodType:
		return soap_out_PointerTods__CanonicalizationMethodType(soap, tag, id, (struct ds__CanonicalizationMethodType *const*)ptr, "ds:CanonicalizationMethodType");
	case SOAP_TYPE_PointerTo_wsse__SecurityTokenReference:
		return soap_out_PointerTo_wsse__SecurityTokenReference(soap, tag, id, (struct _wsse__SecurityTokenReference *const*)ptr, "wsse:SecurityTokenReference");
	case SOAP_TYPE_PointerTods__RetrievalMethodType:
		return soap_out_PointerTods__RetrievalMethodType(soap, tag, id, (struct ds__RetrievalMethodType *const*)ptr, "ds:RetrievalMethodType");
	case SOAP_TYPE_PointerTods__KeyValueType:
		return soap_out_PointerTods__KeyValueType(soap, tag, id, (struct ds__KeyValueType *const*)ptr, "ds:KeyValueType");
	case SOAP_TYPE_PointerTo_c14n__InclusiveNamespaces:
		return soap_out_PointerTo_c14n__InclusiveNamespaces(soap, tag, id, (struct _c14n__InclusiveNamespaces *const*)ptr, "c14n:InclusiveNamespaces");
	case SOAP_TYPE_PointerTods__KeyInfoType:
		return soap_out_PointerTods__KeyInfoType(soap, tag, id, (struct ds__KeyInfoType *const*)ptr, "ds:KeyInfoType");
	case SOAP_TYPE_PointerTods__SignedInfoType:
		return soap_out_PointerTods__SignedInfoType(soap, tag, id, (struct ds__SignedInfoType *const*)ptr, "ds:SignedInfoType");
	case SOAP_TYPE__ds__SignatureValue:
		return soap_out_string(soap, "ds:SignatureValue", id, (char*const*)(void*)&ptr, "");
	case SOAP_TYPE_PointerToxenc__EncryptedKeyType:
		return soap_out_PointerToxenc__EncryptedKeyType(soap, tag, id, (struct xenc__EncryptedKeyType *const*)ptr, "xenc:EncryptedKeyType");
	case SOAP_TYPE_PointerTods__X509DataType:
		return soap_out_PointerTods__X509DataType(soap, tag, id, (struct ds__X509DataType *const*)ptr, "ds:X509DataType");
	case SOAP_TYPE_PointerTo_wsse__Embedded:
		return soap_out_PointerTo_wsse__Embedded(soap, tag, id, (struct _wsse__Embedded *const*)ptr, "wsse:Embedded");
	case SOAP_TYPE_PointerTo_wsse__KeyIdentifier:
		return soap_out_PointerTo_wsse__KeyIdentifier(soap, tag, id, (struct _wsse__KeyIdentifier *const*)ptr, "wsse:KeyIdentifier");
	case SOAP_TYPE_PointerTo_wsse__Reference:
		return soap_out_PointerTo_wsse__Reference(soap, tag, id, (struct _wsse__Reference *const*)ptr, "wsse:Reference");
	case SOAP_TYPE_PointerTowsse__EncodedString:
		return soap_out_PointerTowsse__EncodedString(soap, tag, id, (struct wsse__EncodedString *const*)ptr, "wsse:EncodedString");
	case SOAP_TYPE_PointerTo_wsse__Password:
		return soap_out_PointerTo_wsse__Password(soap, tag, id, (struct _wsse__Password *const*)ptr, "wsse:Password");
	case SOAP_TYPE_PointerTochan__ChannelInstanceType:
		return soap_out_PointerTochan__ChannelInstanceType(soap, tag, id, (struct chan__ChannelInstanceType *const*)ptr, "chan:ChannelInstanceType");
	case SOAP_TYPE_PointerTo_wsa5__FaultTo:
		return soap_out_PointerTo_wsa5__FaultTo(soap, tag, id, (struct wsa5__EndpointReferenceType *const*)ptr, "wsa5:FaultTo");
	case SOAP_TYPE_PointerTo_wsa5__ReplyTo:
		return soap_out_PointerTo_wsa5__ReplyTo(soap, tag, id, (struct wsa5__EndpointReferenceType *const*)ptr, "wsa5:ReplyTo");
	case SOAP_TYPE_PointerTo_wsa5__From:
		return soap_out_PointerTo_wsa5__From(soap, tag, id, (struct wsa5__EndpointReferenceType *const*)ptr, "wsa5:From");
	case SOAP_TYPE_PointerTo_wsa5__RelatesTo:
		return soap_out_PointerTo_wsa5__RelatesTo(soap, tag, id, (struct wsa5__RelatesToType *const*)ptr, "wsa5:RelatesTo");
	case SOAP_TYPE__wsa5__ProblemIRI:
		return soap_out_string(soap, "wsa5:ProblemIRI", id, (char*const*)(void*)&ptr, "");
	case SOAP_TYPE__wsa5__ProblemHeaderQName:
		return soap_out_string(soap, tag, id, (char*const*)(void*)&ptr, "xsd:QName");
	case SOAP_TYPE__wsa5__Action:
		return soap_out_string(soap, "wsa5:Action", id, (char*const*)(void*)&ptr, "");
	case SOAP_TYPE__wsa5__To:
		return soap_out_string(soap, "wsa5:To", id, (char*const*)(void*)&ptr, "");
	case SOAP_TYPE__wsa5__MessageID:
		return soap_out_string(soap, "wsa5:MessageID", id, (char*const*)(void*)&ptr, "");
	case SOAP_TYPE_PointerToint:
		return soap_out_PointerToint(soap, tag, id, (int *const*)ptr, "xsd:int");
	case SOAP_TYPE_PointerTowsa5__MetadataType:
		return soap_out_PointerTowsa5__MetadataType(soap, tag, id, (struct wsa5__MetadataType *const*)ptr, "wsa5:MetadataType");
	case SOAP_TYPE_PointerTowsa5__ReferenceParametersType:
		return soap_out_PointerTowsa5__ReferenceParametersType(soap, tag, id, (struct wsa5__ReferenceParametersType *const*)ptr, "wsa5:ReferenceParametersType");
	case SOAP_TYPE_wsa5__FaultCodesOpenEnumType:
		return soap_out_string(soap, tag, id, (char*const*)(void*)&ptr, "wsa5:FaultCodesOpenEnumType");
	case SOAP_TYPE_wsa5__RelationshipTypeOpenEnum:
		return soap_out_string(soap, tag, id, (char*const*)(void*)&ptr, "wsa5:RelationshipTypeOpenEnum");
	case SOAP_TYPE_PointerTowsdd__ResolveMatchesType:
		return soap_out_PointerTowsdd__ResolveMatchesType(soap, tag, id, (struct wsdd__ResolveMatchesType *const*)ptr, "wsdd:ResolveMatchesType");
	case SOAP_TYPE_PointerTowsdd__ResolveType:
		return soap_out_PointerTowsdd__ResolveType(soap, tag, id, (struct wsdd__ResolveType *const*)ptr, "wsdd:ResolveType");
	case SOAP_TYPE_PointerTowsdd__ProbeMatchesType:
		return soap_out_PointerTowsdd__ProbeMatchesType(soap, tag, id, (struct wsdd__ProbeMatchesType *const*)ptr, "wsdd:ProbeMatchesType");
	case SOAP_TYPE_PointerTowsdd__ProbeType:
		return soap_out_PointerTowsdd__ProbeType(soap, tag, id, (struct wsdd__ProbeType *const*)ptr, "wsdd:ProbeType");
	case SOAP_TYPE_PointerTowsdd__ByeType:
		return soap_out_PointerTowsdd__ByeType(soap, tag, id, (struct wsdd__ByeType *const*)ptr, "wsdd:ByeType");
	case SOAP_TYPE_PointerTowsdd__HelloType:
		return soap_out_PointerTowsdd__HelloType(soap, tag, id, (struct wsdd__HelloType *const*)ptr, "wsdd:HelloType");
	case SOAP_TYPE_PointerTowsdd__AppSequenceType:
		return soap_out_PointerTowsdd__AppSequenceType(soap, tag, id, (struct wsdd__AppSequenceType *const*)ptr, "wsdd:AppSequenceType");
	case SOAP_TYPE__wsdd__Id:
		return soap_out_string(soap, "wsdd:Id", id, (char*const*)(void*)&ptr, "");
	case SOAP_TYPE__wsdd__SupportedMatchingRules:
		return soap_out_string(soap, "wsdd:SupportedMatchingRules", id, (char*const*)(void*)&ptr, "");
	case SOAP_TYPE__wsdd__XAddrs:
		return soap_out_string(soap, "wsdd:XAddrs", id, (char*const*)(void*)&ptr, "");
	case SOAP_TYPE__wsdd__Types:
		return soap_out_string(soap, tag, id, (char*const*)(void*)&ptr, "xsd:QName");
	case SOAP_TYPE_PointerTowsdd__SigType:
		return soap_out_PointerTowsdd__SigType(soap, tag, id, (struct wsdd__SigType *const*)ptr, "wsdd:SigType");
	case SOAP_TYPE_PointerTowsdd__ResolveMatchType:
		return soap_out_PointerTowsdd__ResolveMatchType(soap, tag, id, (struct wsdd__ResolveMatchType *const*)ptr, "wsdd:ResolveMatchType");
	case SOAP_TYPE_PointerTowsdd__ProbeMatchType:
		return soap_out_PointerTowsdd__ProbeMatchType(soap, tag, id, (struct wsdd__ProbeMatchType *const*)ptr, "wsdd:ProbeMatchType");
	case SOAP_TYPE_PointerTounsignedInt:
		return soap_out_PointerTounsignedInt(soap, tag, id, (unsigned int *const*)ptr, "xsd:unsignedInt");
	case SOAP_TYPE_PointerTowsdd__ScopesType:
		return soap_out_PointerTowsdd__ScopesType(soap, tag, id, (struct wsdd__ScopesType *const*)ptr, "wsdd:ScopesType");
	case SOAP_TYPE_wsdd__FaultCodeOpenType:
		return soap_out_string(soap, tag, id, (char*const*)(void*)&ptr, "wsdd:FaultCodeOpenType");
	case SOAP_TYPE_wsdd__UriListType:
		return soap_out_string(soap, tag, id, (char*const*)(void*)&ptr, "wsdd:UriListType");
	case SOAP_TYPE_wsdd__QNameListType:
		return soap_out_string(soap, tag, id, (char*const*)(void*)&ptr, "xsd:QName");
	case SOAP_TYPE_PointerTo_wsa__FaultTo:
		return soap_out_PointerTo_wsa__FaultTo(soap, tag, id, (struct wsa__EndpointReferenceType *const*)ptr, "wsa:FaultTo");
	case SOAP_TYPE_PointerTo_wsa__ReplyTo:
		return soap_out_PointerTo_wsa__ReplyTo(soap, tag, id, (struct wsa__EndpointReferenceType *const*)ptr, "wsa:ReplyTo");
	case SOAP_TYPE_PointerTo_wsa__From:
		return soap_out_PointerTo_wsa__From(soap, tag, id, (struct wsa__EndpointReferenceType *const*)ptr, "wsa:From");
	case SOAP_TYPE_PointerTo_wsa__RelatesTo:
		return soap_out_PointerTo_wsa__RelatesTo(soap, tag, id, (struct wsa__Relationship *const*)ptr, "wsa:RelatesTo");
	case SOAP_TYPE__wsa__Action:
		return soap_out_string(soap, "wsa:Action", id, (char*const*)(void*)&ptr, "");
	case SOAP_TYPE__wsa__To:
		return soap_out_string(soap, "wsa:To", id, (char*const*)(void*)&ptr, "");
	case SOAP_TYPE__wsa__MessageID:
		return soap_out_string(soap, "wsa:MessageID", id, (char*const*)(void*)&ptr, "");
	case SOAP_TYPE_PointerTowsa__ServiceNameType:
		return soap_out_PointerTowsa__ServiceNameType(soap, tag, id, (struct wsa__ServiceNameType *const*)ptr, "wsa:ServiceNameType");
	case SOAP_TYPE_PointerTo_QName:
		return soap_out_PointerTo_QName(soap, tag, id, (char **const*)ptr, "xsd:QName");
	case SOAP_TYPE_PointerTowsa__ReferenceParametersType:
		return soap_out_PointerTowsa__ReferenceParametersType(soap, tag, id, (struct wsa__ReferenceParametersType *const*)ptr, "wsa:ReferenceParametersType");
	case SOAP_TYPE_PointerTowsa__ReferencePropertiesType:
		return soap_out_PointerTowsa__ReferencePropertiesType(soap, tag, id, (struct wsa__ReferencePropertiesType *const*)ptr, "wsa:ReferencePropertiesType");
	case SOAP_TYPE__QName:
		return soap_out_string(soap, tag, id, (char*const*)(void*)&ptr, "xsd:QName");
	case SOAP_TYPE_string:
		return soap_out_string(soap, tag, id, (char*const*)(void*)&ptr, "xsd:string");
	case 0:
		return SOAP_OK;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_putelement '%s' failed for type %d in soapC.c\n", tag ? tag : "", type));
	return soap_element_empty(soap, tag, 0, NULL); /* unknown type to serialize */
}

#ifndef WITH_NOIDREF
SOAP_FMAC3 void SOAP_FMAC4 soap_markelement(struct soap *soap, const void *ptr, int type)
{
	(void)soap; (void)ptr; (void)type; /* appease -Wall -Werror */
	switch (type)
	{
	case SOAP_TYPE___trt__GetSnapshotUri:
		soap_serialize___trt__GetSnapshotUri(soap, (const struct __trt__GetSnapshotUri *)ptr);
		break;
	case SOAP_TYPE___trt__GetProfiles:
		soap_serialize___trt__GetProfiles(soap, (const struct __trt__GetProfiles *)ptr);
		break;
	case SOAP_TYPE___trt__GetProfile:
		soap_serialize___trt__GetProfile(soap, (const struct __trt__GetProfile *)ptr);
		break;
	case SOAP_TYPE___trt__CreateProfile:
		soap_serialize___trt__CreateProfile(soap, (const struct __trt__CreateProfile *)ptr);
		break;
	case SOAP_TYPE___trt__GetServiceCapabilities:
		soap_serialize___trt__GetServiceCapabilities(soap, (const struct __trt__GetServiceCapabilities *)ptr);
		break;
	case SOAP_TYPE___tds__GetCapabilities:
		soap_serialize___tds__GetCapabilities(soap, (const struct __tds__GetCapabilities *)ptr);
		break;
	case SOAP_TYPE___tds__SystemReboot:
		soap_serialize___tds__SystemReboot(soap, (const struct __tds__SystemReboot *)ptr);
		break;
	case SOAP_TYPE___tds__GetDeviceInformation:
		soap_serialize___tds__GetDeviceInformation(soap, (const struct __tds__GetDeviceInformation *)ptr);
		break;
	case SOAP_TYPE___tds__GetServiceCapabilities:
		soap_serialize___tds__GetServiceCapabilities(soap, (const struct __tds__GetServiceCapabilities *)ptr);
		break;
	case SOAP_TYPE___tds__GetServices:
		soap_serialize___tds__GetServices(soap, (const struct __tds__GetServices *)ptr);
		break;
	case SOAP_TYPE___tdn__Probe:
		soap_serialize___tdn__Probe(soap, (const struct __tdn__Probe *)ptr);
		break;
	case SOAP_TYPE___tdn__Bye:
		soap_serialize___tdn__Bye(soap, (const struct __tdn__Bye *)ptr);
		break;
	case SOAP_TYPE___tdn__Hello:
		soap_serialize___tdn__Hello(soap, (const struct __tdn__Hello *)ptr);
		break;
	case SOAP_TYPE_wstop__TopicType:
		soap_serialize_wstop__TopicType(soap, (const struct wstop__TopicType *)ptr);
		break;
	case SOAP_TYPE__wstop__TopicNamespaceType_Topic:
		soap_serialize__wstop__TopicNamespaceType_Topic(soap, (const struct _wstop__TopicNamespaceType_Topic *)ptr);
		break;
	case SOAP_TYPE_wstop__TopicNamespaceType:
		soap_serialize_wstop__TopicNamespaceType(soap, (const struct wstop__TopicNamespaceType *)ptr);
		break;
	case SOAP_TYPE__wsnt__ResumeFailedFaultType_FaultCause:
		soap_serialize__wsnt__ResumeFailedFaultType_FaultCause(soap, (const struct _wsnt__ResumeFailedFaultType_FaultCause *)ptr);
		break;
	case SOAP_TYPE__wsnt__ResumeFailedFaultType_Description:
		soap_serialize__wsnt__ResumeFailedFaultType_Description(soap, (const struct _wsnt__ResumeFailedFaultType_Description *)ptr);
		break;
	case SOAP_TYPE__wsnt__ResumeFailedFaultType_ErrorCode:
		soap_serialize__wsnt__ResumeFailedFaultType_ErrorCode(soap, (const struct _wsnt__ResumeFailedFaultType_ErrorCode *)ptr);
		break;
	case SOAP_TYPE_wsnt__ResumeFailedFaultType:
		soap_serialize_wsnt__ResumeFailedFaultType(soap, (const struct wsnt__ResumeFailedFaultType *)ptr);
		break;
	case SOAP_TYPE__wsnt__PauseFailedFaultType_FaultCause:
		soap_serialize__wsnt__PauseFailedFaultType_FaultCause(soap, (const struct _wsnt__PauseFailedFaultType_FaultCause *)ptr);
		break;
	case SOAP_TYPE__wsnt__PauseFailedFaultType_Description:
		soap_serialize__wsnt__PauseFailedFaultType_Description(soap, (const struct _wsnt__PauseFailedFaultType_Description *)ptr);
		break;
	case SOAP_TYPE__wsnt__PauseFailedFaultType_ErrorCode:
		soap_serialize__wsnt__PauseFailedFaultType_ErrorCode(soap, (const struct _wsnt__PauseFailedFaultType_ErrorCode *)ptr);
		break;
	case SOAP_TYPE_wsnt__PauseFailedFaultType:
		soap_serialize_wsnt__PauseFailedFaultType(soap, (const struct wsnt__PauseFailedFaultType *)ptr);
		break;
	case SOAP_TYPE__wsnt__UnableToDestroySubscriptionFaultType_FaultCause:
		soap_serialize__wsnt__UnableToDestroySubscriptionFaultType_FaultCause(soap, (const struct _wsnt__UnableToDestroySubscriptionFaultType_FaultCause *)ptr);
		break;
	case SOAP_TYPE__wsnt__UnableToDestroySubscriptionFaultType_Description:
		soap_serialize__wsnt__UnableToDestroySubscriptionFaultType_Description(soap, (const struct _wsnt__UnableToDestroySubscriptionFaultType_Description *)ptr);
		break;
	case SOAP_TYPE__wsnt__UnableToDestroySubscriptionFaultType_ErrorCode:
		soap_serialize__wsnt__UnableToDestroySubscriptionFaultType_ErrorCode(soap, (const struct _wsnt__UnableToDestroySubscriptionFaultType_ErrorCode *)ptr);
		break;
	case SOAP_TYPE_wsnt__UnableToDestroySubscriptionFaultType:
		soap_serialize_wsnt__UnableToDestroySubscriptionFaultType(soap, (const struct wsnt__UnableToDestroySubscriptionFaultType *)ptr);
		break;
	case SOAP_TYPE__wsnt__UnacceptableTerminationTimeFaultType_FaultCause:
		soap_serialize__wsnt__UnacceptableTerminationTimeFaultType_FaultCause(soap, (const struct _wsnt__UnacceptableTerminationTimeFaultType_FaultCause *)ptr);
		break;
	case SOAP_TYPE__wsnt__UnacceptableTerminationTimeFaultType_Description:
		soap_serialize__wsnt__UnacceptableTerminationTimeFaultType_Description(soap, (const struct _wsnt__UnacceptableTerminationTimeFaultType_Description *)ptr);
		break;
	case SOAP_TYPE__wsnt__UnacceptableTerminationTimeFaultType_ErrorCode:
		soap_serialize__wsnt__UnacceptableTerminationTimeFaultType_ErrorCode(soap, (const struct _wsnt__UnacceptableTerminationTimeFaultType_ErrorCode *)ptr);
		break;
	case SOAP_TYPE_wsnt__UnacceptableTerminationTimeFaultType:
		soap_serialize_wsnt__UnacceptableTerminationTimeFaultType(soap, (const struct wsnt__UnacceptableTerminationTimeFaultType *)ptr);
		break;
	case SOAP_TYPE__wsnt__UnableToCreatePullPointFaultType_FaultCause:
		soap_serialize__wsnt__UnableToCreatePullPointFaultType_FaultCause(soap, (const struct _wsnt__UnableToCreatePullPointFaultType_FaultCause *)ptr);
		break;
	case SOAP_TYPE__wsnt__UnableToCreatePullPointFaultType_Description:
		soap_serialize__wsnt__UnableToCreatePullPointFaultType_Description(soap, (const struct _wsnt__UnableToCreatePullPointFaultType_Description *)ptr);
		break;
	case SOAP_TYPE__wsnt__UnableToCreatePullPointFaultType_ErrorCode:
		soap_serialize__wsnt__UnableToCreatePullPointFaultType_ErrorCode(soap, (const struct _wsnt__UnableToCreatePullPointFaultType_ErrorCode *)ptr);
		break;
	case SOAP_TYPE_wsnt__UnableToCreatePullPointFaultType:
		soap_serialize_wsnt__UnableToCreatePullPointFaultType(soap, (const struct wsnt__UnableToCreatePullPointFaultType *)ptr);
		break;
	case SOAP_TYPE__wsnt__UnableToDestroyPullPointFaultType_FaultCause:
		soap_serialize__wsnt__UnableToDestroyPullPointFaultType_FaultCause(soap, (const struct _wsnt__UnableToDestroyPullPointFaultType_FaultCause *)ptr);
		break;
	case SOAP_TYPE__wsnt__UnableToDestroyPullPointFaultType_Description:
		soap_serialize__wsnt__UnableToDestroyPullPointFaultType_Description(soap, (const struct _wsnt__UnableToDestroyPullPointFaultType_Description *)ptr);
		break;
	case SOAP_TYPE__wsnt__UnableToDestroyPullPointFaultType_ErrorCode:
		soap_serialize__wsnt__UnableToDestroyPullPointFaultType_ErrorCode(soap, (const struct _wsnt__UnableToDestroyPullPointFaultType_ErrorCode *)ptr);
		break;
	case SOAP_TYPE_wsnt__UnableToDestroyPullPointFaultType:
		soap_serialize_wsnt__UnableToDestroyPullPointFaultType(soap, (const struct wsnt__UnableToDestroyPullPointFaultType *)ptr);
		break;
	case SOAP_TYPE__wsnt__UnableToGetMessagesFaultType_FaultCause:
		soap_serialize__wsnt__UnableToGetMessagesFaultType_FaultCause(soap, (const struct _wsnt__UnableToGetMessagesFaultType_FaultCause *)ptr);
		break;
	case SOAP_TYPE__wsnt__UnableToGetMessagesFaultType_Description:
		soap_serialize__wsnt__UnableToGetMessagesFaultType_Description(soap, (const struct _wsnt__UnableToGetMessagesFaultType_Description *)ptr);
		break;
	case SOAP_TYPE__wsnt__UnableToGetMessagesFaultType_ErrorCode:
		soap_serialize__wsnt__UnableToGetMessagesFaultType_ErrorCode(soap, (const struct _wsnt__UnableToGetMessagesFaultType_ErrorCode *)ptr);
		break;
	case SOAP_TYPE_wsnt__UnableToGetMessagesFaultType:
		soap_serialize_wsnt__UnableToGetMessagesFaultType(soap, (const struct wsnt__UnableToGetMessagesFaultType *)ptr);
		break;
	case SOAP_TYPE__wsnt__NoCurrentMessageOnTopicFaultType_FaultCause:
		soap_serialize__wsnt__NoCurrentMessageOnTopicFaultType_FaultCause(soap, (const struct _wsnt__NoCurrentMessageOnTopicFaultType_FaultCause *)ptr);
		break;
	case SOAP_TYPE__wsnt__NoCurrentMessageOnTopicFaultType_Description:
		soap_serialize__wsnt__NoCurrentMessageOnTopicFaultType_Description(soap, (const struct _wsnt__NoCurrentMessageOnTopicFaultType_Description *)ptr);
		break;
	case SOAP_TYPE__wsnt__NoCurrentMessageOnTopicFaultType_ErrorCode:
		soap_serialize__wsnt__NoCurrentMessageOnTopicFaultType_ErrorCode(soap, (const struct _wsnt__NoCurrentMessageOnTopicFaultType_ErrorCode *)ptr);
		break;
	case SOAP_TYPE_wsnt__NoCurrentMessageOnTopicFaultType:
		soap_serialize_wsnt__NoCurrentMessageOnTopicFaultType(soap, (const struct wsnt__NoCurrentMessageOnTopicFaultType *)ptr);
		break;
	case SOAP_TYPE__wsnt__UnacceptableInitialTerminationTimeFaultType_FaultCause:
		soap_serialize__wsnt__UnacceptableInitialTerminationTimeFaultType_FaultCause(soap, (const struct _wsnt__UnacceptableInitialTerminationTimeFaultType_FaultCause *)ptr);
		break;
	case SOAP_TYPE__wsnt__UnacceptableInitialTerminationTimeFaultType_Description:
		soap_serialize__wsnt__UnacceptableInitialTerminationTimeFaultType_Description(soap, (const struct _wsnt__UnacceptableInitialTerminationTimeFaultType_Description *)ptr);
		break;
	case SOAP_TYPE__wsnt__UnacceptableInitialTerminationTimeFaultType_ErrorCode:
		soap_serialize__wsnt__UnacceptableInitialTerminationTimeFaultType_ErrorCode(soap, (const struct _wsnt__UnacceptableInitialTerminationTimeFaultType_ErrorCode *)ptr);
		break;
	case SOAP_TYPE_wsnt__UnacceptableInitialTerminationTimeFaultType:
		soap_serialize_wsnt__UnacceptableInitialTerminationTimeFaultType(soap, (const struct wsnt__UnacceptableInitialTerminationTimeFaultType *)ptr);
		break;
	case SOAP_TYPE__wsnt__NotifyMessageNotSupportedFaultType_FaultCause:
		soap_serialize__wsnt__NotifyMessageNotSupportedFaultType_FaultCause(soap, (const struct _wsnt__NotifyMessageNotSupportedFaultType_FaultCause *)ptr);
		break;
	case SOAP_TYPE__wsnt__NotifyMessageNotSupportedFaultType_Description:
		soap_serialize__wsnt__NotifyMessageNotSupportedFaultType_Description(soap, (const struct _wsnt__NotifyMessageNotSupportedFaultType_Description *)ptr);
		break;
	case SOAP_TYPE__wsnt__NotifyMessageNotSupportedFaultType_ErrorCode:
		soap_serialize__wsnt__NotifyMessageNotSupportedFaultType_ErrorCode(soap, (const struct _wsnt__NotifyMessageNotSupportedFaultType_ErrorCode *)ptr);
		break;
	case SOAP_TYPE_wsnt__NotifyMessageNotSupportedFaultType:
		soap_serialize_wsnt__NotifyMessageNotSupportedFaultType(soap, (const struct wsnt__NotifyMessageNotSupportedFaultType *)ptr);
		break;
	case SOAP_TYPE__wsnt__UnsupportedPolicyRequestFaultType_FaultCause:
		soap_serialize__wsnt__UnsupportedPolicyRequestFaultType_FaultCause(soap, (const struct _wsnt__UnsupportedPolicyRequestFaultType_FaultCause *)ptr);
		break;
	case SOAP_TYPE__wsnt__UnsupportedPolicyRequestFaultType_Description:
		soap_serialize__wsnt__UnsupportedPolicyRequestFaultType_Description(soap, (const struct _wsnt__UnsupportedPolicyRequestFaultType_Description *)ptr);
		break;
	case SOAP_TYPE__wsnt__UnsupportedPolicyRequestFaultType_ErrorCode:
		soap_serialize__wsnt__UnsupportedPolicyRequestFaultType_ErrorCode(soap, (const struct _wsnt__UnsupportedPolicyRequestFaultType_ErrorCode *)ptr);
		break;
	case SOAP_TYPE_wsnt__UnsupportedPolicyRequestFaultType:
		soap_serialize_wsnt__UnsupportedPolicyRequestFaultType(soap, (const struct wsnt__UnsupportedPolicyRequestFaultType *)ptr);
		break;
	case SOAP_TYPE__wsnt__UnrecognizedPolicyRequestFaultType_FaultCause:
		soap_serialize__wsnt__UnrecognizedPolicyRequestFaultType_FaultCause(soap, (const struct _wsnt__UnrecognizedPolicyRequestFaultType_FaultCause *)ptr);
		break;
	case SOAP_TYPE__wsnt__UnrecognizedPolicyRequestFaultType_Description:
		soap_serialize__wsnt__UnrecognizedPolicyRequestFaultType_Description(soap, (const struct _wsnt__UnrecognizedPolicyRequestFaultType_Description *)ptr);
		break;
	case SOAP_TYPE__wsnt__UnrecognizedPolicyRequestFaultType_ErrorCode:
		soap_serialize__wsnt__UnrecognizedPolicyRequestFaultType_ErrorCode(soap, (const struct _wsnt__UnrecognizedPolicyRequestFaultType_ErrorCode *)ptr);
		break;
	case SOAP_TYPE_wsnt__UnrecognizedPolicyRequestFaultType:
		soap_serialize_wsnt__UnrecognizedPolicyRequestFaultType(soap, (const struct wsnt__UnrecognizedPolicyRequestFaultType *)ptr);
		break;
	case SOAP_TYPE__wsnt__InvalidMessageContentExpressionFaultType_FaultCause:
		soap_serialize__wsnt__InvalidMessageContentExpressionFaultType_FaultCause(soap, (const struct _wsnt__InvalidMessageContentExpressionFaultType_FaultCause *)ptr);
		break;
	case SOAP_TYPE__wsnt__InvalidMessageContentExpressionFaultType_Description:
		soap_serialize__wsnt__InvalidMessageContentExpressionFaultType_Description(soap, (const struct _wsnt__InvalidMessageContentExpressionFaultType_Description *)ptr);
		break;
	case SOAP_TYPE__wsnt__InvalidMessageContentExpressionFaultType_ErrorCode:
		soap_serialize__wsnt__InvalidMessageContentExpressionFaultType_ErrorCode(soap, (const struct _wsnt__InvalidMessageContentExpressionFaultType_ErrorCode *)ptr);
		break;
	case SOAP_TYPE_wsnt__InvalidMessageContentExpressionFaultType:
		soap_serialize_wsnt__InvalidMessageContentExpressionFaultType(soap, (const struct wsnt__InvalidMessageContentExpressionFaultType *)ptr);
		break;
	case SOAP_TYPE__wsnt__InvalidProducerPropertiesExpressionFaultType_FaultCause:
		soap_serialize__wsnt__InvalidProducerPropertiesExpressionFaultType_FaultCause(soap, (const struct _wsnt__InvalidProducerPropertiesExpressionFaultType_FaultCause *)ptr);
		break;
	case SOAP_TYPE__wsnt__InvalidProducerPropertiesExpressionFaultType_Description:
		soap_serialize__wsnt__InvalidProducerPropertiesExpressionFaultType_Description(soap, (const struct _wsnt__InvalidProducerPropertiesExpressionFaultType_Description *)ptr);
		break;
	case SOAP_TYPE__wsnt__InvalidProducerPropertiesExpressionFaultType_ErrorCode:
		soap_serialize__wsnt__InvalidProducerPropertiesExpressionFaultType_ErrorCode(soap, (const struct _wsnt__InvalidProducerPropertiesExpressionFaultType_ErrorCode *)ptr);
		break;
	case SOAP_TYPE_wsnt__InvalidProducerPropertiesExpressionFaultType:
		soap_serialize_wsnt__InvalidProducerPropertiesExpressionFaultType(soap, (const struct wsnt__InvalidProducerPropertiesExpressionFaultType *)ptr);
		break;
	case SOAP_TYPE__wsnt__MultipleTopicsSpecifiedFaultType_FaultCause:
		soap_serialize__wsnt__MultipleTopicsSpecifiedFaultType_FaultCause(soap, (const struct _wsnt__MultipleTopicsSpecifiedFaultType_FaultCause *)ptr);
		break;
	case SOAP_TYPE__wsnt__MultipleTopicsSpecifiedFaultType_Description:
		soap_serialize__wsnt__MultipleTopicsSpecifiedFaultType_Description(soap, (const struct _wsnt__MultipleTopicsSpecifiedFaultType_Description *)ptr);
		break;
	case SOAP_TYPE__wsnt__MultipleTopicsSpecifiedFaultType_ErrorCode:
		soap_serialize__wsnt__MultipleTopicsSpecifiedFaultType_ErrorCode(soap, (const struct _wsnt__MultipleTopicsSpecifiedFaultType_ErrorCode *)ptr);
		break;
	case SOAP_TYPE_wsnt__MultipleTopicsSpecifiedFaultType:
		soap_serialize_wsnt__MultipleTopicsSpecifiedFaultType(soap, (const struct wsnt__MultipleTopicsSpecifiedFaultType *)ptr);
		break;
	case SOAP_TYPE__wsnt__TopicNotSupportedFaultType_FaultCause:
		soap_serialize__wsnt__TopicNotSupportedFaultType_FaultCause(soap, (const struct _wsnt__TopicNotSupportedFaultType_FaultCause *)ptr);
		break;
	case SOAP_TYPE__wsnt__TopicNotSupportedFaultType_Description:
		soap_serialize__wsnt__TopicNotSupportedFaultType_Description(soap, (const struct _wsnt__TopicNotSupportedFaultType_Description *)ptr);
		break;
	case SOAP_TYPE__wsnt__TopicNotSupportedFaultType_ErrorCode:
		soap_serialize__wsnt__TopicNotSupportedFaultType_ErrorCode(soap, (const struct _wsnt__TopicNotSupportedFaultType_ErrorCode *)ptr);
		break;
	case SOAP_TYPE_wsnt__TopicNotSupportedFaultType:
		soap_serialize_wsnt__TopicNotSupportedFaultType(soap, (const struct wsnt__TopicNotSupportedFaultType *)ptr);
		break;
	case SOAP_TYPE__wsnt__InvalidTopicExpressionFaultType_FaultCause:
		soap_serialize__wsnt__InvalidTopicExpressionFaultType_FaultCause(soap, (const struct _wsnt__InvalidTopicExpressionFaultType_FaultCause *)ptr);
		break;
	case SOAP_TYPE__wsnt__InvalidTopicExpressionFaultType_Description:
		soap_serialize__wsnt__InvalidTopicExpressionFaultType_Description(soap, (const struct _wsnt__InvalidTopicExpressionFaultType_Description *)ptr);
		break;
	case SOAP_TYPE__wsnt__InvalidTopicExpressionFaultType_ErrorCode:
		soap_serialize__wsnt__InvalidTopicExpressionFaultType_ErrorCode(soap, (const struct _wsnt__InvalidTopicExpressionFaultType_ErrorCode *)ptr);
		break;
	case SOAP_TYPE_wsnt__InvalidTopicExpressionFaultType:
		soap_serialize_wsnt__InvalidTopicExpressionFaultType(soap, (const struct wsnt__InvalidTopicExpressionFaultType *)ptr);
		break;
	case SOAP_TYPE__wsnt__TopicExpressionDialectUnknownFaultType_FaultCause:
		soap_serialize__wsnt__TopicExpressionDialectUnknownFaultType_FaultCause(soap, (const struct _wsnt__TopicExpressionDialectUnknownFaultType_FaultCause *)ptr);
		break;
	case SOAP_TYPE__wsnt__TopicExpressionDialectUnknownFaultType_Description:
		soap_serialize__wsnt__TopicExpressionDialectUnknownFaultType_Description(soap, (const struct _wsnt__TopicExpressionDialectUnknownFaultType_Description *)ptr);
		break;
	case SOAP_TYPE__wsnt__TopicExpressionDialectUnknownFaultType_ErrorCode:
		soap_serialize__wsnt__TopicExpressionDialectUnknownFaultType_ErrorCode(soap, (const struct _wsnt__TopicExpressionDialectUnknownFaultType_ErrorCode *)ptr);
		break;
	case SOAP_TYPE_wsnt__TopicExpressionDialectUnknownFaultType:
		soap_serialize_wsnt__TopicExpressionDialectUnknownFaultType(soap, (const struct wsnt__TopicExpressionDialectUnknownFaultType *)ptr);
		break;
	case SOAP_TYPE__wsnt__InvalidFilterFaultType_FaultCause:
		soap_serialize__wsnt__InvalidFilterFaultType_FaultCause(soap, (const struct _wsnt__InvalidFilterFaultType_FaultCause *)ptr);
		break;
	case SOAP_TYPE__wsnt__InvalidFilterFaultType_Description:
		soap_serialize__wsnt__InvalidFilterFaultType_Description(soap, (const struct _wsnt__InvalidFilterFaultType_Description *)ptr);
		break;
	case SOAP_TYPE__wsnt__InvalidFilterFaultType_ErrorCode:
		soap_serialize__wsnt__InvalidFilterFaultType_ErrorCode(soap, (const struct _wsnt__InvalidFilterFaultType_ErrorCode *)ptr);
		break;
	case SOAP_TYPE_wsnt__InvalidFilterFaultType:
		soap_serialize_wsnt__InvalidFilterFaultType(soap, (const struct wsnt__InvalidFilterFaultType *)ptr);
		break;
	case SOAP_TYPE__wsnt__SubscribeCreationFailedFaultType_FaultCause:
		soap_serialize__wsnt__SubscribeCreationFailedFaultType_FaultCause(soap, (const struct _wsnt__SubscribeCreationFailedFaultType_FaultCause *)ptr);
		break;
	case SOAP_TYPE__wsnt__SubscribeCreationFailedFaultType_Description:
		soap_serialize__wsnt__SubscribeCreationFailedFaultType_Description(soap, (const struct _wsnt__SubscribeCreationFailedFaultType_Description *)ptr);
		break;
	case SOAP_TYPE__wsnt__SubscribeCreationFailedFaultType_ErrorCode:
		soap_serialize__wsnt__SubscribeCreationFailedFaultType_ErrorCode(soap, (const struct _wsnt__SubscribeCreationFailedFaultType_ErrorCode *)ptr);
		break;
	case SOAP_TYPE_wsnt__SubscribeCreationFailedFaultType:
		soap_serialize_wsnt__SubscribeCreationFailedFaultType(soap, (const struct wsnt__SubscribeCreationFailedFaultType *)ptr);
		break;
	case SOAP_TYPE__trt__GetSnapshotUriResponse:
		soap_serialize__trt__GetSnapshotUriResponse(soap, (const struct _trt__GetSnapshotUriResponse *)ptr);
		break;
	case SOAP_TYPE__trt__GetSnapshotUri:
		soap_serialize__trt__GetSnapshotUri(soap, (const struct _trt__GetSnapshotUri *)ptr);
		break;
	case SOAP_TYPE__trt__DeleteProfileResponse:
		soap_serialize__trt__DeleteProfileResponse(soap, (const struct _trt__DeleteProfileResponse *)ptr);
		break;
	case SOAP_TYPE__trt__DeleteProfile:
		soap_serialize__trt__DeleteProfile(soap, (const struct _trt__DeleteProfile *)ptr);
		break;
	case SOAP_TYPE__trt__GetProfilesResponse:
		soap_serialize__trt__GetProfilesResponse(soap, (const struct _trt__GetProfilesResponse *)ptr);
		break;
	case SOAP_TYPE__trt__GetProfiles:
		soap_serialize__trt__GetProfiles(soap, (const struct _trt__GetProfiles *)ptr);
		break;
	case SOAP_TYPE__trt__GetProfileResponse:
		soap_serialize__trt__GetProfileResponse(soap, (const struct _trt__GetProfileResponse *)ptr);
		break;
	case SOAP_TYPE__trt__GetProfile:
		soap_serialize__trt__GetProfile(soap, (const struct _trt__GetProfile *)ptr);
		break;
	case SOAP_TYPE__trt__CreateProfileResponse:
		soap_serialize__trt__CreateProfileResponse(soap, (const struct _trt__CreateProfileResponse *)ptr);
		break;
	case SOAP_TYPE__trt__CreateProfile:
		soap_serialize__trt__CreateProfile(soap, (const struct _trt__CreateProfile *)ptr);
		break;
	case SOAP_TYPE__trt__GetServiceCapabilitiesResponse:
		soap_serialize__trt__GetServiceCapabilitiesResponse(soap, (const struct _trt__GetServiceCapabilitiesResponse *)ptr);
		break;
	case SOAP_TYPE__trt__GetServiceCapabilities:
		soap_serialize__trt__GetServiceCapabilities(soap, (const struct _trt__GetServiceCapabilities *)ptr);
		break;
	case SOAP_TYPE_trt__ProfileCapabilities:
		soap_serialize_trt__ProfileCapabilities(soap, (const struct trt__ProfileCapabilities *)ptr);
		break;
	case SOAP_TYPE_trt__Capabilities:
		soap_serialize_trt__Capabilities(soap, (const struct trt__Capabilities *)ptr);
		break;
	case SOAP_TYPE_wstop__QueryExpressionType:
		soap_serialize_wstop__QueryExpressionType(soap, (const struct wstop__QueryExpressionType *)ptr);
		break;
	case SOAP_TYPE_wstop__ExtensibleDocumented:
		soap_serialize_wstop__ExtensibleDocumented(soap, (const struct wstop__ExtensibleDocumented *)ptr);
		break;
	case SOAP_TYPE_wstop__Documentation:
		soap_serialize_wstop__Documentation(soap, (const struct wstop__Documentation *)ptr);
		break;
	case SOAP_TYPE__wsrfbf__BaseFaultType_FaultCause:
		soap_serialize__wsrfbf__BaseFaultType_FaultCause(soap, (const struct _wsrfbf__BaseFaultType_FaultCause *)ptr);
		break;
	case SOAP_TYPE__wsrfbf__BaseFaultType_Description:
		soap_serialize__wsrfbf__BaseFaultType_Description(soap, (const struct _wsrfbf__BaseFaultType_Description *)ptr);
		break;
	case SOAP_TYPE__wsrfbf__BaseFaultType_ErrorCode:
		soap_serialize__wsrfbf__BaseFaultType_ErrorCode(soap, (const struct _wsrfbf__BaseFaultType_ErrorCode *)ptr);
		break;
	case SOAP_TYPE_wsrfbf__BaseFaultType:
		soap_serialize_wsrfbf__BaseFaultType(soap, (const struct wsrfbf__BaseFaultType *)ptr);
		break;
	case SOAP_TYPE__wsnt__ResumeSubscriptionResponse:
		soap_serialize__wsnt__ResumeSubscriptionResponse(soap, (const struct _wsnt__ResumeSubscriptionResponse *)ptr);
		break;
	case SOAP_TYPE__wsnt__ResumeSubscription:
		soap_serialize__wsnt__ResumeSubscription(soap, (const struct _wsnt__ResumeSubscription *)ptr);
		break;
	case SOAP_TYPE__wsnt__PauseSubscriptionResponse:
		soap_serialize__wsnt__PauseSubscriptionResponse(soap, (const struct _wsnt__PauseSubscriptionResponse *)ptr);
		break;
	case SOAP_TYPE__wsnt__PauseSubscription:
		soap_serialize__wsnt__PauseSubscription(soap, (const struct _wsnt__PauseSubscription *)ptr);
		break;
	case SOAP_TYPE__wsnt__UnsubscribeResponse:
		soap_serialize__wsnt__UnsubscribeResponse(soap, (const struct _wsnt__UnsubscribeResponse *)ptr);
		break;
	case SOAP_TYPE__wsnt__Unsubscribe:
		soap_serialize__wsnt__Unsubscribe(soap, (const struct _wsnt__Unsubscribe *)ptr);
		break;
	case SOAP_TYPE__wsnt__RenewResponse:
		soap_serialize__wsnt__RenewResponse(soap, (const struct _wsnt__RenewResponse *)ptr);
		break;
	case SOAP_TYPE__wsnt__Renew:
		soap_serialize__wsnt__Renew(soap, (const struct _wsnt__Renew *)ptr);
		break;
	case SOAP_TYPE__wsnt__CreatePullPointResponse:
		soap_serialize__wsnt__CreatePullPointResponse(soap, (const struct _wsnt__CreatePullPointResponse *)ptr);
		break;
	case SOAP_TYPE__wsnt__CreatePullPoint:
		soap_serialize__wsnt__CreatePullPoint(soap, (const struct _wsnt__CreatePullPoint *)ptr);
		break;
	case SOAP_TYPE__wsnt__DestroyPullPointResponse:
		soap_serialize__wsnt__DestroyPullPointResponse(soap, (const struct _wsnt__DestroyPullPointResponse *)ptr);
		break;
	case SOAP_TYPE__wsnt__DestroyPullPoint:
		soap_serialize__wsnt__DestroyPullPoint(soap, (const struct _wsnt__DestroyPullPoint *)ptr);
		break;
	case SOAP_TYPE__wsnt__GetMessagesResponse:
		soap_serialize__wsnt__GetMessagesResponse(soap, (const struct _wsnt__GetMessagesResponse *)ptr);
		break;
	case SOAP_TYPE__wsnt__GetMessages:
		soap_serialize__wsnt__GetMessages(soap, (const struct _wsnt__GetMessages *)ptr);
		break;
	case SOAP_TYPE__wsnt__GetCurrentMessageResponse:
		soap_serialize__wsnt__GetCurrentMessageResponse(soap, (const struct _wsnt__GetCurrentMessageResponse *)ptr);
		break;
	case SOAP_TYPE__wsnt__GetCurrentMessage:
		soap_serialize__wsnt__GetCurrentMessage(soap, (const struct _wsnt__GetCurrentMessage *)ptr);
		break;
	case SOAP_TYPE__wsnt__SubscribeResponse:
		soap_serialize__wsnt__SubscribeResponse(soap, (const struct _wsnt__SubscribeResponse *)ptr);
		break;
	case SOAP_TYPE__wsnt__Subscribe_SubscriptionPolicy:
		soap_serialize__wsnt__Subscribe_SubscriptionPolicy(soap, (const struct _wsnt__Subscribe_SubscriptionPolicy *)ptr);
		break;
	case SOAP_TYPE__wsnt__Subscribe:
		soap_serialize__wsnt__Subscribe(soap, (const struct _wsnt__Subscribe *)ptr);
		break;
	case SOAP_TYPE__wsnt__UseRaw:
		soap_serialize__wsnt__UseRaw(soap, (const struct _wsnt__UseRaw *)ptr);
		break;
	case SOAP_TYPE__wsnt__Notify:
		soap_serialize__wsnt__Notify(soap, (const struct _wsnt__Notify *)ptr);
		break;
	case SOAP_TYPE__wsnt__SubscriptionManagerRP:
		soap_serialize__wsnt__SubscriptionManagerRP(soap, (const struct _wsnt__SubscriptionManagerRP *)ptr);
		break;
	case SOAP_TYPE_wstop__TopicSetType:
		soap_serialize_wstop__TopicSetType(soap, (const struct wstop__TopicSetType *)ptr);
		break;
	case SOAP_TYPE__wsnt__NotificationProducerRP:
		soap_serialize__wsnt__NotificationProducerRP(soap, (const struct _wsnt__NotificationProducerRP *)ptr);
		break;
	case SOAP_TYPE__wsnt__NotificationMessageHolderType_Message:
		soap_serialize__wsnt__NotificationMessageHolderType_Message(soap, (const struct _wsnt__NotificationMessageHolderType_Message *)ptr);
		break;
	case SOAP_TYPE_wsnt__NotificationMessageHolderType:
		soap_serialize_wsnt__NotificationMessageHolderType(soap, (const struct wsnt__NotificationMessageHolderType *)ptr);
		break;
	case SOAP_TYPE_wsnt__SubscriptionPolicyType:
		soap_serialize_wsnt__SubscriptionPolicyType(soap, (const struct wsnt__SubscriptionPolicyType *)ptr);
		break;
	case SOAP_TYPE_wsnt__FilterType:
		soap_serialize_wsnt__FilterType(soap, (const struct wsnt__FilterType *)ptr);
		break;
	case SOAP_TYPE_wsnt__TopicExpressionType:
		soap_serialize_wsnt__TopicExpressionType(soap, (const struct wsnt__TopicExpressionType *)ptr);
		break;
	case SOAP_TYPE_wsnt__QueryExpressionType:
		soap_serialize_wsnt__QueryExpressionType(soap, (const struct wsnt__QueryExpressionType *)ptr);
		break;
	case SOAP_TYPE__tt__Message:
		soap_serialize__tt__Message(soap, (const struct _tt__Message *)ptr);
		break;
	case SOAP_TYPE_tt__MediaUri:
		soap_serialize_tt__MediaUri(soap, (const struct tt__MediaUri *)ptr);
		break;
	case SOAP_TYPE_tt__MulticastConfiguration:
		soap_serialize_tt__MulticastConfiguration(soap, (const struct tt__MulticastConfiguration *)ptr);
		break;
	case SOAP_TYPE_tt__IPAddress:
		soap_serialize_tt__IPAddress(soap, (const struct tt__IPAddress *)ptr);
		break;
	case SOAP_TYPE_tt__VideoEncoderOptionsExtension2:
		soap_serialize_tt__VideoEncoderOptionsExtension2(soap, (const struct tt__VideoEncoderOptionsExtension2 *)ptr);
		break;
	case SOAP_TYPE_tt__H264Options2:
		soap_serialize_tt__H264Options2(soap, (const struct tt__H264Options2 *)ptr);
		break;
	case SOAP_TYPE_tt__Mpeg4Options2:
		soap_serialize_tt__Mpeg4Options2(soap, (const struct tt__Mpeg4Options2 *)ptr);
		break;
	case SOAP_TYPE_tt__JpegOptions2:
		soap_serialize_tt__JpegOptions2(soap, (const struct tt__JpegOptions2 *)ptr);
		break;
	case SOAP_TYPE_tt__VideoEncoderOptionsExtension:
		soap_serialize_tt__VideoEncoderOptionsExtension(soap, (const struct tt__VideoEncoderOptionsExtension *)ptr);
		break;
	case SOAP_TYPE_tt__H264Options:
		soap_serialize_tt__H264Options(soap, (const struct tt__H264Options *)ptr);
		break;
	case SOAP_TYPE_tt__Mpeg4Options:
		soap_serialize_tt__Mpeg4Options(soap, (const struct tt__Mpeg4Options *)ptr);
		break;
	case SOAP_TYPE_tt__JpegOptions:
		soap_serialize_tt__JpegOptions(soap, (const struct tt__JpegOptions *)ptr);
		break;
	case SOAP_TYPE_tt__VideoEncoderConfigurationOptions:
		soap_serialize_tt__VideoEncoderConfigurationOptions(soap, (const struct tt__VideoEncoderConfigurationOptions *)ptr);
		break;
	case SOAP_TYPE_tt__H264Configuration:
		soap_serialize_tt__H264Configuration(soap, (const struct tt__H264Configuration *)ptr);
		break;
	case SOAP_TYPE_tt__Mpeg4Configuration:
		soap_serialize_tt__Mpeg4Configuration(soap, (const struct tt__Mpeg4Configuration *)ptr);
		break;
	case SOAP_TYPE_tt__VideoRateControl:
		soap_serialize_tt__VideoRateControl(soap, (const struct tt__VideoRateControl *)ptr);
		break;
	case SOAP_TYPE_tt__VideoResolution:
		soap_serialize_tt__VideoResolution(soap, (const struct tt__VideoResolution *)ptr);
		break;
	case SOAP_TYPE_tt__ItemListDescriptionExtension:
		soap_serialize_tt__ItemListDescriptionExtension(soap, (const struct tt__ItemListDescriptionExtension *)ptr);
		break;
	case SOAP_TYPE__tt__ItemListDescription_ElementItemDescription:
		soap_serialize__tt__ItemListDescription_ElementItemDescription(soap, (const struct _tt__ItemListDescription_ElementItemDescription *)ptr);
		break;
	case SOAP_TYPE__tt__ItemListDescription_SimpleItemDescription:
		soap_serialize__tt__ItemListDescription_SimpleItemDescription(soap, (const struct _tt__ItemListDescription_SimpleItemDescription *)ptr);
		break;
	case SOAP_TYPE_tt__MessageDescriptionExtension:
		soap_serialize_tt__MessageDescriptionExtension(soap, (const struct tt__MessageDescriptionExtension *)ptr);
		break;
	case SOAP_TYPE_tt__ItemListDescription:
		soap_serialize_tt__ItemListDescription(soap, (const struct tt__ItemListDescription *)ptr);
		break;
	case SOAP_TYPE_tt__MessageDescription:
		soap_serialize_tt__MessageDescription(soap, (const struct tt__MessageDescription *)ptr);
		break;
	case SOAP_TYPE_tt__ItemListExtension:
		soap_serialize_tt__ItemListExtension(soap, (const struct tt__ItemListExtension *)ptr);
		break;
	case SOAP_TYPE__tt__ItemList_ElementItem:
		soap_serialize__tt__ItemList_ElementItem(soap, (const struct _tt__ItemList_ElementItem *)ptr);
		break;
	case SOAP_TYPE__tt__ItemList_SimpleItem:
		soap_serialize__tt__ItemList_SimpleItem(soap, (const struct _tt__ItemList_SimpleItem *)ptr);
		break;
	case SOAP_TYPE_tt__ItemList:
		soap_serialize_tt__ItemList(soap, (const struct tt__ItemList *)ptr);
		break;
	case SOAP_TYPE_tt__MessageExtension:
		soap_serialize_tt__MessageExtension(soap, (const struct tt__MessageExtension *)ptr);
		break;
	case SOAP_TYPE_tt__PTZMoveStatus:
		soap_serialize_tt__PTZMoveStatus(soap, (const struct tt__PTZMoveStatus *)ptr);
		break;
	case SOAP_TYPE_tt__PTZPreset:
		soap_serialize_tt__PTZPreset(soap, (const struct tt__PTZPreset *)ptr);
		break;
	case SOAP_TYPE_tt__PTZSpeed:
		soap_serialize_tt__PTZSpeed(soap, (const struct tt__PTZSpeed *)ptr);
		break;
	case SOAP_TYPE_tt__PTZVector:
		soap_serialize_tt__PTZVector(soap, (const struct tt__PTZVector *)ptr);
		break;
	case SOAP_TYPE_tt__Vector1D:
		soap_serialize_tt__Vector1D(soap, (const struct tt__Vector1D *)ptr);
		break;
	case SOAP_TYPE_tt__Vector2D:
		soap_serialize_tt__Vector2D(soap, (const struct tt__Vector2D *)ptr);
		break;
	case SOAP_TYPE_tt__PTZSpaces:
		soap_serialize_tt__PTZSpaces(soap, (const struct tt__PTZSpaces *)ptr);
		break;
	case SOAP_TYPE_tt__Space1DDescription:
		soap_serialize_tt__Space1DDescription(soap, (const struct tt__Space1DDescription *)ptr);
		break;
	case SOAP_TYPE_tt__ZoomLimits:
		soap_serialize_tt__ZoomLimits(soap, (const struct tt__ZoomLimits *)ptr);
		break;
	case SOAP_TYPE_tt__Space2DDescription:
		soap_serialize_tt__Space2DDescription(soap, (const struct tt__Space2DDescription *)ptr);
		break;
	case SOAP_TYPE_tt__PanTiltLimits:
		soap_serialize_tt__PanTiltLimits(soap, (const struct tt__PanTiltLimits *)ptr);
		break;
	case SOAP_TYPE_tt__ProfileCapabilities:
		soap_serialize_tt__ProfileCapabilities(soap, (const struct tt__ProfileCapabilities *)ptr);
		break;
	case SOAP_TYPE_tt__MediaCapabilitiesExtension:
		soap_serialize_tt__MediaCapabilitiesExtension(soap, (const struct tt__MediaCapabilitiesExtension *)ptr);
		break;
	case SOAP_TYPE_tt__RealTimeStreamingCapabilities:
		soap_serialize_tt__RealTimeStreamingCapabilities(soap, (const struct tt__RealTimeStreamingCapabilities *)ptr);
		break;
	case SOAP_TYPE_tt__SystemCapabilities:
		soap_serialize_tt__SystemCapabilities(soap, (const struct tt__SystemCapabilities *)ptr);
		break;
	case SOAP_TYPE_tt__PTZCapabilities:
		soap_serialize_tt__PTZCapabilities(soap, (const struct tt__PTZCapabilities *)ptr);
		break;
	case SOAP_TYPE_tt__MediaCapabilities:
		soap_serialize_tt__MediaCapabilities(soap, (const struct tt__MediaCapabilities *)ptr);
		break;
	case SOAP_TYPE_tt__EventCapabilities:
		soap_serialize_tt__EventCapabilities(soap, (const struct tt__EventCapabilities *)ptr);
		break;
	case SOAP_TYPE_tt__DeviceCapabilities:
		soap_serialize_tt__DeviceCapabilities(soap, (const struct tt__DeviceCapabilities *)ptr);
		break;
	case SOAP_TYPE_tt__ConfigurationEntity:
		soap_serialize_tt__ConfigurationEntity(soap, (const struct tt__ConfigurationEntity *)ptr);
		break;
	case SOAP_TYPE_tt__VideoEncoderConfiguration:
		soap_serialize_tt__VideoEncoderConfiguration(soap, (const struct tt__VideoEncoderConfiguration *)ptr);
		break;
	case SOAP_TYPE_tt__Profile:
		soap_serialize_tt__Profile(soap, (const struct tt__Profile *)ptr);
		break;
	case SOAP_TYPE_tt__AnyHolder:
		soap_serialize_tt__AnyHolder(soap, (const struct tt__AnyHolder *)ptr);
		break;
	case SOAP_TYPE_tt__FloatList:
		soap_serialize_tt__FloatList(soap, (const struct tt__FloatList *)ptr);
		break;
	case SOAP_TYPE_tt__IntList:
		soap_serialize_tt__IntList(soap, (const struct tt__IntList *)ptr);
		break;
	case SOAP_TYPE_tt__DurationRange:
		soap_serialize_tt__DurationRange(soap, (const struct tt__DurationRange *)ptr);
		break;
	case SOAP_TYPE_tt__FloatRange:
		soap_serialize_tt__FloatRange(soap, (const struct tt__FloatRange *)ptr);
		break;
	case SOAP_TYPE_tt__IntRange:
		soap_serialize_tt__IntRange(soap, (const struct tt__IntRange *)ptr);
		break;
	case SOAP_TYPE_tt__IntRectangleRange:
		soap_serialize_tt__IntRectangleRange(soap, (const struct tt__IntRectangleRange *)ptr);
		break;
	case SOAP_TYPE_tt__IntRectangle:
		soap_serialize_tt__IntRectangle(soap, (const struct tt__IntRectangle *)ptr);
		break;
	case SOAP_TYPE_tt__DeviceEntity:
		soap_serialize_tt__DeviceEntity(soap, (const struct tt__DeviceEntity *)ptr);
		break;
	case SOAP_TYPE_tt__Capabilities:
		soap_serialize_tt__Capabilities(soap, (const struct tt__Capabilities *)ptr);
		break;
	case SOAP_TYPE__tds__GetCapabilitiesResponse:
		soap_serialize__tds__GetCapabilitiesResponse(soap, (const struct _tds__GetCapabilitiesResponse *)ptr);
		break;
	case SOAP_TYPE__tds__GetCapabilities:
		soap_serialize__tds__GetCapabilities(soap, (const struct _tds__GetCapabilities *)ptr);
		break;
	case SOAP_TYPE__tds__SystemRebootResponse:
		soap_serialize__tds__SystemRebootResponse(soap, (const struct _tds__SystemRebootResponse *)ptr);
		break;
	case SOAP_TYPE__tds__SystemReboot:
		soap_serialize__tds__SystemReboot(soap, (const struct _tds__SystemReboot *)ptr);
		break;
	case SOAP_TYPE__tds__GetDeviceInformationResponse:
		soap_serialize__tds__GetDeviceInformationResponse(soap, (const struct _tds__GetDeviceInformationResponse *)ptr);
		break;
	case SOAP_TYPE__tds__GetDeviceInformation:
		soap_serialize__tds__GetDeviceInformation(soap, (const struct _tds__GetDeviceInformation *)ptr);
		break;
	case SOAP_TYPE__tds__GetServiceCapabilitiesResponse:
		soap_serialize__tds__GetServiceCapabilitiesResponse(soap, (const struct _tds__GetServiceCapabilitiesResponse *)ptr);
		break;
	case SOAP_TYPE__tds__GetServiceCapabilities:
		soap_serialize__tds__GetServiceCapabilities(soap, (const struct _tds__GetServiceCapabilities *)ptr);
		break;
	case SOAP_TYPE__tds__GetServicesResponse:
		soap_serialize__tds__GetServicesResponse(soap, (const struct _tds__GetServicesResponse *)ptr);
		break;
	case SOAP_TYPE__tds__GetServices:
		soap_serialize__tds__GetServices(soap, (const struct _tds__GetServices *)ptr);
		break;
	case SOAP_TYPE_tds__DeviceServiceCapabilities:
		soap_serialize_tds__DeviceServiceCapabilities(soap, (const struct tds__DeviceServiceCapabilities *)ptr);
		break;
	case SOAP_TYPE_tt__OnvifVersion:
		soap_serialize_tt__OnvifVersion(soap, (const struct tt__OnvifVersion *)ptr);
		break;
	case SOAP_TYPE__tds__Service_Capabilities:
		soap_serialize__tds__Service_Capabilities(soap, (const struct _tds__Service_Capabilities *)ptr);
		break;
	case SOAP_TYPE_tds__Service:
		soap_serialize_tds__Service(soap, (const struct tds__Service *)ptr);
		break;
	case SOAP_TYPE__wsse__Security:
		soap_serialize__wsse__Security(soap, (const struct _wsse__Security *)ptr);
		break;
	case SOAP_TYPE__saml2__EncryptedAttribute:
		soap_serialize__saml2__EncryptedAttribute(soap, (const struct saml2__EncryptedElementType *)ptr);
		break;
	case SOAP_TYPE__saml2__Attribute:
		soap_serialize__saml2__Attribute(soap, (const struct saml2__AttributeType *)ptr);
		break;
	case SOAP_TYPE__saml2__AttributeStatement:
		soap_serialize__saml2__AttributeStatement(soap, (const struct saml2__AttributeStatementType *)ptr);
		break;
	case SOAP_TYPE__saml2__Evidence:
		soap_serialize__saml2__Evidence(soap, (const struct saml2__EvidenceType *)ptr);
		break;
	case SOAP_TYPE__saml2__Action:
		soap_serialize__saml2__Action(soap, (const struct saml2__ActionType *)ptr);
		break;
	case SOAP_TYPE__saml2__AuthzDecisionStatement:
		soap_serialize__saml2__AuthzDecisionStatement(soap, (const struct saml2__AuthzDecisionStatementType *)ptr);
		break;
	case SOAP_TYPE__saml2__AuthnContext:
		soap_serialize__saml2__AuthnContext(soap, (const struct saml2__AuthnContextType *)ptr);
		break;
	case SOAP_TYPE__saml2__SubjectLocality:
		soap_serialize__saml2__SubjectLocality(soap, (const struct saml2__SubjectLocalityType *)ptr);
		break;
	case SOAP_TYPE__saml2__AuthnStatement:
		soap_serialize__saml2__AuthnStatement(soap, (const struct saml2__AuthnStatementType *)ptr);
		break;
	case SOAP_TYPE__saml2__Statement:
		soap_serialize__saml2__Statement(soap, (const struct saml2__StatementAbstractType *)ptr);
		break;
	case SOAP_TYPE__saml2__EncryptedAssertion:
		soap_serialize__saml2__EncryptedAssertion(soap, (const struct saml2__EncryptedElementType *)ptr);
		break;
	case SOAP_TYPE__saml2__Advice:
		soap_serialize__saml2__Advice(soap, (const struct saml2__AdviceType *)ptr);
		break;
	case SOAP_TYPE__saml2__ProxyRestriction:
		soap_serialize__saml2__ProxyRestriction(soap, (const struct saml2__ProxyRestrictionType *)ptr);
		break;
	case SOAP_TYPE__saml2__OneTimeUse:
		soap_serialize__saml2__OneTimeUse(soap, (const struct saml2__OneTimeUseType *)ptr);
		break;
	case SOAP_TYPE__saml2__AudienceRestriction:
		soap_serialize__saml2__AudienceRestriction(soap, (const struct saml2__AudienceRestrictionType *)ptr);
		break;
	case SOAP_TYPE__saml2__Condition:
		soap_serialize__saml2__Condition(soap, (const struct saml2__ConditionAbstractType *)ptr);
		break;
	case SOAP_TYPE__saml2__Conditions:
		soap_serialize__saml2__Conditions(soap, (const struct saml2__ConditionsType *)ptr);
		break;
	case SOAP_TYPE__saml2__SubjectConfirmationData:
		soap_serialize__saml2__SubjectConfirmationData(soap, (const struct saml2__SubjectConfirmationDataType *)ptr);
		break;
	case SOAP_TYPE__saml2__SubjectConfirmation:
		soap_serialize__saml2__SubjectConfirmation(soap, (const struct saml2__SubjectConfirmationType *)ptr);
		break;
	case SOAP_TYPE__saml2__Subject:
		soap_serialize__saml2__Subject(soap, (const struct saml2__SubjectType *)ptr);
		break;
	case SOAP_TYPE__saml2__Assertion:
		soap_serialize__saml2__Assertion(soap, (const struct saml2__AssertionType *)ptr);
		break;
	case SOAP_TYPE__saml2__Issuer:
		soap_serialize__saml2__Issuer(soap, (const struct saml2__NameIDType *)ptr);
		break;
	case SOAP_TYPE__saml2__EncryptedID:
		soap_serialize__saml2__EncryptedID(soap, (const struct saml2__EncryptedElementType *)ptr);
		break;
	case SOAP_TYPE__saml2__NameID:
		soap_serialize__saml2__NameID(soap, (const struct saml2__NameIDType *)ptr);
		break;
	case SOAP_TYPE__saml2__BaseID:
		soap_serialize__saml2__BaseID(soap, (const struct saml2__BaseIDAbstractType *)ptr);
		break;
	case SOAP_TYPE___saml2__union_AttributeStatementType:
		soap_serialize___saml2__union_AttributeStatementType(soap, (const struct __saml2__union_AttributeStatementType *)ptr);
		break;
	case SOAP_TYPE___saml2__union_EvidenceType:
		soap_serialize___saml2__union_EvidenceType(soap, (const struct __saml2__union_EvidenceType *)ptr);
		break;
	case SOAP_TYPE___saml2__union_AdviceType:
		soap_serialize___saml2__union_AdviceType(soap, (const struct __saml2__union_AdviceType *)ptr);
		break;
	case SOAP_TYPE___saml2__union_ConditionsType:
		soap_serialize___saml2__union_ConditionsType(soap, (const struct __saml2__union_ConditionsType *)ptr);
		break;
	case SOAP_TYPE___saml2__union_AssertionType:
		soap_serialize___saml2__union_AssertionType(soap, (const struct __saml2__union_AssertionType *)ptr);
		break;
	case SOAP_TYPE_saml2__AttributeType:
		soap_serialize_saml2__AttributeType(soap, (const struct saml2__AttributeType *)ptr);
		break;
	case SOAP_TYPE_saml2__AttributeStatementType:
		soap_serialize_saml2__AttributeStatementType(soap, (const struct saml2__AttributeStatementType *)ptr);
		break;
	case SOAP_TYPE_saml2__EvidenceType:
		soap_serialize_saml2__EvidenceType(soap, (const struct saml2__EvidenceType *)ptr);
		break;
	case SOAP_TYPE_saml2__ActionType:
		soap_serialize_saml2__ActionType(soap, (const struct saml2__ActionType *)ptr);
		break;
	case SOAP_TYPE_saml2__AuthzDecisionStatementType:
		soap_serialize_saml2__AuthzDecisionStatementType(soap, (const struct saml2__AuthzDecisionStatementType *)ptr);
		break;
	case SOAP_TYPE_saml2__AuthnContextType:
		soap_serialize_saml2__AuthnContextType(soap, (const struct saml2__AuthnContextType *)ptr);
		break;
	case SOAP_TYPE_saml2__SubjectLocalityType:
		soap_serialize_saml2__SubjectLocalityType(soap, (const struct saml2__SubjectLocalityType *)ptr);
		break;
	case SOAP_TYPE_saml2__AuthnStatementType:
		soap_serialize_saml2__AuthnStatementType(soap, (const struct saml2__AuthnStatementType *)ptr);
		break;
	case SOAP_TYPE_saml2__StatementAbstractType:
		soap_serialize_saml2__StatementAbstractType(soap, (const struct saml2__StatementAbstractType *)ptr);
		break;
	case SOAP_TYPE_saml2__AdviceType:
		soap_serialize_saml2__AdviceType(soap, (const struct saml2__AdviceType *)ptr);
		break;
	case SOAP_TYPE_saml2__ProxyRestrictionType:
		soap_serialize_saml2__ProxyRestrictionType(soap, (const struct saml2__ProxyRestrictionType *)ptr);
		break;
	case SOAP_TYPE_saml2__OneTimeUseType:
		soap_serialize_saml2__OneTimeUseType(soap, (const struct saml2__OneTimeUseType *)ptr);
		break;
	case SOAP_TYPE_saml2__AudienceRestrictionType:
		soap_serialize_saml2__AudienceRestrictionType(soap, (const struct saml2__AudienceRestrictionType *)ptr);
		break;
	case SOAP_TYPE_saml2__ConditionAbstractType:
		soap_serialize_saml2__ConditionAbstractType(soap, (const struct saml2__ConditionAbstractType *)ptr);
		break;
	case SOAP_TYPE_saml2__ConditionsType:
		soap_serialize_saml2__ConditionsType(soap, (const struct saml2__ConditionsType *)ptr);
		break;
	case SOAP_TYPE_saml2__KeyInfoConfirmationDataType:
		soap_serialize_saml2__KeyInfoConfirmationDataType(soap, (const struct saml2__KeyInfoConfirmationDataType *)ptr);
		break;
	case SOAP_TYPE_saml2__SubjectConfirmationDataType:
		soap_serialize_saml2__SubjectConfirmationDataType(soap, (const struct saml2__SubjectConfirmationDataType *)ptr);
		break;
	case SOAP_TYPE_saml2__SubjectConfirmationType:
		soap_serialize_saml2__SubjectConfirmationType(soap, (const struct saml2__SubjectConfirmationType *)ptr);
		break;
	case SOAP_TYPE_saml2__SubjectType:
		soap_serialize_saml2__SubjectType(soap, (const struct saml2__SubjectType *)ptr);
		break;
	case SOAP_TYPE_saml2__AssertionType:
		soap_serialize_saml2__AssertionType(soap, (const struct saml2__AssertionType *)ptr);
		break;
	case SOAP_TYPE_saml2__EncryptedElementType:
		soap_serialize_saml2__EncryptedElementType(soap, (const struct saml2__EncryptedElementType *)ptr);
		break;
	case SOAP_TYPE_saml2__NameIDType:
		soap_serialize_saml2__NameIDType(soap, (const struct saml2__NameIDType *)ptr);
		break;
	case SOAP_TYPE_saml2__BaseIDAbstractType:
		soap_serialize_saml2__BaseIDAbstractType(soap, (const struct saml2__BaseIDAbstractType *)ptr);
		break;
	case SOAP_TYPE__saml1__Attribute:
		soap_serialize__saml1__Attribute(soap, (const struct saml1__AttributeType *)ptr);
		break;
	case SOAP_TYPE__saml1__AttributeDesignator:
		soap_serialize__saml1__AttributeDesignator(soap, (const struct saml1__AttributeDesignatorType *)ptr);
		break;
	case SOAP_TYPE__saml1__AttributeStatement:
		soap_serialize__saml1__AttributeStatement(soap, (const struct saml1__AttributeStatementType *)ptr);
		break;
	case SOAP_TYPE__saml1__Evidence:
		soap_serialize__saml1__Evidence(soap, (const struct saml1__EvidenceType *)ptr);
		break;
	case SOAP_TYPE__saml1__Action:
		soap_serialize__saml1__Action(soap, (const struct saml1__ActionType *)ptr);
		break;
	case SOAP_TYPE__saml1__AuthorizationDecisionStatement:
		soap_serialize__saml1__AuthorizationDecisionStatement(soap, (const struct saml1__AuthorizationDecisionStatementType *)ptr);
		break;
	case SOAP_TYPE__saml1__AuthorityBinding:
		soap_serialize__saml1__AuthorityBinding(soap, (const struct saml1__AuthorityBindingType *)ptr);
		break;
	case SOAP_TYPE__saml1__SubjectLocality:
		soap_serialize__saml1__SubjectLocality(soap, (const struct saml1__SubjectLocalityType *)ptr);
		break;
	case SOAP_TYPE__saml1__AuthenticationStatement:
		soap_serialize__saml1__AuthenticationStatement(soap, (const struct saml1__AuthenticationStatementType *)ptr);
		break;
	case SOAP_TYPE__saml1__SubjectConfirmation:
		soap_serialize__saml1__SubjectConfirmation(soap, (const struct saml1__SubjectConfirmationType *)ptr);
		break;
	case SOAP_TYPE__saml1__NameIdentifier:
		soap_serialize__saml1__NameIdentifier(soap, (const struct saml1__NameIdentifierType *)ptr);
		break;
	case SOAP_TYPE__saml1__Subject:
		soap_serialize__saml1__Subject(soap, (const struct saml1__SubjectType *)ptr);
		break;
	case SOAP_TYPE__saml1__SubjectStatement:
		soap_serialize__saml1__SubjectStatement(soap, (const struct saml1__SubjectStatementAbstractType *)ptr);
		break;
	case SOAP_TYPE__saml1__Statement:
		soap_serialize__saml1__Statement(soap, (const struct saml1__StatementAbstractType *)ptr);
		break;
	case SOAP_TYPE__saml1__Advice:
		soap_serialize__saml1__Advice(soap, (const struct saml1__AdviceType *)ptr);
		break;
	case SOAP_TYPE__saml1__DoNotCacheCondition:
		soap_serialize__saml1__DoNotCacheCondition(soap, (const struct saml1__DoNotCacheConditionType *)ptr);
		break;
	case SOAP_TYPE__saml1__AudienceRestrictionCondition:
		soap_serialize__saml1__AudienceRestrictionCondition(soap, (const struct saml1__AudienceRestrictionConditionType *)ptr);
		break;
	case SOAP_TYPE__saml1__Condition:
		soap_serialize__saml1__Condition(soap, (const struct saml1__ConditionAbstractType *)ptr);
		break;
	case SOAP_TYPE__saml1__Conditions:
		soap_serialize__saml1__Conditions(soap, (const struct saml1__ConditionsType *)ptr);
		break;
	case SOAP_TYPE__saml1__Assertion:
		soap_serialize__saml1__Assertion(soap, (const struct saml1__AssertionType *)ptr);
		break;
	case SOAP_TYPE___saml1__union_EvidenceType:
		soap_serialize___saml1__union_EvidenceType(soap, (const struct __saml1__union_EvidenceType *)ptr);
		break;
	case SOAP_TYPE___saml1__union_AdviceType:
		soap_serialize___saml1__union_AdviceType(soap, (const struct __saml1__union_AdviceType *)ptr);
		break;
	case SOAP_TYPE___saml1__union_ConditionsType:
		soap_serialize___saml1__union_ConditionsType(soap, (const struct __saml1__union_ConditionsType *)ptr);
		break;
	case SOAP_TYPE___saml1__union_AssertionType:
		soap_serialize___saml1__union_AssertionType(soap, (const struct __saml1__union_AssertionType *)ptr);
		break;
	case SOAP_TYPE_saml1__AttributeType:
		soap_serialize_saml1__AttributeType(soap, (const struct saml1__AttributeType *)ptr);
		break;
	case SOAP_TYPE_saml1__AttributeDesignatorType:
		soap_serialize_saml1__AttributeDesignatorType(soap, (const struct saml1__AttributeDesignatorType *)ptr);
		break;
	case SOAP_TYPE_saml1__AttributeStatementType:
		soap_serialize_saml1__AttributeStatementType(soap, (const struct saml1__AttributeStatementType *)ptr);
		break;
	case SOAP_TYPE_saml1__EvidenceType:
		soap_serialize_saml1__EvidenceType(soap, (const struct saml1__EvidenceType *)ptr);
		break;
	case SOAP_TYPE_saml1__ActionType:
		soap_serialize_saml1__ActionType(soap, (const struct saml1__ActionType *)ptr);
		break;
	case SOAP_TYPE_saml1__AuthorizationDecisionStatementType:
		soap_serialize_saml1__AuthorizationDecisionStatementType(soap, (const struct saml1__AuthorizationDecisionStatementType *)ptr);
		break;
	case SOAP_TYPE_saml1__AuthorityBindingType:
		soap_serialize_saml1__AuthorityBindingType(soap, (const struct saml1__AuthorityBindingType *)ptr);
		break;
	case SOAP_TYPE_saml1__SubjectLocalityType:
		soap_serialize_saml1__SubjectLocalityType(soap, (const struct saml1__SubjectLocalityType *)ptr);
		break;
	case SOAP_TYPE_saml1__AuthenticationStatementType:
		soap_serialize_saml1__AuthenticationStatementType(soap, (const struct saml1__AuthenticationStatementType *)ptr);
		break;
	case SOAP_TYPE_saml1__SubjectConfirmationType:
		soap_serialize_saml1__SubjectConfirmationType(soap, (const struct saml1__SubjectConfirmationType *)ptr);
		break;
	case SOAP_TYPE_saml1__NameIdentifierType:
		soap_serialize_saml1__NameIdentifierType(soap, (const struct saml1__NameIdentifierType *)ptr);
		break;
	case SOAP_TYPE_saml1__SubjectType:
		soap_serialize_saml1__SubjectType(soap, (const struct saml1__SubjectType *)ptr);
		break;
	case SOAP_TYPE_saml1__SubjectStatementAbstractType:
		soap_serialize_saml1__SubjectStatementAbstractType(soap, (const struct saml1__SubjectStatementAbstractType *)ptr);
		break;
	case SOAP_TYPE_saml1__StatementAbstractType:
		soap_serialize_saml1__StatementAbstractType(soap, (const struct saml1__StatementAbstractType *)ptr);
		break;
	case SOAP_TYPE_saml1__AdviceType:
		soap_serialize_saml1__AdviceType(soap, (const struct saml1__AdviceType *)ptr);
		break;
	case SOAP_TYPE_saml1__DoNotCacheConditionType:
		soap_serialize_saml1__DoNotCacheConditionType(soap, (const struct saml1__DoNotCacheConditionType *)ptr);
		break;
	case SOAP_TYPE_saml1__AudienceRestrictionConditionType:
		soap_serialize_saml1__AudienceRestrictionConditionType(soap, (const struct saml1__AudienceRestrictionConditionType *)ptr);
		break;
	case SOAP_TYPE_saml1__ConditionAbstractType:
		soap_serialize_saml1__ConditionAbstractType(soap, (const struct saml1__ConditionAbstractType *)ptr);
		break;
	case SOAP_TYPE_saml1__ConditionsType:
		soap_serialize_saml1__ConditionsType(soap, (const struct saml1__ConditionsType *)ptr);
		break;
	case SOAP_TYPE_saml1__AssertionType:
		soap_serialize_saml1__AssertionType(soap, (const struct saml1__AssertionType *)ptr);
		break;
	case SOAP_TYPE_xsd__dateTime:
		soap_serialize_xsd__dateTime(soap, (const struct timeval *)ptr);
		break;
	case SOAP_TYPE___wsc__DerivedKeyTokenType_sequence:
		soap_serialize___wsc__DerivedKeyTokenType_sequence(soap, (const struct __wsc__DerivedKeyTokenType_sequence *)ptr);
		break;
	case SOAP_TYPE_wsc__PropertiesType:
		soap_serialize_wsc__PropertiesType(soap, (const struct wsc__PropertiesType *)ptr);
		break;
	case SOAP_TYPE_wsc__DerivedKeyTokenType:
		soap_serialize_wsc__DerivedKeyTokenType(soap, (const struct wsc__DerivedKeyTokenType *)ptr);
		break;
	case SOAP_TYPE_wsc__SecurityContextTokenType:
		soap_serialize_wsc__SecurityContextTokenType(soap, (const struct wsc__SecurityContextTokenType *)ptr);
		break;
	case SOAP_TYPE___xenc__union_ReferenceList:
		soap_serialize___xenc__union_ReferenceList(soap, (const struct __xenc__union_ReferenceList *)ptr);
		break;
	case SOAP_TYPE__xenc__ReferenceList:
		soap_serialize__xenc__ReferenceList(soap, (const struct _xenc__ReferenceList *)ptr);
		break;
	case SOAP_TYPE_xenc__EncryptionPropertyType:
		soap_serialize_xenc__EncryptionPropertyType(soap, (const struct xenc__EncryptionPropertyType *)ptr);
		break;
	case SOAP_TYPE_xenc__EncryptionPropertiesType:
		soap_serialize_xenc__EncryptionPropertiesType(soap, (const struct xenc__EncryptionPropertiesType *)ptr);
		break;
	case SOAP_TYPE_xenc__ReferenceType:
		soap_serialize_xenc__ReferenceType(soap, (const struct xenc__ReferenceType *)ptr);
		break;
	case SOAP_TYPE_xenc__AgreementMethodType:
		soap_serialize_xenc__AgreementMethodType(soap, (const struct xenc__AgreementMethodType *)ptr);
		break;
	case SOAP_TYPE_xenc__EncryptedDataType:
		soap_serialize_xenc__EncryptedDataType(soap, (const struct xenc__EncryptedDataType *)ptr);
		break;
	case SOAP_TYPE_xenc__TransformsType:
		soap_serialize_xenc__TransformsType(soap, (const struct xenc__TransformsType *)ptr);
		break;
	case SOAP_TYPE_xenc__CipherReferenceType:
		soap_serialize_xenc__CipherReferenceType(soap, (const struct xenc__CipherReferenceType *)ptr);
		break;
	case SOAP_TYPE_xenc__CipherDataType:
		soap_serialize_xenc__CipherDataType(soap, (const struct xenc__CipherDataType *)ptr);
		break;
	case SOAP_TYPE_xenc__EncryptionMethodType:
		soap_serialize_xenc__EncryptionMethodType(soap, (const struct xenc__EncryptionMethodType *)ptr);
		break;
	case SOAP_TYPE_xenc__EncryptedType:
		soap_serialize_xenc__EncryptedType(soap, (const struct xenc__EncryptedType *)ptr);
		break;
	case SOAP_TYPE_ds__RSAKeyValueType:
		soap_serialize_ds__RSAKeyValueType(soap, (const struct ds__RSAKeyValueType *)ptr);
		break;
	case SOAP_TYPE_ds__DSAKeyValueType:
		soap_serialize_ds__DSAKeyValueType(soap, (const struct ds__DSAKeyValueType *)ptr);
		break;
	case SOAP_TYPE_ds__X509IssuerSerialType:
		soap_serialize_ds__X509IssuerSerialType(soap, (const struct ds__X509IssuerSerialType *)ptr);
		break;
	case SOAP_TYPE__ds__KeyInfo:
		soap_serialize__ds__KeyInfo(soap, (const struct ds__KeyInfoType *)ptr);
		break;
	case SOAP_TYPE_ds__RetrievalMethodType:
		soap_serialize_ds__RetrievalMethodType(soap, (const struct ds__RetrievalMethodType *)ptr);
		break;
	case SOAP_TYPE_ds__KeyValueType:
		soap_serialize_ds__KeyValueType(soap, (const struct ds__KeyValueType *)ptr);
		break;
	case SOAP_TYPE_ds__DigestMethodType:
		soap_serialize_ds__DigestMethodType(soap, (const struct ds__DigestMethodType *)ptr);
		break;
	case SOAP_TYPE__ds__Transform:
		soap_serialize__ds__Transform(soap, (const struct ds__TransformType *)ptr);
		break;
	case SOAP_TYPE_ds__TransformType:
		soap_serialize_ds__TransformType(soap, (const struct ds__TransformType *)ptr);
		break;
	case SOAP_TYPE__c14n__InclusiveNamespaces:
		soap_serialize__c14n__InclusiveNamespaces(soap, (const struct _c14n__InclusiveNamespaces *)ptr);
		break;
	case SOAP_TYPE_ds__TransformsType:
		soap_serialize_ds__TransformsType(soap, (const struct ds__TransformsType *)ptr);
		break;
	case SOAP_TYPE_ds__ReferenceType:
		soap_serialize_ds__ReferenceType(soap, (const struct ds__ReferenceType *)ptr);
		break;
	case SOAP_TYPE_ds__SignatureMethodType:
		soap_serialize_ds__SignatureMethodType(soap, (const struct ds__SignatureMethodType *)ptr);
		break;
	case SOAP_TYPE_ds__CanonicalizationMethodType:
		soap_serialize_ds__CanonicalizationMethodType(soap, (const struct ds__CanonicalizationMethodType *)ptr);
		break;
	case SOAP_TYPE__ds__Signature:
		soap_serialize__ds__Signature(soap, (const struct ds__SignatureType *)ptr);
		break;
	case SOAP_TYPE_ds__SignedInfoType:
		soap_serialize_ds__SignedInfoType(soap, (const struct ds__SignedInfoType *)ptr);
		break;
	case SOAP_TYPE_ds__SignatureType:
		soap_serialize_ds__SignatureType(soap, (const struct ds__SignatureType *)ptr);
		break;
	case SOAP_TYPE_xenc__EncryptedKeyType:
		soap_serialize_xenc__EncryptedKeyType(soap, (const struct xenc__EncryptedKeyType *)ptr);
		break;
	case SOAP_TYPE_ds__KeyInfoType:
		soap_serialize_ds__KeyInfoType(soap, (const struct ds__KeyInfoType *)ptr);
		break;
	case SOAP_TYPE_ds__X509DataType:
		soap_serialize_ds__X509DataType(soap, (const struct ds__X509DataType *)ptr);
		break;
	case SOAP_TYPE__wsse__SecurityTokenReference:
		soap_serialize__wsse__SecurityTokenReference(soap, (const struct _wsse__SecurityTokenReference *)ptr);
		break;
	case SOAP_TYPE__wsse__KeyIdentifier:
		soap_serialize__wsse__KeyIdentifier(soap, (const struct _wsse__KeyIdentifier *)ptr);
		break;
	case SOAP_TYPE__wsse__Embedded:
		soap_serialize__wsse__Embedded(soap, (const struct _wsse__Embedded *)ptr);
		break;
	case SOAP_TYPE__wsse__Reference:
		soap_serialize__wsse__Reference(soap, (const struct _wsse__Reference *)ptr);
		break;
	case SOAP_TYPE__wsse__BinarySecurityToken:
		soap_serialize__wsse__BinarySecurityToken(soap, (const struct _wsse__BinarySecurityToken *)ptr);
		break;
	case SOAP_TYPE__wsse__Password:
		soap_serialize__wsse__Password(soap, (const struct _wsse__Password *)ptr);
		break;
	case SOAP_TYPE__wsse__UsernameToken:
		soap_serialize__wsse__UsernameToken(soap, (const struct _wsse__UsernameToken *)ptr);
		break;
	case SOAP_TYPE_wsse__EncodedString:
		soap_serialize_wsse__EncodedString(soap, (const struct wsse__EncodedString *)ptr);
		break;
	case SOAP_TYPE__wsu__Timestamp:
		soap_serialize__wsu__Timestamp(soap, (const struct _wsu__Timestamp *)ptr);
		break;
	case SOAP_TYPE_SOAP_ENV__Fault_alex:
		soap_serialize_SOAP_ENV__Fault_alex(soap, (const struct SOAP_ENV__Fault_alex *)ptr);
		break;
	case SOAP_TYPE_chan__ChannelInstanceType:
		soap_serialize_chan__ChannelInstanceType(soap, (const struct chan__ChannelInstanceType *)ptr);
		break;
	case SOAP_TYPE__wsa5__ProblemAction:
		soap_serialize__wsa5__ProblemAction(soap, (const struct wsa5__ProblemActionType *)ptr);
		break;
	case SOAP_TYPE__wsa5__FaultTo:
		soap_serialize__wsa5__FaultTo(soap, (const struct wsa5__EndpointReferenceType *)ptr);
		break;
	case SOAP_TYPE__wsa5__From:
		soap_serialize__wsa5__From(soap, (const struct wsa5__EndpointReferenceType *)ptr);
		break;
	case SOAP_TYPE__wsa5__ReplyTo:
		soap_serialize__wsa5__ReplyTo(soap, (const struct wsa5__EndpointReferenceType *)ptr);
		break;
	case SOAP_TYPE__wsa5__RelatesTo:
		soap_serialize__wsa5__RelatesTo(soap, (const struct wsa5__RelatesToType *)ptr);
		break;
	case SOAP_TYPE__wsa5__Metadata:
		soap_serialize__wsa5__Metadata(soap, (const struct wsa5__MetadataType *)ptr);
		break;
	case SOAP_TYPE__wsa5__ReferenceParameters:
		soap_serialize__wsa5__ReferenceParameters(soap, (const struct wsa5__ReferenceParametersType *)ptr);
		break;
	case SOAP_TYPE__wsa5__EndpointReference:
		soap_serialize__wsa5__EndpointReference(soap, (const struct wsa5__EndpointReferenceType *)ptr);
		break;
	case SOAP_TYPE_wsa5__ProblemActionType:
		soap_serialize_wsa5__ProblemActionType(soap, (const struct wsa5__ProblemActionType *)ptr);
		break;
	case SOAP_TYPE_wsa5__RelatesToType:
		soap_serialize_wsa5__RelatesToType(soap, (const struct wsa5__RelatesToType *)ptr);
		break;
	case SOAP_TYPE_wsa5__MetadataType:
		soap_serialize_wsa5__MetadataType(soap, (const struct wsa5__MetadataType *)ptr);
		break;
	case SOAP_TYPE_wsa5__ReferenceParametersType:
		soap_serialize_wsa5__ReferenceParametersType(soap, (const struct wsa5__ReferenceParametersType *)ptr);
		break;
	case SOAP_TYPE_wsa5__EndpointReferenceType:
		soap_serialize_wsa5__EndpointReferenceType(soap, (const struct wsa5__EndpointReferenceType *)ptr);
		break;
	case SOAP_TYPE___wsdd__ResolveMatches:
		soap_serialize___wsdd__ResolveMatches(soap, (const struct __wsdd__ResolveMatches *)ptr);
		break;
	case SOAP_TYPE___wsdd__Resolve:
		soap_serialize___wsdd__Resolve(soap, (const struct __wsdd__Resolve *)ptr);
		break;
	case SOAP_TYPE___wsdd__ProbeMatches:
		soap_serialize___wsdd__ProbeMatches(soap, (const struct __wsdd__ProbeMatches *)ptr);
		break;
	case SOAP_TYPE___wsdd__Probe:
		soap_serialize___wsdd__Probe(soap, (const struct __wsdd__Probe *)ptr);
		break;
	case SOAP_TYPE___wsdd__Bye:
		soap_serialize___wsdd__Bye(soap, (const struct __wsdd__Bye *)ptr);
		break;
	case SOAP_TYPE___wsdd__Hello:
		soap_serialize___wsdd__Hello(soap, (const struct __wsdd__Hello *)ptr);
		break;
	case SOAP_TYPE__wsdd__AppSequence:
		soap_serialize__wsdd__AppSequence(soap, (const struct wsdd__AppSequenceType *)ptr);
		break;
	case SOAP_TYPE__wsdd__Sig:
		soap_serialize__wsdd__Sig(soap, (const struct wsdd__SigType *)ptr);
		break;
	case SOAP_TYPE__wsdd__Security:
		soap_serialize__wsdd__Security(soap, (const struct wsdd__SecurityType *)ptr);
		break;
	case SOAP_TYPE__wsdd__Scopes:
		soap_serialize__wsdd__Scopes(soap, (const struct wsdd__ScopesType *)ptr);
		break;
	case SOAP_TYPE__wsdd__ResolveMatches:
		soap_serialize__wsdd__ResolveMatches(soap, (const struct wsdd__ResolveMatchesType *)ptr);
		break;
	case SOAP_TYPE__wsdd__Resolve:
		soap_serialize__wsdd__Resolve(soap, (const struct wsdd__ResolveType *)ptr);
		break;
	case SOAP_TYPE__wsdd__ProbeMatches:
		soap_serialize__wsdd__ProbeMatches(soap, (const struct wsdd__ProbeMatchesType *)ptr);
		break;
	case SOAP_TYPE__wsdd__Probe:
		soap_serialize__wsdd__Probe(soap, (const struct wsdd__ProbeType *)ptr);
		break;
	case SOAP_TYPE__wsdd__Bye:
		soap_serialize__wsdd__Bye(soap, (const struct wsdd__ByeType *)ptr);
		break;
	case SOAP_TYPE__wsdd__Hello:
		soap_serialize__wsdd__Hello(soap, (const struct wsdd__HelloType *)ptr);
		break;
	case SOAP_TYPE_wsdd__AppSequenceType:
		soap_serialize_wsdd__AppSequenceType(soap, (const struct wsdd__AppSequenceType *)ptr);
		break;
	case SOAP_TYPE_wsdd__SigType:
		soap_serialize_wsdd__SigType(soap, (const struct wsdd__SigType *)ptr);
		break;
	case SOAP_TYPE_wsdd__SecurityType:
		soap_serialize_wsdd__SecurityType(soap, (const struct wsdd__SecurityType *)ptr);
		break;
	case SOAP_TYPE_wsdd__ScopesType:
		soap_serialize_wsdd__ScopesType(soap, (const struct wsdd__ScopesType *)ptr);
		break;
	case SOAP_TYPE_wsdd__ResolveMatchType:
		soap_serialize_wsdd__ResolveMatchType(soap, (const struct wsdd__ResolveMatchType *)ptr);
		break;
	case SOAP_TYPE_wsdd__ResolveMatchesType:
		soap_serialize_wsdd__ResolveMatchesType(soap, (const struct wsdd__ResolveMatchesType *)ptr);
		break;
	case SOAP_TYPE_wsdd__ResolveType:
		soap_serialize_wsdd__ResolveType(soap, (const struct wsdd__ResolveType *)ptr);
		break;
	case SOAP_TYPE_wsdd__ProbeMatchType:
		soap_serialize_wsdd__ProbeMatchType(soap, (const struct wsdd__ProbeMatchType *)ptr);
		break;
	case SOAP_TYPE_wsdd__ProbeMatchesType:
		soap_serialize_wsdd__ProbeMatchesType(soap, (const struct wsdd__ProbeMatchesType *)ptr);
		break;
	case SOAP_TYPE_wsdd__ProbeType:
		soap_serialize_wsdd__ProbeType(soap, (const struct wsdd__ProbeType *)ptr);
		break;
	case SOAP_TYPE_wsdd__ByeType:
		soap_serialize_wsdd__ByeType(soap, (const struct wsdd__ByeType *)ptr);
		break;
	case SOAP_TYPE_wsdd__HelloType:
		soap_serialize_wsdd__HelloType(soap, (const struct wsdd__HelloType *)ptr);
		break;
	case SOAP_TYPE__wsa__FaultTo:
		soap_serialize__wsa__FaultTo(soap, (const struct wsa__EndpointReferenceType *)ptr);
		break;
	case SOAP_TYPE__wsa__ReplyTo:
		soap_serialize__wsa__ReplyTo(soap, (const struct wsa__EndpointReferenceType *)ptr);
		break;
	case SOAP_TYPE__wsa__From:
		soap_serialize__wsa__From(soap, (const struct wsa__EndpointReferenceType *)ptr);
		break;
	case SOAP_TYPE__wsa__RelatesTo:
		soap_serialize__wsa__RelatesTo(soap, (const struct wsa__Relationship *)ptr);
		break;
	case SOAP_TYPE__wsa__EndpointReference:
		soap_serialize__wsa__EndpointReference(soap, (const struct wsa__EndpointReferenceType *)ptr);
		break;
	case SOAP_TYPE_wsa__Relationship:
		soap_serialize_wsa__Relationship(soap, (const struct wsa__Relationship *)ptr);
		break;
	case SOAP_TYPE_wsa__ServiceNameType:
		soap_serialize_wsa__ServiceNameType(soap, (const struct wsa__ServiceNameType *)ptr);
		break;
	case SOAP_TYPE_wsa__ReferenceParametersType:
		soap_serialize_wsa__ReferenceParametersType(soap, (const struct wsa__ReferenceParametersType *)ptr);
		break;
	case SOAP_TYPE_wsa__ReferencePropertiesType:
		soap_serialize_wsa__ReferencePropertiesType(soap, (const struct wsa__ReferencePropertiesType *)ptr);
		break;
	case SOAP_TYPE_wsa__EndpointReferenceType:
		soap_serialize_wsa__EndpointReferenceType(soap, (const struct wsa__EndpointReferenceType *)ptr);
		break;
	case SOAP_TYPE_PointerTo_trt__GetSnapshotUriResponse:
		soap_serialize_PointerTo_trt__GetSnapshotUriResponse(soap, (struct _trt__GetSnapshotUriResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_trt__GetSnapshotUri:
		soap_serialize_PointerTo_trt__GetSnapshotUri(soap, (struct _trt__GetSnapshotUri *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_trt__GetProfilesResponse:
		soap_serialize_PointerTo_trt__GetProfilesResponse(soap, (struct _trt__GetProfilesResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_trt__GetProfiles:
		soap_serialize_PointerTo_trt__GetProfiles(soap, (struct _trt__GetProfiles *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_trt__GetProfileResponse:
		soap_serialize_PointerTo_trt__GetProfileResponse(soap, (struct _trt__GetProfileResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_trt__GetProfile:
		soap_serialize_PointerTo_trt__GetProfile(soap, (struct _trt__GetProfile *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_trt__CreateProfileResponse:
		soap_serialize_PointerTo_trt__CreateProfileResponse(soap, (struct _trt__CreateProfileResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_trt__CreateProfile:
		soap_serialize_PointerTo_trt__CreateProfile(soap, (struct _trt__CreateProfile *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_trt__GetServiceCapabilitiesResponse:
		soap_serialize_PointerTo_trt__GetServiceCapabilitiesResponse(soap, (struct _trt__GetServiceCapabilitiesResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_trt__GetServiceCapabilities:
		soap_serialize_PointerTo_trt__GetServiceCapabilities(soap, (struct _trt__GetServiceCapabilities *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_tds__GetCapabilitiesResponse:
		soap_serialize_PointerTo_tds__GetCapabilitiesResponse(soap, (struct _tds__GetCapabilitiesResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_tds__GetCapabilities:
		soap_serialize_PointerTo_tds__GetCapabilities(soap, (struct _tds__GetCapabilities *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_tds__SystemRebootResponse:
		soap_serialize_PointerTo_tds__SystemRebootResponse(soap, (struct _tds__SystemRebootResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_tds__SystemReboot:
		soap_serialize_PointerTo_tds__SystemReboot(soap, (struct _tds__SystemReboot *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_tds__GetDeviceInformationResponse:
		soap_serialize_PointerTo_tds__GetDeviceInformationResponse(soap, (struct _tds__GetDeviceInformationResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_tds__GetDeviceInformation:
		soap_serialize_PointerTo_tds__GetDeviceInformation(soap, (struct _tds__GetDeviceInformation *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_tds__GetServiceCapabilitiesResponse:
		soap_serialize_PointerTo_tds__GetServiceCapabilitiesResponse(soap, (struct _tds__GetServiceCapabilitiesResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_tds__GetServiceCapabilities:
		soap_serialize_PointerTo_tds__GetServiceCapabilities(soap, (struct _tds__GetServiceCapabilities *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_tds__GetServicesResponse:
		soap_serialize_PointerTo_tds__GetServicesResponse(soap, (struct _tds__GetServicesResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_tds__GetServices:
		soap_serialize_PointerTo_tds__GetServices(soap, (struct _tds__GetServices *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_wstop__TopicNamespaceType_Topic:
		soap_serialize_PointerTo_wstop__TopicNamespaceType_Topic(soap, (struct _wstop__TopicNamespaceType_Topic *const*)ptr);
		break;
	case SOAP_TYPE_PointerTowstop__TopicType:
		soap_serialize_PointerTowstop__TopicType(soap, (struct wstop__TopicType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTowstop__QueryExpressionType:
		soap_serialize_PointerTowstop__QueryExpressionType(soap, (struct wstop__QueryExpressionType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_wsnt__ResumeFailedFaultType_FaultCause:
		soap_serialize_PointerTo_wsnt__ResumeFailedFaultType_FaultCause(soap, (struct _wsnt__ResumeFailedFaultType_FaultCause *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_wsnt__ResumeFailedFaultType_Description:
		soap_serialize_PointerTo_wsnt__ResumeFailedFaultType_Description(soap, (struct _wsnt__ResumeFailedFaultType_Description *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_wsnt__ResumeFailedFaultType_ErrorCode:
		soap_serialize_PointerTo_wsnt__ResumeFailedFaultType_ErrorCode(soap, (struct _wsnt__ResumeFailedFaultType_ErrorCode *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_wsnt__PauseFailedFaultType_FaultCause:
		soap_serialize_PointerTo_wsnt__PauseFailedFaultType_FaultCause(soap, (struct _wsnt__PauseFailedFaultType_FaultCause *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_wsnt__PauseFailedFaultType_Description:
		soap_serialize_PointerTo_wsnt__PauseFailedFaultType_Description(soap, (struct _wsnt__PauseFailedFaultType_Description *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_wsnt__PauseFailedFaultType_ErrorCode:
		soap_serialize_PointerTo_wsnt__PauseFailedFaultType_ErrorCode(soap, (struct _wsnt__PauseFailedFaultType_ErrorCode *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_wsnt__UnableToDestroySubscriptionFaultType_FaultCause:
		soap_serialize_PointerTo_wsnt__UnableToDestroySubscriptionFaultType_FaultCause(soap, (struct _wsnt__UnableToDestroySubscriptionFaultType_FaultCause *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_wsnt__UnableToDestroySubscriptionFaultType_Description:
		soap_serialize_PointerTo_wsnt__UnableToDestroySubscriptionFaultType_Description(soap, (struct _wsnt__UnableToDestroySubscriptionFaultType_Description *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_wsnt__UnableToDestroySubscriptionFaultType_ErrorCode:
		soap_serialize_PointerTo_wsnt__UnableToDestroySubscriptionFaultType_ErrorCode(soap, (struct _wsnt__UnableToDestroySubscriptionFaultType_ErrorCode *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_wsnt__UnacceptableTerminationTimeFaultType_FaultCause:
		soap_serialize_PointerTo_wsnt__UnacceptableTerminationTimeFaultType_FaultCause(soap, (struct _wsnt__UnacceptableTerminationTimeFaultType_FaultCause *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_wsnt__UnacceptableTerminationTimeFaultType_Description:
		soap_serialize_PointerTo_wsnt__UnacceptableTerminationTimeFaultType_Description(soap, (struct _wsnt__UnacceptableTerminationTimeFaultType_Description *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_wsnt__UnacceptableTerminationTimeFaultType_ErrorCode:
		soap_serialize_PointerTo_wsnt__UnacceptableTerminationTimeFaultType_ErrorCode(soap, (struct _wsnt__UnacceptableTerminationTimeFaultType_ErrorCode *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_wsnt__UnableToCreatePullPointFaultType_FaultCause:
		soap_serialize_PointerTo_wsnt__UnableToCreatePullPointFaultType_FaultCause(soap, (struct _wsnt__UnableToCreatePullPointFaultType_FaultCause *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_wsnt__UnableToCreatePullPointFaultType_Description:
		soap_serialize_PointerTo_wsnt__UnableToCreatePullPointFaultType_Description(soap, (struct _wsnt__UnableToCreatePullPointFaultType_Description *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_wsnt__UnableToCreatePullPointFaultType_ErrorCode:
		soap_serialize_PointerTo_wsnt__UnableToCreatePullPointFaultType_ErrorCode(soap, (struct _wsnt__UnableToCreatePullPointFaultType_ErrorCode *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_wsnt__UnableToDestroyPullPointFaultType_FaultCause:
		soap_serialize_PointerTo_wsnt__UnableToDestroyPullPointFaultType_FaultCause(soap, (struct _wsnt__UnableToDestroyPullPointFaultType_FaultCause *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_wsnt__UnableToDestroyPullPointFaultType_Description:
		soap_serialize_PointerTo_wsnt__UnableToDestroyPullPointFaultType_Description(soap, (struct _wsnt__UnableToDestroyPullPointFaultType_Description *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_wsnt__UnableToDestroyPullPointFaultType_ErrorCode:
		soap_serialize_PointerTo_wsnt__UnableToDestroyPullPointFaultType_ErrorCode(soap, (struct _wsnt__UnableToDestroyPullPointFaultType_ErrorCode *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_wsnt__UnableToGetMessagesFaultType_FaultCause:
		soap_serialize_PointerTo_wsnt__UnableToGetMessagesFaultType_FaultCause(soap, (struct _wsnt__UnableToGetMessagesFaultType_FaultCause *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_wsnt__UnableToGetMessagesFaultType_Description:
		soap_serialize_PointerTo_wsnt__UnableToGetMessagesFaultType_Description(soap, (struct _wsnt__UnableToGetMessagesFaultType_Description *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_wsnt__UnableToGetMessagesFaultType_ErrorCode:
		soap_serialize_PointerTo_wsnt__UnableToGetMessagesFaultType_ErrorCode(soap, (struct _wsnt__UnableToGetMessagesFaultType_ErrorCode *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_wsnt__NoCurrentMessageOnTopicFaultType_FaultCause:
		soap_serialize_PointerTo_wsnt__NoCurrentMessageOnTopicFaultType_FaultCause(soap, (struct _wsnt__NoCurrentMessageOnTopicFaultType_FaultCause *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_wsnt__NoCurrentMessageOnTopicFaultType_Description:
		soap_serialize_PointerTo_wsnt__NoCurrentMessageOnTopicFaultType_Description(soap, (struct _wsnt__NoCurrentMessageOnTopicFaultType_Description *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_wsnt__NoCurrentMessageOnTopicFaultType_ErrorCode:
		soap_serialize_PointerTo_wsnt__NoCurrentMessageOnTopicFaultType_ErrorCode(soap, (struct _wsnt__NoCurrentMessageOnTopicFaultType_ErrorCode *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_wsnt__UnacceptableInitialTerminationTimeFaultType_FaultCause:
		soap_serialize_PointerTo_wsnt__UnacceptableInitialTerminationTimeFaultType_FaultCause(soap, (struct _wsnt__UnacceptableInitialTerminationTimeFaultType_FaultCause *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_wsnt__UnacceptableInitialTerminationTimeFaultType_Description:
		soap_serialize_PointerTo_wsnt__UnacceptableInitialTerminationTimeFaultType_Description(soap, (struct _wsnt__UnacceptableInitialTerminationTimeFaultType_Description *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_wsnt__UnacceptableInitialTerminationTimeFaultType_ErrorCode:
		soap_serialize_PointerTo_wsnt__UnacceptableInitialTerminationTimeFaultType_ErrorCode(soap, (struct _wsnt__UnacceptableInitialTerminationTimeFaultType_ErrorCode *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_wsnt__NotifyMessageNotSupportedFaultType_FaultCause:
		soap_serialize_PointerTo_wsnt__NotifyMessageNotSupportedFaultType_FaultCause(soap, (struct _wsnt__NotifyMessageNotSupportedFaultType_FaultCause *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_wsnt__NotifyMessageNotSupportedFaultType_Description:
		soap_serialize_PointerTo_wsnt__NotifyMessageNotSupportedFaultType_Description(soap, (struct _wsnt__NotifyMessageNotSupportedFaultType_Description *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_wsnt__NotifyMessageNotSupportedFaultType_ErrorCode:
		soap_serialize_PointerTo_wsnt__NotifyMessageNotSupportedFaultType_ErrorCode(soap, (struct _wsnt__NotifyMessageNotSupportedFaultType_ErrorCode *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_wsnt__UnsupportedPolicyRequestFaultType_FaultCause:
		soap_serialize_PointerTo_wsnt__UnsupportedPolicyRequestFaultType_FaultCause(soap, (struct _wsnt__UnsupportedPolicyRequestFaultType_FaultCause *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_wsnt__UnsupportedPolicyRequestFaultType_Description:
		soap_serialize_PointerTo_wsnt__UnsupportedPolicyRequestFaultType_Description(soap, (struct _wsnt__UnsupportedPolicyRequestFaultType_Description *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_wsnt__UnsupportedPolicyRequestFaultType_ErrorCode:
		soap_serialize_PointerTo_wsnt__UnsupportedPolicyRequestFaultType_ErrorCode(soap, (struct _wsnt__UnsupportedPolicyRequestFaultType_ErrorCode *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_wsnt__UnrecognizedPolicyRequestFaultType_FaultCause:
		soap_serialize_PointerTo_wsnt__UnrecognizedPolicyRequestFaultType_FaultCause(soap, (struct _wsnt__UnrecognizedPolicyRequestFaultType_FaultCause *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_wsnt__UnrecognizedPolicyRequestFaultType_Description:
		soap_serialize_PointerTo_wsnt__UnrecognizedPolicyRequestFaultType_Description(soap, (struct _wsnt__UnrecognizedPolicyRequestFaultType_Description *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_wsnt__UnrecognizedPolicyRequestFaultType_ErrorCode:
		soap_serialize_PointerTo_wsnt__UnrecognizedPolicyRequestFaultType_ErrorCode(soap, (struct _wsnt__UnrecognizedPolicyRequestFaultType_ErrorCode *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_wsnt__InvalidMessageContentExpressionFaultType_FaultCause:
		soap_serialize_PointerTo_wsnt__InvalidMessageContentExpressionFaultType_FaultCause(soap, (struct _wsnt__InvalidMessageContentExpressionFaultType_FaultCause *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_wsnt__InvalidMessageContentExpressionFaultType_Description:
		soap_serialize_PointerTo_wsnt__InvalidMessageContentExpressionFaultType_Description(soap, (struct _wsnt__InvalidMessageContentExpressionFaultType_Description *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_wsnt__InvalidMessageContentExpressionFaultType_ErrorCode:
		soap_serialize_PointerTo_wsnt__InvalidMessageContentExpressionFaultType_ErrorCode(soap, (struct _wsnt__InvalidMessageContentExpressionFaultType_ErrorCode *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_wsnt__InvalidProducerPropertiesExpressionFaultType_FaultCause:
		soap_serialize_PointerTo_wsnt__InvalidProducerPropertiesExpressionFaultType_FaultCause(soap, (struct _wsnt__InvalidProducerPropertiesExpressionFaultType_FaultCause *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_wsnt__InvalidProducerPropertiesExpressionFaultType_Description:
		soap_serialize_PointerTo_wsnt__InvalidProducerPropertiesExpressionFaultType_Description(soap, (struct _wsnt__InvalidProducerPropertiesExpressionFaultType_Description *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_wsnt__InvalidProducerPropertiesExpressionFaultType_ErrorCode:
		soap_serialize_PointerTo_wsnt__InvalidProducerPropertiesExpressionFaultType_ErrorCode(soap, (struct _wsnt__InvalidProducerPropertiesExpressionFaultType_ErrorCode *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_wsnt__MultipleTopicsSpecifiedFaultType_FaultCause:
		soap_serialize_PointerTo_wsnt__MultipleTopicsSpecifiedFaultType_FaultCause(soap, (struct _wsnt__MultipleTopicsSpecifiedFaultType_FaultCause *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_wsnt__MultipleTopicsSpecifiedFaultType_Description:
		soap_serialize_PointerTo_wsnt__MultipleTopicsSpecifiedFaultType_Description(soap, (struct _wsnt__MultipleTopicsSpecifiedFaultType_Description *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_wsnt__MultipleTopicsSpecifiedFaultType_ErrorCode:
		soap_serialize_PointerTo_wsnt__MultipleTopicsSpecifiedFaultType_ErrorCode(soap, (struct _wsnt__MultipleTopicsSpecifiedFaultType_ErrorCode *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_wsnt__TopicNotSupportedFaultType_FaultCause:
		soap_serialize_PointerTo_wsnt__TopicNotSupportedFaultType_FaultCause(soap, (struct _wsnt__TopicNotSupportedFaultType_FaultCause *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_wsnt__TopicNotSupportedFaultType_Description:
		soap_serialize_PointerTo_wsnt__TopicNotSupportedFaultType_Description(soap, (struct _wsnt__TopicNotSupportedFaultType_Description *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_wsnt__TopicNotSupportedFaultType_ErrorCode:
		soap_serialize_PointerTo_wsnt__TopicNotSupportedFaultType_ErrorCode(soap, (struct _wsnt__TopicNotSupportedFaultType_ErrorCode *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_wsnt__InvalidTopicExpressionFaultType_FaultCause:
		soap_serialize_PointerTo_wsnt__InvalidTopicExpressionFaultType_FaultCause(soap, (struct _wsnt__InvalidTopicExpressionFaultType_FaultCause *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_wsnt__InvalidTopicExpressionFaultType_Description:
		soap_serialize_PointerTo_wsnt__InvalidTopicExpressionFaultType_Description(soap, (struct _wsnt__InvalidTopicExpressionFaultType_Description *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_wsnt__InvalidTopicExpressionFaultType_ErrorCode:
		soap_serialize_PointerTo_wsnt__InvalidTopicExpressionFaultType_ErrorCode(soap, (struct _wsnt__InvalidTopicExpressionFaultType_ErrorCode *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_wsnt__TopicExpressionDialectUnknownFaultType_FaultCause:
		soap_serialize_PointerTo_wsnt__TopicExpressionDialectUnknownFaultType_FaultCause(soap, (struct _wsnt__TopicExpressionDialectUnknownFaultType_FaultCause *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_wsnt__TopicExpressionDialectUnknownFaultType_Description:
		soap_serialize_PointerTo_wsnt__TopicExpressionDialectUnknownFaultType_Description(soap, (struct _wsnt__TopicExpressionDialectUnknownFaultType_Description *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_wsnt__TopicExpressionDialectUnknownFaultType_ErrorCode:
		soap_serialize_PointerTo_wsnt__TopicExpressionDialectUnknownFaultType_ErrorCode(soap, (struct _wsnt__TopicExpressionDialectUnknownFaultType_ErrorCode *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_wsnt__InvalidFilterFaultType_FaultCause:
		soap_serialize_PointerTo_wsnt__InvalidFilterFaultType_FaultCause(soap, (struct _wsnt__InvalidFilterFaultType_FaultCause *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_wsnt__InvalidFilterFaultType_Description:
		soap_serialize_PointerTo_wsnt__InvalidFilterFaultType_Description(soap, (struct _wsnt__InvalidFilterFaultType_Description *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_wsnt__InvalidFilterFaultType_ErrorCode:
		soap_serialize_PointerTo_wsnt__InvalidFilterFaultType_ErrorCode(soap, (struct _wsnt__InvalidFilterFaultType_ErrorCode *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_wsnt__SubscribeCreationFailedFaultType_FaultCause:
		soap_serialize_PointerTo_wsnt__SubscribeCreationFailedFaultType_FaultCause(soap, (struct _wsnt__SubscribeCreationFailedFaultType_FaultCause *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_wsnt__SubscribeCreationFailedFaultType_Description:
		soap_serialize_PointerTo_wsnt__SubscribeCreationFailedFaultType_Description(soap, (struct _wsnt__SubscribeCreationFailedFaultType_Description *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_wsnt__SubscribeCreationFailedFaultType_ErrorCode:
		soap_serialize_PointerTo_wsnt__SubscribeCreationFailedFaultType_ErrorCode(soap, (struct _wsnt__SubscribeCreationFailedFaultType_ErrorCode *const*)ptr);
		break;
	case SOAP_TYPE_PointerTott__MulticastConfiguration:
		soap_serialize_PointerTott__MulticastConfiguration(soap, (struct tt__MulticastConfiguration *const*)ptr);
		break;
	case SOAP_TYPE_PointerTott__H264Configuration:
		soap_serialize_PointerTott__H264Configuration(soap, (struct tt__H264Configuration *const*)ptr);
		break;
	case SOAP_TYPE_PointerTott__Mpeg4Configuration:
		soap_serialize_PointerTott__Mpeg4Configuration(soap, (struct tt__Mpeg4Configuration *const*)ptr);
		break;
	case SOAP_TYPE_PointerTott__VideoRateControl:
		soap_serialize_PointerTott__VideoRateControl(soap, (struct tt__VideoRateControl *const*)ptr);
		break;
	case SOAP_TYPE_PointerTott__MediaUri:
		soap_serialize_PointerTott__MediaUri(soap, (struct tt__MediaUri *const*)ptr);
		break;
	case SOAP_TYPE_PointerTott__Profile:
		soap_serialize_PointerTott__Profile(soap, (struct tt__Profile *const*)ptr);
		break;
	case SOAP_TYPE_PointerTotrt__Capabilities:
		soap_serialize_PointerTotrt__Capabilities(soap, (struct trt__Capabilities *const*)ptr);
		break;
	case SOAP_TYPE_PointerTotrt__ProfileCapabilities:
		soap_serialize_PointerTotrt__ProfileCapabilities(soap, (struct trt__ProfileCapabilities *const*)ptr);
		break;
	case SOAP_TYPE_PointerTowstop__Documentation:
		soap_serialize_PointerTowstop__Documentation(soap, (struct wstop__Documentation *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_wsrfbf__BaseFaultType_FaultCause:
		soap_serialize_PointerTo_wsrfbf__BaseFaultType_FaultCause(soap, (struct _wsrfbf__BaseFaultType_FaultCause *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_wsrfbf__BaseFaultType_Description:
		soap_serialize_PointerTo_wsrfbf__BaseFaultType_Description(soap, (struct _wsrfbf__BaseFaultType_Description *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_wsrfbf__BaseFaultType_ErrorCode:
		soap_serialize_PointerTo_wsrfbf__BaseFaultType_ErrorCode(soap, (struct _wsrfbf__BaseFaultType_ErrorCode *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_wsnt__Subscribe_SubscriptionPolicy:
		soap_serialize_PointerTo_wsnt__Subscribe_SubscriptionPolicy(soap, (struct _wsnt__Subscribe_SubscriptionPolicy *const*)ptr);
		break;
	case SOAP_TYPE_PointerTowsnt__NotificationMessageHolderType:
		soap_serialize_PointerTowsnt__NotificationMessageHolderType(soap, (struct wsnt__NotificationMessageHolderType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTodateTime:
		soap_serialize_PointerTodateTime(soap, (time_t *const*)ptr);
		break;
	case SOAP_TYPE_PointerTowsnt__SubscriptionPolicyType:
		soap_serialize_PointerTowsnt__SubscriptionPolicyType(soap, (struct wsnt__SubscriptionPolicyType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTowsnt__FilterType:
		soap_serialize_PointerTowsnt__FilterType(soap, (struct wsnt__FilterType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTowstop__TopicSetType:
		soap_serialize_PointerTowstop__TopicSetType(soap, (struct wstop__TopicSetType *const*)ptr);
		break;
	case SOAP_TYPE_PointerToxsd__anyURI:
		soap_serialize_PointerToxsd__anyURI(soap, (char **const*)ptr);
		break;
	case SOAP_TYPE_PointerTowsnt__TopicExpressionType:
		soap_serialize_PointerTowsnt__TopicExpressionType(soap, (struct wsnt__TopicExpressionType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTowsa5__EndpointReferenceType:
		soap_serialize_PointerTowsa5__EndpointReferenceType(soap, (struct wsa5__EndpointReferenceType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTott__PropertyOperation:
		soap_serialize_PointerTott__PropertyOperation(soap, (enum tt__PropertyOperation *const*)ptr);
		break;
	case SOAP_TYPE_PointerTott__MessageExtension:
		soap_serialize_PointerTott__MessageExtension(soap, (struct tt__MessageExtension *const*)ptr);
		break;
	case SOAP_TYPE_PointerTott__ItemList:
		soap_serialize_PointerTott__ItemList(soap, (struct tt__ItemList *const*)ptr);
		break;
	case SOAP_TYPE_PointerTott__IPAddress:
		soap_serialize_PointerTott__IPAddress(soap, (struct tt__IPAddress *const*)ptr);
		break;
	case SOAP_TYPE_PointerTott__H264Profile:
		soap_serialize_PointerTott__H264Profile(soap, (enum tt__H264Profile *const*)ptr);
		break;
	case SOAP_TYPE_PointerTott__Mpeg4Profile:
		soap_serialize_PointerTott__Mpeg4Profile(soap, (enum tt__Mpeg4Profile *const*)ptr);
		break;
	case SOAP_TYPE_PointerTott__VideoResolution:
		soap_serialize_PointerTott__VideoResolution(soap, (struct tt__VideoResolution *const*)ptr);
		break;
	case SOAP_TYPE_PointerTott__VideoEncoderOptionsExtension2:
		soap_serialize_PointerTott__VideoEncoderOptionsExtension2(soap, (struct tt__VideoEncoderOptionsExtension2 *const*)ptr);
		break;
	case SOAP_TYPE_PointerTott__H264Options2:
		soap_serialize_PointerTott__H264Options2(soap, (struct tt__H264Options2 *const*)ptr);
		break;
	case SOAP_TYPE_PointerTott__Mpeg4Options2:
		soap_serialize_PointerTott__Mpeg4Options2(soap, (struct tt__Mpeg4Options2 *const*)ptr);
		break;
	case SOAP_TYPE_PointerTott__JpegOptions2:
		soap_serialize_PointerTott__JpegOptions2(soap, (struct tt__JpegOptions2 *const*)ptr);
		break;
	case SOAP_TYPE_PointerTott__VideoEncoderOptionsExtension:
		soap_serialize_PointerTott__VideoEncoderOptionsExtension(soap, (struct tt__VideoEncoderOptionsExtension *const*)ptr);
		break;
	case SOAP_TYPE_PointerTott__H264Options:
		soap_serialize_PointerTott__H264Options(soap, (struct tt__H264Options *const*)ptr);
		break;
	case SOAP_TYPE_PointerTott__Mpeg4Options:
		soap_serialize_PointerTott__Mpeg4Options(soap, (struct tt__Mpeg4Options *const*)ptr);
		break;
	case SOAP_TYPE_PointerTott__JpegOptions:
		soap_serialize_PointerTott__JpegOptions(soap, (struct tt__JpegOptions *const*)ptr);
		break;
	case SOAP_TYPE_PointerTott__ItemListDescriptionExtension:
		soap_serialize_PointerTott__ItemListDescriptionExtension(soap, (struct tt__ItemListDescriptionExtension *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_tt__ItemListDescription_ElementItemDescription:
		soap_serialize_PointerTo_tt__ItemListDescription_ElementItemDescription(soap, (struct _tt__ItemListDescription_ElementItemDescription *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_tt__ItemListDescription_SimpleItemDescription:
		soap_serialize_PointerTo_tt__ItemListDescription_SimpleItemDescription(soap, (struct _tt__ItemListDescription_SimpleItemDescription *const*)ptr);
		break;
	case SOAP_TYPE_PointerTott__MessageDescriptionExtension:
		soap_serialize_PointerTott__MessageDescriptionExtension(soap, (struct tt__MessageDescriptionExtension *const*)ptr);
		break;
	case SOAP_TYPE_PointerTott__ItemListDescription:
		soap_serialize_PointerTott__ItemListDescription(soap, (struct tt__ItemListDescription *const*)ptr);
		break;
	case SOAP_TYPE_PointerTott__ItemListExtension:
		soap_serialize_PointerTott__ItemListExtension(soap, (struct tt__ItemListExtension *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_tt__ItemList_ElementItem:
		soap_serialize_PointerTo_tt__ItemList_ElementItem(soap, (struct _tt__ItemList_ElementItem *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_tt__ItemList_SimpleItem:
		soap_serialize_PointerTo_tt__ItemList_SimpleItem(soap, (struct _tt__ItemList_SimpleItem *const*)ptr);
		break;
	case SOAP_TYPE_PointerTott__MoveStatus:
		soap_serialize_PointerTott__MoveStatus(soap, (enum tt__MoveStatus *const*)ptr);
		break;
	case SOAP_TYPE_PointerTott__PTZVector:
		soap_serialize_PointerTott__PTZVector(soap, (struct tt__PTZVector *const*)ptr);
		break;
	case SOAP_TYPE_PointerTott__Vector1D:
		soap_serialize_PointerTott__Vector1D(soap, (struct tt__Vector1D *const*)ptr);
		break;
	case SOAP_TYPE_PointerTott__Vector2D:
		soap_serialize_PointerTott__Vector2D(soap, (struct tt__Vector2D *const*)ptr);
		break;
	case SOAP_TYPE_PointerTott__FloatRange:
		soap_serialize_PointerTott__FloatRange(soap, (struct tt__FloatRange *const*)ptr);
		break;
	case SOAP_TYPE_PointerTott__Space1DDescription:
		soap_serialize_PointerTott__Space1DDescription(soap, (struct tt__Space1DDescription *const*)ptr);
		break;
	case SOAP_TYPE_PointerTott__Space2DDescription:
		soap_serialize_PointerTott__Space2DDescription(soap, (struct tt__Space2DDescription *const*)ptr);
		break;
	case SOAP_TYPE_PointerTott__ProfileCapabilities:
		soap_serialize_PointerTott__ProfileCapabilities(soap, (struct tt__ProfileCapabilities *const*)ptr);
		break;
	case SOAP_TYPE_PointerTott__MediaCapabilitiesExtension:
		soap_serialize_PointerTott__MediaCapabilitiesExtension(soap, (struct tt__MediaCapabilitiesExtension *const*)ptr);
		break;
	case SOAP_TYPE_PointerTott__RealTimeStreamingCapabilities:
		soap_serialize_PointerTott__RealTimeStreamingCapabilities(soap, (struct tt__RealTimeStreamingCapabilities *const*)ptr);
		break;
	case SOAP_TYPE_PointerTott__SystemCapabilities:
		soap_serialize_PointerTott__SystemCapabilities(soap, (struct tt__SystemCapabilities *const*)ptr);
		break;
	case SOAP_TYPE_PointerTott__PTZCapabilities:
		soap_serialize_PointerTott__PTZCapabilities(soap, (struct tt__PTZCapabilities *const*)ptr);
		break;
	case SOAP_TYPE_PointerTott__MediaCapabilities:
		soap_serialize_PointerTott__MediaCapabilities(soap, (struct tt__MediaCapabilities *const*)ptr);
		break;
	case SOAP_TYPE_PointerTott__EventCapabilities:
		soap_serialize_PointerTott__EventCapabilities(soap, (struct tt__EventCapabilities *const*)ptr);
		break;
	case SOAP_TYPE_PointerTott__DeviceCapabilities:
		soap_serialize_PointerTott__DeviceCapabilities(soap, (struct tt__DeviceCapabilities *const*)ptr);
		break;
	case SOAP_TYPE_PointerToxsd__boolean:
		soap_serialize_PointerToxsd__boolean(soap, (enum xsd__boolean *const*)ptr);
		break;
	case SOAP_TYPE_PointerTott__VideoEncoderConfiguration:
		soap_serialize_PointerTott__VideoEncoderConfiguration(soap, (struct tt__VideoEncoderConfiguration *const*)ptr);
		break;
	case SOAP_TYPE_PointerTofloat:
		soap_serialize_PointerTofloat(soap, (float *const*)ptr);
		break;
	case SOAP_TYPE_PointerTott__IntRange:
		soap_serialize_PointerTott__IntRange(soap, (struct tt__IntRange *const*)ptr);
		break;
	case SOAP_TYPE_PointerTott__Capabilities:
		soap_serialize_PointerTott__Capabilities(soap, (struct tt__Capabilities *const*)ptr);
		break;
	case SOAP_TYPE_PointerTott__CapabilityCategory:
		soap_serialize_PointerTott__CapabilityCategory(soap, (enum tt__CapabilityCategory *const*)ptr);
		break;
	case SOAP_TYPE_PointerTotds__DeviceServiceCapabilities:
		soap_serialize_PointerTotds__DeviceServiceCapabilities(soap, (struct tds__DeviceServiceCapabilities *const*)ptr);
		break;
	case SOAP_TYPE_PointerTotds__Service:
		soap_serialize_PointerTotds__Service(soap, (struct tds__Service *const*)ptr);
		break;
	case SOAP_TYPE_PointerTott__OnvifVersion:
		soap_serialize_PointerTott__OnvifVersion(soap, (struct tt__OnvifVersion *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_tds__Service_Capabilities:
		soap_serialize_PointerTo_tds__Service_Capabilities(soap, (struct _tds__Service_Capabilities *const*)ptr);
		break;
	case SOAP_TYPE_wstop__SimpleTopicExpression:
		soap_serialize_string(soap, (char*const*)(void*)&ptr);
		break;
	case SOAP_TYPE_wstop__ConcreteTopicExpression:
		soap_serialize_string(soap, (char*const*)(void*)&ptr);
		break;
	case SOAP_TYPE_wstop__FullTopicExpression:
		soap_serialize_string(soap, (char*const*)(void*)&ptr);
		break;
	case SOAP_TYPE_tt__IPv6Address:
		soap_serialize_string(soap, (char*const*)(void*)&ptr);
		break;
	case SOAP_TYPE_tt__IPv4Address:
		soap_serialize_string(soap, (char*const*)(void*)&ptr);
		break;
	case SOAP_TYPE_tt__TopicNamespaceLocation:
		soap_serialize_string(soap, (char*const*)(void*)&ptr);
		break;
	case SOAP_TYPE_tt__Name:
		soap_serialize_string(soap, (char*const*)(void*)&ptr);
		break;
	case SOAP_TYPE_tt__ReferenceToken:
		soap_serialize_string(soap, (char*const*)(void*)&ptr);
		break;
	case SOAP_TYPE_wsnt__AbsoluteOrRelativeTimeType:
		soap_serialize_string(soap, (char*const*)(void*)&ptr);
		break;
	case SOAP_TYPE_tt__StringAttrList:
		soap_serialize_string(soap, (char*const*)(void*)&ptr);
		break;
	case SOAP_TYPE_tt__FloatAttrList:
		soap_serialize_string(soap, (char*const*)(void*)&ptr);
		break;
	case SOAP_TYPE_tt__IntAttrList:
		soap_serialize_string(soap, (char*const*)(void*)&ptr);
		break;
	case SOAP_TYPE_tds__EAPMethodTypes:
		soap_serialize_string(soap, (char*const*)(void*)&ptr);
		break;
	case SOAP_TYPE__xml__lang:
		soap_serialize_string(soap, (char*const*)(void*)&ptr);
		break;
	case SOAP_TYPE_xsd__token:
		soap_serialize_string(soap, (char*const*)(void*)&ptr);
		break;
	case SOAP_TYPE_xsd__nonNegativeInteger:
		soap_serialize_string(soap, (char*const*)(void*)&ptr);
		break;
	case SOAP_TYPE_xsd__anyURI:
		soap_serialize_string(soap, (char*const*)(void*)&ptr);
		break;
	case SOAP_TYPE_xsd__anySimpleType:
		soap_serialize_string(soap, (char*const*)(void*)&ptr);
		break;
	case SOAP_TYPE_xsd__NCName:
		soap_serialize_string(soap, (char*const*)(void*)&ptr);
		break;
	case SOAP_TYPE_PointerTo_wsse__Security:
		soap_serialize_PointerTo_wsse__Security(soap, (struct _wsse__Security *const*)ptr);
		break;
	case SOAP_TYPE_PointerTods__SignatureType:
		soap_serialize_PointerTods__SignatureType(soap, (struct ds__SignatureType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTowsc__SecurityContextTokenType:
		soap_serialize_PointerTowsc__SecurityContextTokenType(soap, (struct wsc__SecurityContextTokenType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_wsse__BinarySecurityToken:
		soap_serialize_PointerTo_wsse__BinarySecurityToken(soap, (struct _wsse__BinarySecurityToken *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_wsse__UsernameToken:
		soap_serialize_PointerTo_wsse__UsernameToken(soap, (struct _wsse__UsernameToken *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_wsu__Timestamp:
		soap_serialize_PointerTo_wsu__Timestamp(soap, (struct _wsu__Timestamp *const*)ptr);
		break;
	case SOAP_TYPE__saml2__AuthenticatingAuthority:
		soap_serialize_string(soap, (char*const*)(void*)&ptr);
		break;
	case SOAP_TYPE__saml2__AuthnContextDeclRef:
		soap_serialize_string(soap, (char*const*)(void*)&ptr);
		break;
	case SOAP_TYPE__saml2__AuthnContextClassRef:
		soap_serialize_string(soap, (char*const*)(void*)&ptr);
		break;
	case SOAP_TYPE__saml2__Audience:
		soap_serialize_string(soap, (char*const*)(void*)&ptr);
		break;
	case SOAP_TYPE__saml2__AssertionURIRef:
		soap_serialize_string(soap, (char*const*)(void*)&ptr);
		break;
	case SOAP_TYPE__saml2__AssertionIDRef:
		soap_serialize_string(soap, (char*const*)(void*)&ptr);
		break;
	case SOAP_TYPE_PointerToPointerTo_ds__KeyInfo:
		soap_serialize_PointerToPointerTo_ds__KeyInfo(soap, (struct ds__KeyInfoType **const*)ptr);
		break;
	case SOAP_TYPE_PointerTo__saml2__union_AttributeStatementType:
		soap_serialize_PointerTo__saml2__union_AttributeStatementType(soap, (struct __saml2__union_AttributeStatementType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTosaml2__AttributeType:
		soap_serialize_PointerTosaml2__AttributeType(soap, (struct saml2__AttributeType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTosaml2__EvidenceType:
		soap_serialize_PointerTosaml2__EvidenceType(soap, (struct saml2__EvidenceType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTosaml2__ActionType:
		soap_serialize_PointerTosaml2__ActionType(soap, (struct saml2__ActionType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTosaml2__AuthnContextType:
		soap_serialize_PointerTosaml2__AuthnContextType(soap, (struct saml2__AuthnContextType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTosaml2__SubjectLocalityType:
		soap_serialize_PointerTosaml2__SubjectLocalityType(soap, (struct saml2__SubjectLocalityType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo__saml2__union_EvidenceType:
		soap_serialize_PointerTo__saml2__union_EvidenceType(soap, (struct __saml2__union_EvidenceType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo__saml2__union_AdviceType:
		soap_serialize_PointerTo__saml2__union_AdviceType(soap, (struct __saml2__union_AdviceType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTosaml2__AssertionType:
		soap_serialize_PointerTosaml2__AssertionType(soap, (struct saml2__AssertionType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo__saml2__union_ConditionsType:
		soap_serialize_PointerTo__saml2__union_ConditionsType(soap, (struct __saml2__union_ConditionsType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTosaml2__ProxyRestrictionType:
		soap_serialize_PointerTosaml2__ProxyRestrictionType(soap, (struct saml2__ProxyRestrictionType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTosaml2__OneTimeUseType:
		soap_serialize_PointerTosaml2__OneTimeUseType(soap, (struct saml2__OneTimeUseType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTosaml2__AudienceRestrictionType:
		soap_serialize_PointerTosaml2__AudienceRestrictionType(soap, (struct saml2__AudienceRestrictionType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTosaml2__ConditionAbstractType:
		soap_serialize_PointerTosaml2__ConditionAbstractType(soap, (struct saml2__ConditionAbstractType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTosaml2__SubjectConfirmationDataType:
		soap_serialize_PointerTosaml2__SubjectConfirmationDataType(soap, (struct saml2__SubjectConfirmationDataType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTosaml2__SubjectConfirmationType:
		soap_serialize_PointerTosaml2__SubjectConfirmationType(soap, (struct saml2__SubjectConfirmationType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTosaml2__EncryptedElementType:
		soap_serialize_PointerTosaml2__EncryptedElementType(soap, (struct saml2__EncryptedElementType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTosaml2__BaseIDAbstractType:
		soap_serialize_PointerTosaml2__BaseIDAbstractType(soap, (struct saml2__BaseIDAbstractType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo__saml2__union_AssertionType:
		soap_serialize_PointerTo__saml2__union_AssertionType(soap, (struct __saml2__union_AssertionType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTosaml2__AttributeStatementType:
		soap_serialize_PointerTosaml2__AttributeStatementType(soap, (struct saml2__AttributeStatementType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTosaml2__AuthzDecisionStatementType:
		soap_serialize_PointerTosaml2__AuthzDecisionStatementType(soap, (struct saml2__AuthzDecisionStatementType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTosaml2__AuthnStatementType:
		soap_serialize_PointerTosaml2__AuthnStatementType(soap, (struct saml2__AuthnStatementType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTosaml2__StatementAbstractType:
		soap_serialize_PointerTosaml2__StatementAbstractType(soap, (struct saml2__StatementAbstractType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTosaml2__AdviceType:
		soap_serialize_PointerTosaml2__AdviceType(soap, (struct saml2__AdviceType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTosaml2__ConditionsType:
		soap_serialize_PointerTosaml2__ConditionsType(soap, (struct saml2__ConditionsType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTosaml2__SubjectType:
		soap_serialize_PointerTosaml2__SubjectType(soap, (struct saml2__SubjectType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTosaml2__NameIDType:
		soap_serialize_PointerTosaml2__NameIDType(soap, (struct saml2__NameIDType *const*)ptr);
		break;
	case SOAP_TYPE_PointerToPointerToxenc__EncryptedKeyType:
		soap_serialize_PointerToPointerToxenc__EncryptedKeyType(soap, (struct xenc__EncryptedKeyType **const*)ptr);
		break;
	case SOAP_TYPE__saml1__ConfirmationMethod:
		soap_serialize_string(soap, (char*const*)(void*)&ptr);
		break;
	case SOAP_TYPE__saml1__Audience:
		soap_serialize_string(soap, (char*const*)(void*)&ptr);
		break;
	case SOAP_TYPE__saml1__AssertionIDReference:
		soap_serialize_string(soap, (char*const*)(void*)&ptr);
		break;
	case SOAP_TYPE_PointerTosaml1__AttributeType:
		soap_serialize_PointerTosaml1__AttributeType(soap, (struct saml1__AttributeType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTosaml1__EvidenceType:
		soap_serialize_PointerTosaml1__EvidenceType(soap, (struct saml1__EvidenceType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTosaml1__ActionType:
		soap_serialize_PointerTosaml1__ActionType(soap, (struct saml1__ActionType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTosaml1__AuthorityBindingType:
		soap_serialize_PointerTosaml1__AuthorityBindingType(soap, (struct saml1__AuthorityBindingType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTosaml1__SubjectLocalityType:
		soap_serialize_PointerTosaml1__SubjectLocalityType(soap, (struct saml1__SubjectLocalityType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTosaml1__SubjectType:
		soap_serialize_PointerTosaml1__SubjectType(soap, (struct saml1__SubjectType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo__saml1__union_EvidenceType:
		soap_serialize_PointerTo__saml1__union_EvidenceType(soap, (struct __saml1__union_EvidenceType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTostring:
		soap_serialize_PointerTostring(soap, (char **const*)ptr);
		break;
	case SOAP_TYPE_PointerTosaml1__SubjectConfirmationType:
		soap_serialize_PointerTosaml1__SubjectConfirmationType(soap, (struct saml1__SubjectConfirmationType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTosaml1__NameIdentifierType:
		soap_serialize_PointerTosaml1__NameIdentifierType(soap, (struct saml1__NameIdentifierType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo__saml1__union_AdviceType:
		soap_serialize_PointerTo__saml1__union_AdviceType(soap, (struct __saml1__union_AdviceType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTosaml1__AssertionType:
		soap_serialize_PointerTosaml1__AssertionType(soap, (struct saml1__AssertionType *const*)ptr);
		break;
	case SOAP_TYPE_PointerToxsd__dateTime:
		soap_serialize_PointerToxsd__dateTime(soap, (struct timeval *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo__saml1__union_ConditionsType:
		soap_serialize_PointerTo__saml1__union_ConditionsType(soap, (struct __saml1__union_ConditionsType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTosaml1__ConditionAbstractType:
		soap_serialize_PointerTosaml1__ConditionAbstractType(soap, (struct saml1__ConditionAbstractType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTosaml1__DoNotCacheConditionType:
		soap_serialize_PointerTosaml1__DoNotCacheConditionType(soap, (struct saml1__DoNotCacheConditionType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTosaml1__AudienceRestrictionConditionType:
		soap_serialize_PointerTosaml1__AudienceRestrictionConditionType(soap, (struct saml1__AudienceRestrictionConditionType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ds__Signature:
		soap_serialize_PointerTo_ds__Signature(soap, (struct ds__SignatureType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo__saml1__union_AssertionType:
		soap_serialize_PointerTo__saml1__union_AssertionType(soap, (struct __saml1__union_AssertionType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTosaml1__AttributeStatementType:
		soap_serialize_PointerTosaml1__AttributeStatementType(soap, (struct saml1__AttributeStatementType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTosaml1__AuthorizationDecisionStatementType:
		soap_serialize_PointerTosaml1__AuthorizationDecisionStatementType(soap, (struct saml1__AuthorizationDecisionStatementType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTosaml1__AuthenticationStatementType:
		soap_serialize_PointerTosaml1__AuthenticationStatementType(soap, (struct saml1__AuthenticationStatementType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTosaml1__SubjectStatementAbstractType:
		soap_serialize_PointerTosaml1__SubjectStatementAbstractType(soap, (struct saml1__SubjectStatementAbstractType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTosaml1__StatementAbstractType:
		soap_serialize_PointerTosaml1__StatementAbstractType(soap, (struct saml1__StatementAbstractType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTosaml1__AdviceType:
		soap_serialize_PointerTosaml1__AdviceType(soap, (struct saml1__AdviceType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTosaml1__ConditionsType:
		soap_serialize_PointerTosaml1__ConditionsType(soap, (struct saml1__ConditionsType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo__wsc__DerivedKeyTokenType_sequence:
		soap_serialize_PointerTo__wsc__DerivedKeyTokenType_sequence(soap, (struct __wsc__DerivedKeyTokenType_sequence *const*)ptr);
		break;
	case SOAP_TYPE_PointerToULONG64:
		soap_serialize_PointerToULONG64(soap, (ULONG64 *const*)ptr);
		break;
	case SOAP_TYPE_PointerTowsc__PropertiesType:
		soap_serialize_PointerTowsc__PropertiesType(soap, (struct wsc__PropertiesType *const*)ptr);
		break;
	case SOAP_TYPE_wsc__FaultCodeOpenEnumType:
		soap_serialize_string(soap, (char*const*)(void*)&ptr);
		break;
	case SOAP_TYPE_PointerTo_xenc__ReferenceList:
		soap_serialize_PointerTo_xenc__ReferenceList(soap, (struct _xenc__ReferenceList *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo__xenc__union_ReferenceList:
		soap_serialize_PointerTo__xenc__union_ReferenceList(soap, (struct __xenc__union_ReferenceList *const*)ptr);
		break;
	case SOAP_TYPE_PointerToxenc__ReferenceType:
		soap_serialize_PointerToxenc__ReferenceType(soap, (struct xenc__ReferenceType *const*)ptr);
		break;
	case SOAP_TYPE_PointerToxenc__EncryptionPropertyType:
		soap_serialize_PointerToxenc__EncryptionPropertyType(soap, (struct xenc__EncryptionPropertyType *const*)ptr);
		break;
	case SOAP_TYPE_PointerToxenc__TransformsType:
		soap_serialize_PointerToxenc__TransformsType(soap, (struct xenc__TransformsType *const*)ptr);
		break;
	case SOAP_TYPE_PointerToxenc__CipherReferenceType:
		soap_serialize_PointerToxenc__CipherReferenceType(soap, (struct xenc__CipherReferenceType *const*)ptr);
		break;
	case SOAP_TYPE_PointerToxenc__EncryptionPropertiesType:
		soap_serialize_PointerToxenc__EncryptionPropertiesType(soap, (struct xenc__EncryptionPropertiesType *const*)ptr);
		break;
	case SOAP_TYPE_PointerToxenc__CipherDataType:
		soap_serialize_PointerToxenc__CipherDataType(soap, (struct xenc__CipherDataType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ds__KeyInfo:
		soap_serialize_PointerTo_ds__KeyInfo(soap, (struct ds__KeyInfoType *const*)ptr);
		break;
	case SOAP_TYPE_PointerToxenc__EncryptionMethodType:
		soap_serialize_PointerToxenc__EncryptionMethodType(soap, (struct xenc__EncryptionMethodType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTods__X509IssuerSerialType:
		soap_serialize_PointerTods__X509IssuerSerialType(soap, (struct ds__X509IssuerSerialType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTods__RSAKeyValueType:
		soap_serialize_PointerTods__RSAKeyValueType(soap, (struct ds__RSAKeyValueType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTods__DSAKeyValueType:
		soap_serialize_PointerTods__DSAKeyValueType(soap, (struct ds__DSAKeyValueType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTods__TransformType:
		soap_serialize_PointerTods__TransformType(soap, (struct ds__TransformType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTods__DigestMethodType:
		soap_serialize_PointerTods__DigestMethodType(soap, (struct ds__DigestMethodType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTods__TransformsType:
		soap_serialize_PointerTods__TransformsType(soap, (struct ds__TransformsType *const*)ptr);
		break;
	case SOAP_TYPE_PointerToPointerTods__ReferenceType:
		soap_serialize_PointerToPointerTods__ReferenceType(soap, (struct ds__ReferenceType **const*)ptr);
		break;
	case SOAP_TYPE_PointerTods__ReferenceType:
		soap_serialize_PointerTods__ReferenceType(soap, (struct ds__ReferenceType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTods__SignatureMethodType:
		soap_serialize_PointerTods__SignatureMethodType(soap, (struct ds__SignatureMethodType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTods__CanonicalizationMethodType:
		soap_serialize_PointerTods__CanonicalizationMethodType(soap, (struct ds__CanonicalizationMethodType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_wsse__SecurityTokenReference:
		soap_serialize_PointerTo_wsse__SecurityTokenReference(soap, (struct _wsse__SecurityTokenReference *const*)ptr);
		break;
	case SOAP_TYPE_PointerTods__RetrievalMethodType:
		soap_serialize_PointerTods__RetrievalMethodType(soap, (struct ds__RetrievalMethodType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTods__KeyValueType:
		soap_serialize_PointerTods__KeyValueType(soap, (struct ds__KeyValueType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_c14n__InclusiveNamespaces:
		soap_serialize_PointerTo_c14n__InclusiveNamespaces(soap, (struct _c14n__InclusiveNamespaces *const*)ptr);
		break;
	case SOAP_TYPE_PointerTods__KeyInfoType:
		soap_serialize_PointerTods__KeyInfoType(soap, (struct ds__KeyInfoType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTods__SignedInfoType:
		soap_serialize_PointerTods__SignedInfoType(soap, (struct ds__SignedInfoType *const*)ptr);
		break;
	case SOAP_TYPE__ds__SignatureValue:
		soap_serialize_string(soap, (char*const*)(void*)&ptr);
		break;
	case SOAP_TYPE_PointerToxenc__EncryptedKeyType:
		soap_serialize_PointerToxenc__EncryptedKeyType(soap, (struct xenc__EncryptedKeyType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTods__X509DataType:
		soap_serialize_PointerTods__X509DataType(soap, (struct ds__X509DataType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_wsse__Embedded:
		soap_serialize_PointerTo_wsse__Embedded(soap, (struct _wsse__Embedded *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_wsse__KeyIdentifier:
		soap_serialize_PointerTo_wsse__KeyIdentifier(soap, (struct _wsse__KeyIdentifier *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_wsse__Reference:
		soap_serialize_PointerTo_wsse__Reference(soap, (struct _wsse__Reference *const*)ptr);
		break;
	case SOAP_TYPE_PointerTowsse__EncodedString:
		soap_serialize_PointerTowsse__EncodedString(soap, (struct wsse__EncodedString *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_wsse__Password:
		soap_serialize_PointerTo_wsse__Password(soap, (struct _wsse__Password *const*)ptr);
		break;
	case SOAP_TYPE_PointerTochan__ChannelInstanceType:
		soap_serialize_PointerTochan__ChannelInstanceType(soap, (struct chan__ChannelInstanceType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_wsa5__FaultTo:
		soap_serialize_PointerTo_wsa5__FaultTo(soap, (struct wsa5__EndpointReferenceType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_wsa5__ReplyTo:
		soap_serialize_PointerTo_wsa5__ReplyTo(soap, (struct wsa5__EndpointReferenceType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_wsa5__From:
		soap_serialize_PointerTo_wsa5__From(soap, (struct wsa5__EndpointReferenceType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_wsa5__RelatesTo:
		soap_serialize_PointerTo_wsa5__RelatesTo(soap, (struct wsa5__RelatesToType *const*)ptr);
		break;
	case SOAP_TYPE__wsa5__ProblemIRI:
		soap_serialize_string(soap, (char*const*)(void*)&ptr);
		break;
	case SOAP_TYPE__wsa5__ProblemHeaderQName:
		soap_serialize_string(soap, (char*const*)(void*)&ptr);
		break;
	case SOAP_TYPE__wsa5__Action:
		soap_serialize_string(soap, (char*const*)(void*)&ptr);
		break;
	case SOAP_TYPE__wsa5__To:
		soap_serialize_string(soap, (char*const*)(void*)&ptr);
		break;
	case SOAP_TYPE__wsa5__MessageID:
		soap_serialize_string(soap, (char*const*)(void*)&ptr);
		break;
	case SOAP_TYPE_PointerToint:
		soap_serialize_PointerToint(soap, (int *const*)ptr);
		break;
	case SOAP_TYPE_PointerTowsa5__MetadataType:
		soap_serialize_PointerTowsa5__MetadataType(soap, (struct wsa5__MetadataType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTowsa5__ReferenceParametersType:
		soap_serialize_PointerTowsa5__ReferenceParametersType(soap, (struct wsa5__ReferenceParametersType *const*)ptr);
		break;
	case SOAP_TYPE_wsa5__FaultCodesOpenEnumType:
		soap_serialize_string(soap, (char*const*)(void*)&ptr);
		break;
	case SOAP_TYPE_wsa5__RelationshipTypeOpenEnum:
		soap_serialize_string(soap, (char*const*)(void*)&ptr);
		break;
	case SOAP_TYPE_PointerTowsdd__ResolveMatchesType:
		soap_serialize_PointerTowsdd__ResolveMatchesType(soap, (struct wsdd__ResolveMatchesType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTowsdd__ResolveType:
		soap_serialize_PointerTowsdd__ResolveType(soap, (struct wsdd__ResolveType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTowsdd__ProbeMatchesType:
		soap_serialize_PointerTowsdd__ProbeMatchesType(soap, (struct wsdd__ProbeMatchesType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTowsdd__ProbeType:
		soap_serialize_PointerTowsdd__ProbeType(soap, (struct wsdd__ProbeType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTowsdd__ByeType:
		soap_serialize_PointerTowsdd__ByeType(soap, (struct wsdd__ByeType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTowsdd__HelloType:
		soap_serialize_PointerTowsdd__HelloType(soap, (struct wsdd__HelloType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTowsdd__AppSequenceType:
		soap_serialize_PointerTowsdd__AppSequenceType(soap, (struct wsdd__AppSequenceType *const*)ptr);
		break;
	case SOAP_TYPE__wsdd__Id:
		soap_serialize_string(soap, (char*const*)(void*)&ptr);
		break;
	case SOAP_TYPE__wsdd__SupportedMatchingRules:
		soap_serialize_string(soap, (char*const*)(void*)&ptr);
		break;
	case SOAP_TYPE__wsdd__XAddrs:
		soap_serialize_string(soap, (char*const*)(void*)&ptr);
		break;
	case SOAP_TYPE__wsdd__Types:
		soap_serialize_string(soap, (char*const*)(void*)&ptr);
		break;
	case SOAP_TYPE_PointerTowsdd__SigType:
		soap_serialize_PointerTowsdd__SigType(soap, (struct wsdd__SigType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTowsdd__ResolveMatchType:
		soap_serialize_PointerTowsdd__ResolveMatchType(soap, (struct wsdd__ResolveMatchType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTowsdd__ProbeMatchType:
		soap_serialize_PointerTowsdd__ProbeMatchType(soap, (struct wsdd__ProbeMatchType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTounsignedInt:
		soap_serialize_PointerTounsignedInt(soap, (unsigned int *const*)ptr);
		break;
	case SOAP_TYPE_PointerTowsdd__ScopesType:
		soap_serialize_PointerTowsdd__ScopesType(soap, (struct wsdd__ScopesType *const*)ptr);
		break;
	case SOAP_TYPE_wsdd__FaultCodeOpenType:
		soap_serialize_string(soap, (char*const*)(void*)&ptr);
		break;
	case SOAP_TYPE_wsdd__UriListType:
		soap_serialize_string(soap, (char*const*)(void*)&ptr);
		break;
	case SOAP_TYPE_wsdd__QNameListType:
		soap_serialize_string(soap, (char*const*)(void*)&ptr);
		break;
	case SOAP_TYPE_PointerTo_wsa__FaultTo:
		soap_serialize_PointerTo_wsa__FaultTo(soap, (struct wsa__EndpointReferenceType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_wsa__ReplyTo:
		soap_serialize_PointerTo_wsa__ReplyTo(soap, (struct wsa__EndpointReferenceType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_wsa__From:
		soap_serialize_PointerTo_wsa__From(soap, (struct wsa__EndpointReferenceType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_wsa__RelatesTo:
		soap_serialize_PointerTo_wsa__RelatesTo(soap, (struct wsa__Relationship *const*)ptr);
		break;
	case SOAP_TYPE__wsa__Action:
		soap_serialize_string(soap, (char*const*)(void*)&ptr);
		break;
	case SOAP_TYPE__wsa__To:
		soap_serialize_string(soap, (char*const*)(void*)&ptr);
		break;
	case SOAP_TYPE__wsa__MessageID:
		soap_serialize_string(soap, (char*const*)(void*)&ptr);
		break;
	case SOAP_TYPE_PointerTowsa__ServiceNameType:
		soap_serialize_PointerTowsa__ServiceNameType(soap, (struct wsa__ServiceNameType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_QName:
		soap_serialize_PointerTo_QName(soap, (char **const*)ptr);
		break;
	case SOAP_TYPE_PointerTowsa__ReferenceParametersType:
		soap_serialize_PointerTowsa__ReferenceParametersType(soap, (struct wsa__ReferenceParametersType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTowsa__ReferencePropertiesType:
		soap_serialize_PointerTowsa__ReferencePropertiesType(soap, (struct wsa__ReferencePropertiesType *const*)ptr);
		break;
	case SOAP_TYPE__QName:
		soap_serialize_string(soap, (char*const*)(void*)&ptr);
		break;
	case SOAP_TYPE_string:
		soap_serialize_string(soap, (char*const*)(void*)&ptr);
		break;
	}
}
#endif

SOAP_FMAC3 void * SOAP_FMAC4 soap_dupelement(struct soap *soap, const void *ptr, int type)
{(void)soap; (void)ptr; (void)type; /* appease -Wall -Werror */
	return NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_delelement(const void *ptr, int type)
{(void)ptr; (void)type; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_byte(struct soap *soap, const char *tag, int id, const char *a, const char *type)
{
	return soap_outbyte(soap, tag, id, a, type, SOAP_TYPE_byte);
}

SOAP_FMAC3 char * SOAP_FMAC4 soap_in_byte(struct soap *soap, const char *tag, char *a, const char *type)
{
	a = soap_inbyte(soap, tag, a, type, SOAP_TYPE_byte);
	return a;
}

SOAP_FMAC3 char * SOAP_FMAC4 soap_new_byte(struct soap *soap, int n)
{
	char *p;
	char *a = (char*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(char));
	for (p = a; p && n--; p++)
		soap_default_byte(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_byte(struct soap *soap, const char *a, const char *tag, const char *type)
{
	if (soap_out_byte(soap, tag ? tag : "byte", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 char * SOAP_FMAC4 soap_get_byte(struct soap *soap, char *p, const char *tag, const char *type)
{
	if ((p = soap_in_byte(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_int(struct soap *soap, const char *tag, int id, const int *a, const char *type)
{
	return soap_outint(soap, tag, id, a, type, SOAP_TYPE_int);
}

SOAP_FMAC3 int * SOAP_FMAC4 soap_in_int(struct soap *soap, const char *tag, int *a, const char *type)
{
	a = soap_inint(soap, tag, a, type, SOAP_TYPE_int);
	return a;
}

SOAP_FMAC3 int * SOAP_FMAC4 soap_new_int(struct soap *soap, int n)
{
	int *p;
	int *a = (int*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(int));
	for (p = a; p && n--; p++)
		soap_default_int(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_int(struct soap *soap, const int *a, const char *tag, const char *type)
{
	if (soap_out_int(soap, tag ? tag : "int", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int * SOAP_FMAC4 soap_get_int(struct soap *soap, int *p, const char *tag, const char *type)
{
	if ((p = soap_in_int(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 LONG64 * SOAP_FMAC4 soap_new_xsd__duration(struct soap *soap, int n)
{
	LONG64 *p;
	LONG64 *a = (LONG64*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(LONG64));
	for (p = a; p && n--; p++)
		soap_default_xsd__duration(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_xsd__duration(struct soap *soap, const LONG64 *a, const char *tag, const char *type)
{
	if (soap_out_xsd__duration(soap, tag ? tag : "xsd:duration", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 LONG64 * SOAP_FMAC4 soap_get_xsd__duration(struct soap *soap, LONG64 *p, const char *tag, const char *type)
{
	if ((p = soap_in_xsd__duration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_float(struct soap *soap, const char *tag, int id, const float *a, const char *type)
{
	return soap_outfloat(soap, tag, id, a, type, SOAP_TYPE_float);
}

SOAP_FMAC3 float * SOAP_FMAC4 soap_in_float(struct soap *soap, const char *tag, float *a, const char *type)
{
	a = soap_infloat(soap, tag, a, type, SOAP_TYPE_float);
	return a;
}

SOAP_FMAC3 float * SOAP_FMAC4 soap_new_float(struct soap *soap, int n)
{
	float *p;
	float *a = (float*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(float));
	for (p = a; p && n--; p++)
		soap_default_float(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_float(struct soap *soap, const float *a, const char *tag, const char *type)
{
	if (soap_out_float(soap, tag ? tag : "float", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 float * SOAP_FMAC4 soap_get_float(struct soap *soap, float *p, const char *tag, const char *type)
{
	if ((p = soap_in_float(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__wsdd__MetadataVersion(struct soap *soap, const unsigned int *a, const char *tag, const char *type)
{
	if (soap_out__wsdd__MetadataVersion(soap, tag ? tag : "wsdd:MetadataVersion", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__wsa__ReplyAfter(struct soap *soap, const unsigned int *a, const char *tag, const char *type)
{
	if (soap_out__wsa__ReplyAfter(soap, tag ? tag : "wsa:ReplyAfter", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_unsignedInt(struct soap *soap, const char *tag, int id, const unsigned int *a, const char *type)
{
	return soap_outunsignedInt(soap, tag, id, a, type, SOAP_TYPE_unsignedInt);
}

SOAP_FMAC3 unsigned int * SOAP_FMAC4 soap_in_unsignedInt(struct soap *soap, const char *tag, unsigned int *a, const char *type)
{
	a = soap_inunsignedInt(soap, tag, a, type, SOAP_TYPE_unsignedInt);
	return a;
}

SOAP_FMAC3 unsigned int * SOAP_FMAC4 soap_new_unsignedInt(struct soap *soap, int n)
{
	unsigned int *p;
	unsigned int *a = (unsigned int*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(unsigned int));
	for (p = a; p && n--; p++)
		soap_default_unsignedInt(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_unsignedInt(struct soap *soap, const unsigned int *a, const char *tag, const char *type)
{
	if (soap_out_unsignedInt(soap, tag ? tag : "unsignedInt", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 unsigned int * SOAP_FMAC4 soap_get_unsignedInt(struct soap *soap, unsigned int *p, const char *tag, const char *type)
{
	if ((p = soap_in_unsignedInt(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__wsa5__RetryAfter(struct soap *soap, const ULONG64 *a, const char *tag, const char *type)
{
	if (soap_out__wsa5__RetryAfter(soap, tag ? tag : "wsa5:RetryAfter", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ULONG64(struct soap *soap, const char *tag, int id, const ULONG64 *a, const char *type)
{
	return soap_outULONG64(soap, tag, id, a, type, SOAP_TYPE_ULONG64);
}

SOAP_FMAC3 ULONG64 * SOAP_FMAC4 soap_in_ULONG64(struct soap *soap, const char *tag, ULONG64 *a, const char *type)
{
	a = soap_inULONG64(soap, tag, a, type, SOAP_TYPE_ULONG64);
	return a;
}

SOAP_FMAC3 ULONG64 * SOAP_FMAC4 soap_new_ULONG64(struct soap *soap, int n)
{
	ULONG64 *p;
	ULONG64 *a = (ULONG64*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(ULONG64));
	for (p = a; p && n--; p++)
		soap_default_ULONG64(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ULONG64(struct soap *soap, const ULONG64 *a, const char *tag, const char *type)
{
	if (soap_out_ULONG64(soap, tag ? tag : "unsignedLong", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ULONG64 * SOAP_FMAC4 soap_get_ULONG64(struct soap *soap, ULONG64 *p, const char *tag, const char *type)
{
	if ((p = soap_in_ULONG64(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_dateTime(struct soap *soap, const char *tag, int id, const time_t *a, const char *type)
{
	return soap_outdateTime(soap, tag, id, a, type, SOAP_TYPE_dateTime);
}

SOAP_FMAC3 time_t * SOAP_FMAC4 soap_in_dateTime(struct soap *soap, const char *tag, time_t *a, const char *type)
{
	a = soap_indateTime(soap, tag, a, type, SOAP_TYPE_dateTime);
	return a;
}

SOAP_FMAC3 time_t * SOAP_FMAC4 soap_new_dateTime(struct soap *soap, int n)
{
	time_t *p;
	time_t *a = (time_t*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(time_t));
	for (p = a; p && n--; p++)
		soap_default_dateTime(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_dateTime(struct soap *soap, const time_t *a, const char *tag, const char *type)
{
	if (soap_out_dateTime(soap, tag ? tag : "dateTime", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 time_t * SOAP_FMAC4 soap_get_dateTime(struct soap *soap, time_t *p, const char *tag, const char *type)
{
	if ((p = soap_in_dateTime(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

static const struct soap_code_map soap_codes_tt__IPType[] =
{	{ (LONG64)tt__IPType__IPv4, "IPv4" },
	{ (LONG64)tt__IPType__IPv6, "IPv6" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_tt__IPType2s(struct soap *soap, enum tt__IPType n)
{
	const char *s = soap_code_str(soap_codes_tt__IPType, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__IPType(struct soap *soap, const char *tag, int id, const enum tt__IPType *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__IPType), type) || soap_send(soap, soap_tt__IPType2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2tt__IPType(struct soap *soap, const char *s, enum tt__IPType *a)
{
	const struct soap_code_map *map;
	if (!s)
		return soap->error;
	map = soap_code(soap_codes_tt__IPType, s);
	if (map)
		*a = (enum tt__IPType)map->code;
	else if (!*s)
		return soap->error = SOAP_EMPTY;
	else
	{	int n;
		if (soap_s2int(soap, s, &n) || n < 0 || n > 1)
			return soap->error = SOAP_TYPE;
		*a = (enum tt__IPType)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum tt__IPType * SOAP_FMAC4 soap_in_tt__IPType(struct soap *soap, const char *tag, enum tt__IPType *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum tt__IPType*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__IPType, sizeof(enum tt__IPType), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (*soap->href != '#')
	{	int err = soap_s2tt__IPType(soap, soap_value(soap), a);
		if ((soap->body && soap_element_end_in(soap, tag)) || err)
			return NULL;
	}
	else
	{	a = (enum tt__IPType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__IPType, SOAP_TYPE_tt__IPType, sizeof(enum tt__IPType), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 enum tt__IPType * SOAP_FMAC4 soap_new_tt__IPType(struct soap *soap, int n)
{
	enum tt__IPType *p;
	enum tt__IPType *a = (enum tt__IPType*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(enum tt__IPType));
	for (p = a; p && n--; p++)
		soap_default_tt__IPType(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__IPType(struct soap *soap, const enum tt__IPType *a, const char *tag, const char *type)
{
	if (soap_out_tt__IPType(soap, tag ? tag : "tt:IPType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum tt__IPType * SOAP_FMAC4 soap_get_tt__IPType(struct soap *soap, enum tt__IPType *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__IPType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

static const struct soap_code_map soap_codes_tt__H264Profile[] =
{	{ (LONG64)tt__H264Profile__Baseline, "Baseline" },
	{ (LONG64)tt__H264Profile__Main, "Main" },
	{ (LONG64)tt__H264Profile__Extended, "Extended" },
	{ (LONG64)tt__H264Profile__High, "High" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_tt__H264Profile2s(struct soap *soap, enum tt__H264Profile n)
{
	const char *s = soap_code_str(soap_codes_tt__H264Profile, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__H264Profile(struct soap *soap, const char *tag, int id, const enum tt__H264Profile *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__H264Profile), type) || soap_send(soap, soap_tt__H264Profile2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2tt__H264Profile(struct soap *soap, const char *s, enum tt__H264Profile *a)
{
	const struct soap_code_map *map;
	if (!s)
		return soap->error;
	map = soap_code(soap_codes_tt__H264Profile, s);
	if (map)
		*a = (enum tt__H264Profile)map->code;
	else if (!*s)
		return soap->error = SOAP_EMPTY;
	else
	{	int n;
		if (soap_s2int(soap, s, &n) || n < 0 || n > 3)
			return soap->error = SOAP_TYPE;
		*a = (enum tt__H264Profile)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum tt__H264Profile * SOAP_FMAC4 soap_in_tt__H264Profile(struct soap *soap, const char *tag, enum tt__H264Profile *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum tt__H264Profile*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__H264Profile, sizeof(enum tt__H264Profile), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (*soap->href != '#')
	{	int err = soap_s2tt__H264Profile(soap, soap_value(soap), a);
		if ((soap->body && soap_element_end_in(soap, tag)) || err)
			return NULL;
	}
	else
	{	a = (enum tt__H264Profile *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__H264Profile, SOAP_TYPE_tt__H264Profile, sizeof(enum tt__H264Profile), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 enum tt__H264Profile * SOAP_FMAC4 soap_new_tt__H264Profile(struct soap *soap, int n)
{
	enum tt__H264Profile *p;
	enum tt__H264Profile *a = (enum tt__H264Profile*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(enum tt__H264Profile));
	for (p = a; p && n--; p++)
		soap_default_tt__H264Profile(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__H264Profile(struct soap *soap, const enum tt__H264Profile *a, const char *tag, const char *type)
{
	if (soap_out_tt__H264Profile(soap, tag ? tag : "tt:H264Profile", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum tt__H264Profile * SOAP_FMAC4 soap_get_tt__H264Profile(struct soap *soap, enum tt__H264Profile *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__H264Profile(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

static const struct soap_code_map soap_codes_tt__Mpeg4Profile[] =
{	{ (LONG64)tt__Mpeg4Profile__SP, "SP" },
	{ (LONG64)tt__Mpeg4Profile__ASP, "ASP" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_tt__Mpeg4Profile2s(struct soap *soap, enum tt__Mpeg4Profile n)
{
	const char *s = soap_code_str(soap_codes_tt__Mpeg4Profile, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__Mpeg4Profile(struct soap *soap, const char *tag, int id, const enum tt__Mpeg4Profile *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__Mpeg4Profile), type) || soap_send(soap, soap_tt__Mpeg4Profile2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2tt__Mpeg4Profile(struct soap *soap, const char *s, enum tt__Mpeg4Profile *a)
{
	const struct soap_code_map *map;
	if (!s)
		return soap->error;
	map = soap_code(soap_codes_tt__Mpeg4Profile, s);
	if (map)
		*a = (enum tt__Mpeg4Profile)map->code;
	else if (!*s)
		return soap->error = SOAP_EMPTY;
	else
	{	int n;
		if (soap_s2int(soap, s, &n) || n < 0 || n > 1)
			return soap->error = SOAP_TYPE;
		*a = (enum tt__Mpeg4Profile)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum tt__Mpeg4Profile * SOAP_FMAC4 soap_in_tt__Mpeg4Profile(struct soap *soap, const char *tag, enum tt__Mpeg4Profile *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum tt__Mpeg4Profile*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__Mpeg4Profile, sizeof(enum tt__Mpeg4Profile), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (*soap->href != '#')
	{	int err = soap_s2tt__Mpeg4Profile(soap, soap_value(soap), a);
		if ((soap->body && soap_element_end_in(soap, tag)) || err)
			return NULL;
	}
	else
	{	a = (enum tt__Mpeg4Profile *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__Mpeg4Profile, SOAP_TYPE_tt__Mpeg4Profile, sizeof(enum tt__Mpeg4Profile), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 enum tt__Mpeg4Profile * SOAP_FMAC4 soap_new_tt__Mpeg4Profile(struct soap *soap, int n)
{
	enum tt__Mpeg4Profile *p;
	enum tt__Mpeg4Profile *a = (enum tt__Mpeg4Profile*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(enum tt__Mpeg4Profile));
	for (p = a; p && n--; p++)
		soap_default_tt__Mpeg4Profile(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__Mpeg4Profile(struct soap *soap, const enum tt__Mpeg4Profile *a, const char *tag, const char *type)
{
	if (soap_out_tt__Mpeg4Profile(soap, tag ? tag : "tt:Mpeg4Profile", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum tt__Mpeg4Profile * SOAP_FMAC4 soap_get_tt__Mpeg4Profile(struct soap *soap, enum tt__Mpeg4Profile *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__Mpeg4Profile(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

static const struct soap_code_map soap_codes_tt__VideoEncoding[] =
{	{ (LONG64)tt__VideoEncoding__JPEG, "JPEG" },
	{ (LONG64)tt__VideoEncoding__MPEG4, "MPEG4" },
	{ (LONG64)tt__VideoEncoding__H264, "H264" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_tt__VideoEncoding2s(struct soap *soap, enum tt__VideoEncoding n)
{
	const char *s = soap_code_str(soap_codes_tt__VideoEncoding, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__VideoEncoding(struct soap *soap, const char *tag, int id, const enum tt__VideoEncoding *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__VideoEncoding), type) || soap_send(soap, soap_tt__VideoEncoding2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2tt__VideoEncoding(struct soap *soap, const char *s, enum tt__VideoEncoding *a)
{
	const struct soap_code_map *map;
	if (!s)
		return soap->error;
	map = soap_code(soap_codes_tt__VideoEncoding, s);
	if (map)
		*a = (enum tt__VideoEncoding)map->code;
	else if (!*s)
		return soap->error = SOAP_EMPTY;
	else
	{	int n;
		if (soap_s2int(soap, s, &n) || n < 0 || n > 2)
			return soap->error = SOAP_TYPE;
		*a = (enum tt__VideoEncoding)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum tt__VideoEncoding * SOAP_FMAC4 soap_in_tt__VideoEncoding(struct soap *soap, const char *tag, enum tt__VideoEncoding *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum tt__VideoEncoding*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__VideoEncoding, sizeof(enum tt__VideoEncoding), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (*soap->href != '#')
	{	int err = soap_s2tt__VideoEncoding(soap, soap_value(soap), a);
		if ((soap->body && soap_element_end_in(soap, tag)) || err)
			return NULL;
	}
	else
	{	a = (enum tt__VideoEncoding *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__VideoEncoding, SOAP_TYPE_tt__VideoEncoding, sizeof(enum tt__VideoEncoding), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 enum tt__VideoEncoding * SOAP_FMAC4 soap_new_tt__VideoEncoding(struct soap *soap, int n)
{
	enum tt__VideoEncoding *p;
	enum tt__VideoEncoding *a = (enum tt__VideoEncoding*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(enum tt__VideoEncoding));
	for (p = a; p && n--; p++)
		soap_default_tt__VideoEncoding(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__VideoEncoding(struct soap *soap, const enum tt__VideoEncoding *a, const char *tag, const char *type)
{
	if (soap_out_tt__VideoEncoding(soap, tag ? tag : "tt:VideoEncoding", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum tt__VideoEncoding * SOAP_FMAC4 soap_get_tt__VideoEncoding(struct soap *soap, enum tt__VideoEncoding *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__VideoEncoding(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

static const struct soap_code_map soap_codes_tt__PropertyOperation[] =
{	{ (LONG64)tt__PropertyOperation__Initialized, "Initialized" },
	{ (LONG64)tt__PropertyOperation__Deleted, "Deleted" },
	{ (LONG64)tt__PropertyOperation__Changed, "Changed" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_tt__PropertyOperation2s(struct soap *soap, enum tt__PropertyOperation n)
{
	const char *s = soap_code_str(soap_codes_tt__PropertyOperation, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__PropertyOperation(struct soap *soap, const char *tag, int id, const enum tt__PropertyOperation *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__PropertyOperation), type) || soap_send(soap, soap_tt__PropertyOperation2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2tt__PropertyOperation(struct soap *soap, const char *s, enum tt__PropertyOperation *a)
{
	const struct soap_code_map *map;
	if (!s)
		return soap->error;
	map = soap_code(soap_codes_tt__PropertyOperation, s);
	if (map)
		*a = (enum tt__PropertyOperation)map->code;
	else if (!*s)
		return soap->error = SOAP_EMPTY;
	else
	{	int n;
		if (soap_s2int(soap, s, &n) || n < 0 || n > 2)
			return soap->error = SOAP_TYPE;
		*a = (enum tt__PropertyOperation)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum tt__PropertyOperation * SOAP_FMAC4 soap_in_tt__PropertyOperation(struct soap *soap, const char *tag, enum tt__PropertyOperation *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum tt__PropertyOperation*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__PropertyOperation, sizeof(enum tt__PropertyOperation), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (*soap->href != '#')
	{	int err = soap_s2tt__PropertyOperation(soap, soap_value(soap), a);
		if ((soap->body && soap_element_end_in(soap, tag)) || err)
			return NULL;
	}
	else
	{	a = (enum tt__PropertyOperation *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__PropertyOperation, SOAP_TYPE_tt__PropertyOperation, sizeof(enum tt__PropertyOperation), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 enum tt__PropertyOperation * SOAP_FMAC4 soap_new_tt__PropertyOperation(struct soap *soap, int n)
{
	enum tt__PropertyOperation *p;
	enum tt__PropertyOperation *a = (enum tt__PropertyOperation*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(enum tt__PropertyOperation));
	for (p = a; p && n--; p++)
		soap_default_tt__PropertyOperation(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__PropertyOperation(struct soap *soap, const enum tt__PropertyOperation *a, const char *tag, const char *type)
{
	if (soap_out_tt__PropertyOperation(soap, tag ? tag : "tt:PropertyOperation", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum tt__PropertyOperation * SOAP_FMAC4 soap_get_tt__PropertyOperation(struct soap *soap, enum tt__PropertyOperation *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__PropertyOperation(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

static const struct soap_code_map soap_codes_tt__MoveStatus[] =
{	{ (LONG64)tt__MoveStatus__IDLE, "IDLE" },
	{ (LONG64)tt__MoveStatus__MOVING, "MOVING" },
	{ (LONG64)tt__MoveStatus__UNKNOWN, "UNKNOWN" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_tt__MoveStatus2s(struct soap *soap, enum tt__MoveStatus n)
{
	const char *s = soap_code_str(soap_codes_tt__MoveStatus, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__MoveStatus(struct soap *soap, const char *tag, int id, const enum tt__MoveStatus *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__MoveStatus), type) || soap_send(soap, soap_tt__MoveStatus2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2tt__MoveStatus(struct soap *soap, const char *s, enum tt__MoveStatus *a)
{
	const struct soap_code_map *map;
	if (!s)
		return soap->error;
	map = soap_code(soap_codes_tt__MoveStatus, s);
	if (map)
		*a = (enum tt__MoveStatus)map->code;
	else if (!*s)
		return soap->error = SOAP_EMPTY;
	else
	{	int n;
		if (soap_s2int(soap, s, &n) || n < 0 || n > 2)
			return soap->error = SOAP_TYPE;
		*a = (enum tt__MoveStatus)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum tt__MoveStatus * SOAP_FMAC4 soap_in_tt__MoveStatus(struct soap *soap, const char *tag, enum tt__MoveStatus *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum tt__MoveStatus*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__MoveStatus, sizeof(enum tt__MoveStatus), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (*soap->href != '#')
	{	int err = soap_s2tt__MoveStatus(soap, soap_value(soap), a);
		if ((soap->body && soap_element_end_in(soap, tag)) || err)
			return NULL;
	}
	else
	{	a = (enum tt__MoveStatus *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__MoveStatus, SOAP_TYPE_tt__MoveStatus, sizeof(enum tt__MoveStatus), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 enum tt__MoveStatus * SOAP_FMAC4 soap_new_tt__MoveStatus(struct soap *soap, int n)
{
	enum tt__MoveStatus *p;
	enum tt__MoveStatus *a = (enum tt__MoveStatus*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(enum tt__MoveStatus));
	for (p = a; p && n--; p++)
		soap_default_tt__MoveStatus(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__MoveStatus(struct soap *soap, const enum tt__MoveStatus *a, const char *tag, const char *type)
{
	if (soap_out_tt__MoveStatus(soap, tag ? tag : "tt:MoveStatus", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum tt__MoveStatus * SOAP_FMAC4 soap_get_tt__MoveStatus(struct soap *soap, enum tt__MoveStatus *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__MoveStatus(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

static const struct soap_code_map soap_codes_tt__CapabilityCategory[] =
{	{ (LONG64)tt__CapabilityCategory__All, "All" },
	{ (LONG64)tt__CapabilityCategory__Device, "Device" },
	{ (LONG64)tt__CapabilityCategory__Events, "Events" },
	{ (LONG64)tt__CapabilityCategory__Media, "Media" },
	{ (LONG64)tt__CapabilityCategory__PTZ, "PTZ" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_tt__CapabilityCategory2s(struct soap *soap, enum tt__CapabilityCategory n)
{
	const char *s = soap_code_str(soap_codes_tt__CapabilityCategory, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__CapabilityCategory(struct soap *soap, const char *tag, int id, const enum tt__CapabilityCategory *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__CapabilityCategory), type) || soap_send(soap, soap_tt__CapabilityCategory2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2tt__CapabilityCategory(struct soap *soap, const char *s, enum tt__CapabilityCategory *a)
{
	const struct soap_code_map *map;
	if (!s)
		return soap->error;
	map = soap_code(soap_codes_tt__CapabilityCategory, s);
	if (map)
		*a = (enum tt__CapabilityCategory)map->code;
	else if (!*s)
		return soap->error = SOAP_EMPTY;
	else
	{	int n;
		if (soap_s2int(soap, s, &n) || n < 0 || n > 4)
			return soap->error = SOAP_TYPE;
		*a = (enum tt__CapabilityCategory)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum tt__CapabilityCategory * SOAP_FMAC4 soap_in_tt__CapabilityCategory(struct soap *soap, const char *tag, enum tt__CapabilityCategory *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum tt__CapabilityCategory*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__CapabilityCategory, sizeof(enum tt__CapabilityCategory), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (*soap->href != '#')
	{	int err = soap_s2tt__CapabilityCategory(soap, soap_value(soap), a);
		if ((soap->body && soap_element_end_in(soap, tag)) || err)
			return NULL;
	}
	else
	{	a = (enum tt__CapabilityCategory *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__CapabilityCategory, SOAP_TYPE_tt__CapabilityCategory, sizeof(enum tt__CapabilityCategory), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 enum tt__CapabilityCategory * SOAP_FMAC4 soap_new_tt__CapabilityCategory(struct soap *soap, int n)
{
	enum tt__CapabilityCategory *p;
	enum tt__CapabilityCategory *a = (enum tt__CapabilityCategory*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(enum tt__CapabilityCategory));
	for (p = a; p && n--; p++)
		soap_default_tt__CapabilityCategory(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__CapabilityCategory(struct soap *soap, const enum tt__CapabilityCategory *a, const char *tag, const char *type)
{
	if (soap_out_tt__CapabilityCategory(soap, tag ? tag : "tt:CapabilityCategory", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum tt__CapabilityCategory * SOAP_FMAC4 soap_get_tt__CapabilityCategory(struct soap *soap, enum tt__CapabilityCategory *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__CapabilityCategory(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

static const struct soap_code_map soap_codes_xsd__boolean[] =
{	{ (LONG64)xsd__boolean__false_, "false" },
	{ (LONG64)xsd__boolean__true_, "true" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_xsd__boolean2s(struct soap *soap, enum xsd__boolean n)
{
	(void)soap; /* appease -Wall -Werror */
	return soap_code_str(soap_codes_xsd__boolean, n != 0);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_xsd__boolean(struct soap *soap, const char *tag, int id, const enum xsd__boolean *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_xsd__boolean), type) || soap_send(soap, soap_xsd__boolean2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2xsd__boolean(struct soap *soap, const char *s, enum xsd__boolean *a)
{
	const struct soap_code_map *map;
	if (!s)
		return soap->error;
	map = soap_code(soap_codes_xsd__boolean, s);
	if (map)
		*a = (enum xsd__boolean)(map->code != 0);
	else if (!*s)
		return soap->error = SOAP_EMPTY;
	else
	{	long n;
		if (soap_s2long(soap, s, &n) || n < 0 || n > 1)
			return soap->error = SOAP_TYPE;
		*a = (enum xsd__boolean)(n != 0);
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum xsd__boolean * SOAP_FMAC4 soap_in_xsd__boolean(struct soap *soap, const char *tag, enum xsd__boolean *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type) && soap_match_tag(soap, soap->type, ":boolean"))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (enum xsd__boolean*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_xsd__boolean, sizeof(enum xsd__boolean), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (*soap->href != '#')
	{	int err = soap_s2xsd__boolean(soap, soap_value(soap), a);
		if ((soap->body && soap_element_end_in(soap, tag)) || err)
			return NULL;
	}
	else
	{	a = (enum xsd__boolean *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_xsd__boolean, SOAP_TYPE_xsd__boolean, sizeof(enum xsd__boolean), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 enum xsd__boolean * SOAP_FMAC4 soap_new_xsd__boolean(struct soap *soap, int n)
{
	enum xsd__boolean *p;
	enum xsd__boolean *a = (enum xsd__boolean*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(enum xsd__boolean));
	for (p = a; p && n--; p++)
		soap_default_xsd__boolean(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_xsd__boolean(struct soap *soap, const enum xsd__boolean *a, const char *tag, const char *type)
{
	if (soap_out_xsd__boolean(soap, tag ? tag : "xsd:boolean", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum xsd__boolean * SOAP_FMAC4 soap_get_xsd__boolean(struct soap *soap, enum xsd__boolean *p, const char *tag, const char *type)
{
	if ((p = soap_in_xsd__boolean(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

static const struct soap_code_map soap_codes_saml2__DecisionType[] =
{	{ (LONG64)saml2__DecisionType__Permit, "Permit" },
	{ (LONG64)saml2__DecisionType__Deny, "Deny" },
	{ (LONG64)saml2__DecisionType__Indeterminate, "Indeterminate" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_saml2__DecisionType2s(struct soap *soap, enum saml2__DecisionType n)
{
	const char *s = soap_code_str(soap_codes_saml2__DecisionType, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_saml2__DecisionType(struct soap *soap, const char *tag, int id, const enum saml2__DecisionType *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_saml2__DecisionType), type) || soap_send(soap, soap_saml2__DecisionType2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2saml2__DecisionType(struct soap *soap, const char *s, enum saml2__DecisionType *a)
{
	const struct soap_code_map *map;
	if (!s)
		return soap->error;
	map = soap_code(soap_codes_saml2__DecisionType, s);
	if (map)
		*a = (enum saml2__DecisionType)map->code;
	else if (!*s)
		return soap->error = SOAP_EMPTY;
	else
	{	int n;
		if (soap_s2int(soap, s, &n) || n < 0 || n > 2)
			return soap->error = SOAP_TYPE;
		*a = (enum saml2__DecisionType)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum saml2__DecisionType * SOAP_FMAC4 soap_in_saml2__DecisionType(struct soap *soap, const char *tag, enum saml2__DecisionType *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum saml2__DecisionType*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_saml2__DecisionType, sizeof(enum saml2__DecisionType), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (*soap->href != '#')
	{	int err = soap_s2saml2__DecisionType(soap, soap_value(soap), a);
		if ((soap->body && soap_element_end_in(soap, tag)) || err)
			return NULL;
	}
	else
	{	a = (enum saml2__DecisionType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_saml2__DecisionType, SOAP_TYPE_saml2__DecisionType, sizeof(enum saml2__DecisionType), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 enum saml2__DecisionType * SOAP_FMAC4 soap_new_saml2__DecisionType(struct soap *soap, int n)
{
	enum saml2__DecisionType *p;
	enum saml2__DecisionType *a = (enum saml2__DecisionType*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(enum saml2__DecisionType));
	for (p = a; p && n--; p++)
		soap_default_saml2__DecisionType(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_saml2__DecisionType(struct soap *soap, const enum saml2__DecisionType *a, const char *tag, const char *type)
{
	if (soap_out_saml2__DecisionType(soap, tag ? tag : "saml2:DecisionType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum saml2__DecisionType * SOAP_FMAC4 soap_get_saml2__DecisionType(struct soap *soap, enum saml2__DecisionType *p, const char *tag, const char *type)
{
	if ((p = soap_in_saml2__DecisionType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

static const struct soap_code_map soap_codes_saml1__DecisionType[] =
{	{ (LONG64)saml1__DecisionType__Permit, "Permit" },
	{ (LONG64)saml1__DecisionType__Deny, "Deny" },
	{ (LONG64)saml1__DecisionType__Indeterminate, "Indeterminate" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_saml1__DecisionType2s(struct soap *soap, enum saml1__DecisionType n)
{
	const char *s = soap_code_str(soap_codes_saml1__DecisionType, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_saml1__DecisionType(struct soap *soap, const char *tag, int id, const enum saml1__DecisionType *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_saml1__DecisionType), type) || soap_send(soap, soap_saml1__DecisionType2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2saml1__DecisionType(struct soap *soap, const char *s, enum saml1__DecisionType *a)
{
	const struct soap_code_map *map;
	if (!s)
		return soap->error;
	map = soap_code(soap_codes_saml1__DecisionType, s);
	if (map)
		*a = (enum saml1__DecisionType)map->code;
	else if (!*s)
		return soap->error = SOAP_EMPTY;
	else
	{	int n;
		if (soap_s2int(soap, s, &n) || n < 0 || n > 2)
			return soap->error = SOAP_TYPE;
		*a = (enum saml1__DecisionType)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum saml1__DecisionType * SOAP_FMAC4 soap_in_saml1__DecisionType(struct soap *soap, const char *tag, enum saml1__DecisionType *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum saml1__DecisionType*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_saml1__DecisionType, sizeof(enum saml1__DecisionType), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (*soap->href != '#')
	{	int err = soap_s2saml1__DecisionType(soap, soap_value(soap), a);
		if ((soap->body && soap_element_end_in(soap, tag)) || err)
			return NULL;
	}
	else
	{	a = (enum saml1__DecisionType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_saml1__DecisionType, SOAP_TYPE_saml1__DecisionType, sizeof(enum saml1__DecisionType), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 enum saml1__DecisionType * SOAP_FMAC4 soap_new_saml1__DecisionType(struct soap *soap, int n)
{
	enum saml1__DecisionType *p;
	enum saml1__DecisionType *a = (enum saml1__DecisionType*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(enum saml1__DecisionType));
	for (p = a; p && n--; p++)
		soap_default_saml1__DecisionType(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_saml1__DecisionType(struct soap *soap, const enum saml1__DecisionType *a, const char *tag, const char *type)
{
	if (soap_out_saml1__DecisionType(soap, tag ? tag : "saml1:DecisionType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum saml1__DecisionType * SOAP_FMAC4 soap_get_saml1__DecisionType(struct soap *soap, enum saml1__DecisionType *p, const char *tag, const char *type)
{
	if ((p = soap_in_saml1__DecisionType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

static const struct soap_code_map soap_codes_wsc__FaultCodeType[] =
{	{ (LONG64)wsc__BadContextToken, "wsc:BadContextToken" },
	{ (LONG64)wsc__UnsupportedContextToken, "wsc:UnsupportedContextToken" },
	{ (LONG64)wsc__UnknownDerivationSource, "wsc:UnknownDerivationSource" },
	{ (LONG64)wsc__RenewNeeded, "wsc:RenewNeeded" },
	{ (LONG64)wsc__UnableToRenew, "wsc:UnableToRenew" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_wsc__FaultCodeType2s(struct soap *soap, enum wsc__FaultCodeType n)
{
	const char *s = soap_code_str(soap_codes_wsc__FaultCodeType, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_wsc__FaultCodeType(struct soap *soap, const char *tag, int id, const enum wsc__FaultCodeType *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_wsc__FaultCodeType), type) || soap_send(soap, soap_wsc__FaultCodeType2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2wsc__FaultCodeType(struct soap *soap, const char *s, enum wsc__FaultCodeType *a)
{
	const struct soap_code_map *map;
	char *t;
	if (!s)
		return soap->error;
	soap_s2QName(soap, s, &t, 0, -1, NULL);
	map = soap_code(soap_codes_wsc__FaultCodeType, t);
	if (map)
		*a = (enum wsc__FaultCodeType)map->code;
	else if (!*s)
		return soap->error = SOAP_EMPTY;
	else
	{	int n;
		if (soap_s2int(soap, s, &n) || n < 0 || n > 4)
			return soap->error = SOAP_TYPE;
		*a = (enum wsc__FaultCodeType)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum wsc__FaultCodeType * SOAP_FMAC4 soap_in_wsc__FaultCodeType(struct soap *soap, const char *tag, enum wsc__FaultCodeType *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum wsc__FaultCodeType*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_wsc__FaultCodeType, sizeof(enum wsc__FaultCodeType), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (*soap->href != '#')
	{	int err = soap_s2wsc__FaultCodeType(soap, soap_value(soap), a);
		if ((soap->body && soap_element_end_in(soap, tag)) || err)
			return NULL;
	}
	else
	{	a = (enum wsc__FaultCodeType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_wsc__FaultCodeType, SOAP_TYPE_wsc__FaultCodeType, sizeof(enum wsc__FaultCodeType), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 enum wsc__FaultCodeType * SOAP_FMAC4 soap_new_wsc__FaultCodeType(struct soap *soap, int n)
{
	enum wsc__FaultCodeType *p;
	enum wsc__FaultCodeType *a = (enum wsc__FaultCodeType*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(enum wsc__FaultCodeType));
	for (p = a; p && n--; p++)
		soap_default_wsc__FaultCodeType(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_wsc__FaultCodeType(struct soap *soap, const enum wsc__FaultCodeType *a, const char *tag, const char *type)
{
	if (soap_out_wsc__FaultCodeType(soap, tag ? tag : "wsc:FaultCodeType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum wsc__FaultCodeType * SOAP_FMAC4 soap_get_wsc__FaultCodeType(struct soap *soap, enum wsc__FaultCodeType *p, const char *tag, const char *type)
{
	if ((p = soap_in_wsc__FaultCodeType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

static const struct soap_code_map soap_codes_wsse__FaultcodeEnum[] =
{	{ (LONG64)wsse__UnsupportedSecurityToken, "wsse:UnsupportedSecurityToken" },
	{ (LONG64)wsse__UnsupportedAlgorithm, "wsse:UnsupportedAlgorithm" },
	{ (LONG64)wsse__InvalidSecurity, "wsse:InvalidSecurity" },
	{ (LONG64)wsse__InvalidSecurityToken, "wsse:InvalidSecurityToken" },
	{ (LONG64)wsse__FailedAuthentication, "wsse:FailedAuthentication" },
	{ (LONG64)wsse__FailedCheck, "wsse:FailedCheck" },
	{ (LONG64)wsse__SecurityTokenUnavailable, "wsse:SecurityTokenUnavailable" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_wsse__FaultcodeEnum2s(struct soap *soap, enum wsse__FaultcodeEnum n)
{
	const char *s = soap_code_str(soap_codes_wsse__FaultcodeEnum, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_wsse__FaultcodeEnum(struct soap *soap, const char *tag, int id, const enum wsse__FaultcodeEnum *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_wsse__FaultcodeEnum), type) || soap_send(soap, soap_wsse__FaultcodeEnum2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2wsse__FaultcodeEnum(struct soap *soap, const char *s, enum wsse__FaultcodeEnum *a)
{
	const struct soap_code_map *map;
	char *t;
	if (!s)
		return soap->error;
	soap_s2QName(soap, s, &t, 0, -1, NULL);
	map = soap_code(soap_codes_wsse__FaultcodeEnum, t);
	if (map)
		*a = (enum wsse__FaultcodeEnum)map->code;
	else if (!*s)
		return soap->error = SOAP_EMPTY;
	else
	{	int n;
		if (soap_s2int(soap, s, &n) || n < 0 || n > 6)
			return soap->error = SOAP_TYPE;
		*a = (enum wsse__FaultcodeEnum)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum wsse__FaultcodeEnum * SOAP_FMAC4 soap_in_wsse__FaultcodeEnum(struct soap *soap, const char *tag, enum wsse__FaultcodeEnum *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum wsse__FaultcodeEnum*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_wsse__FaultcodeEnum, sizeof(enum wsse__FaultcodeEnum), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (*soap->href != '#')
	{	int err = soap_s2wsse__FaultcodeEnum(soap, soap_value(soap), a);
		if ((soap->body && soap_element_end_in(soap, tag)) || err)
			return NULL;
	}
	else
	{	a = (enum wsse__FaultcodeEnum *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_wsse__FaultcodeEnum, SOAP_TYPE_wsse__FaultcodeEnum, sizeof(enum wsse__FaultcodeEnum), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 enum wsse__FaultcodeEnum * SOAP_FMAC4 soap_new_wsse__FaultcodeEnum(struct soap *soap, int n)
{
	enum wsse__FaultcodeEnum *p;
	enum wsse__FaultcodeEnum *a = (enum wsse__FaultcodeEnum*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(enum wsse__FaultcodeEnum));
	for (p = a; p && n--; p++)
		soap_default_wsse__FaultcodeEnum(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_wsse__FaultcodeEnum(struct soap *soap, const enum wsse__FaultcodeEnum *a, const char *tag, const char *type)
{
	if (soap_out_wsse__FaultcodeEnum(soap, tag ? tag : "wsse:FaultcodeEnum", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum wsse__FaultcodeEnum * SOAP_FMAC4 soap_get_wsse__FaultcodeEnum(struct soap *soap, enum wsse__FaultcodeEnum *p, const char *tag, const char *type)
{
	if ((p = soap_in_wsse__FaultcodeEnum(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

static const struct soap_code_map soap_codes_wsu__tTimestampFault[] =
{	{ (LONG64)wsu__MessageExpired, "wsu:MessageExpired" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_wsu__tTimestampFault2s(struct soap *soap, enum wsu__tTimestampFault n)
{
	const char *s = soap_code_str(soap_codes_wsu__tTimestampFault, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_wsu__tTimestampFault(struct soap *soap, const char *tag, int id, const enum wsu__tTimestampFault *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_wsu__tTimestampFault), type) || soap_send(soap, soap_wsu__tTimestampFault2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2wsu__tTimestampFault(struct soap *soap, const char *s, enum wsu__tTimestampFault *a)
{
	const struct soap_code_map *map;
	char *t;
	if (!s)
		return soap->error;
	soap_s2QName(soap, s, &t, 0, -1, NULL);
	map = soap_code(soap_codes_wsu__tTimestampFault, t);
	if (map)
		*a = (enum wsu__tTimestampFault)map->code;
	else if (!*s)
		return soap->error = SOAP_EMPTY;
	else
	{	int n;
		if (soap_s2int(soap, s, &n) || n < 0 || n > 0)
			return soap->error = SOAP_TYPE;
		*a = (enum wsu__tTimestampFault)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum wsu__tTimestampFault * SOAP_FMAC4 soap_in_wsu__tTimestampFault(struct soap *soap, const char *tag, enum wsu__tTimestampFault *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum wsu__tTimestampFault*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_wsu__tTimestampFault, sizeof(enum wsu__tTimestampFault), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (*soap->href != '#')
	{	int err = soap_s2wsu__tTimestampFault(soap, soap_value(soap), a);
		if ((soap->body && soap_element_end_in(soap, tag)) || err)
			return NULL;
	}
	else
	{	a = (enum wsu__tTimestampFault *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_wsu__tTimestampFault, SOAP_TYPE_wsu__tTimestampFault, sizeof(enum wsu__tTimestampFault), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 enum wsu__tTimestampFault * SOAP_FMAC4 soap_new_wsu__tTimestampFault(struct soap *soap, int n)
{
	enum wsu__tTimestampFault *p;
	enum wsu__tTimestampFault *a = (enum wsu__tTimestampFault*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(enum wsu__tTimestampFault));
	for (p = a; p && n--; p++)
		soap_default_wsu__tTimestampFault(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_wsu__tTimestampFault(struct soap *soap, const enum wsu__tTimestampFault *a, const char *tag, const char *type)
{
	if (soap_out_wsu__tTimestampFault(soap, tag ? tag : "wsu:tTimestampFault", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum wsu__tTimestampFault * SOAP_FMAC4 soap_get_wsu__tTimestampFault(struct soap *soap, enum wsu__tTimestampFault *p, const char *tag, const char *type)
{
	if ((p = soap_in_wsu__tTimestampFault(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

static const struct soap_code_map soap_codes__wsa5__IsReferenceParameter[] =
{	{ (LONG64)_wsa5__IsReferenceParameter__false, "false" },
	{ (LONG64)_wsa5__IsReferenceParameter__true, "true" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap__wsa5__IsReferenceParameter2s(struct soap *soap, enum _wsa5__IsReferenceParameter n)
{
	const char *s = soap_code_str(soap_codes__wsa5__IsReferenceParameter, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__wsa5__IsReferenceParameter(struct soap *soap, const char *tag, int id, const enum _wsa5__IsReferenceParameter *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__wsa5__IsReferenceParameter), type) || soap_send(soap, soap__wsa5__IsReferenceParameter2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2_wsa5__IsReferenceParameter(struct soap *soap, const char *s, enum _wsa5__IsReferenceParameter *a)
{
	const struct soap_code_map *map;
	if (!s)
		return soap->error;
	map = soap_code(soap_codes__wsa5__IsReferenceParameter, s);
	if (map)
		*a = (enum _wsa5__IsReferenceParameter)map->code;
	else if (!*s)
		return soap->error = SOAP_EMPTY;
	else
	{	int n;
		if (soap_s2int(soap, s, &n) || n < 0 || n > 1)
			return soap->error = SOAP_TYPE;
		*a = (enum _wsa5__IsReferenceParameter)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum _wsa5__IsReferenceParameter * SOAP_FMAC4 soap_in__wsa5__IsReferenceParameter(struct soap *soap, const char *tag, enum _wsa5__IsReferenceParameter *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum _wsa5__IsReferenceParameter*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__wsa5__IsReferenceParameter, sizeof(enum _wsa5__IsReferenceParameter), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (*soap->href != '#')
	{	int err = soap_s2_wsa5__IsReferenceParameter(soap, soap_value(soap), a);
		if ((soap->body && soap_element_end_in(soap, tag)) || err)
			return NULL;
	}
	else
	{	a = (enum _wsa5__IsReferenceParameter *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__wsa5__IsReferenceParameter, SOAP_TYPE__wsa5__IsReferenceParameter, sizeof(enum _wsa5__IsReferenceParameter), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 enum _wsa5__IsReferenceParameter * SOAP_FMAC4 soap_new__wsa5__IsReferenceParameter(struct soap *soap, int n)
{
	enum _wsa5__IsReferenceParameter *p;
	enum _wsa5__IsReferenceParameter *a = (enum _wsa5__IsReferenceParameter*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(enum _wsa5__IsReferenceParameter));
	for (p = a; p && n--; p++)
		soap_default__wsa5__IsReferenceParameter(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__wsa5__IsReferenceParameter(struct soap *soap, const enum _wsa5__IsReferenceParameter *a, const char *tag, const char *type)
{
	if (soap_out__wsa5__IsReferenceParameter(soap, tag ? tag : "wsa5:IsReferenceParameter", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum _wsa5__IsReferenceParameter * SOAP_FMAC4 soap_get__wsa5__IsReferenceParameter(struct soap *soap, enum _wsa5__IsReferenceParameter *p, const char *tag, const char *type)
{
	if ((p = soap_in__wsa5__IsReferenceParameter(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

static const struct soap_code_map soap_codes_wsa5__FaultCodesType[] =
{	{ (LONG64)wsa5__InvalidAddressingHeader, "wsa5:InvalidAddressingHeader" },
	{ (LONG64)wsa5__InvalidAddress, "wsa5:InvalidAddress" },
	{ (LONG64)wsa5__InvalidEPR, "wsa5:InvalidEPR" },
	{ (LONG64)wsa5__InvalidCardinality, "wsa5:InvalidCardinality" },
	{ (LONG64)wsa5__MissingAddressInEPR, "wsa5:MissingAddressInEPR" },
	{ (LONG64)wsa5__DuplicateMessageID, "wsa5:DuplicateMessageID" },
	{ (LONG64)wsa5__ActionMismatch, "wsa5:ActionMismatch" },
	{ (LONG64)wsa5__MessageAddressingHeaderRequired, "wsa5:MessageAddressingHeaderRequired" },
	{ (LONG64)wsa5__DestinationUnreachable, "wsa5:DestinationUnreachable" },
	{ (LONG64)wsa5__ActionNotSupported, "wsa5:ActionNotSupported" },
	{ (LONG64)wsa5__EndpointUnavailable, "wsa5:EndpointUnavailable" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_wsa5__FaultCodesType2s(struct soap *soap, enum wsa5__FaultCodesType n)
{
	const char *s = soap_code_str(soap_codes_wsa5__FaultCodesType, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_wsa5__FaultCodesType(struct soap *soap, const char *tag, int id, const enum wsa5__FaultCodesType *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_wsa5__FaultCodesType), type) || soap_send(soap, soap_wsa5__FaultCodesType2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2wsa5__FaultCodesType(struct soap *soap, const char *s, enum wsa5__FaultCodesType *a)
{
	const struct soap_code_map *map;
	char *t;
	if (!s)
		return soap->error;
	soap_s2QName(soap, s, &t, 0, -1, NULL);
	map = soap_code(soap_codes_wsa5__FaultCodesType, t);
	if (map)
		*a = (enum wsa5__FaultCodesType)map->code;
	else if (!*s)
		return soap->error = SOAP_EMPTY;
	else
	{	int n;
		if (soap_s2int(soap, s, &n) || n < 0 || n > 10)
			return soap->error = SOAP_TYPE;
		*a = (enum wsa5__FaultCodesType)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum wsa5__FaultCodesType * SOAP_FMAC4 soap_in_wsa5__FaultCodesType(struct soap *soap, const char *tag, enum wsa5__FaultCodesType *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum wsa5__FaultCodesType*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_wsa5__FaultCodesType, sizeof(enum wsa5__FaultCodesType), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (*soap->href != '#')
	{	int err = soap_s2wsa5__FaultCodesType(soap, soap_value(soap), a);
		if ((soap->body && soap_element_end_in(soap, tag)) || err)
			return NULL;
	}
	else
	{	a = (enum wsa5__FaultCodesType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_wsa5__FaultCodesType, SOAP_TYPE_wsa5__FaultCodesType, sizeof(enum wsa5__FaultCodesType), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 enum wsa5__FaultCodesType * SOAP_FMAC4 soap_new_wsa5__FaultCodesType(struct soap *soap, int n)
{
	enum wsa5__FaultCodesType *p;
	enum wsa5__FaultCodesType *a = (enum wsa5__FaultCodesType*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(enum wsa5__FaultCodesType));
	for (p = a; p && n--; p++)
		soap_default_wsa5__FaultCodesType(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_wsa5__FaultCodesType(struct soap *soap, const enum wsa5__FaultCodesType *a, const char *tag, const char *type)
{
	if (soap_out_wsa5__FaultCodesType(soap, tag ? tag : "wsa5:FaultCodesType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum wsa5__FaultCodesType * SOAP_FMAC4 soap_get_wsa5__FaultCodesType(struct soap *soap, enum wsa5__FaultCodesType *p, const char *tag, const char *type)
{
	if ((p = soap_in_wsa5__FaultCodesType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

static const struct soap_code_map soap_codes_wsa5__RelationshipType[] =
{	{ (LONG64)http_x003a_x002f_x002fwww_x002ew3_x002eorg_x002f2005_x002f08_x002faddressing_x002freply, "http://www.w3.org/2005/08/addressing/reply" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_wsa5__RelationshipType2s(struct soap *soap, enum wsa5__RelationshipType n)
{
	const char *s = soap_code_str(soap_codes_wsa5__RelationshipType, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_wsa5__RelationshipType(struct soap *soap, const char *tag, int id, const enum wsa5__RelationshipType *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_wsa5__RelationshipType), type) || soap_send(soap, soap_wsa5__RelationshipType2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2wsa5__RelationshipType(struct soap *soap, const char *s, enum wsa5__RelationshipType *a)
{
	const struct soap_code_map *map;
	if (!s)
		return soap->error;
	map = soap_code(soap_codes_wsa5__RelationshipType, s);
	if (map)
		*a = (enum wsa5__RelationshipType)map->code;
	else if (!*s)
		return soap->error = SOAP_EMPTY;
	else
	{	int n;
		if (soap_s2int(soap, s, &n) || n < 0 || n > 0)
			return soap->error = SOAP_TYPE;
		*a = (enum wsa5__RelationshipType)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum wsa5__RelationshipType * SOAP_FMAC4 soap_in_wsa5__RelationshipType(struct soap *soap, const char *tag, enum wsa5__RelationshipType *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum wsa5__RelationshipType*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_wsa5__RelationshipType, sizeof(enum wsa5__RelationshipType), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (*soap->href != '#')
	{	int err = soap_s2wsa5__RelationshipType(soap, soap_value(soap), a);
		if ((soap->body && soap_element_end_in(soap, tag)) || err)
			return NULL;
	}
	else
	{	a = (enum wsa5__RelationshipType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_wsa5__RelationshipType, SOAP_TYPE_wsa5__RelationshipType, sizeof(enum wsa5__RelationshipType), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 enum wsa5__RelationshipType * SOAP_FMAC4 soap_new_wsa5__RelationshipType(struct soap *soap, int n)
{
	enum wsa5__RelationshipType *p;
	enum wsa5__RelationshipType *a = (enum wsa5__RelationshipType*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(enum wsa5__RelationshipType));
	for (p = a; p && n--; p++)
		soap_default_wsa5__RelationshipType(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_wsa5__RelationshipType(struct soap *soap, const enum wsa5__RelationshipType *a, const char *tag, const char *type)
{
	if (soap_out_wsa5__RelationshipType(soap, tag ? tag : "wsa5:RelationshipType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum wsa5__RelationshipType * SOAP_FMAC4 soap_get_wsa5__RelationshipType(struct soap *soap, enum wsa5__RelationshipType *p, const char *tag, const char *type)
{
	if ((p = soap_in_wsa5__RelationshipType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

static const struct soap_code_map soap_codes_wsdd__FaultCodeType[] =
{	{ (LONG64)wsdd__MatchingRuleNotSupported, "wsdd:MatchingRuleNotSupported" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_wsdd__FaultCodeType2s(struct soap *soap, enum wsdd__FaultCodeType n)
{
	const char *s = soap_code_str(soap_codes_wsdd__FaultCodeType, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_wsdd__FaultCodeType(struct soap *soap, const char *tag, int id, const enum wsdd__FaultCodeType *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_wsdd__FaultCodeType), type) || soap_send(soap, soap_wsdd__FaultCodeType2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2wsdd__FaultCodeType(struct soap *soap, const char *s, enum wsdd__FaultCodeType *a)
{
	const struct soap_code_map *map;
	char *t;
	if (!s)
		return soap->error;
	soap_s2QName(soap, s, &t, 0, -1, NULL);
	map = soap_code(soap_codes_wsdd__FaultCodeType, t);
	if (map)
		*a = (enum wsdd__FaultCodeType)map->code;
	else if (!*s)
		return soap->error = SOAP_EMPTY;
	else
	{	int n;
		if (soap_s2int(soap, s, &n) || n < 0 || n > 0)
			return soap->error = SOAP_TYPE;
		*a = (enum wsdd__FaultCodeType)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum wsdd__FaultCodeType * SOAP_FMAC4 soap_in_wsdd__FaultCodeType(struct soap *soap, const char *tag, enum wsdd__FaultCodeType *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum wsdd__FaultCodeType*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_wsdd__FaultCodeType, sizeof(enum wsdd__FaultCodeType), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (*soap->href != '#')
	{	int err = soap_s2wsdd__FaultCodeType(soap, soap_value(soap), a);
		if ((soap->body && soap_element_end_in(soap, tag)) || err)
			return NULL;
	}
	else
	{	a = (enum wsdd__FaultCodeType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_wsdd__FaultCodeType, SOAP_TYPE_wsdd__FaultCodeType, sizeof(enum wsdd__FaultCodeType), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 enum wsdd__FaultCodeType * SOAP_FMAC4 soap_new_wsdd__FaultCodeType(struct soap *soap, int n)
{
	enum wsdd__FaultCodeType *p;
	enum wsdd__FaultCodeType *a = (enum wsdd__FaultCodeType*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(enum wsdd__FaultCodeType));
	for (p = a; p && n--; p++)
		soap_default_wsdd__FaultCodeType(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_wsdd__FaultCodeType(struct soap *soap, const enum wsdd__FaultCodeType *a, const char *tag, const char *type)
{
	if (soap_out_wsdd__FaultCodeType(soap, tag ? tag : "wsdd:FaultCodeType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum wsdd__FaultCodeType * SOAP_FMAC4 soap_get_wsdd__FaultCodeType(struct soap *soap, enum wsdd__FaultCodeType *p, const char *tag, const char *type)
{
	if ((p = soap_in_wsdd__FaultCodeType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

static const struct soap_code_map soap_codes_wsa__FaultSubcodeValues[] =
{	{ (LONG64)wsa__InvalidMessageInformationHeader, "wsa:InvalidMessageInformationHeader" },
	{ (LONG64)wsa__MessageInformationHeaderRequired, "wsa:MessageInformationHeaderRequired" },
	{ (LONG64)wsa__DestinationUnreachable, "wsa:DestinationUnreachable" },
	{ (LONG64)wsa__ActionNotSupported, "wsa:ActionNotSupported" },
	{ (LONG64)wsa__EndpointUnavailable, "wsa:EndpointUnavailable" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_wsa__FaultSubcodeValues2s(struct soap *soap, enum wsa__FaultSubcodeValues n)
{
	const char *s = soap_code_str(soap_codes_wsa__FaultSubcodeValues, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_wsa__FaultSubcodeValues(struct soap *soap, const char *tag, int id, const enum wsa__FaultSubcodeValues *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_wsa__FaultSubcodeValues), type) || soap_send(soap, soap_wsa__FaultSubcodeValues2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2wsa__FaultSubcodeValues(struct soap *soap, const char *s, enum wsa__FaultSubcodeValues *a)
{
	const struct soap_code_map *map;
	char *t;
	if (!s)
		return soap->error;
	soap_s2QName(soap, s, &t, 0, -1, NULL);
	map = soap_code(soap_codes_wsa__FaultSubcodeValues, t);
	if (map)
		*a = (enum wsa__FaultSubcodeValues)map->code;
	else if (!*s)
		return soap->error = SOAP_EMPTY;
	else
	{	int n;
		if (soap_s2int(soap, s, &n) || n < 0 || n > 4)
			return soap->error = SOAP_TYPE;
		*a = (enum wsa__FaultSubcodeValues)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum wsa__FaultSubcodeValues * SOAP_FMAC4 soap_in_wsa__FaultSubcodeValues(struct soap *soap, const char *tag, enum wsa__FaultSubcodeValues *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum wsa__FaultSubcodeValues*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_wsa__FaultSubcodeValues, sizeof(enum wsa__FaultSubcodeValues), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (*soap->href != '#')
	{	int err = soap_s2wsa__FaultSubcodeValues(soap, soap_value(soap), a);
		if ((soap->body && soap_element_end_in(soap, tag)) || err)
			return NULL;
	}
	else
	{	a = (enum wsa__FaultSubcodeValues *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_wsa__FaultSubcodeValues, SOAP_TYPE_wsa__FaultSubcodeValues, sizeof(enum wsa__FaultSubcodeValues), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 enum wsa__FaultSubcodeValues * SOAP_FMAC4 soap_new_wsa__FaultSubcodeValues(struct soap *soap, int n)
{
	enum wsa__FaultSubcodeValues *p;
	enum wsa__FaultSubcodeValues *a = (enum wsa__FaultSubcodeValues*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(enum wsa__FaultSubcodeValues));
	for (p = a; p && n--; p++)
		soap_default_wsa__FaultSubcodeValues(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_wsa__FaultSubcodeValues(struct soap *soap, const enum wsa__FaultSubcodeValues *a, const char *tag, const char *type)
{
	if (soap_out_wsa__FaultSubcodeValues(soap, tag ? tag : "wsa:FaultSubcodeValues", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum wsa__FaultSubcodeValues * SOAP_FMAC4 soap_get_wsa__FaultSubcodeValues(struct soap *soap, enum wsa__FaultSubcodeValues *p, const char *tag, const char *type)
{
	if ((p = soap_in_wsa__FaultSubcodeValues(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

static const struct soap_code_map soap_codes_wsa__RelationshipTypeValues[] =
{	{ (LONG64)wsa__Reply, "wsa:Reply" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_wsa__RelationshipTypeValues2s(struct soap *soap, enum wsa__RelationshipTypeValues n)
{
	const char *s = soap_code_str(soap_codes_wsa__RelationshipTypeValues, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_wsa__RelationshipTypeValues(struct soap *soap, const char *tag, int id, const enum wsa__RelationshipTypeValues *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_wsa__RelationshipTypeValues), type) || soap_send(soap, soap_wsa__RelationshipTypeValues2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2wsa__RelationshipTypeValues(struct soap *soap, const char *s, enum wsa__RelationshipTypeValues *a)
{
	const struct soap_code_map *map;
	char *t;
	if (!s)
		return soap->error;
	soap_s2QName(soap, s, &t, 0, -1, NULL);
	map = soap_code(soap_codes_wsa__RelationshipTypeValues, t);
	if (map)
		*a = (enum wsa__RelationshipTypeValues)map->code;
	else if (!*s)
		return soap->error = SOAP_EMPTY;
	else
	{	int n;
		if (soap_s2int(soap, s, &n) || n < 0 || n > 0)
			return soap->error = SOAP_TYPE;
		*a = (enum wsa__RelationshipTypeValues)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum wsa__RelationshipTypeValues * SOAP_FMAC4 soap_in_wsa__RelationshipTypeValues(struct soap *soap, const char *tag, enum wsa__RelationshipTypeValues *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum wsa__RelationshipTypeValues*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_wsa__RelationshipTypeValues, sizeof(enum wsa__RelationshipTypeValues), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (*soap->href != '#')
	{	int err = soap_s2wsa__RelationshipTypeValues(soap, soap_value(soap), a);
		if ((soap->body && soap_element_end_in(soap, tag)) || err)
			return NULL;
	}
	else
	{	a = (enum wsa__RelationshipTypeValues *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_wsa__RelationshipTypeValues, SOAP_TYPE_wsa__RelationshipTypeValues, sizeof(enum wsa__RelationshipTypeValues), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 enum wsa__RelationshipTypeValues * SOAP_FMAC4 soap_new_wsa__RelationshipTypeValues(struct soap *soap, int n)
{
	enum wsa__RelationshipTypeValues *p;
	enum wsa__RelationshipTypeValues *a = (enum wsa__RelationshipTypeValues*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(enum wsa__RelationshipTypeValues));
	for (p = a; p && n--; p++)
		soap_default_wsa__RelationshipTypeValues(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_wsa__RelationshipTypeValues(struct soap *soap, const enum wsa__RelationshipTypeValues *a, const char *tag, const char *type)
{
	if (soap_out_wsa__RelationshipTypeValues(soap, tag ? tag : "wsa:RelationshipTypeValues", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum wsa__RelationshipTypeValues * SOAP_FMAC4 soap_get_wsa__RelationshipTypeValues(struct soap *soap, enum wsa__RelationshipTypeValues *p, const char *tag, const char *type)
{
	if ((p = soap_in_wsa__RelationshipTypeValues(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___trt__GetSnapshotUri(struct soap *soap, struct __trt__GetSnapshotUri *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->trt__GetSnapshotUri = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___trt__GetSnapshotUri(struct soap *soap, const struct __trt__GetSnapshotUri *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_trt__GetSnapshotUri(soap, &a->trt__GetSnapshotUri);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___trt__GetSnapshotUri(struct soap *soap, const char *tag, int id, const struct __trt__GetSnapshotUri *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_trt__GetSnapshotUri(soap, "trt:GetSnapshotUri", -1, &a->trt__GetSnapshotUri, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __trt__GetSnapshotUri * SOAP_FMAC4 soap_in___trt__GetSnapshotUri(struct soap *soap, const char *tag, struct __trt__GetSnapshotUri *a, const char *type)
{
	size_t soap_flag_trt__GetSnapshotUri = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __trt__GetSnapshotUri*)soap_id_enter(soap, "", a, SOAP_TYPE___trt__GetSnapshotUri, sizeof(struct __trt__GetSnapshotUri), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___trt__GetSnapshotUri(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_trt__GetSnapshotUri && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_trt__GetSnapshotUri(soap, "trt:GetSnapshotUri", &a->trt__GetSnapshotUri, ""))
				{	soap_flag_trt__GetSnapshotUri--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 struct __trt__GetSnapshotUri * SOAP_FMAC4 soap_new___trt__GetSnapshotUri(struct soap *soap, int n)
{
	struct __trt__GetSnapshotUri *p;
	struct __trt__GetSnapshotUri *a = (struct __trt__GetSnapshotUri*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct __trt__GetSnapshotUri));
	for (p = a; p && n--; p++)
		soap_default___trt__GetSnapshotUri(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___trt__GetSnapshotUri(struct soap *soap, const struct __trt__GetSnapshotUri *a, const char *tag, const char *type)
{
	if (soap_out___trt__GetSnapshotUri(soap, tag ? tag : "-trt:GetSnapshotUri", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __trt__GetSnapshotUri * SOAP_FMAC4 soap_get___trt__GetSnapshotUri(struct soap *soap, struct __trt__GetSnapshotUri *p, const char *tag, const char *type)
{
	if ((p = soap_in___trt__GetSnapshotUri(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___trt__GetProfiles(struct soap *soap, struct __trt__GetProfiles *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->trt__GetProfiles = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___trt__GetProfiles(struct soap *soap, const struct __trt__GetProfiles *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_trt__GetProfiles(soap, &a->trt__GetProfiles);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___trt__GetProfiles(struct soap *soap, const char *tag, int id, const struct __trt__GetProfiles *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_trt__GetProfiles(soap, "trt:GetProfiles", -1, &a->trt__GetProfiles, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __trt__GetProfiles * SOAP_FMAC4 soap_in___trt__GetProfiles(struct soap *soap, const char *tag, struct __trt__GetProfiles *a, const char *type)
{
	size_t soap_flag_trt__GetProfiles = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __trt__GetProfiles*)soap_id_enter(soap, "", a, SOAP_TYPE___trt__GetProfiles, sizeof(struct __trt__GetProfiles), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___trt__GetProfiles(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_trt__GetProfiles && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_trt__GetProfiles(soap, "trt:GetProfiles", &a->trt__GetProfiles, ""))
				{	soap_flag_trt__GetProfiles--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 struct __trt__GetProfiles * SOAP_FMAC4 soap_new___trt__GetProfiles(struct soap *soap, int n)
{
	struct __trt__GetProfiles *p;
	struct __trt__GetProfiles *a = (struct __trt__GetProfiles*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct __trt__GetProfiles));
	for (p = a; p && n--; p++)
		soap_default___trt__GetProfiles(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___trt__GetProfiles(struct soap *soap, const struct __trt__GetProfiles *a, const char *tag, const char *type)
{
	if (soap_out___trt__GetProfiles(soap, tag ? tag : "-trt:GetProfiles", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __trt__GetProfiles * SOAP_FMAC4 soap_get___trt__GetProfiles(struct soap *soap, struct __trt__GetProfiles *p, const char *tag, const char *type)
{
	if ((p = soap_in___trt__GetProfiles(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___trt__GetProfile(struct soap *soap, struct __trt__GetProfile *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->trt__GetProfile = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___trt__GetProfile(struct soap *soap, const struct __trt__GetProfile *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_trt__GetProfile(soap, &a->trt__GetProfile);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___trt__GetProfile(struct soap *soap, const char *tag, int id, const struct __trt__GetProfile *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_trt__GetProfile(soap, "trt:GetProfile", -1, &a->trt__GetProfile, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __trt__GetProfile * SOAP_FMAC4 soap_in___trt__GetProfile(struct soap *soap, const char *tag, struct __trt__GetProfile *a, const char *type)
{
	size_t soap_flag_trt__GetProfile = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __trt__GetProfile*)soap_id_enter(soap, "", a, SOAP_TYPE___trt__GetProfile, sizeof(struct __trt__GetProfile), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___trt__GetProfile(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_trt__GetProfile && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_trt__GetProfile(soap, "trt:GetProfile", &a->trt__GetProfile, ""))
				{	soap_flag_trt__GetProfile--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 struct __trt__GetProfile * SOAP_FMAC4 soap_new___trt__GetProfile(struct soap *soap, int n)
{
	struct __trt__GetProfile *p;
	struct __trt__GetProfile *a = (struct __trt__GetProfile*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct __trt__GetProfile));
	for (p = a; p && n--; p++)
		soap_default___trt__GetProfile(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___trt__GetProfile(struct soap *soap, const struct __trt__GetProfile *a, const char *tag, const char *type)
{
	if (soap_out___trt__GetProfile(soap, tag ? tag : "-trt:GetProfile", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __trt__GetProfile * SOAP_FMAC4 soap_get___trt__GetProfile(struct soap *soap, struct __trt__GetProfile *p, const char *tag, const char *type)
{
	if ((p = soap_in___trt__GetProfile(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___trt__CreateProfile(struct soap *soap, struct __trt__CreateProfile *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->trt__CreateProfile = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___trt__CreateProfile(struct soap *soap, const struct __trt__CreateProfile *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_trt__CreateProfile(soap, &a->trt__CreateProfile);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___trt__CreateProfile(struct soap *soap, const char *tag, int id, const struct __trt__CreateProfile *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_trt__CreateProfile(soap, "trt:CreateProfile", -1, &a->trt__CreateProfile, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __trt__CreateProfile * SOAP_FMAC4 soap_in___trt__CreateProfile(struct soap *soap, const char *tag, struct __trt__CreateProfile *a, const char *type)
{
	size_t soap_flag_trt__CreateProfile = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __trt__CreateProfile*)soap_id_enter(soap, "", a, SOAP_TYPE___trt__CreateProfile, sizeof(struct __trt__CreateProfile), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___trt__CreateProfile(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_trt__CreateProfile && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_trt__CreateProfile(soap, "trt:CreateProfile", &a->trt__CreateProfile, ""))
				{	soap_flag_trt__CreateProfile--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 struct __trt__CreateProfile * SOAP_FMAC4 soap_new___trt__CreateProfile(struct soap *soap, int n)
{
	struct __trt__CreateProfile *p;
	struct __trt__CreateProfile *a = (struct __trt__CreateProfile*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct __trt__CreateProfile));
	for (p = a; p && n--; p++)
		soap_default___trt__CreateProfile(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___trt__CreateProfile(struct soap *soap, const struct __trt__CreateProfile *a, const char *tag, const char *type)
{
	if (soap_out___trt__CreateProfile(soap, tag ? tag : "-trt:CreateProfile", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __trt__CreateProfile * SOAP_FMAC4 soap_get___trt__CreateProfile(struct soap *soap, struct __trt__CreateProfile *p, const char *tag, const char *type)
{
	if ((p = soap_in___trt__CreateProfile(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___trt__GetServiceCapabilities(struct soap *soap, struct __trt__GetServiceCapabilities *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->trt__GetServiceCapabilities = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___trt__GetServiceCapabilities(struct soap *soap, const struct __trt__GetServiceCapabilities *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_trt__GetServiceCapabilities(soap, &a->trt__GetServiceCapabilities);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___trt__GetServiceCapabilities(struct soap *soap, const char *tag, int id, const struct __trt__GetServiceCapabilities *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_trt__GetServiceCapabilities(soap, "trt:GetServiceCapabilities", -1, &a->trt__GetServiceCapabilities, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __trt__GetServiceCapabilities * SOAP_FMAC4 soap_in___trt__GetServiceCapabilities(struct soap *soap, const char *tag, struct __trt__GetServiceCapabilities *a, const char *type)
{
	size_t soap_flag_trt__GetServiceCapabilities = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __trt__GetServiceCapabilities*)soap_id_enter(soap, "", a, SOAP_TYPE___trt__GetServiceCapabilities, sizeof(struct __trt__GetServiceCapabilities), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___trt__GetServiceCapabilities(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_trt__GetServiceCapabilities && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_trt__GetServiceCapabilities(soap, "trt:GetServiceCapabilities", &a->trt__GetServiceCapabilities, ""))
				{	soap_flag_trt__GetServiceCapabilities--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 struct __trt__GetServiceCapabilities * SOAP_FMAC4 soap_new___trt__GetServiceCapabilities(struct soap *soap, int n)
{
	struct __trt__GetServiceCapabilities *p;
	struct __trt__GetServiceCapabilities *a = (struct __trt__GetServiceCapabilities*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct __trt__GetServiceCapabilities));
	for (p = a; p && n--; p++)
		soap_default___trt__GetServiceCapabilities(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___trt__GetServiceCapabilities(struct soap *soap, const struct __trt__GetServiceCapabilities *a, const char *tag, const char *type)
{
	if (soap_out___trt__GetServiceCapabilities(soap, tag ? tag : "-trt:GetServiceCapabilities", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __trt__GetServiceCapabilities * SOAP_FMAC4 soap_get___trt__GetServiceCapabilities(struct soap *soap, struct __trt__GetServiceCapabilities *p, const char *tag, const char *type)
{
	if ((p = soap_in___trt__GetServiceCapabilities(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___tds__GetCapabilities(struct soap *soap, struct __tds__GetCapabilities *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->tds__GetCapabilities = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___tds__GetCapabilities(struct soap *soap, const struct __tds__GetCapabilities *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_tds__GetCapabilities(soap, &a->tds__GetCapabilities);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___tds__GetCapabilities(struct soap *soap, const char *tag, int id, const struct __tds__GetCapabilities *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_tds__GetCapabilities(soap, "tds:GetCapabilities", -1, &a->tds__GetCapabilities, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tds__GetCapabilities * SOAP_FMAC4 soap_in___tds__GetCapabilities(struct soap *soap, const char *tag, struct __tds__GetCapabilities *a, const char *type)
{
	size_t soap_flag_tds__GetCapabilities = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __tds__GetCapabilities*)soap_id_enter(soap, "", a, SOAP_TYPE___tds__GetCapabilities, sizeof(struct __tds__GetCapabilities), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___tds__GetCapabilities(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_tds__GetCapabilities && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_tds__GetCapabilities(soap, "tds:GetCapabilities", &a->tds__GetCapabilities, ""))
				{	soap_flag_tds__GetCapabilities--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 struct __tds__GetCapabilities * SOAP_FMAC4 soap_new___tds__GetCapabilities(struct soap *soap, int n)
{
	struct __tds__GetCapabilities *p;
	struct __tds__GetCapabilities *a = (struct __tds__GetCapabilities*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct __tds__GetCapabilities));
	for (p = a; p && n--; p++)
		soap_default___tds__GetCapabilities(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___tds__GetCapabilities(struct soap *soap, const struct __tds__GetCapabilities *a, const char *tag, const char *type)
{
	if (soap_out___tds__GetCapabilities(soap, tag ? tag : "-tds:GetCapabilities", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tds__GetCapabilities * SOAP_FMAC4 soap_get___tds__GetCapabilities(struct soap *soap, struct __tds__GetCapabilities *p, const char *tag, const char *type)
{
	if ((p = soap_in___tds__GetCapabilities(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___tds__SystemReboot(struct soap *soap, struct __tds__SystemReboot *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->tds__SystemReboot = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___tds__SystemReboot(struct soap *soap, const struct __tds__SystemReboot *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_tds__SystemReboot(soap, &a->tds__SystemReboot);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___tds__SystemReboot(struct soap *soap, const char *tag, int id, const struct __tds__SystemReboot *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_tds__SystemReboot(soap, "tds:SystemReboot", -1, &a->tds__SystemReboot, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tds__SystemReboot * SOAP_FMAC4 soap_in___tds__SystemReboot(struct soap *soap, const char *tag, struct __tds__SystemReboot *a, const char *type)
{
	size_t soap_flag_tds__SystemReboot = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __tds__SystemReboot*)soap_id_enter(soap, "", a, SOAP_TYPE___tds__SystemReboot, sizeof(struct __tds__SystemReboot), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___tds__SystemReboot(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_tds__SystemReboot && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_tds__SystemReboot(soap, "tds:SystemReboot", &a->tds__SystemReboot, ""))
				{	soap_flag_tds__SystemReboot--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 struct __tds__SystemReboot * SOAP_FMAC4 soap_new___tds__SystemReboot(struct soap *soap, int n)
{
	struct __tds__SystemReboot *p;
	struct __tds__SystemReboot *a = (struct __tds__SystemReboot*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct __tds__SystemReboot));
	for (p = a; p && n--; p++)
		soap_default___tds__SystemReboot(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___tds__SystemReboot(struct soap *soap, const struct __tds__SystemReboot *a, const char *tag, const char *type)
{
	if (soap_out___tds__SystemReboot(soap, tag ? tag : "-tds:SystemReboot", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tds__SystemReboot * SOAP_FMAC4 soap_get___tds__SystemReboot(struct soap *soap, struct __tds__SystemReboot *p, const char *tag, const char *type)
{
	if ((p = soap_in___tds__SystemReboot(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___tds__GetDeviceInformation(struct soap *soap, struct __tds__GetDeviceInformation *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->tds__GetDeviceInformation = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___tds__GetDeviceInformation(struct soap *soap, const struct __tds__GetDeviceInformation *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_tds__GetDeviceInformation(soap, &a->tds__GetDeviceInformation);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___tds__GetDeviceInformation(struct soap *soap, const char *tag, int id, const struct __tds__GetDeviceInformation *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_tds__GetDeviceInformation(soap, "tds:GetDeviceInformation", -1, &a->tds__GetDeviceInformation, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tds__GetDeviceInformation * SOAP_FMAC4 soap_in___tds__GetDeviceInformation(struct soap *soap, const char *tag, struct __tds__GetDeviceInformation *a, const char *type)
{
	size_t soap_flag_tds__GetDeviceInformation = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __tds__GetDeviceInformation*)soap_id_enter(soap, "", a, SOAP_TYPE___tds__GetDeviceInformation, sizeof(struct __tds__GetDeviceInformation), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___tds__GetDeviceInformation(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_tds__GetDeviceInformation && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_tds__GetDeviceInformation(soap, "tds:GetDeviceInformation", &a->tds__GetDeviceInformation, ""))
				{	soap_flag_tds__GetDeviceInformation--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 struct __tds__GetDeviceInformation * SOAP_FMAC4 soap_new___tds__GetDeviceInformation(struct soap *soap, int n)
{
	struct __tds__GetDeviceInformation *p;
	struct __tds__GetDeviceInformation *a = (struct __tds__GetDeviceInformation*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct __tds__GetDeviceInformation));
	for (p = a; p && n--; p++)
		soap_default___tds__GetDeviceInformation(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___tds__GetDeviceInformation(struct soap *soap, const struct __tds__GetDeviceInformation *a, const char *tag, const char *type)
{
	if (soap_out___tds__GetDeviceInformation(soap, tag ? tag : "-tds:GetDeviceInformation", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tds__GetDeviceInformation * SOAP_FMAC4 soap_get___tds__GetDeviceInformation(struct soap *soap, struct __tds__GetDeviceInformation *p, const char *tag, const char *type)
{
	if ((p = soap_in___tds__GetDeviceInformation(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___tds__GetServiceCapabilities(struct soap *soap, struct __tds__GetServiceCapabilities *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->tds__GetServiceCapabilities = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___tds__GetServiceCapabilities(struct soap *soap, const struct __tds__GetServiceCapabilities *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_tds__GetServiceCapabilities(soap, &a->tds__GetServiceCapabilities);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___tds__GetServiceCapabilities(struct soap *soap, const char *tag, int id, const struct __tds__GetServiceCapabilities *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_tds__GetServiceCapabilities(soap, "tds:GetServiceCapabilities", -1, &a->tds__GetServiceCapabilities, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tds__GetServiceCapabilities * SOAP_FMAC4 soap_in___tds__GetServiceCapabilities(struct soap *soap, const char *tag, struct __tds__GetServiceCapabilities *a, const char *type)
{
	size_t soap_flag_tds__GetServiceCapabilities = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __tds__GetServiceCapabilities*)soap_id_enter(soap, "", a, SOAP_TYPE___tds__GetServiceCapabilities, sizeof(struct __tds__GetServiceCapabilities), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___tds__GetServiceCapabilities(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_tds__GetServiceCapabilities && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_tds__GetServiceCapabilities(soap, "tds:GetServiceCapabilities", &a->tds__GetServiceCapabilities, ""))
				{	soap_flag_tds__GetServiceCapabilities--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 struct __tds__GetServiceCapabilities * SOAP_FMAC4 soap_new___tds__GetServiceCapabilities(struct soap *soap, int n)
{
	struct __tds__GetServiceCapabilities *p;
	struct __tds__GetServiceCapabilities *a = (struct __tds__GetServiceCapabilities*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct __tds__GetServiceCapabilities));
	for (p = a; p && n--; p++)
		soap_default___tds__GetServiceCapabilities(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___tds__GetServiceCapabilities(struct soap *soap, const struct __tds__GetServiceCapabilities *a, const char *tag, const char *type)
{
	if (soap_out___tds__GetServiceCapabilities(soap, tag ? tag : "-tds:GetServiceCapabilities", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tds__GetServiceCapabilities * SOAP_FMAC4 soap_get___tds__GetServiceCapabilities(struct soap *soap, struct __tds__GetServiceCapabilities *p, const char *tag, const char *type)
{
	if ((p = soap_in___tds__GetServiceCapabilities(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___tds__GetServices(struct soap *soap, struct __tds__GetServices *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->tds__GetServices = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___tds__GetServices(struct soap *soap, const struct __tds__GetServices *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_tds__GetServices(soap, &a->tds__GetServices);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___tds__GetServices(struct soap *soap, const char *tag, int id, const struct __tds__GetServices *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_tds__GetServices(soap, "tds:GetServices", -1, &a->tds__GetServices, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tds__GetServices * SOAP_FMAC4 soap_in___tds__GetServices(struct soap *soap, const char *tag, struct __tds__GetServices *a, const char *type)
{
	size_t soap_flag_tds__GetServices = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __tds__GetServices*)soap_id_enter(soap, "", a, SOAP_TYPE___tds__GetServices, sizeof(struct __tds__GetServices), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___tds__GetServices(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_tds__GetServices && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_tds__GetServices(soap, "tds:GetServices", &a->tds__GetServices, ""))
				{	soap_flag_tds__GetServices--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 struct __tds__GetServices * SOAP_FMAC4 soap_new___tds__GetServices(struct soap *soap, int n)
{
	struct __tds__GetServices *p;
	struct __tds__GetServices *a = (struct __tds__GetServices*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct __tds__GetServices));
	for (p = a; p && n--; p++)
		soap_default___tds__GetServices(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___tds__GetServices(struct soap *soap, const struct __tds__GetServices *a, const char *tag, const char *type)
{
	if (soap_out___tds__GetServices(soap, tag ? tag : "-tds:GetServices", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tds__GetServices * SOAP_FMAC4 soap_get___tds__GetServices(struct soap *soap, struct __tds__GetServices *p, const char *tag, const char *type)
{
	if ((p = soap_in___tds__GetServices(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___tdn__Probe(struct soap *soap, struct __tdn__Probe *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_wsdd__ProbeType(soap, &a->tdn__Probe);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___tdn__Probe(struct soap *soap, const struct __tdn__Probe *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &a->tdn__Probe, SOAP_TYPE_wsdd__ProbeType);
	soap_serialize_wsdd__ProbeType(soap, &a->tdn__Probe);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___tdn__Probe(struct soap *soap, const char *tag, int id, const struct __tdn__Probe *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_wsdd__ProbeType(soap, "tdn:Probe", -1, &a->tdn__Probe, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tdn__Probe * SOAP_FMAC4 soap_in___tdn__Probe(struct soap *soap, const char *tag, struct __tdn__Probe *a, const char *type)
{
	size_t soap_flag_tdn__Probe = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __tdn__Probe*)soap_id_enter(soap, "", a, SOAP_TYPE___tdn__Probe, sizeof(struct __tdn__Probe), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___tdn__Probe(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_tdn__Probe && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_wsdd__ProbeType(soap, "tdn:Probe", &a->tdn__Probe, "wsdd:ProbeType"))
				{	soap_flag_tdn__Probe--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_tdn__Probe > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	return a;
}

SOAP_FMAC3 struct __tdn__Probe * SOAP_FMAC4 soap_new___tdn__Probe(struct soap *soap, int n)
{
	struct __tdn__Probe *p;
	struct __tdn__Probe *a = (struct __tdn__Probe*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct __tdn__Probe));
	for (p = a; p && n--; p++)
		soap_default___tdn__Probe(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___tdn__Probe(struct soap *soap, const struct __tdn__Probe *a, const char *tag, const char *type)
{
	if (soap_out___tdn__Probe(soap, tag ? tag : "-tdn:Probe", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tdn__Probe * SOAP_FMAC4 soap_get___tdn__Probe(struct soap *soap, struct __tdn__Probe *p, const char *tag, const char *type)
{
	if ((p = soap_in___tdn__Probe(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___tdn__Bye(struct soap *soap, struct __tdn__Bye *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_wsdd__ByeType(soap, &a->tdn__Bye);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___tdn__Bye(struct soap *soap, const struct __tdn__Bye *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &a->tdn__Bye, SOAP_TYPE_wsdd__ByeType);
	soap_serialize_wsdd__ByeType(soap, &a->tdn__Bye);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___tdn__Bye(struct soap *soap, const char *tag, int id, const struct __tdn__Bye *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_wsdd__ByeType(soap, "tdn:Bye", -1, &a->tdn__Bye, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tdn__Bye * SOAP_FMAC4 soap_in___tdn__Bye(struct soap *soap, const char *tag, struct __tdn__Bye *a, const char *type)
{
	size_t soap_flag_tdn__Bye = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __tdn__Bye*)soap_id_enter(soap, "", a, SOAP_TYPE___tdn__Bye, sizeof(struct __tdn__Bye), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___tdn__Bye(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_tdn__Bye && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_wsdd__ByeType(soap, "tdn:Bye", &a->tdn__Bye, "wsdd:ByeType"))
				{	soap_flag_tdn__Bye--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_tdn__Bye > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	return a;
}

SOAP_FMAC3 struct __tdn__Bye * SOAP_FMAC4 soap_new___tdn__Bye(struct soap *soap, int n)
{
	struct __tdn__Bye *p;
	struct __tdn__Bye *a = (struct __tdn__Bye*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct __tdn__Bye));
	for (p = a; p && n--; p++)
		soap_default___tdn__Bye(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___tdn__Bye(struct soap *soap, const struct __tdn__Bye *a, const char *tag, const char *type)
{
	if (soap_out___tdn__Bye(soap, tag ? tag : "-tdn:Bye", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tdn__Bye * SOAP_FMAC4 soap_get___tdn__Bye(struct soap *soap, struct __tdn__Bye *p, const char *tag, const char *type)
{
	if ((p = soap_in___tdn__Bye(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___tdn__Hello(struct soap *soap, struct __tdn__Hello *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_wsdd__HelloType(soap, &a->tdn__Hello);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___tdn__Hello(struct soap *soap, const struct __tdn__Hello *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &a->tdn__Hello, SOAP_TYPE_wsdd__HelloType);
	soap_serialize_wsdd__HelloType(soap, &a->tdn__Hello);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___tdn__Hello(struct soap *soap, const char *tag, int id, const struct __tdn__Hello *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_wsdd__HelloType(soap, "tdn:Hello", -1, &a->tdn__Hello, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tdn__Hello * SOAP_FMAC4 soap_in___tdn__Hello(struct soap *soap, const char *tag, struct __tdn__Hello *a, const char *type)
{
	size_t soap_flag_tdn__Hello = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __tdn__Hello*)soap_id_enter(soap, "", a, SOAP_TYPE___tdn__Hello, sizeof(struct __tdn__Hello), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___tdn__Hello(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_tdn__Hello && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_wsdd__HelloType(soap, "tdn:Hello", &a->tdn__Hello, "wsdd:HelloType"))
				{	soap_flag_tdn__Hello--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_tdn__Hello > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	return a;
}

SOAP_FMAC3 struct __tdn__Hello * SOAP_FMAC4 soap_new___tdn__Hello(struct soap *soap, int n)
{
	struct __tdn__Hello *p;
	struct __tdn__Hello *a = (struct __tdn__Hello*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct __tdn__Hello));
	for (p = a; p && n--; p++)
		soap_default___tdn__Hello(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___tdn__Hello(struct soap *soap, const struct __tdn__Hello *a, const char *tag, const char *type)
{
	if (soap_out___tdn__Hello(soap, tag ? tag : "-tdn:Hello", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tdn__Hello * SOAP_FMAC4 soap_get___tdn__Hello(struct soap *soap, struct __tdn__Hello *p, const char *tag, const char *type)
{
	if ((p = soap_in___tdn__Hello(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_wstop__TopicType(struct soap *soap, struct wstop__TopicType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->documentation = NULL;
	a->__anyAttribute = NULL;
	a->MessagePattern = NULL;
	a->__sizeTopic = 0;
	a->Topic = NULL;
	a->__size = 0;
	a->__any = NULL;
	soap_default_xsd__NCName(soap, &a->name);
	a->messageTypes = NULL;
	a->final_ = (enum xsd__boolean)0;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_wstop__TopicType(struct soap *soap, const struct wstop__TopicType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTowstop__Documentation(soap, &a->documentation);
	soap_serialize_PointerTowstop__QueryExpressionType(soap, &a->MessagePattern);
	if (a->Topic)
	{	int i;
		for (i = 0; i < (int)a->__sizeTopic; i++)
		{
			soap_embedded(soap, a->Topic + i, SOAP_TYPE_wstop__TopicType);
			soap_serialize_wstop__TopicType(soap, a->Topic + i);
		}
	}
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_wstop__TopicType(struct soap *soap, const char *tag, int id, const struct wstop__TopicType *a, const char *type)
{
	if (a->__anyAttribute)
		soap_set_attr(soap, "-anyAttribute", a->__anyAttribute, 1);
	soap_set_attr(soap, "name", a->name ? soap_xsd__NCName2s(soap, a->name) : "", 1);
	if (a->messageTypes)
	{	if (*a->messageTypes)
			soap_set_attr(soap, "messageTypes", soap__QName2s(soap, *a->messageTypes), 1);
	}
	if (a->final_ != (enum xsd__boolean)0)
	{	soap_set_attr(soap, "final", soap_xsd__boolean2s(soap, a->final_), 1);
	}
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_wstop__TopicType), type))
		return soap->error;
	if (soap_out_PointerTowstop__Documentation(soap, "wstop:documentation", -1, &a->documentation, ""))
		return soap->error;
	if (soap_out_PointerTowstop__QueryExpressionType(soap, "wstop:MessagePattern", -1, &a->MessagePattern, ""))
		return soap->error;
	if (a->Topic)
	{	int i;
		for (i = 0; i < (int)a->__sizeTopic; i++)
			if (soap_out_wstop__TopicType(soap, "wstop:Topic", -1, a->Topic + i, ""))
				return soap->error;
	}
	if (a->__any)
	{	int i;
		for (i = 0; i < (int)a->__size; i++)
			if (soap_outliteral(soap, "-any", (char*const*)(a->__any + i), NULL))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct wstop__TopicType * SOAP_FMAC4 soap_in_wstop__TopicType(struct soap *soap, const char *tag, struct wstop__TopicType *a, const char *type)
{
	size_t soap_flag_documentation = 1;
	size_t soap_flag_MessagePattern = 1;
	struct soap_blist *soap_blist_Topic = NULL;
	struct soap_blist *soap_blist___any = NULL;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct wstop__TopicType*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_wstop__TopicType, sizeof(struct wstop__TopicType), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_wstop__TopicType(soap, a);
	if (soap_s2char(soap, soap_attr_value(soap, "-anyAttribute", 0, 0), &a->__anyAttribute, 0, 0, -1, NULL))
		return NULL;
	if (soap_s2xsd__NCName(soap, soap_attr_value(soap, "name", 5, 1), &a->name))
		return NULL;
	{
		const char *t = soap_attr_value(soap, "messageTypes", 2, 0);
		if (t)
		{
			if (!(a->messageTypes = (char **)soap_malloc(soap, sizeof(char *))))
				return NULL;
			if (soap_s2_QName(soap, t, a->messageTypes))
				return NULL;
		}
		else if (soap->error)
			return NULL;
	}
	if (soap_s2xsd__boolean(soap, soap_attr_value(soap, "final", 5, 0), &a->final_))
		return NULL;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_documentation && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTowstop__Documentation(soap, "wstop:documentation", &a->documentation, "wstop:Documentation"))
				{	soap_flag_documentation--;
					continue;
				}
			}
			if (soap_flag_MessagePattern && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTowstop__QueryExpressionType(soap, "wstop:MessagePattern", &a->MessagePattern, "wstop:QueryExpressionType"))
				{	soap_flag_MessagePattern--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "wstop:Topic", 1, NULL))
			{	if (a->Topic == NULL)
				{	if (soap_blist_Topic == NULL)
						soap_blist_Topic = soap_alloc_block(soap);
					a->Topic = (struct wstop__TopicType *)soap_push_block_max(soap, soap_blist_Topic, sizeof(struct wstop__TopicType));
					if (a->Topic == NULL)
						return NULL;
					soap_default_wstop__TopicType(soap, a->Topic);
				}
				soap_revert(soap);
				if (soap_in_wstop__TopicType(soap, "wstop:Topic", a->Topic, "wstop:TopicType"))
				{	a->__sizeTopic++;
					a->Topic = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	if (a->__any == NULL)
				{	if (soap_blist___any == NULL)
						soap_blist___any = soap_alloc_block(soap);
					a->__any = (char **)soap_push_block_max(soap, soap_blist___any, sizeof(char *));
					if (a->__any == NULL)
						return NULL;
					*a->__any = NULL;
				}
				if (soap_inliteral(soap, "-any", (char**)a->__any))
				{	a->__size++;
					a->__any = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->Topic)
			soap_pop_block(soap, soap_blist_Topic);
		if (a->__sizeTopic)
		{	a->Topic = (struct wstop__TopicType *)soap_save_block(soap, soap_blist_Topic, NULL, 1);
		}
		else
		{	a->Topic = NULL;
			if (soap_blist_Topic)
				soap_end_block(soap, soap_blist_Topic);
		}
		if (a->__any)
			soap_pop_block(soap, soap_blist___any);
		if (a->__size)
		{	a->__any = (char **)soap_save_block(soap, soap_blist___any, NULL, 1);
		}
		else
		{	a->__any = NULL;
			if (soap_blist___any)
				soap_end_block(soap, soap_blist___any);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct wstop__TopicType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_wstop__TopicType, SOAP_TYPE_wstop__TopicType, sizeof(struct wstop__TopicType), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct wstop__TopicType * SOAP_FMAC4 soap_new_wstop__TopicType(struct soap *soap, int n)
{
	struct wstop__TopicType *p;
	struct wstop__TopicType *a = (struct wstop__TopicType*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct wstop__TopicType));
	for (p = a; p && n--; p++)
		soap_default_wstop__TopicType(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_wstop__TopicType(struct soap *soap, const struct wstop__TopicType *a, const char *tag, const char *type)
{
	if (soap_out_wstop__TopicType(soap, tag ? tag : "wstop:TopicType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct wstop__TopicType * SOAP_FMAC4 soap_get_wstop__TopicType(struct soap *soap, struct wstop__TopicType *p, const char *tag, const char *type)
{
	if ((p = soap_in_wstop__TopicType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__wstop__TopicNamespaceType_Topic(struct soap *soap, struct _wstop__TopicNamespaceType_Topic *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->documentation = NULL;
	a->__anyAttribute = NULL;
	a->MessagePattern = NULL;
	a->__sizeTopic = 0;
	a->Topic = NULL;
	a->__size = 0;
	a->__any = NULL;
	soap_default_xsd__NCName(soap, &a->name);
	a->messageTypes = NULL;
	a->final_ = (enum xsd__boolean)0;
	soap_default_wstop__ConcreteTopicExpression(soap, &a->parent);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__wstop__TopicNamespaceType_Topic(struct soap *soap, const struct _wstop__TopicNamespaceType_Topic *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTowstop__Documentation(soap, &a->documentation);
	soap_serialize_PointerTowstop__QueryExpressionType(soap, &a->MessagePattern);
	if (a->Topic)
	{	int i;
		for (i = 0; i < (int)a->__sizeTopic; i++)
		{
			soap_embedded(soap, a->Topic + i, SOAP_TYPE_wstop__TopicType);
			soap_serialize_wstop__TopicType(soap, a->Topic + i);
		}
	}
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__wstop__TopicNamespaceType_Topic(struct soap *soap, const char *tag, int id, const struct _wstop__TopicNamespaceType_Topic *a, const char *type)
{
	if (a->__anyAttribute)
		soap_set_attr(soap, "-anyAttribute", a->__anyAttribute, 1);
	soap_set_attr(soap, "name", a->name ? soap_xsd__NCName2s(soap, a->name) : "", 1);
	if (a->messageTypes)
	{	if (*a->messageTypes)
			soap_set_attr(soap, "messageTypes", soap__QName2s(soap, *a->messageTypes), 1);
	}
	if (a->final_ != (enum xsd__boolean)0)
	{	soap_set_attr(soap, "final", soap_xsd__boolean2s(soap, a->final_), 1);
	}
	if (a->parent)
		soap_set_attr(soap, "parent", soap_wstop__ConcreteTopicExpression2s(soap, a->parent), 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__wstop__TopicNamespaceType_Topic), type))
		return soap->error;
	if (soap_out_PointerTowstop__Documentation(soap, "wstop:documentation", -1, &a->documentation, ""))
		return soap->error;
	if (soap_out_PointerTowstop__QueryExpressionType(soap, "wstop:MessagePattern", -1, &a->MessagePattern, ""))
		return soap->error;
	if (a->Topic)
	{	int i;
		for (i = 0; i < (int)a->__sizeTopic; i++)
			if (soap_out_wstop__TopicType(soap, "wstop:Topic", -1, a->Topic + i, ""))
				return soap->error;
	}
	if (a->__any)
	{	int i;
		for (i = 0; i < (int)a->__size; i++)
			if (soap_outliteral(soap, "-any", (char*const*)(a->__any + i), NULL))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _wstop__TopicNamespaceType_Topic * SOAP_FMAC4 soap_in__wstop__TopicNamespaceType_Topic(struct soap *soap, const char *tag, struct _wstop__TopicNamespaceType_Topic *a, const char *type)
{
	size_t soap_flag_documentation = 1;
	size_t soap_flag_MessagePattern = 1;
	struct soap_blist *soap_blist_Topic = NULL;
	struct soap_blist *soap_blist___any = NULL;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct _wstop__TopicNamespaceType_Topic*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__wstop__TopicNamespaceType_Topic, sizeof(struct _wstop__TopicNamespaceType_Topic), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__wstop__TopicNamespaceType_Topic(soap, a);
	if (soap_s2char(soap, soap_attr_value(soap, "-anyAttribute", 0, 0), &a->__anyAttribute, 0, 0, -1, NULL))
		return NULL;
	if (soap_s2xsd__NCName(soap, soap_attr_value(soap, "name", 5, 1), &a->name))
		return NULL;
	{
		const char *t = soap_attr_value(soap, "messageTypes", 2, 0);
		if (t)
		{
			if (!(a->messageTypes = (char **)soap_malloc(soap, sizeof(char *))))
				return NULL;
			if (soap_s2_QName(soap, t, a->messageTypes))
				return NULL;
		}
		else if (soap->error)
			return NULL;
	}
	if (soap_s2xsd__boolean(soap, soap_attr_value(soap, "final", 5, 0), &a->final_))
		return NULL;
	if (soap_s2wstop__ConcreteTopicExpression(soap, soap_attr_value(soap, "parent", 5, 0), &a->parent))
		return NULL;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_documentation && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTowstop__Documentation(soap, "wstop:documentation", &a->documentation, "wstop:Documentation"))
				{	soap_flag_documentation--;
					continue;
				}
			}
			if (soap_flag_MessagePattern && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTowstop__QueryExpressionType(soap, "wstop:MessagePattern", &a->MessagePattern, "wstop:QueryExpressionType"))
				{	soap_flag_MessagePattern--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "wstop:Topic", 1, NULL))
			{	if (a->Topic == NULL)
				{	if (soap_blist_Topic == NULL)
						soap_blist_Topic = soap_alloc_block(soap);
					a->Topic = (struct wstop__TopicType *)soap_push_block_max(soap, soap_blist_Topic, sizeof(struct wstop__TopicType));
					if (a->Topic == NULL)
						return NULL;
					soap_default_wstop__TopicType(soap, a->Topic);
				}
				soap_revert(soap);
				if (soap_in_wstop__TopicType(soap, "wstop:Topic", a->Topic, "wstop:TopicType"))
				{	a->__sizeTopic++;
					a->Topic = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	if (a->__any == NULL)
				{	if (soap_blist___any == NULL)
						soap_blist___any = soap_alloc_block(soap);
					a->__any = (char **)soap_push_block_max(soap, soap_blist___any, sizeof(char *));
					if (a->__any == NULL)
						return NULL;
					*a->__any = NULL;
				}
				if (soap_inliteral(soap, "-any", (char**)a->__any))
				{	a->__size++;
					a->__any = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->Topic)
			soap_pop_block(soap, soap_blist_Topic);
		if (a->__sizeTopic)
		{	a->Topic = (struct wstop__TopicType *)soap_save_block(soap, soap_blist_Topic, NULL, 1);
		}
		else
		{	a->Topic = NULL;
			if (soap_blist_Topic)
				soap_end_block(soap, soap_blist_Topic);
		}
		if (a->__any)
			soap_pop_block(soap, soap_blist___any);
		if (a->__size)
		{	a->__any = (char **)soap_save_block(soap, soap_blist___any, NULL, 1);
		}
		else
		{	a->__any = NULL;
			if (soap_blist___any)
				soap_end_block(soap, soap_blist___any);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _wstop__TopicNamespaceType_Topic *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__wstop__TopicNamespaceType_Topic, SOAP_TYPE__wstop__TopicNamespaceType_Topic, sizeof(struct _wstop__TopicNamespaceType_Topic), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _wstop__TopicNamespaceType_Topic * SOAP_FMAC4 soap_new__wstop__TopicNamespaceType_Topic(struct soap *soap, int n)
{
	struct _wstop__TopicNamespaceType_Topic *p;
	struct _wstop__TopicNamespaceType_Topic *a = (struct _wstop__TopicNamespaceType_Topic*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _wstop__TopicNamespaceType_Topic));
	for (p = a; p && n--; p++)
		soap_default__wstop__TopicNamespaceType_Topic(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__wstop__TopicNamespaceType_Topic(struct soap *soap, const struct _wstop__TopicNamespaceType_Topic *a, const char *tag, const char *type)
{
	if (soap_out__wstop__TopicNamespaceType_Topic(soap, tag ? tag : "wstop:TopicNamespaceType-Topic", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _wstop__TopicNamespaceType_Topic * SOAP_FMAC4 soap_get__wstop__TopicNamespaceType_Topic(struct soap *soap, struct _wstop__TopicNamespaceType_Topic *p, const char *tag, const char *type)
{
	if ((p = soap_in__wstop__TopicNamespaceType_Topic(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_wstop__TopicNamespaceType(struct soap *soap, struct wstop__TopicNamespaceType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->documentation = NULL;
	a->__anyAttribute = NULL;
	a->__sizeTopic = 0;
	a->Topic = NULL;
	a->__size = 0;
	a->__any = NULL;
	soap_default_xsd__NCName(soap, &a->name);
	soap_default_xsd__anyURI(soap, &a->targetNamespace);
	a->final_ = (enum xsd__boolean)0;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_wstop__TopicNamespaceType(struct soap *soap, const struct wstop__TopicNamespaceType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTowstop__Documentation(soap, &a->documentation);
	if (a->Topic)
	{	int i;
		for (i = 0; i < (int)a->__sizeTopic; i++)
		{
			soap_embedded(soap, a->Topic + i, SOAP_TYPE__wstop__TopicNamespaceType_Topic);
			soap_serialize__wstop__TopicNamespaceType_Topic(soap, a->Topic + i);
		}
	}
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_wstop__TopicNamespaceType(struct soap *soap, const char *tag, int id, const struct wstop__TopicNamespaceType *a, const char *type)
{
	if (a->__anyAttribute)
		soap_set_attr(soap, "-anyAttribute", a->__anyAttribute, 1);
	if (a->name)
		soap_set_attr(soap, "name", soap_xsd__NCName2s(soap, a->name), 1);
	soap_set_attr(soap, "targetNamespace", a->targetNamespace ? soap_xsd__anyURI2s(soap, a->targetNamespace) : "", 1);
	if (a->final_ != (enum xsd__boolean)0)
	{	soap_set_attr(soap, "final", soap_xsd__boolean2s(soap, a->final_), 1);
	}
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_wstop__TopicNamespaceType), type))
		return soap->error;
	if (soap_out_PointerTowstop__Documentation(soap, "wstop:documentation", -1, &a->documentation, ""))
		return soap->error;
	if (a->Topic)
	{	int i;
		for (i = 0; i < (int)a->__sizeTopic; i++)
			if (soap_out__wstop__TopicNamespaceType_Topic(soap, "wstop:Topic", -1, a->Topic + i, ""))
				return soap->error;
	}
	if (a->__any)
	{	int i;
		for (i = 0; i < (int)a->__size; i++)
			if (soap_outliteral(soap, "-any", (char*const*)(a->__any + i), NULL))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct wstop__TopicNamespaceType * SOAP_FMAC4 soap_in_wstop__TopicNamespaceType(struct soap *soap, const char *tag, struct wstop__TopicNamespaceType *a, const char *type)
{
	size_t soap_flag_documentation = 1;
	struct soap_blist *soap_blist_Topic = NULL;
	struct soap_blist *soap_blist___any = NULL;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct wstop__TopicNamespaceType*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_wstop__TopicNamespaceType, sizeof(struct wstop__TopicNamespaceType), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_wstop__TopicNamespaceType(soap, a);
	if (soap_s2char(soap, soap_attr_value(soap, "-anyAttribute", 0, 0), &a->__anyAttribute, 0, 0, -1, NULL))
		return NULL;
	if (soap_s2xsd__NCName(soap, soap_attr_value(soap, "name", 5, 0), &a->name))
		return NULL;
	if (soap_s2xsd__anyURI(soap, soap_attr_value(soap, "targetNamespace", 4, 1), &a->targetNamespace))
		return NULL;
	if (soap_s2xsd__boolean(soap, soap_attr_value(soap, "final", 5, 0), &a->final_))
		return NULL;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_documentation && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTowstop__Documentation(soap, "wstop:documentation", &a->documentation, "wstop:Documentation"))
				{	soap_flag_documentation--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "wstop:Topic", 1, NULL))
			{	if (a->Topic == NULL)
				{	if (soap_blist_Topic == NULL)
						soap_blist_Topic = soap_alloc_block(soap);
					a->Topic = (struct _wstop__TopicNamespaceType_Topic *)soap_push_block_max(soap, soap_blist_Topic, sizeof(struct _wstop__TopicNamespaceType_Topic));
					if (a->Topic == NULL)
						return NULL;
					soap_default__wstop__TopicNamespaceType_Topic(soap, a->Topic);
				}
				soap_revert(soap);
				if (soap_in__wstop__TopicNamespaceType_Topic(soap, "wstop:Topic", a->Topic, ""))
				{	a->__sizeTopic++;
					a->Topic = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	if (a->__any == NULL)
				{	if (soap_blist___any == NULL)
						soap_blist___any = soap_alloc_block(soap);
					a->__any = (char **)soap_push_block_max(soap, soap_blist___any, sizeof(char *));
					if (a->__any == NULL)
						return NULL;
					*a->__any = NULL;
				}
				if (soap_inliteral(soap, "-any", (char**)a->__any))
				{	a->__size++;
					a->__any = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->Topic)
			soap_pop_block(soap, soap_blist_Topic);
		if (a->__sizeTopic)
		{	a->Topic = (struct _wstop__TopicNamespaceType_Topic *)soap_save_block(soap, soap_blist_Topic, NULL, 1);
		}
		else
		{	a->Topic = NULL;
			if (soap_blist_Topic)
				soap_end_block(soap, soap_blist_Topic);
		}
		if (a->__any)
			soap_pop_block(soap, soap_blist___any);
		if (a->__size)
		{	a->__any = (char **)soap_save_block(soap, soap_blist___any, NULL, 1);
		}
		else
		{	a->__any = NULL;
			if (soap_blist___any)
				soap_end_block(soap, soap_blist___any);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct wstop__TopicNamespaceType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_wstop__TopicNamespaceType, SOAP_TYPE_wstop__TopicNamespaceType, sizeof(struct wstop__TopicNamespaceType), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct wstop__TopicNamespaceType * SOAP_FMAC4 soap_new_wstop__TopicNamespaceType(struct soap *soap, int n)
{
	struct wstop__TopicNamespaceType *p;
	struct wstop__TopicNamespaceType *a = (struct wstop__TopicNamespaceType*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct wstop__TopicNamespaceType));
	for (p = a; p && n--; p++)
		soap_default_wstop__TopicNamespaceType(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_wstop__TopicNamespaceType(struct soap *soap, const struct wstop__TopicNamespaceType *a, const char *tag, const char *type)
{
	if (soap_out_wstop__TopicNamespaceType(soap, tag ? tag : "wstop:TopicNamespaceType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct wstop__TopicNamespaceType * SOAP_FMAC4 soap_get_wstop__TopicNamespaceType(struct soap *soap, struct wstop__TopicNamespaceType *p, const char *tag, const char *type)
{
	if ((p = soap_in_wstop__TopicNamespaceType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__wsnt__ResumeFailedFaultType_FaultCause(struct soap *soap, struct _wsnt__ResumeFailedFaultType_FaultCause *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__any = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__wsnt__ResumeFailedFaultType_FaultCause(struct soap *soap, const struct _wsnt__ResumeFailedFaultType_FaultCause *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__wsnt__ResumeFailedFaultType_FaultCause(struct soap *soap, const char *tag, int id, const struct _wsnt__ResumeFailedFaultType_FaultCause *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__wsnt__ResumeFailedFaultType_FaultCause), type))
		return soap->error;
	if (soap_outliteral(soap, "-any", (char*const*)&a->__any, NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _wsnt__ResumeFailedFaultType_FaultCause * SOAP_FMAC4 soap_in__wsnt__ResumeFailedFaultType_FaultCause(struct soap *soap, const char *tag, struct _wsnt__ResumeFailedFaultType_FaultCause *a, const char *type)
{
	size_t soap_flag___any = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct _wsnt__ResumeFailedFaultType_FaultCause*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__wsnt__ResumeFailedFaultType_FaultCause, sizeof(struct _wsnt__ResumeFailedFaultType_FaultCause), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__wsnt__ResumeFailedFaultType_FaultCause(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag___any && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_inliteral(soap, "-any", (char**)&a->__any))
				{	soap_flag___any--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _wsnt__ResumeFailedFaultType_FaultCause *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__wsnt__ResumeFailedFaultType_FaultCause, SOAP_TYPE__wsnt__ResumeFailedFaultType_FaultCause, sizeof(struct _wsnt__ResumeFailedFaultType_FaultCause), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _wsnt__ResumeFailedFaultType_FaultCause * SOAP_FMAC4 soap_new__wsnt__ResumeFailedFaultType_FaultCause(struct soap *soap, int n)
{
	struct _wsnt__ResumeFailedFaultType_FaultCause *p;
	struct _wsnt__ResumeFailedFaultType_FaultCause *a = (struct _wsnt__ResumeFailedFaultType_FaultCause*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _wsnt__ResumeFailedFaultType_FaultCause));
	for (p = a; p && n--; p++)
		soap_default__wsnt__ResumeFailedFaultType_FaultCause(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__wsnt__ResumeFailedFaultType_FaultCause(struct soap *soap, const struct _wsnt__ResumeFailedFaultType_FaultCause *a, const char *tag, const char *type)
{
	if (soap_out__wsnt__ResumeFailedFaultType_FaultCause(soap, tag ? tag : "wsnt:ResumeFailedFaultType-FaultCause", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _wsnt__ResumeFailedFaultType_FaultCause * SOAP_FMAC4 soap_get__wsnt__ResumeFailedFaultType_FaultCause(struct soap *soap, struct _wsnt__ResumeFailedFaultType_FaultCause *p, const char *tag, const char *type)
{
	if ((p = soap_in__wsnt__ResumeFailedFaultType_FaultCause(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__wsnt__ResumeFailedFaultType_Description(struct soap *soap, struct _wsnt__ResumeFailedFaultType_Description *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->__item);
	soap_default__xml__lang(soap, &a->xml__lang);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__wsnt__ResumeFailedFaultType_Description(struct soap *soap, const struct _wsnt__ResumeFailedFaultType_Description *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_string(soap, (char*const*)&a->__item);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__wsnt__ResumeFailedFaultType_Description(struct soap *soap, const char *tag, int id, const struct _wsnt__ResumeFailedFaultType_Description *a, const char *type)
{
	if (a->xml__lang)
		soap_set_attr(soap, "xml:lang", soap__xml__lang2s(soap, a->xml__lang), 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	return soap_out_string(soap, tag, id, (char*const*)&a->__item, "");
}

SOAP_FMAC3 struct _wsnt__ResumeFailedFaultType_Description * SOAP_FMAC4 soap_in__wsnt__ResumeFailedFaultType_Description(struct soap *soap, const char *tag, struct _wsnt__ResumeFailedFaultType_Description *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	if (!(a = (struct _wsnt__ResumeFailedFaultType_Description *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__wsnt__ResumeFailedFaultType_Description, sizeof(struct _wsnt__ResumeFailedFaultType_Description), NULL, NULL, NULL, NULL)))
		return NULL;
	soap_revert(soap);
	*soap->id = '\0';
	soap_default__wsnt__ResumeFailedFaultType_Description(soap, a);
	if (soap_s2_xml__lang(soap, soap_attr_value(soap, "xml:lang", 1, 0), &a->xml__lang))
		return NULL;
	if (!soap_in_string(soap, tag, (char**)&a->__item, ""))
		return NULL;
	return a;
}

SOAP_FMAC3 struct _wsnt__ResumeFailedFaultType_Description * SOAP_FMAC4 soap_new__wsnt__ResumeFailedFaultType_Description(struct soap *soap, int n)
{
	struct _wsnt__ResumeFailedFaultType_Description *p;
	struct _wsnt__ResumeFailedFaultType_Description *a = (struct _wsnt__ResumeFailedFaultType_Description*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _wsnt__ResumeFailedFaultType_Description));
	for (p = a; p && n--; p++)
		soap_default__wsnt__ResumeFailedFaultType_Description(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__wsnt__ResumeFailedFaultType_Description(struct soap *soap, const struct _wsnt__ResumeFailedFaultType_Description *a, const char *tag, const char *type)
{
	if (soap_out__wsnt__ResumeFailedFaultType_Description(soap, tag ? tag : "wsnt:ResumeFailedFaultType-Description", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _wsnt__ResumeFailedFaultType_Description * SOAP_FMAC4 soap_get__wsnt__ResumeFailedFaultType_Description(struct soap *soap, struct _wsnt__ResumeFailedFaultType_Description *p, const char *tag, const char *type)
{
	if ((p = soap_in__wsnt__ResumeFailedFaultType_Description(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__wsnt__ResumeFailedFaultType_ErrorCode(struct soap *soap, struct _wsnt__ResumeFailedFaultType_ErrorCode *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_xsd__anyURI(soap, &a->dialect);
	a->__mixed = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__wsnt__ResumeFailedFaultType_ErrorCode(struct soap *soap, const struct _wsnt__ResumeFailedFaultType_ErrorCode *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__wsnt__ResumeFailedFaultType_ErrorCode(struct soap *soap, const char *tag, int id, const struct _wsnt__ResumeFailedFaultType_ErrorCode *a, const char *type)
{
	soap_set_attr(soap, "dialect", a->dialect ? soap_xsd__anyURI2s(soap, a->dialect) : "", 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__wsnt__ResumeFailedFaultType_ErrorCode), type))
		return soap->error;
	if (soap_outliteral(soap, "-mixed", (char*const*)&a->__mixed, NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _wsnt__ResumeFailedFaultType_ErrorCode * SOAP_FMAC4 soap_in__wsnt__ResumeFailedFaultType_ErrorCode(struct soap *soap, const char *tag, struct _wsnt__ResumeFailedFaultType_ErrorCode *a, const char *type)
{
	size_t soap_flag___mixed = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct _wsnt__ResumeFailedFaultType_ErrorCode*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__wsnt__ResumeFailedFaultType_ErrorCode, sizeof(struct _wsnt__ResumeFailedFaultType_ErrorCode), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__wsnt__ResumeFailedFaultType_ErrorCode(soap, a);
	if (soap_s2xsd__anyURI(soap, soap_attr_value(soap, "dialect", 4, 1), &a->dialect))
		return NULL;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag___mixed && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_inliteral(soap, "-mixed", (char**)&a->__mixed))
				{	soap_flag___mixed--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _wsnt__ResumeFailedFaultType_ErrorCode *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__wsnt__ResumeFailedFaultType_ErrorCode, SOAP_TYPE__wsnt__ResumeFailedFaultType_ErrorCode, sizeof(struct _wsnt__ResumeFailedFaultType_ErrorCode), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _wsnt__ResumeFailedFaultType_ErrorCode * SOAP_FMAC4 soap_new__wsnt__ResumeFailedFaultType_ErrorCode(struct soap *soap, int n)
{
	struct _wsnt__ResumeFailedFaultType_ErrorCode *p;
	struct _wsnt__ResumeFailedFaultType_ErrorCode *a = (struct _wsnt__ResumeFailedFaultType_ErrorCode*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _wsnt__ResumeFailedFaultType_ErrorCode));
	for (p = a; p && n--; p++)
		soap_default__wsnt__ResumeFailedFaultType_ErrorCode(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__wsnt__ResumeFailedFaultType_ErrorCode(struct soap *soap, const struct _wsnt__ResumeFailedFaultType_ErrorCode *a, const char *tag, const char *type)
{
	if (soap_out__wsnt__ResumeFailedFaultType_ErrorCode(soap, tag ? tag : "wsnt:ResumeFailedFaultType-ErrorCode", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _wsnt__ResumeFailedFaultType_ErrorCode * SOAP_FMAC4 soap_get__wsnt__ResumeFailedFaultType_ErrorCode(struct soap *soap, struct _wsnt__ResumeFailedFaultType_ErrorCode *p, const char *tag, const char *type)
{
	if ((p = soap_in__wsnt__ResumeFailedFaultType_ErrorCode(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_wsnt__ResumeFailedFaultType(struct soap *soap, struct wsnt__ResumeFailedFaultType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__size = 0;
	a->__any = NULL;
	soap_default_dateTime(soap, &a->wsrfbf__Timestamp);
	a->wsrfbf__Originator = NULL;
	a->wsrfbf__ErrorCode = NULL;
	a->__sizeDescription = 0;
	a->wsrfbf__Description = NULL;
	a->wsrfbf__FaultCause = NULL;
	a->__anyAttribute = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_wsnt__ResumeFailedFaultType(struct soap *soap, const struct wsnt__ResumeFailedFaultType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &a->wsrfbf__Timestamp, SOAP_TYPE_dateTime);
	soap_serialize_PointerTowsa5__EndpointReferenceType(soap, &a->wsrfbf__Originator);
	soap_serialize_PointerTo_wsnt__ResumeFailedFaultType_ErrorCode(soap, &a->wsrfbf__ErrorCode);
	if (a->wsrfbf__Description)
	{	int i;
		for (i = 0; i < (int)a->__sizeDescription; i++)
		{
			soap_embedded(soap, a->wsrfbf__Description + i, SOAP_TYPE__wsnt__ResumeFailedFaultType_Description);
			soap_serialize__wsnt__ResumeFailedFaultType_Description(soap, a->wsrfbf__Description + i);
		}
	}
	soap_serialize_PointerTo_wsnt__ResumeFailedFaultType_FaultCause(soap, &a->wsrfbf__FaultCause);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_wsnt__ResumeFailedFaultType(struct soap *soap, const char *tag, int id, const struct wsnt__ResumeFailedFaultType *a, const char *type)
{
	if (a->__anyAttribute)
		soap_set_attr(soap, "-anyAttribute", a->__anyAttribute, 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_wsnt__ResumeFailedFaultType), type))
		return soap->error;
	if (a->__any)
	{	int i;
		for (i = 0; i < (int)a->__size; i++)
			if (soap_outliteral(soap, "-any", (char*const*)(a->__any + i), NULL))
				return soap->error;
	}
	if (soap_out_dateTime(soap, "wsrfbf:Timestamp", -1, &a->wsrfbf__Timestamp, ""))
		return soap->error;
	if (soap_out_PointerTowsa5__EndpointReferenceType(soap, "wsrfbf:Originator", -1, &a->wsrfbf__Originator, ""))
		return soap->error;
	if (soap_out_PointerTo_wsnt__ResumeFailedFaultType_ErrorCode(soap, "wsrfbf:ErrorCode", -1, &a->wsrfbf__ErrorCode, ""))
		return soap->error;
	if (a->wsrfbf__Description)
	{	int i;
		for (i = 0; i < (int)a->__sizeDescription; i++)
			if (soap_out__wsnt__ResumeFailedFaultType_Description(soap, "wsrfbf:Description", -1, a->wsrfbf__Description + i, ""))
				return soap->error;
	}
	if (soap_out_PointerTo_wsnt__ResumeFailedFaultType_FaultCause(soap, "wsrfbf:FaultCause", -1, &a->wsrfbf__FaultCause, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct wsnt__ResumeFailedFaultType * SOAP_FMAC4 soap_in_wsnt__ResumeFailedFaultType(struct soap *soap, const char *tag, struct wsnt__ResumeFailedFaultType *a, const char *type)
{
	struct soap_blist *soap_blist___any = NULL;
	size_t soap_flag_wsrfbf__Timestamp = 1;
	size_t soap_flag_wsrfbf__Originator = 1;
	size_t soap_flag_wsrfbf__ErrorCode = 1;
	struct soap_blist *soap_blist_wsrfbf__Description = NULL;
	size_t soap_flag_wsrfbf__FaultCause = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct wsnt__ResumeFailedFaultType*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_wsnt__ResumeFailedFaultType, sizeof(struct wsnt__ResumeFailedFaultType), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_wsnt__ResumeFailedFaultType(soap, a);
	if (soap_s2char(soap, soap_attr_value(soap, "-anyAttribute", 0, 0), &a->__anyAttribute, 0, 0, -1, NULL))
		return NULL;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_wsrfbf__Timestamp && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_dateTime(soap, "wsrfbf:Timestamp", &a->wsrfbf__Timestamp, "xsd:dateTime"))
				{	soap_flag_wsrfbf__Timestamp--;
					continue;
				}
			}
			if (soap_flag_wsrfbf__Originator && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTowsa5__EndpointReferenceType(soap, "wsrfbf:Originator", &a->wsrfbf__Originator, "wsa5:EndpointReferenceType"))
				{	soap_flag_wsrfbf__Originator--;
					continue;
				}
			}
			if (soap_flag_wsrfbf__ErrorCode && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_wsnt__ResumeFailedFaultType_ErrorCode(soap, "wsrfbf:ErrorCode", &a->wsrfbf__ErrorCode, ""))
				{	soap_flag_wsrfbf__ErrorCode--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "wsrfbf:Description", 1, NULL))
			{	if (a->wsrfbf__Description == NULL)
				{	if (soap_blist_wsrfbf__Description == NULL)
						soap_blist_wsrfbf__Description = soap_alloc_block(soap);
					a->wsrfbf__Description = (struct _wsnt__ResumeFailedFaultType_Description *)soap_push_block_max(soap, soap_blist_wsrfbf__Description, sizeof(struct _wsnt__ResumeFailedFaultType_Description));
					if (a->wsrfbf__Description == NULL)
						return NULL;
					soap_default__wsnt__ResumeFailedFaultType_Description(soap, a->wsrfbf__Description);
				}
				soap_revert(soap);
				if (soap_in__wsnt__ResumeFailedFaultType_Description(soap, "wsrfbf:Description", a->wsrfbf__Description, ""))
				{	a->__sizeDescription++;
					a->wsrfbf__Description = NULL;
					continue;
				}
			}
			if (soap_flag_wsrfbf__FaultCause && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_wsnt__ResumeFailedFaultType_FaultCause(soap, "wsrfbf:FaultCause", &a->wsrfbf__FaultCause, ""))
				{	soap_flag_wsrfbf__FaultCause--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	if (a->__any == NULL)
				{	if (soap_blist___any == NULL)
						soap_blist___any = soap_alloc_block(soap);
					a->__any = (char **)soap_push_block_max(soap, soap_blist___any, sizeof(char *));
					if (a->__any == NULL)
						return NULL;
					*a->__any = NULL;
				}
				if (soap_inliteral(soap, "-any", (char**)a->__any))
				{	a->__size++;
					a->__any = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->__any)
			soap_pop_block(soap, soap_blist___any);
		if (a->__size)
		{	a->__any = (char **)soap_save_block(soap, soap_blist___any, NULL, 1);
		}
		else
		{	a->__any = NULL;
			if (soap_blist___any)
				soap_end_block(soap, soap_blist___any);
		}
		if (a->wsrfbf__Description)
			soap_pop_block(soap, soap_blist_wsrfbf__Description);
		if (a->__sizeDescription)
		{	a->wsrfbf__Description = (struct _wsnt__ResumeFailedFaultType_Description *)soap_save_block(soap, soap_blist_wsrfbf__Description, NULL, 1);
		}
		else
		{	a->wsrfbf__Description = NULL;
			if (soap_blist_wsrfbf__Description)
				soap_end_block(soap, soap_blist_wsrfbf__Description);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_wsrfbf__Timestamp > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct wsnt__ResumeFailedFaultType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_wsnt__ResumeFailedFaultType, SOAP_TYPE_wsnt__ResumeFailedFaultType, sizeof(struct wsnt__ResumeFailedFaultType), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct wsnt__ResumeFailedFaultType * SOAP_FMAC4 soap_new_wsnt__ResumeFailedFaultType(struct soap *soap, int n)
{
	struct wsnt__ResumeFailedFaultType *p;
	struct wsnt__ResumeFailedFaultType *a = (struct wsnt__ResumeFailedFaultType*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct wsnt__ResumeFailedFaultType));
	for (p = a; p && n--; p++)
		soap_default_wsnt__ResumeFailedFaultType(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_wsnt__ResumeFailedFaultType(struct soap *soap, const struct wsnt__ResumeFailedFaultType *a, const char *tag, const char *type)
{
	if (soap_out_wsnt__ResumeFailedFaultType(soap, tag ? tag : "wsnt:ResumeFailedFaultType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct wsnt__ResumeFailedFaultType * SOAP_FMAC4 soap_get_wsnt__ResumeFailedFaultType(struct soap *soap, struct wsnt__ResumeFailedFaultType *p, const char *tag, const char *type)
{
	if ((p = soap_in_wsnt__ResumeFailedFaultType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__wsnt__PauseFailedFaultType_FaultCause(struct soap *soap, struct _wsnt__PauseFailedFaultType_FaultCause *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__any = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__wsnt__PauseFailedFaultType_FaultCause(struct soap *soap, const struct _wsnt__PauseFailedFaultType_FaultCause *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__wsnt__PauseFailedFaultType_FaultCause(struct soap *soap, const char *tag, int id, const struct _wsnt__PauseFailedFaultType_FaultCause *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__wsnt__PauseFailedFaultType_FaultCause), type))
		return soap->error;
	if (soap_outliteral(soap, "-any", (char*const*)&a->__any, NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _wsnt__PauseFailedFaultType_FaultCause * SOAP_FMAC4 soap_in__wsnt__PauseFailedFaultType_FaultCause(struct soap *soap, const char *tag, struct _wsnt__PauseFailedFaultType_FaultCause *a, const char *type)
{
	size_t soap_flag___any = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct _wsnt__PauseFailedFaultType_FaultCause*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__wsnt__PauseFailedFaultType_FaultCause, sizeof(struct _wsnt__PauseFailedFaultType_FaultCause), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__wsnt__PauseFailedFaultType_FaultCause(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag___any && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_inliteral(soap, "-any", (char**)&a->__any))
				{	soap_flag___any--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _wsnt__PauseFailedFaultType_FaultCause *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__wsnt__PauseFailedFaultType_FaultCause, SOAP_TYPE__wsnt__PauseFailedFaultType_FaultCause, sizeof(struct _wsnt__PauseFailedFaultType_FaultCause), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _wsnt__PauseFailedFaultType_FaultCause * SOAP_FMAC4 soap_new__wsnt__PauseFailedFaultType_FaultCause(struct soap *soap, int n)
{
	struct _wsnt__PauseFailedFaultType_FaultCause *p;
	struct _wsnt__PauseFailedFaultType_FaultCause *a = (struct _wsnt__PauseFailedFaultType_FaultCause*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _wsnt__PauseFailedFaultType_FaultCause));
	for (p = a; p && n--; p++)
		soap_default__wsnt__PauseFailedFaultType_FaultCause(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__wsnt__PauseFailedFaultType_FaultCause(struct soap *soap, const struct _wsnt__PauseFailedFaultType_FaultCause *a, const char *tag, const char *type)
{
	if (soap_out__wsnt__PauseFailedFaultType_FaultCause(soap, tag ? tag : "wsnt:PauseFailedFaultType-FaultCause", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _wsnt__PauseFailedFaultType_FaultCause * SOAP_FMAC4 soap_get__wsnt__PauseFailedFaultType_FaultCause(struct soap *soap, struct _wsnt__PauseFailedFaultType_FaultCause *p, const char *tag, const char *type)
{
	if ((p = soap_in__wsnt__PauseFailedFaultType_FaultCause(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__wsnt__PauseFailedFaultType_Description(struct soap *soap, struct _wsnt__PauseFailedFaultType_Description *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->__item);
	soap_default__xml__lang(soap, &a->xml__lang);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__wsnt__PauseFailedFaultType_Description(struct soap *soap, const struct _wsnt__PauseFailedFaultType_Description *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_string(soap, (char*const*)&a->__item);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__wsnt__PauseFailedFaultType_Description(struct soap *soap, const char *tag, int id, const struct _wsnt__PauseFailedFaultType_Description *a, const char *type)
{
	if (a->xml__lang)
		soap_set_attr(soap, "xml:lang", soap__xml__lang2s(soap, a->xml__lang), 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	return soap_out_string(soap, tag, id, (char*const*)&a->__item, "");
}

SOAP_FMAC3 struct _wsnt__PauseFailedFaultType_Description * SOAP_FMAC4 soap_in__wsnt__PauseFailedFaultType_Description(struct soap *soap, const char *tag, struct _wsnt__PauseFailedFaultType_Description *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	if (!(a = (struct _wsnt__PauseFailedFaultType_Description *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__wsnt__PauseFailedFaultType_Description, sizeof(struct _wsnt__PauseFailedFaultType_Description), NULL, NULL, NULL, NULL)))
		return NULL;
	soap_revert(soap);
	*soap->id = '\0';
	soap_default__wsnt__PauseFailedFaultType_Description(soap, a);
	if (soap_s2_xml__lang(soap, soap_attr_value(soap, "xml:lang", 1, 0), &a->xml__lang))
		return NULL;
	if (!soap_in_string(soap, tag, (char**)&a->__item, ""))
		return NULL;
	return a;
}

SOAP_FMAC3 struct _wsnt__PauseFailedFaultType_Description * SOAP_FMAC4 soap_new__wsnt__PauseFailedFaultType_Description(struct soap *soap, int n)
{
	struct _wsnt__PauseFailedFaultType_Description *p;
	struct _wsnt__PauseFailedFaultType_Description *a = (struct _wsnt__PauseFailedFaultType_Description*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _wsnt__PauseFailedFaultType_Description));
	for (p = a; p && n--; p++)
		soap_default__wsnt__PauseFailedFaultType_Description(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__wsnt__PauseFailedFaultType_Description(struct soap *soap, const struct _wsnt__PauseFailedFaultType_Description *a, const char *tag, const char *type)
{
	if (soap_out__wsnt__PauseFailedFaultType_Description(soap, tag ? tag : "wsnt:PauseFailedFaultType-Description", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _wsnt__PauseFailedFaultType_Description * SOAP_FMAC4 soap_get__wsnt__PauseFailedFaultType_Description(struct soap *soap, struct _wsnt__PauseFailedFaultType_Description *p, const char *tag, const char *type)
{
	if ((p = soap_in__wsnt__PauseFailedFaultType_Description(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__wsnt__PauseFailedFaultType_ErrorCode(struct soap *soap, struct _wsnt__PauseFailedFaultType_ErrorCode *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_xsd__anyURI(soap, &a->dialect);
	a->__mixed = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__wsnt__PauseFailedFaultType_ErrorCode(struct soap *soap, const struct _wsnt__PauseFailedFaultType_ErrorCode *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__wsnt__PauseFailedFaultType_ErrorCode(struct soap *soap, const char *tag, int id, const struct _wsnt__PauseFailedFaultType_ErrorCode *a, const char *type)
{
	soap_set_attr(soap, "dialect", a->dialect ? soap_xsd__anyURI2s(soap, a->dialect) : "", 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__wsnt__PauseFailedFaultType_ErrorCode), type))
		return soap->error;
	if (soap_outliteral(soap, "-mixed", (char*const*)&a->__mixed, NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _wsnt__PauseFailedFaultType_ErrorCode * SOAP_FMAC4 soap_in__wsnt__PauseFailedFaultType_ErrorCode(struct soap *soap, const char *tag, struct _wsnt__PauseFailedFaultType_ErrorCode *a, const char *type)
{
	size_t soap_flag___mixed = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct _wsnt__PauseFailedFaultType_ErrorCode*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__wsnt__PauseFailedFaultType_ErrorCode, sizeof(struct _wsnt__PauseFailedFaultType_ErrorCode), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__wsnt__PauseFailedFaultType_ErrorCode(soap, a);
	if (soap_s2xsd__anyURI(soap, soap_attr_value(soap, "dialect", 4, 1), &a->dialect))
		return NULL;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag___mixed && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_inliteral(soap, "-mixed", (char**)&a->__mixed))
				{	soap_flag___mixed--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _wsnt__PauseFailedFaultType_ErrorCode *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__wsnt__PauseFailedFaultType_ErrorCode, SOAP_TYPE__wsnt__PauseFailedFaultType_ErrorCode, sizeof(struct _wsnt__PauseFailedFaultType_ErrorCode), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _wsnt__PauseFailedFaultType_ErrorCode * SOAP_FMAC4 soap_new__wsnt__PauseFailedFaultType_ErrorCode(struct soap *soap, int n)
{
	struct _wsnt__PauseFailedFaultType_ErrorCode *p;
	struct _wsnt__PauseFailedFaultType_ErrorCode *a = (struct _wsnt__PauseFailedFaultType_ErrorCode*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _wsnt__PauseFailedFaultType_ErrorCode));
	for (p = a; p && n--; p++)
		soap_default__wsnt__PauseFailedFaultType_ErrorCode(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__wsnt__PauseFailedFaultType_ErrorCode(struct soap *soap, const struct _wsnt__PauseFailedFaultType_ErrorCode *a, const char *tag, const char *type)
{
	if (soap_out__wsnt__PauseFailedFaultType_ErrorCode(soap, tag ? tag : "wsnt:PauseFailedFaultType-ErrorCode", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _wsnt__PauseFailedFaultType_ErrorCode * SOAP_FMAC4 soap_get__wsnt__PauseFailedFaultType_ErrorCode(struct soap *soap, struct _wsnt__PauseFailedFaultType_ErrorCode *p, const char *tag, const char *type)
{
	if ((p = soap_in__wsnt__PauseFailedFaultType_ErrorCode(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_wsnt__PauseFailedFaultType(struct soap *soap, struct wsnt__PauseFailedFaultType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__size = 0;
	a->__any = NULL;
	soap_default_dateTime(soap, &a->wsrfbf__Timestamp);
	a->wsrfbf__Originator = NULL;
	a->wsrfbf__ErrorCode = NULL;
	a->__sizeDescription = 0;
	a->wsrfbf__Description = NULL;
	a->wsrfbf__FaultCause = NULL;
	a->__anyAttribute = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_wsnt__PauseFailedFaultType(struct soap *soap, const struct wsnt__PauseFailedFaultType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &a->wsrfbf__Timestamp, SOAP_TYPE_dateTime);
	soap_serialize_PointerTowsa5__EndpointReferenceType(soap, &a->wsrfbf__Originator);
	soap_serialize_PointerTo_wsnt__PauseFailedFaultType_ErrorCode(soap, &a->wsrfbf__ErrorCode);
	if (a->wsrfbf__Description)
	{	int i;
		for (i = 0; i < (int)a->__sizeDescription; i++)
		{
			soap_embedded(soap, a->wsrfbf__Description + i, SOAP_TYPE__wsnt__PauseFailedFaultType_Description);
			soap_serialize__wsnt__PauseFailedFaultType_Description(soap, a->wsrfbf__Description + i);
		}
	}
	soap_serialize_PointerTo_wsnt__PauseFailedFaultType_FaultCause(soap, &a->wsrfbf__FaultCause);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_wsnt__PauseFailedFaultType(struct soap *soap, const char *tag, int id, const struct wsnt__PauseFailedFaultType *a, const char *type)
{
	if (a->__anyAttribute)
		soap_set_attr(soap, "-anyAttribute", a->__anyAttribute, 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_wsnt__PauseFailedFaultType), type))
		return soap->error;
	if (a->__any)
	{	int i;
		for (i = 0; i < (int)a->__size; i++)
			if (soap_outliteral(soap, "-any", (char*const*)(a->__any + i), NULL))
				return soap->error;
	}
	if (soap_out_dateTime(soap, "wsrfbf:Timestamp", -1, &a->wsrfbf__Timestamp, ""))
		return soap->error;
	if (soap_out_PointerTowsa5__EndpointReferenceType(soap, "wsrfbf:Originator", -1, &a->wsrfbf__Originator, ""))
		return soap->error;
	if (soap_out_PointerTo_wsnt__PauseFailedFaultType_ErrorCode(soap, "wsrfbf:ErrorCode", -1, &a->wsrfbf__ErrorCode, ""))
		return soap->error;
	if (a->wsrfbf__Description)
	{	int i;
		for (i = 0; i < (int)a->__sizeDescription; i++)
			if (soap_out__wsnt__PauseFailedFaultType_Description(soap, "wsrfbf:Description", -1, a->wsrfbf__Description + i, ""))
				return soap->error;
	}
	if (soap_out_PointerTo_wsnt__PauseFailedFaultType_FaultCause(soap, "wsrfbf:FaultCause", -1, &a->wsrfbf__FaultCause, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct wsnt__PauseFailedFaultType * SOAP_FMAC4 soap_in_wsnt__PauseFailedFaultType(struct soap *soap, const char *tag, struct wsnt__PauseFailedFaultType *a, const char *type)
{
	struct soap_blist *soap_blist___any = NULL;
	size_t soap_flag_wsrfbf__Timestamp = 1;
	size_t soap_flag_wsrfbf__Originator = 1;
	size_t soap_flag_wsrfbf__ErrorCode = 1;
	struct soap_blist *soap_blist_wsrfbf__Description = NULL;
	size_t soap_flag_wsrfbf__FaultCause = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct wsnt__PauseFailedFaultType*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_wsnt__PauseFailedFaultType, sizeof(struct wsnt__PauseFailedFaultType), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_wsnt__PauseFailedFaultType(soap, a);
	if (soap_s2char(soap, soap_attr_value(soap, "-anyAttribute", 0, 0), &a->__anyAttribute, 0, 0, -1, NULL))
		return NULL;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_wsrfbf__Timestamp && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_dateTime(soap, "wsrfbf:Timestamp", &a->wsrfbf__Timestamp, "xsd:dateTime"))
				{	soap_flag_wsrfbf__Timestamp--;
					continue;
				}
			}
			if (soap_flag_wsrfbf__Originator && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTowsa5__EndpointReferenceType(soap, "wsrfbf:Originator", &a->wsrfbf__Originator, "wsa5:EndpointReferenceType"))
				{	soap_flag_wsrfbf__Originator--;
					continue;
				}
			}
			if (soap_flag_wsrfbf__ErrorCode && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_wsnt__PauseFailedFaultType_ErrorCode(soap, "wsrfbf:ErrorCode", &a->wsrfbf__ErrorCode, ""))
				{	soap_flag_wsrfbf__ErrorCode--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "wsrfbf:Description", 1, NULL))
			{	if (a->wsrfbf__Description == NULL)
				{	if (soap_blist_wsrfbf__Description == NULL)
						soap_blist_wsrfbf__Description = soap_alloc_block(soap);
					a->wsrfbf__Description = (struct _wsnt__PauseFailedFaultType_Description *)soap_push_block_max(soap, soap_blist_wsrfbf__Description, sizeof(struct _wsnt__PauseFailedFaultType_Description));
					if (a->wsrfbf__Description == NULL)
						return NULL;
					soap_default__wsnt__PauseFailedFaultType_Description(soap, a->wsrfbf__Description);
				}
				soap_revert(soap);
				if (soap_in__wsnt__PauseFailedFaultType_Description(soap, "wsrfbf:Description", a->wsrfbf__Description, ""))
				{	a->__sizeDescription++;
					a->wsrfbf__Description = NULL;
					continue;
				}
			}
			if (soap_flag_wsrfbf__FaultCause && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_wsnt__PauseFailedFaultType_FaultCause(soap, "wsrfbf:FaultCause", &a->wsrfbf__FaultCause, ""))
				{	soap_flag_wsrfbf__FaultCause--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	if (a->__any == NULL)
				{	if (soap_blist___any == NULL)
						soap_blist___any = soap_alloc_block(soap);
					a->__any = (char **)soap_push_block_max(soap, soap_blist___any, sizeof(char *));
					if (a->__any == NULL)
						return NULL;
					*a->__any = NULL;
				}
				if (soap_inliteral(soap, "-any", (char**)a->__any))
				{	a->__size++;
					a->__any = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->__any)
			soap_pop_block(soap, soap_blist___any);
		if (a->__size)
		{	a->__any = (char **)soap_save_block(soap, soap_blist___any, NULL, 1);
		}
		else
		{	a->__any = NULL;
			if (soap_blist___any)
				soap_end_block(soap, soap_blist___any);
		}
		if (a->wsrfbf__Description)
			soap_pop_block(soap, soap_blist_wsrfbf__Description);
		if (a->__sizeDescription)
		{	a->wsrfbf__Description = (struct _wsnt__PauseFailedFaultType_Description *)soap_save_block(soap, soap_blist_wsrfbf__Description, NULL, 1);
		}
		else
		{	a->wsrfbf__Description = NULL;
			if (soap_blist_wsrfbf__Description)
				soap_end_block(soap, soap_blist_wsrfbf__Description);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_wsrfbf__Timestamp > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct wsnt__PauseFailedFaultType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_wsnt__PauseFailedFaultType, SOAP_TYPE_wsnt__PauseFailedFaultType, sizeof(struct wsnt__PauseFailedFaultType), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct wsnt__PauseFailedFaultType * SOAP_FMAC4 soap_new_wsnt__PauseFailedFaultType(struct soap *soap, int n)
{
	struct wsnt__PauseFailedFaultType *p;
	struct wsnt__PauseFailedFaultType *a = (struct wsnt__PauseFailedFaultType*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct wsnt__PauseFailedFaultType));
	for (p = a; p && n--; p++)
		soap_default_wsnt__PauseFailedFaultType(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_wsnt__PauseFailedFaultType(struct soap *soap, const struct wsnt__PauseFailedFaultType *a, const char *tag, const char *type)
{
	if (soap_out_wsnt__PauseFailedFaultType(soap, tag ? tag : "wsnt:PauseFailedFaultType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct wsnt__PauseFailedFaultType * SOAP_FMAC4 soap_get_wsnt__PauseFailedFaultType(struct soap *soap, struct wsnt__PauseFailedFaultType *p, const char *tag, const char *type)
{
	if ((p = soap_in_wsnt__PauseFailedFaultType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__wsnt__UnableToDestroySubscriptionFaultType_FaultCause(struct soap *soap, struct _wsnt__UnableToDestroySubscriptionFaultType_FaultCause *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__any = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__wsnt__UnableToDestroySubscriptionFaultType_FaultCause(struct soap *soap, const struct _wsnt__UnableToDestroySubscriptionFaultType_FaultCause *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__wsnt__UnableToDestroySubscriptionFaultType_FaultCause(struct soap *soap, const char *tag, int id, const struct _wsnt__UnableToDestroySubscriptionFaultType_FaultCause *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__wsnt__UnableToDestroySubscriptionFaultType_FaultCause), type))
		return soap->error;
	if (soap_outliteral(soap, "-any", (char*const*)&a->__any, NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _wsnt__UnableToDestroySubscriptionFaultType_FaultCause * SOAP_FMAC4 soap_in__wsnt__UnableToDestroySubscriptionFaultType_FaultCause(struct soap *soap, const char *tag, struct _wsnt__UnableToDestroySubscriptionFaultType_FaultCause *a, const char *type)
{
	size_t soap_flag___any = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct _wsnt__UnableToDestroySubscriptionFaultType_FaultCause*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__wsnt__UnableToDestroySubscriptionFaultType_FaultCause, sizeof(struct _wsnt__UnableToDestroySubscriptionFaultType_FaultCause), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__wsnt__UnableToDestroySubscriptionFaultType_FaultCause(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag___any && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_inliteral(soap, "-any", (char**)&a->__any))
				{	soap_flag___any--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _wsnt__UnableToDestroySubscriptionFaultType_FaultCause *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__wsnt__UnableToDestroySubscriptionFaultType_FaultCause, SOAP_TYPE__wsnt__UnableToDestroySubscriptionFaultType_FaultCause, sizeof(struct _wsnt__UnableToDestroySubscriptionFaultType_FaultCause), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _wsnt__UnableToDestroySubscriptionFaultType_FaultCause * SOAP_FMAC4 soap_new__wsnt__UnableToDestroySubscriptionFaultType_FaultCause(struct soap *soap, int n)
{
	struct _wsnt__UnableToDestroySubscriptionFaultType_FaultCause *p;
	struct _wsnt__UnableToDestroySubscriptionFaultType_FaultCause *a = (struct _wsnt__UnableToDestroySubscriptionFaultType_FaultCause*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _wsnt__UnableToDestroySubscriptionFaultType_FaultCause));
	for (p = a; p && n--; p++)
		soap_default__wsnt__UnableToDestroySubscriptionFaultType_FaultCause(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__wsnt__UnableToDestroySubscriptionFaultType_FaultCause(struct soap *soap, const struct _wsnt__UnableToDestroySubscriptionFaultType_FaultCause *a, const char *tag, const char *type)
{
	if (soap_out__wsnt__UnableToDestroySubscriptionFaultType_FaultCause(soap, tag ? tag : "wsnt:UnableToDestroySubscriptionFaultType-FaultCause", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _wsnt__UnableToDestroySubscriptionFaultType_FaultCause * SOAP_FMAC4 soap_get__wsnt__UnableToDestroySubscriptionFaultType_FaultCause(struct soap *soap, struct _wsnt__UnableToDestroySubscriptionFaultType_FaultCause *p, const char *tag, const char *type)
{
	if ((p = soap_in__wsnt__UnableToDestroySubscriptionFaultType_FaultCause(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__wsnt__UnableToDestroySubscriptionFaultType_Description(struct soap *soap, struct _wsnt__UnableToDestroySubscriptionFaultType_Description *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->__item);
	soap_default__xml__lang(soap, &a->xml__lang);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__wsnt__UnableToDestroySubscriptionFaultType_Description(struct soap *soap, const struct _wsnt__UnableToDestroySubscriptionFaultType_Description *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_string(soap, (char*const*)&a->__item);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__wsnt__UnableToDestroySubscriptionFaultType_Description(struct soap *soap, const char *tag, int id, const struct _wsnt__UnableToDestroySubscriptionFaultType_Description *a, const char *type)
{
	if (a->xml__lang)
		soap_set_attr(soap, "xml:lang", soap__xml__lang2s(soap, a->xml__lang), 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	return soap_out_string(soap, tag, id, (char*const*)&a->__item, "");
}

SOAP_FMAC3 struct _wsnt__UnableToDestroySubscriptionFaultType_Description * SOAP_FMAC4 soap_in__wsnt__UnableToDestroySubscriptionFaultType_Description(struct soap *soap, const char *tag, struct _wsnt__UnableToDestroySubscriptionFaultType_Description *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	if (!(a = (struct _wsnt__UnableToDestroySubscriptionFaultType_Description *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__wsnt__UnableToDestroySubscriptionFaultType_Description, sizeof(struct _wsnt__UnableToDestroySubscriptionFaultType_Description), NULL, NULL, NULL, NULL)))
		return NULL;
	soap_revert(soap);
	*soap->id = '\0';
	soap_default__wsnt__UnableToDestroySubscriptionFaultType_Description(soap, a);
	if (soap_s2_xml__lang(soap, soap_attr_value(soap, "xml:lang", 1, 0), &a->xml__lang))
		return NULL;
	if (!soap_in_string(soap, tag, (char**)&a->__item, ""))
		return NULL;
	return a;
}

SOAP_FMAC3 struct _wsnt__UnableToDestroySubscriptionFaultType_Description * SOAP_FMAC4 soap_new__wsnt__UnableToDestroySubscriptionFaultType_Description(struct soap *soap, int n)
{
	struct _wsnt__UnableToDestroySubscriptionFaultType_Description *p;
	struct _wsnt__UnableToDestroySubscriptionFaultType_Description *a = (struct _wsnt__UnableToDestroySubscriptionFaultType_Description*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _wsnt__UnableToDestroySubscriptionFaultType_Description));
	for (p = a; p && n--; p++)
		soap_default__wsnt__UnableToDestroySubscriptionFaultType_Description(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__wsnt__UnableToDestroySubscriptionFaultType_Description(struct soap *soap, const struct _wsnt__UnableToDestroySubscriptionFaultType_Description *a, const char *tag, const char *type)
{
	if (soap_out__wsnt__UnableToDestroySubscriptionFaultType_Description(soap, tag ? tag : "wsnt:UnableToDestroySubscriptionFaultType-Description", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _wsnt__UnableToDestroySubscriptionFaultType_Description * SOAP_FMAC4 soap_get__wsnt__UnableToDestroySubscriptionFaultType_Description(struct soap *soap, struct _wsnt__UnableToDestroySubscriptionFaultType_Description *p, const char *tag, const char *type)
{
	if ((p = soap_in__wsnt__UnableToDestroySubscriptionFaultType_Description(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__wsnt__UnableToDestroySubscriptionFaultType_ErrorCode(struct soap *soap, struct _wsnt__UnableToDestroySubscriptionFaultType_ErrorCode *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_xsd__anyURI(soap, &a->dialect);
	a->__mixed = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__wsnt__UnableToDestroySubscriptionFaultType_ErrorCode(struct soap *soap, const struct _wsnt__UnableToDestroySubscriptionFaultType_ErrorCode *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__wsnt__UnableToDestroySubscriptionFaultType_ErrorCode(struct soap *soap, const char *tag, int id, const struct _wsnt__UnableToDestroySubscriptionFaultType_ErrorCode *a, const char *type)
{
	soap_set_attr(soap, "dialect", a->dialect ? soap_xsd__anyURI2s(soap, a->dialect) : "", 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__wsnt__UnableToDestroySubscriptionFaultType_ErrorCode), type))
		return soap->error;
	if (soap_outliteral(soap, "-mixed", (char*const*)&a->__mixed, NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _wsnt__UnableToDestroySubscriptionFaultType_ErrorCode * SOAP_FMAC4 soap_in__wsnt__UnableToDestroySubscriptionFaultType_ErrorCode(struct soap *soap, const char *tag, struct _wsnt__UnableToDestroySubscriptionFaultType_ErrorCode *a, const char *type)
{
	size_t soap_flag___mixed = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct _wsnt__UnableToDestroySubscriptionFaultType_ErrorCode*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__wsnt__UnableToDestroySubscriptionFaultType_ErrorCode, sizeof(struct _wsnt__UnableToDestroySubscriptionFaultType_ErrorCode), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__wsnt__UnableToDestroySubscriptionFaultType_ErrorCode(soap, a);
	if (soap_s2xsd__anyURI(soap, soap_attr_value(soap, "dialect", 4, 1), &a->dialect))
		return NULL;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag___mixed && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_inliteral(soap, "-mixed", (char**)&a->__mixed))
				{	soap_flag___mixed--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _wsnt__UnableToDestroySubscriptionFaultType_ErrorCode *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__wsnt__UnableToDestroySubscriptionFaultType_ErrorCode, SOAP_TYPE__wsnt__UnableToDestroySubscriptionFaultType_ErrorCode, sizeof(struct _wsnt__UnableToDestroySubscriptionFaultType_ErrorCode), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _wsnt__UnableToDestroySubscriptionFaultType_ErrorCode * SOAP_FMAC4 soap_new__wsnt__UnableToDestroySubscriptionFaultType_ErrorCode(struct soap *soap, int n)
{
	struct _wsnt__UnableToDestroySubscriptionFaultType_ErrorCode *p;
	struct _wsnt__UnableToDestroySubscriptionFaultType_ErrorCode *a = (struct _wsnt__UnableToDestroySubscriptionFaultType_ErrorCode*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _wsnt__UnableToDestroySubscriptionFaultType_ErrorCode));
	for (p = a; p && n--; p++)
		soap_default__wsnt__UnableToDestroySubscriptionFaultType_ErrorCode(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__wsnt__UnableToDestroySubscriptionFaultType_ErrorCode(struct soap *soap, const struct _wsnt__UnableToDestroySubscriptionFaultType_ErrorCode *a, const char *tag, const char *type)
{
	if (soap_out__wsnt__UnableToDestroySubscriptionFaultType_ErrorCode(soap, tag ? tag : "wsnt:UnableToDestroySubscriptionFaultType-ErrorCode", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _wsnt__UnableToDestroySubscriptionFaultType_ErrorCode * SOAP_FMAC4 soap_get__wsnt__UnableToDestroySubscriptionFaultType_ErrorCode(struct soap *soap, struct _wsnt__UnableToDestroySubscriptionFaultType_ErrorCode *p, const char *tag, const char *type)
{
	if ((p = soap_in__wsnt__UnableToDestroySubscriptionFaultType_ErrorCode(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_wsnt__UnableToDestroySubscriptionFaultType(struct soap *soap, struct wsnt__UnableToDestroySubscriptionFaultType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__size = 0;
	a->__any = NULL;
	soap_default_dateTime(soap, &a->wsrfbf__Timestamp);
	a->wsrfbf__Originator = NULL;
	a->wsrfbf__ErrorCode = NULL;
	a->__sizeDescription = 0;
	a->wsrfbf__Description = NULL;
	a->wsrfbf__FaultCause = NULL;
	a->__anyAttribute = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_wsnt__UnableToDestroySubscriptionFaultType(struct soap *soap, const struct wsnt__UnableToDestroySubscriptionFaultType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &a->wsrfbf__Timestamp, SOAP_TYPE_dateTime);
	soap_serialize_PointerTowsa5__EndpointReferenceType(soap, &a->wsrfbf__Originator);
	soap_serialize_PointerTo_wsnt__UnableToDestroySubscriptionFaultType_ErrorCode(soap, &a->wsrfbf__ErrorCode);
	if (a->wsrfbf__Description)
	{	int i;
		for (i = 0; i < (int)a->__sizeDescription; i++)
		{
			soap_embedded(soap, a->wsrfbf__Description + i, SOAP_TYPE__wsnt__UnableToDestroySubscriptionFaultType_Description);
			soap_serialize__wsnt__UnableToDestroySubscriptionFaultType_Description(soap, a->wsrfbf__Description + i);
		}
	}
	soap_serialize_PointerTo_wsnt__UnableToDestroySubscriptionFaultType_FaultCause(soap, &a->wsrfbf__FaultCause);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_wsnt__UnableToDestroySubscriptionFaultType(struct soap *soap, const char *tag, int id, const struct wsnt__UnableToDestroySubscriptionFaultType *a, const char *type)
{
	if (a->__anyAttribute)
		soap_set_attr(soap, "-anyAttribute", a->__anyAttribute, 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_wsnt__UnableToDestroySubscriptionFaultType), type))
		return soap->error;
	if (a->__any)
	{	int i;
		for (i = 0; i < (int)a->__size; i++)
			if (soap_outliteral(soap, "-any", (char*const*)(a->__any + i), NULL))
				return soap->error;
	}
	if (soap_out_dateTime(soap, "wsrfbf:Timestamp", -1, &a->wsrfbf__Timestamp, ""))
		return soap->error;
	if (soap_out_PointerTowsa5__EndpointReferenceType(soap, "wsrfbf:Originator", -1, &a->wsrfbf__Originator, ""))
		return soap->error;
	if (soap_out_PointerTo_wsnt__UnableToDestroySubscriptionFaultType_ErrorCode(soap, "wsrfbf:ErrorCode", -1, &a->wsrfbf__ErrorCode, ""))
		return soap->error;
	if (a->wsrfbf__Description)
	{	int i;
		for (i = 0; i < (int)a->__sizeDescription; i++)
			if (soap_out__wsnt__UnableToDestroySubscriptionFaultType_Description(soap, "wsrfbf:Description", -1, a->wsrfbf__Description + i, ""))
				return soap->error;
	}
	if (soap_out_PointerTo_wsnt__UnableToDestroySubscriptionFaultType_FaultCause(soap, "wsrfbf:FaultCause", -1, &a->wsrfbf__FaultCause, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct wsnt__UnableToDestroySubscriptionFaultType * SOAP_FMAC4 soap_in_wsnt__UnableToDestroySubscriptionFaultType(struct soap *soap, const char *tag, struct wsnt__UnableToDestroySubscriptionFaultType *a, const char *type)
{
	struct soap_blist *soap_blist___any = NULL;
	size_t soap_flag_wsrfbf__Timestamp = 1;
	size_t soap_flag_wsrfbf__Originator = 1;
	size_t soap_flag_wsrfbf__ErrorCode = 1;
	struct soap_blist *soap_blist_wsrfbf__Description = NULL;
	size_t soap_flag_wsrfbf__FaultCause = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct wsnt__UnableToDestroySubscriptionFaultType*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_wsnt__UnableToDestroySubscriptionFaultType, sizeof(struct wsnt__UnableToDestroySubscriptionFaultType), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_wsnt__UnableToDestroySubscriptionFaultType(soap, a);
	if (soap_s2char(soap, soap_attr_value(soap, "-anyAttribute", 0, 0), &a->__anyAttribute, 0, 0, -1, NULL))
		return NULL;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_wsrfbf__Timestamp && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_dateTime(soap, "wsrfbf:Timestamp", &a->wsrfbf__Timestamp, "xsd:dateTime"))
				{	soap_flag_wsrfbf__Timestamp--;
					continue;
				}
			}
			if (soap_flag_wsrfbf__Originator && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTowsa5__EndpointReferenceType(soap, "wsrfbf:Originator", &a->wsrfbf__Originator, "wsa5:EndpointReferenceType"))
				{	soap_flag_wsrfbf__Originator--;
					continue;
				}
			}
			if (soap_flag_wsrfbf__ErrorCode && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_wsnt__UnableToDestroySubscriptionFaultType_ErrorCode(soap, "wsrfbf:ErrorCode", &a->wsrfbf__ErrorCode, ""))
				{	soap_flag_wsrfbf__ErrorCode--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "wsrfbf:Description", 1, NULL))
			{	if (a->wsrfbf__Description == NULL)
				{	if (soap_blist_wsrfbf__Description == NULL)
						soap_blist_wsrfbf__Description = soap_alloc_block(soap);
					a->wsrfbf__Description = (struct _wsnt__UnableToDestroySubscriptionFaultType_Description *)soap_push_block_max(soap, soap_blist_wsrfbf__Description, sizeof(struct _wsnt__UnableToDestroySubscriptionFaultType_Description));
					if (a->wsrfbf__Description == NULL)
						return NULL;
					soap_default__wsnt__UnableToDestroySubscriptionFaultType_Description(soap, a->wsrfbf__Description);
				}
				soap_revert(soap);
				if (soap_in__wsnt__UnableToDestroySubscriptionFaultType_Description(soap, "wsrfbf:Description", a->wsrfbf__Description, ""))
				{	a->__sizeDescription++;
					a->wsrfbf__Description = NULL;
					continue;
				}
			}
			if (soap_flag_wsrfbf__FaultCause && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_wsnt__UnableToDestroySubscriptionFaultType_FaultCause(soap, "wsrfbf:FaultCause", &a->wsrfbf__FaultCause, ""))
				{	soap_flag_wsrfbf__FaultCause--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	if (a->__any == NULL)
				{	if (soap_blist___any == NULL)
						soap_blist___any = soap_alloc_block(soap);
					a->__any = (char **)soap_push_block_max(soap, soap_blist___any, sizeof(char *));
					if (a->__any == NULL)
						return NULL;
					*a->__any = NULL;
				}
				if (soap_inliteral(soap, "-any", (char**)a->__any))
				{	a->__size++;
					a->__any = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->__any)
			soap_pop_block(soap, soap_blist___any);
		if (a->__size)
		{	a->__any = (char **)soap_save_block(soap, soap_blist___any, NULL, 1);
		}
		else
		{	a->__any = NULL;
			if (soap_blist___any)
				soap_end_block(soap, soap_blist___any);
		}
		if (a->wsrfbf__Description)
			soap_pop_block(soap, soap_blist_wsrfbf__Description);
		if (a->__sizeDescription)
		{	a->wsrfbf__Description = (struct _wsnt__UnableToDestroySubscriptionFaultType_Description *)soap_save_block(soap, soap_blist_wsrfbf__Description, NULL, 1);
		}
		else
		{	a->wsrfbf__Description = NULL;
			if (soap_blist_wsrfbf__Description)
				soap_end_block(soap, soap_blist_wsrfbf__Description);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_wsrfbf__Timestamp > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct wsnt__UnableToDestroySubscriptionFaultType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_wsnt__UnableToDestroySubscriptionFaultType, SOAP_TYPE_wsnt__UnableToDestroySubscriptionFaultType, sizeof(struct wsnt__UnableToDestroySubscriptionFaultType), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct wsnt__UnableToDestroySubscriptionFaultType * SOAP_FMAC4 soap_new_wsnt__UnableToDestroySubscriptionFaultType(struct soap *soap, int n)
{
	struct wsnt__UnableToDestroySubscriptionFaultType *p;
	struct wsnt__UnableToDestroySubscriptionFaultType *a = (struct wsnt__UnableToDestroySubscriptionFaultType*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct wsnt__UnableToDestroySubscriptionFaultType));
	for (p = a; p && n--; p++)
		soap_default_wsnt__UnableToDestroySubscriptionFaultType(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_wsnt__UnableToDestroySubscriptionFaultType(struct soap *soap, const struct wsnt__UnableToDestroySubscriptionFaultType *a, const char *tag, const char *type)
{
	if (soap_out_wsnt__UnableToDestroySubscriptionFaultType(soap, tag ? tag : "wsnt:UnableToDestroySubscriptionFaultType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct wsnt__UnableToDestroySubscriptionFaultType * SOAP_FMAC4 soap_get_wsnt__UnableToDestroySubscriptionFaultType(struct soap *soap, struct wsnt__UnableToDestroySubscriptionFaultType *p, const char *tag, const char *type)
{
	if ((p = soap_in_wsnt__UnableToDestroySubscriptionFaultType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__wsnt__UnacceptableTerminationTimeFaultType_FaultCause(struct soap *soap, struct _wsnt__UnacceptableTerminationTimeFaultType_FaultCause *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__any = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__wsnt__UnacceptableTerminationTimeFaultType_FaultCause(struct soap *soap, const struct _wsnt__UnacceptableTerminationTimeFaultType_FaultCause *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__wsnt__UnacceptableTerminationTimeFaultType_FaultCause(struct soap *soap, const char *tag, int id, const struct _wsnt__UnacceptableTerminationTimeFaultType_FaultCause *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__wsnt__UnacceptableTerminationTimeFaultType_FaultCause), type))
		return soap->error;
	if (soap_outliteral(soap, "-any", (char*const*)&a->__any, NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _wsnt__UnacceptableTerminationTimeFaultType_FaultCause * SOAP_FMAC4 soap_in__wsnt__UnacceptableTerminationTimeFaultType_FaultCause(struct soap *soap, const char *tag, struct _wsnt__UnacceptableTerminationTimeFaultType_FaultCause *a, const char *type)
{
	size_t soap_flag___any = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct _wsnt__UnacceptableTerminationTimeFaultType_FaultCause*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__wsnt__UnacceptableTerminationTimeFaultType_FaultCause, sizeof(struct _wsnt__UnacceptableTerminationTimeFaultType_FaultCause), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__wsnt__UnacceptableTerminationTimeFaultType_FaultCause(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag___any && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_inliteral(soap, "-any", (char**)&a->__any))
				{	soap_flag___any--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _wsnt__UnacceptableTerminationTimeFaultType_FaultCause *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__wsnt__UnacceptableTerminationTimeFaultType_FaultCause, SOAP_TYPE__wsnt__UnacceptableTerminationTimeFaultType_FaultCause, sizeof(struct _wsnt__UnacceptableTerminationTimeFaultType_FaultCause), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _wsnt__UnacceptableTerminationTimeFaultType_FaultCause * SOAP_FMAC4 soap_new__wsnt__UnacceptableTerminationTimeFaultType_FaultCause(struct soap *soap, int n)
{
	struct _wsnt__UnacceptableTerminationTimeFaultType_FaultCause *p;
	struct _wsnt__UnacceptableTerminationTimeFaultType_FaultCause *a = (struct _wsnt__UnacceptableTerminationTimeFaultType_FaultCause*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _wsnt__UnacceptableTerminationTimeFaultType_FaultCause));
	for (p = a; p && n--; p++)
		soap_default__wsnt__UnacceptableTerminationTimeFaultType_FaultCause(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__wsnt__UnacceptableTerminationTimeFaultType_FaultCause(struct soap *soap, const struct _wsnt__UnacceptableTerminationTimeFaultType_FaultCause *a, const char *tag, const char *type)
{
	if (soap_out__wsnt__UnacceptableTerminationTimeFaultType_FaultCause(soap, tag ? tag : "wsnt:UnacceptableTerminationTimeFaultType-FaultCause", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _wsnt__UnacceptableTerminationTimeFaultType_FaultCause * SOAP_FMAC4 soap_get__wsnt__UnacceptableTerminationTimeFaultType_FaultCause(struct soap *soap, struct _wsnt__UnacceptableTerminationTimeFaultType_FaultCause *p, const char *tag, const char *type)
{
	if ((p = soap_in__wsnt__UnacceptableTerminationTimeFaultType_FaultCause(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__wsnt__UnacceptableTerminationTimeFaultType_Description(struct soap *soap, struct _wsnt__UnacceptableTerminationTimeFaultType_Description *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->__item);
	soap_default__xml__lang(soap, &a->xml__lang);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__wsnt__UnacceptableTerminationTimeFaultType_Description(struct soap *soap, const struct _wsnt__UnacceptableTerminationTimeFaultType_Description *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_string(soap, (char*const*)&a->__item);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__wsnt__UnacceptableTerminationTimeFaultType_Description(struct soap *soap, const char *tag, int id, const struct _wsnt__UnacceptableTerminationTimeFaultType_Description *a, const char *type)
{
	if (a->xml__lang)
		soap_set_attr(soap, "xml:lang", soap__xml__lang2s(soap, a->xml__lang), 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	return soap_out_string(soap, tag, id, (char*const*)&a->__item, "");
}

SOAP_FMAC3 struct _wsnt__UnacceptableTerminationTimeFaultType_Description * SOAP_FMAC4 soap_in__wsnt__UnacceptableTerminationTimeFaultType_Description(struct soap *soap, const char *tag, struct _wsnt__UnacceptableTerminationTimeFaultType_Description *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	if (!(a = (struct _wsnt__UnacceptableTerminationTimeFaultType_Description *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__wsnt__UnacceptableTerminationTimeFaultType_Description, sizeof(struct _wsnt__UnacceptableTerminationTimeFaultType_Description), NULL, NULL, NULL, NULL)))
		return NULL;
	soap_revert(soap);
	*soap->id = '\0';
	soap_default__wsnt__UnacceptableTerminationTimeFaultType_Description(soap, a);
	if (soap_s2_xml__lang(soap, soap_attr_value(soap, "xml:lang", 1, 0), &a->xml__lang))
		return NULL;
	if (!soap_in_string(soap, tag, (char**)&a->__item, ""))
		return NULL;
	return a;
}

SOAP_FMAC3 struct _wsnt__UnacceptableTerminationTimeFaultType_Description * SOAP_FMAC4 soap_new__wsnt__UnacceptableTerminationTimeFaultType_Description(struct soap *soap, int n)
{
	struct _wsnt__UnacceptableTerminationTimeFaultType_Description *p;
	struct _wsnt__UnacceptableTerminationTimeFaultType_Description *a = (struct _wsnt__UnacceptableTerminationTimeFaultType_Description*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _wsnt__UnacceptableTerminationTimeFaultType_Description));
	for (p = a; p && n--; p++)
		soap_default__wsnt__UnacceptableTerminationTimeFaultType_Description(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__wsnt__UnacceptableTerminationTimeFaultType_Description(struct soap *soap, const struct _wsnt__UnacceptableTerminationTimeFaultType_Description *a, const char *tag, const char *type)
{
	if (soap_out__wsnt__UnacceptableTerminationTimeFaultType_Description(soap, tag ? tag : "wsnt:UnacceptableTerminationTimeFaultType-Description", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _wsnt__UnacceptableTerminationTimeFaultType_Description * SOAP_FMAC4 soap_get__wsnt__UnacceptableTerminationTimeFaultType_Description(struct soap *soap, struct _wsnt__UnacceptableTerminationTimeFaultType_Description *p, const char *tag, const char *type)
{
	if ((p = soap_in__wsnt__UnacceptableTerminationTimeFaultType_Description(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__wsnt__UnacceptableTerminationTimeFaultType_ErrorCode(struct soap *soap, struct _wsnt__UnacceptableTerminationTimeFaultType_ErrorCode *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_xsd__anyURI(soap, &a->dialect);
	a->__mixed = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__wsnt__UnacceptableTerminationTimeFaultType_ErrorCode(struct soap *soap, const struct _wsnt__UnacceptableTerminationTimeFaultType_ErrorCode *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__wsnt__UnacceptableTerminationTimeFaultType_ErrorCode(struct soap *soap, const char *tag, int id, const struct _wsnt__UnacceptableTerminationTimeFaultType_ErrorCode *a, const char *type)
{
	soap_set_attr(soap, "dialect", a->dialect ? soap_xsd__anyURI2s(soap, a->dialect) : "", 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__wsnt__UnacceptableTerminationTimeFaultType_ErrorCode), type))
		return soap->error;
	if (soap_outliteral(soap, "-mixed", (char*const*)&a->__mixed, NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _wsnt__UnacceptableTerminationTimeFaultType_ErrorCode * SOAP_FMAC4 soap_in__wsnt__UnacceptableTerminationTimeFaultType_ErrorCode(struct soap *soap, const char *tag, struct _wsnt__UnacceptableTerminationTimeFaultType_ErrorCode *a, const char *type)
{
	size_t soap_flag___mixed = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct _wsnt__UnacceptableTerminationTimeFaultType_ErrorCode*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__wsnt__UnacceptableTerminationTimeFaultType_ErrorCode, sizeof(struct _wsnt__UnacceptableTerminationTimeFaultType_ErrorCode), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__wsnt__UnacceptableTerminationTimeFaultType_ErrorCode(soap, a);
	if (soap_s2xsd__anyURI(soap, soap_attr_value(soap, "dialect", 4, 1), &a->dialect))
		return NULL;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag___mixed && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_inliteral(soap, "-mixed", (char**)&a->__mixed))
				{	soap_flag___mixed--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _wsnt__UnacceptableTerminationTimeFaultType_ErrorCode *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__wsnt__UnacceptableTerminationTimeFaultType_ErrorCode, SOAP_TYPE__wsnt__UnacceptableTerminationTimeFaultType_ErrorCode, sizeof(struct _wsnt__UnacceptableTerminationTimeFaultType_ErrorCode), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _wsnt__UnacceptableTerminationTimeFaultType_ErrorCode * SOAP_FMAC4 soap_new__wsnt__UnacceptableTerminationTimeFaultType_ErrorCode(struct soap *soap, int n)
{
	struct _wsnt__UnacceptableTerminationTimeFaultType_ErrorCode *p;
	struct _wsnt__UnacceptableTerminationTimeFaultType_ErrorCode *a = (struct _wsnt__UnacceptableTerminationTimeFaultType_ErrorCode*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _wsnt__UnacceptableTerminationTimeFaultType_ErrorCode));
	for (p = a; p && n--; p++)
		soap_default__wsnt__UnacceptableTerminationTimeFaultType_ErrorCode(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__wsnt__UnacceptableTerminationTimeFaultType_ErrorCode(struct soap *soap, const struct _wsnt__UnacceptableTerminationTimeFaultType_ErrorCode *a, const char *tag, const char *type)
{
	if (soap_out__wsnt__UnacceptableTerminationTimeFaultType_ErrorCode(soap, tag ? tag : "wsnt:UnacceptableTerminationTimeFaultType-ErrorCode", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _wsnt__UnacceptableTerminationTimeFaultType_ErrorCode * SOAP_FMAC4 soap_get__wsnt__UnacceptableTerminationTimeFaultType_ErrorCode(struct soap *soap, struct _wsnt__UnacceptableTerminationTimeFaultType_ErrorCode *p, const char *tag, const char *type)
{
	if ((p = soap_in__wsnt__UnacceptableTerminationTimeFaultType_ErrorCode(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_wsnt__UnacceptableTerminationTimeFaultType(struct soap *soap, struct wsnt__UnacceptableTerminationTimeFaultType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__size = 0;
	a->__any = NULL;
	soap_default_dateTime(soap, &a->wsrfbf__Timestamp);
	a->wsrfbf__Originator = NULL;
	a->wsrfbf__ErrorCode = NULL;
	a->__sizeDescription = 0;
	a->wsrfbf__Description = NULL;
	a->wsrfbf__FaultCause = NULL;
	a->__anyAttribute = NULL;
	soap_default_dateTime(soap, &a->MinimumTime);
	a->MaximumTime = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_wsnt__UnacceptableTerminationTimeFaultType(struct soap *soap, const struct wsnt__UnacceptableTerminationTimeFaultType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &a->wsrfbf__Timestamp, SOAP_TYPE_dateTime);
	soap_serialize_PointerTowsa5__EndpointReferenceType(soap, &a->wsrfbf__Originator);
	soap_serialize_PointerTo_wsnt__UnacceptableTerminationTimeFaultType_ErrorCode(soap, &a->wsrfbf__ErrorCode);
	if (a->wsrfbf__Description)
	{	int i;
		for (i = 0; i < (int)a->__sizeDescription; i++)
		{
			soap_embedded(soap, a->wsrfbf__Description + i, SOAP_TYPE__wsnt__UnacceptableTerminationTimeFaultType_Description);
			soap_serialize__wsnt__UnacceptableTerminationTimeFaultType_Description(soap, a->wsrfbf__Description + i);
		}
	}
	soap_serialize_PointerTo_wsnt__UnacceptableTerminationTimeFaultType_FaultCause(soap, &a->wsrfbf__FaultCause);
	soap_embedded(soap, &a->MinimumTime, SOAP_TYPE_dateTime);
	soap_serialize_PointerTodateTime(soap, &a->MaximumTime);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_wsnt__UnacceptableTerminationTimeFaultType(struct soap *soap, const char *tag, int id, const struct wsnt__UnacceptableTerminationTimeFaultType *a, const char *type)
{
	if (a->__anyAttribute)
		soap_set_attr(soap, "-anyAttribute", a->__anyAttribute, 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_wsnt__UnacceptableTerminationTimeFaultType), type))
		return soap->error;
	if (a->__any)
	{	int i;
		for (i = 0; i < (int)a->__size; i++)
			if (soap_outliteral(soap, "-any", (char*const*)(a->__any + i), NULL))
				return soap->error;
	}
	if (soap_out_dateTime(soap, "wsrfbf:Timestamp", -1, &a->wsrfbf__Timestamp, ""))
		return soap->error;
	if (soap_out_PointerTowsa5__EndpointReferenceType(soap, "wsrfbf:Originator", -1, &a->wsrfbf__Originator, ""))
		return soap->error;
	if (soap_out_PointerTo_wsnt__UnacceptableTerminationTimeFaultType_ErrorCode(soap, "wsrfbf:ErrorCode", -1, &a->wsrfbf__ErrorCode, ""))
		return soap->error;
	if (a->wsrfbf__Description)
	{	int i;
		for (i = 0; i < (int)a->__sizeDescription; i++)
			if (soap_out__wsnt__UnacceptableTerminationTimeFaultType_Description(soap, "wsrfbf:Description", -1, a->wsrfbf__Description + i, ""))
				return soap->error;
	}
	if (soap_out_PointerTo_wsnt__UnacceptableTerminationTimeFaultType_FaultCause(soap, "wsrfbf:FaultCause", -1, &a->wsrfbf__FaultCause, ""))
		return soap->error;
	if (soap_out_dateTime(soap, "wsnt:MinimumTime", -1, &a->MinimumTime, ""))
		return soap->error;
	if (soap_out_PointerTodateTime(soap, "wsnt:MaximumTime", -1, &a->MaximumTime, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct wsnt__UnacceptableTerminationTimeFaultType * SOAP_FMAC4 soap_in_wsnt__UnacceptableTerminationTimeFaultType(struct soap *soap, const char *tag, struct wsnt__UnacceptableTerminationTimeFaultType *a, const char *type)
{
	struct soap_blist *soap_blist___any = NULL;
	size_t soap_flag_wsrfbf__Timestamp = 1;
	size_t soap_flag_wsrfbf__Originator = 1;
	size_t soap_flag_wsrfbf__ErrorCode = 1;
	struct soap_blist *soap_blist_wsrfbf__Description = NULL;
	size_t soap_flag_wsrfbf__FaultCause = 1;
	size_t soap_flag_MinimumTime = 1;
	size_t soap_flag_MaximumTime = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct wsnt__UnacceptableTerminationTimeFaultType*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_wsnt__UnacceptableTerminationTimeFaultType, sizeof(struct wsnt__UnacceptableTerminationTimeFaultType), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_wsnt__UnacceptableTerminationTimeFaultType(soap, a);
	if (soap_s2char(soap, soap_attr_value(soap, "-anyAttribute", 0, 0), &a->__anyAttribute, 0, 0, -1, NULL))
		return NULL;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_wsrfbf__Timestamp && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_dateTime(soap, "wsrfbf:Timestamp", &a->wsrfbf__Timestamp, "xsd:dateTime"))
				{	soap_flag_wsrfbf__Timestamp--;
					continue;
				}
			}
			if (soap_flag_wsrfbf__Originator && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTowsa5__EndpointReferenceType(soap, "wsrfbf:Originator", &a->wsrfbf__Originator, "wsa5:EndpointReferenceType"))
				{	soap_flag_wsrfbf__Originator--;
					continue;
				}
			}
			if (soap_flag_wsrfbf__ErrorCode && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_wsnt__UnacceptableTerminationTimeFaultType_ErrorCode(soap, "wsrfbf:ErrorCode", &a->wsrfbf__ErrorCode, ""))
				{	soap_flag_wsrfbf__ErrorCode--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "wsrfbf:Description", 1, NULL))
			{	if (a->wsrfbf__Description == NULL)
				{	if (soap_blist_wsrfbf__Description == NULL)
						soap_blist_wsrfbf__Description = soap_alloc_block(soap);
					a->wsrfbf__Description = (struct _wsnt__UnacceptableTerminationTimeFaultType_Description *)soap_push_block_max(soap, soap_blist_wsrfbf__Description, sizeof(struct _wsnt__UnacceptableTerminationTimeFaultType_Description));
					if (a->wsrfbf__Description == NULL)
						return NULL;
					soap_default__wsnt__UnacceptableTerminationTimeFaultType_Description(soap, a->wsrfbf__Description);
				}
				soap_revert(soap);
				if (soap_in__wsnt__UnacceptableTerminationTimeFaultType_Description(soap, "wsrfbf:Description", a->wsrfbf__Description, ""))
				{	a->__sizeDescription++;
					a->wsrfbf__Description = NULL;
					continue;
				}
			}
			if (soap_flag_wsrfbf__FaultCause && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_wsnt__UnacceptableTerminationTimeFaultType_FaultCause(soap, "wsrfbf:FaultCause", &a->wsrfbf__FaultCause, ""))
				{	soap_flag_wsrfbf__FaultCause--;
					continue;
				}
			}
			if (soap_flag_MinimumTime && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_dateTime(soap, "wsnt:MinimumTime", &a->MinimumTime, "xsd:dateTime"))
				{	soap_flag_MinimumTime--;
					continue;
				}
			}
			if (soap_flag_MaximumTime && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTodateTime(soap, "wsnt:MaximumTime", &a->MaximumTime, "xsd:dateTime"))
				{	soap_flag_MaximumTime--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	if (a->__any == NULL)
				{	if (soap_blist___any == NULL)
						soap_blist___any = soap_alloc_block(soap);
					a->__any = (char **)soap_push_block_max(soap, soap_blist___any, sizeof(char *));
					if (a->__any == NULL)
						return NULL;
					*a->__any = NULL;
				}
				if (soap_inliteral(soap, "-any", (char**)a->__any))
				{	a->__size++;
					a->__any = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->__any)
			soap_pop_block(soap, soap_blist___any);
		if (a->__size)
		{	a->__any = (char **)soap_save_block(soap, soap_blist___any, NULL, 1);
		}
		else
		{	a->__any = NULL;
			if (soap_blist___any)
				soap_end_block(soap, soap_blist___any);
		}
		if (a->wsrfbf__Description)
			soap_pop_block(soap, soap_blist_wsrfbf__Description);
		if (a->__sizeDescription)
		{	a->wsrfbf__Description = (struct _wsnt__UnacceptableTerminationTimeFaultType_Description *)soap_save_block(soap, soap_blist_wsrfbf__Description, NULL, 1);
		}
		else
		{	a->wsrfbf__Description = NULL;
			if (soap_blist_wsrfbf__Description)
				soap_end_block(soap, soap_blist_wsrfbf__Description);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_wsrfbf__Timestamp > 0 || soap_flag_MinimumTime > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct wsnt__UnacceptableTerminationTimeFaultType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_wsnt__UnacceptableTerminationTimeFaultType, SOAP_TYPE_wsnt__UnacceptableTerminationTimeFaultType, sizeof(struct wsnt__UnacceptableTerminationTimeFaultType), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct wsnt__UnacceptableTerminationTimeFaultType * SOAP_FMAC4 soap_new_wsnt__UnacceptableTerminationTimeFaultType(struct soap *soap, int n)
{
	struct wsnt__UnacceptableTerminationTimeFaultType *p;
	struct wsnt__UnacceptableTerminationTimeFaultType *a = (struct wsnt__UnacceptableTerminationTimeFaultType*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct wsnt__UnacceptableTerminationTimeFaultType));
	for (p = a; p && n--; p++)
		soap_default_wsnt__UnacceptableTerminationTimeFaultType(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_wsnt__UnacceptableTerminationTimeFaultType(struct soap *soap, const struct wsnt__UnacceptableTerminationTimeFaultType *a, const char *tag, const char *type)
{
	if (soap_out_wsnt__UnacceptableTerminationTimeFaultType(soap, tag ? tag : "wsnt:UnacceptableTerminationTimeFaultType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct wsnt__UnacceptableTerminationTimeFaultType * SOAP_FMAC4 soap_get_wsnt__UnacceptableTerminationTimeFaultType(struct soap *soap, struct wsnt__UnacceptableTerminationTimeFaultType *p, const char *tag, const char *type)
{
	if ((p = soap_in_wsnt__UnacceptableTerminationTimeFaultType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__wsnt__UnableToCreatePullPointFaultType_FaultCause(struct soap *soap, struct _wsnt__UnableToCreatePullPointFaultType_FaultCause *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__any = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__wsnt__UnableToCreatePullPointFaultType_FaultCause(struct soap *soap, const struct _wsnt__UnableToCreatePullPointFaultType_FaultCause *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__wsnt__UnableToCreatePullPointFaultType_FaultCause(struct soap *soap, const char *tag, int id, const struct _wsnt__UnableToCreatePullPointFaultType_FaultCause *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__wsnt__UnableToCreatePullPointFaultType_FaultCause), type))
		return soap->error;
	if (soap_outliteral(soap, "-any", (char*const*)&a->__any, NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _wsnt__UnableToCreatePullPointFaultType_FaultCause * SOAP_FMAC4 soap_in__wsnt__UnableToCreatePullPointFaultType_FaultCause(struct soap *soap, const char *tag, struct _wsnt__UnableToCreatePullPointFaultType_FaultCause *a, const char *type)
{
	size_t soap_flag___any = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct _wsnt__UnableToCreatePullPointFaultType_FaultCause*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__wsnt__UnableToCreatePullPointFaultType_FaultCause, sizeof(struct _wsnt__UnableToCreatePullPointFaultType_FaultCause), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__wsnt__UnableToCreatePullPointFaultType_FaultCause(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag___any && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_inliteral(soap, "-any", (char**)&a->__any))
				{	soap_flag___any--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _wsnt__UnableToCreatePullPointFaultType_FaultCause *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__wsnt__UnableToCreatePullPointFaultType_FaultCause, SOAP_TYPE__wsnt__UnableToCreatePullPointFaultType_FaultCause, sizeof(struct _wsnt__UnableToCreatePullPointFaultType_FaultCause), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _wsnt__UnableToCreatePullPointFaultType_FaultCause * SOAP_FMAC4 soap_new__wsnt__UnableToCreatePullPointFaultType_FaultCause(struct soap *soap, int n)
{
	struct _wsnt__UnableToCreatePullPointFaultType_FaultCause *p;
	struct _wsnt__UnableToCreatePullPointFaultType_FaultCause *a = (struct _wsnt__UnableToCreatePullPointFaultType_FaultCause*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _wsnt__UnableToCreatePullPointFaultType_FaultCause));
	for (p = a; p && n--; p++)
		soap_default__wsnt__UnableToCreatePullPointFaultType_FaultCause(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__wsnt__UnableToCreatePullPointFaultType_FaultCause(struct soap *soap, const struct _wsnt__UnableToCreatePullPointFaultType_FaultCause *a, const char *tag, const char *type)
{
	if (soap_out__wsnt__UnableToCreatePullPointFaultType_FaultCause(soap, tag ? tag : "wsnt:UnableToCreatePullPointFaultType-FaultCause", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _wsnt__UnableToCreatePullPointFaultType_FaultCause * SOAP_FMAC4 soap_get__wsnt__UnableToCreatePullPointFaultType_FaultCause(struct soap *soap, struct _wsnt__UnableToCreatePullPointFaultType_FaultCause *p, const char *tag, const char *type)
{
	if ((p = soap_in__wsnt__UnableToCreatePullPointFaultType_FaultCause(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__wsnt__UnableToCreatePullPointFaultType_Description(struct soap *soap, struct _wsnt__UnableToCreatePullPointFaultType_Description *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->__item);
	soap_default__xml__lang(soap, &a->xml__lang);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__wsnt__UnableToCreatePullPointFaultType_Description(struct soap *soap, const struct _wsnt__UnableToCreatePullPointFaultType_Description *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_string(soap, (char*const*)&a->__item);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__wsnt__UnableToCreatePullPointFaultType_Description(struct soap *soap, const char *tag, int id, const struct _wsnt__UnableToCreatePullPointFaultType_Description *a, const char *type)
{
	if (a->xml__lang)
		soap_set_attr(soap, "xml:lang", soap__xml__lang2s(soap, a->xml__lang), 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	return soap_out_string(soap, tag, id, (char*const*)&a->__item, "");
}

SOAP_FMAC3 struct _wsnt__UnableToCreatePullPointFaultType_Description * SOAP_FMAC4 soap_in__wsnt__UnableToCreatePullPointFaultType_Description(struct soap *soap, const char *tag, struct _wsnt__UnableToCreatePullPointFaultType_Description *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	if (!(a = (struct _wsnt__UnableToCreatePullPointFaultType_Description *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__wsnt__UnableToCreatePullPointFaultType_Description, sizeof(struct _wsnt__UnableToCreatePullPointFaultType_Description), NULL, NULL, NULL, NULL)))
		return NULL;
	soap_revert(soap);
	*soap->id = '\0';
	soap_default__wsnt__UnableToCreatePullPointFaultType_Description(soap, a);
	if (soap_s2_xml__lang(soap, soap_attr_value(soap, "xml:lang", 1, 0), &a->xml__lang))
		return NULL;
	if (!soap_in_string(soap, tag, (char**)&a->__item, ""))
		return NULL;
	return a;
}

SOAP_FMAC3 struct _wsnt__UnableToCreatePullPointFaultType_Description * SOAP_FMAC4 soap_new__wsnt__UnableToCreatePullPointFaultType_Description(struct soap *soap, int n)
{
	struct _wsnt__UnableToCreatePullPointFaultType_Description *p;
	struct _wsnt__UnableToCreatePullPointFaultType_Description *a = (struct _wsnt__UnableToCreatePullPointFaultType_Description*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _wsnt__UnableToCreatePullPointFaultType_Description));
	for (p = a; p && n--; p++)
		soap_default__wsnt__UnableToCreatePullPointFaultType_Description(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__wsnt__UnableToCreatePullPointFaultType_Description(struct soap *soap, const struct _wsnt__UnableToCreatePullPointFaultType_Description *a, const char *tag, const char *type)
{
	if (soap_out__wsnt__UnableToCreatePullPointFaultType_Description(soap, tag ? tag : "wsnt:UnableToCreatePullPointFaultType-Description", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _wsnt__UnableToCreatePullPointFaultType_Description * SOAP_FMAC4 soap_get__wsnt__UnableToCreatePullPointFaultType_Description(struct soap *soap, struct _wsnt__UnableToCreatePullPointFaultType_Description *p, const char *tag, const char *type)
{
	if ((p = soap_in__wsnt__UnableToCreatePullPointFaultType_Description(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__wsnt__UnableToCreatePullPointFaultType_ErrorCode(struct soap *soap, struct _wsnt__UnableToCreatePullPointFaultType_ErrorCode *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_xsd__anyURI(soap, &a->dialect);
	a->__mixed = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__wsnt__UnableToCreatePullPointFaultType_ErrorCode(struct soap *soap, const struct _wsnt__UnableToCreatePullPointFaultType_ErrorCode *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__wsnt__UnableToCreatePullPointFaultType_ErrorCode(struct soap *soap, const char *tag, int id, const struct _wsnt__UnableToCreatePullPointFaultType_ErrorCode *a, const char *type)
{
	soap_set_attr(soap, "dialect", a->dialect ? soap_xsd__anyURI2s(soap, a->dialect) : "", 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__wsnt__UnableToCreatePullPointFaultType_ErrorCode), type))
		return soap->error;
	if (soap_outliteral(soap, "-mixed", (char*const*)&a->__mixed, NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _wsnt__UnableToCreatePullPointFaultType_ErrorCode * SOAP_FMAC4 soap_in__wsnt__UnableToCreatePullPointFaultType_ErrorCode(struct soap *soap, const char *tag, struct _wsnt__UnableToCreatePullPointFaultType_ErrorCode *a, const char *type)
{
	size_t soap_flag___mixed = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct _wsnt__UnableToCreatePullPointFaultType_ErrorCode*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__wsnt__UnableToCreatePullPointFaultType_ErrorCode, sizeof(struct _wsnt__UnableToCreatePullPointFaultType_ErrorCode), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__wsnt__UnableToCreatePullPointFaultType_ErrorCode(soap, a);
	if (soap_s2xsd__anyURI(soap, soap_attr_value(soap, "dialect", 4, 1), &a->dialect))
		return NULL;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag___mixed && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_inliteral(soap, "-mixed", (char**)&a->__mixed))
				{	soap_flag___mixed--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _wsnt__UnableToCreatePullPointFaultType_ErrorCode *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__wsnt__UnableToCreatePullPointFaultType_ErrorCode, SOAP_TYPE__wsnt__UnableToCreatePullPointFaultType_ErrorCode, sizeof(struct _wsnt__UnableToCreatePullPointFaultType_ErrorCode), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _wsnt__UnableToCreatePullPointFaultType_ErrorCode * SOAP_FMAC4 soap_new__wsnt__UnableToCreatePullPointFaultType_ErrorCode(struct soap *soap, int n)
{
	struct _wsnt__UnableToCreatePullPointFaultType_ErrorCode *p;
	struct _wsnt__UnableToCreatePullPointFaultType_ErrorCode *a = (struct _wsnt__UnableToCreatePullPointFaultType_ErrorCode*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _wsnt__UnableToCreatePullPointFaultType_ErrorCode));
	for (p = a; p && n--; p++)
		soap_default__wsnt__UnableToCreatePullPointFaultType_ErrorCode(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__wsnt__UnableToCreatePullPointFaultType_ErrorCode(struct soap *soap, const struct _wsnt__UnableToCreatePullPointFaultType_ErrorCode *a, const char *tag, const char *type)
{
	if (soap_out__wsnt__UnableToCreatePullPointFaultType_ErrorCode(soap, tag ? tag : "wsnt:UnableToCreatePullPointFaultType-ErrorCode", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _wsnt__UnableToCreatePullPointFaultType_ErrorCode * SOAP_FMAC4 soap_get__wsnt__UnableToCreatePullPointFaultType_ErrorCode(struct soap *soap, struct _wsnt__UnableToCreatePullPointFaultType_ErrorCode *p, const char *tag, const char *type)
{
	if ((p = soap_in__wsnt__UnableToCreatePullPointFaultType_ErrorCode(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_wsnt__UnableToCreatePullPointFaultType(struct soap *soap, struct wsnt__UnableToCreatePullPointFaultType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__size = 0;
	a->__any = NULL;
	soap_default_dateTime(soap, &a->wsrfbf__Timestamp);
	a->wsrfbf__Originator = NULL;
	a->wsrfbf__ErrorCode = NULL;
	a->__sizeDescription = 0;
	a->wsrfbf__Description = NULL;
	a->wsrfbf__FaultCause = NULL;
	a->__anyAttribute = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_wsnt__UnableToCreatePullPointFaultType(struct soap *soap, const struct wsnt__UnableToCreatePullPointFaultType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &a->wsrfbf__Timestamp, SOAP_TYPE_dateTime);
	soap_serialize_PointerTowsa5__EndpointReferenceType(soap, &a->wsrfbf__Originator);
	soap_serialize_PointerTo_wsnt__UnableToCreatePullPointFaultType_ErrorCode(soap, &a->wsrfbf__ErrorCode);
	if (a->wsrfbf__Description)
	{	int i;
		for (i = 0; i < (int)a->__sizeDescription; i++)
		{
			soap_embedded(soap, a->wsrfbf__Description + i, SOAP_TYPE__wsnt__UnableToCreatePullPointFaultType_Description);
			soap_serialize__wsnt__UnableToCreatePullPointFaultType_Description(soap, a->wsrfbf__Description + i);
		}
	}
	soap_serialize_PointerTo_wsnt__UnableToCreatePullPointFaultType_FaultCause(soap, &a->wsrfbf__FaultCause);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_wsnt__UnableToCreatePullPointFaultType(struct soap *soap, const char *tag, int id, const struct wsnt__UnableToCreatePullPointFaultType *a, const char *type)
{
	if (a->__anyAttribute)
		soap_set_attr(soap, "-anyAttribute", a->__anyAttribute, 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_wsnt__UnableToCreatePullPointFaultType), type))
		return soap->error;
	if (a->__any)
	{	int i;
		for (i = 0; i < (int)a->__size; i++)
			if (soap_outliteral(soap, "-any", (char*const*)(a->__any + i), NULL))
				return soap->error;
	}
	if (soap_out_dateTime(soap, "wsrfbf:Timestamp", -1, &a->wsrfbf__Timestamp, ""))
		return soap->error;
	if (soap_out_PointerTowsa5__EndpointReferenceType(soap, "wsrfbf:Originator", -1, &a->wsrfbf__Originator, ""))
		return soap->error;
	if (soap_out_PointerTo_wsnt__UnableToCreatePullPointFaultType_ErrorCode(soap, "wsrfbf:ErrorCode", -1, &a->wsrfbf__ErrorCode, ""))
		return soap->error;
	if (a->wsrfbf__Description)
	{	int i;
		for (i = 0; i < (int)a->__sizeDescription; i++)
			if (soap_out__wsnt__UnableToCreatePullPointFaultType_Description(soap, "wsrfbf:Description", -1, a->wsrfbf__Description + i, ""))
				return soap->error;
	}
	if (soap_out_PointerTo_wsnt__UnableToCreatePullPointFaultType_FaultCause(soap, "wsrfbf:FaultCause", -1, &a->wsrfbf__FaultCause, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct wsnt__UnableToCreatePullPointFaultType * SOAP_FMAC4 soap_in_wsnt__UnableToCreatePullPointFaultType(struct soap *soap, const char *tag, struct wsnt__UnableToCreatePullPointFaultType *a, const char *type)
{
	struct soap_blist *soap_blist___any = NULL;
	size_t soap_flag_wsrfbf__Timestamp = 1;
	size_t soap_flag_wsrfbf__Originator = 1;
	size_t soap_flag_wsrfbf__ErrorCode = 1;
	struct soap_blist *soap_blist_wsrfbf__Description = NULL;
	size_t soap_flag_wsrfbf__FaultCause = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct wsnt__UnableToCreatePullPointFaultType*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_wsnt__UnableToCreatePullPointFaultType, sizeof(struct wsnt__UnableToCreatePullPointFaultType), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_wsnt__UnableToCreatePullPointFaultType(soap, a);
	if (soap_s2char(soap, soap_attr_value(soap, "-anyAttribute", 0, 0), &a->__anyAttribute, 0, 0, -1, NULL))
		return NULL;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_wsrfbf__Timestamp && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_dateTime(soap, "wsrfbf:Timestamp", &a->wsrfbf__Timestamp, "xsd:dateTime"))
				{	soap_flag_wsrfbf__Timestamp--;
					continue;
				}
			}
			if (soap_flag_wsrfbf__Originator && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTowsa5__EndpointReferenceType(soap, "wsrfbf:Originator", &a->wsrfbf__Originator, "wsa5:EndpointReferenceType"))
				{	soap_flag_wsrfbf__Originator--;
					continue;
				}
			}
			if (soap_flag_wsrfbf__ErrorCode && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_wsnt__UnableToCreatePullPointFaultType_ErrorCode(soap, "wsrfbf:ErrorCode", &a->wsrfbf__ErrorCode, ""))
				{	soap_flag_wsrfbf__ErrorCode--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "wsrfbf:Description", 1, NULL))
			{	if (a->wsrfbf__Description == NULL)
				{	if (soap_blist_wsrfbf__Description == NULL)
						soap_blist_wsrfbf__Description = soap_alloc_block(soap);
					a->wsrfbf__Description = (struct _wsnt__UnableToCreatePullPointFaultType_Description *)soap_push_block_max(soap, soap_blist_wsrfbf__Description, sizeof(struct _wsnt__UnableToCreatePullPointFaultType_Description));
					if (a->wsrfbf__Description == NULL)
						return NULL;
					soap_default__wsnt__UnableToCreatePullPointFaultType_Description(soap, a->wsrfbf__Description);
				}
				soap_revert(soap);
				if (soap_in__wsnt__UnableToCreatePullPointFaultType_Description(soap, "wsrfbf:Description", a->wsrfbf__Description, ""))
				{	a->__sizeDescription++;
					a->wsrfbf__Description = NULL;
					continue;
				}
			}
			if (soap_flag_wsrfbf__FaultCause && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_wsnt__UnableToCreatePullPointFaultType_FaultCause(soap, "wsrfbf:FaultCause", &a->wsrfbf__FaultCause, ""))
				{	soap_flag_wsrfbf__FaultCause--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	if (a->__any == NULL)
				{	if (soap_blist___any == NULL)
						soap_blist___any = soap_alloc_block(soap);
					a->__any = (char **)soap_push_block_max(soap, soap_blist___any, sizeof(char *));
					if (a->__any == NULL)
						return NULL;
					*a->__any = NULL;
				}
				if (soap_inliteral(soap, "-any", (char**)a->__any))
				{	a->__size++;
					a->__any = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->__any)
			soap_pop_block(soap, soap_blist___any);
		if (a->__size)
		{	a->__any = (char **)soap_save_block(soap, soap_blist___any, NULL, 1);
		}
		else
		{	a->__any = NULL;
			if (soap_blist___any)
				soap_end_block(soap, soap_blist___any);
		}
		if (a->wsrfbf__Description)
			soap_pop_block(soap, soap_blist_wsrfbf__Description);
		if (a->__sizeDescription)
		{	a->wsrfbf__Description = (struct _wsnt__UnableToCreatePullPointFaultType_Description *)soap_save_block(soap, soap_blist_wsrfbf__Description, NULL, 1);
		}
		else
		{	a->wsrfbf__Description = NULL;
			if (soap_blist_wsrfbf__Description)
				soap_end_block(soap, soap_blist_wsrfbf__Description);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_wsrfbf__Timestamp > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct wsnt__UnableToCreatePullPointFaultType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_wsnt__UnableToCreatePullPointFaultType, SOAP_TYPE_wsnt__UnableToCreatePullPointFaultType, sizeof(struct wsnt__UnableToCreatePullPointFaultType), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct wsnt__UnableToCreatePullPointFaultType * SOAP_FMAC4 soap_new_wsnt__UnableToCreatePullPointFaultType(struct soap *soap, int n)
{
	struct wsnt__UnableToCreatePullPointFaultType *p;
	struct wsnt__UnableToCreatePullPointFaultType *a = (struct wsnt__UnableToCreatePullPointFaultType*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct wsnt__UnableToCreatePullPointFaultType));
	for (p = a; p && n--; p++)
		soap_default_wsnt__UnableToCreatePullPointFaultType(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_wsnt__UnableToCreatePullPointFaultType(struct soap *soap, const struct wsnt__UnableToCreatePullPointFaultType *a, const char *tag, const char *type)
{
	if (soap_out_wsnt__UnableToCreatePullPointFaultType(soap, tag ? tag : "wsnt:UnableToCreatePullPointFaultType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct wsnt__UnableToCreatePullPointFaultType * SOAP_FMAC4 soap_get_wsnt__UnableToCreatePullPointFaultType(struct soap *soap, struct wsnt__UnableToCreatePullPointFaultType *p, const char *tag, const char *type)
{
	if ((p = soap_in_wsnt__UnableToCreatePullPointFaultType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__wsnt__UnableToDestroyPullPointFaultType_FaultCause(struct soap *soap, struct _wsnt__UnableToDestroyPullPointFaultType_FaultCause *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__any = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__wsnt__UnableToDestroyPullPointFaultType_FaultCause(struct soap *soap, const struct _wsnt__UnableToDestroyPullPointFaultType_FaultCause *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__wsnt__UnableToDestroyPullPointFaultType_FaultCause(struct soap *soap, const char *tag, int id, const struct _wsnt__UnableToDestroyPullPointFaultType_FaultCause *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__wsnt__UnableToDestroyPullPointFaultType_FaultCause), type))
		return soap->error;
	if (soap_outliteral(soap, "-any", (char*const*)&a->__any, NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _wsnt__UnableToDestroyPullPointFaultType_FaultCause * SOAP_FMAC4 soap_in__wsnt__UnableToDestroyPullPointFaultType_FaultCause(struct soap *soap, const char *tag, struct _wsnt__UnableToDestroyPullPointFaultType_FaultCause *a, const char *type)
{
	size_t soap_flag___any = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct _wsnt__UnableToDestroyPullPointFaultType_FaultCause*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__wsnt__UnableToDestroyPullPointFaultType_FaultCause, sizeof(struct _wsnt__UnableToDestroyPullPointFaultType_FaultCause), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__wsnt__UnableToDestroyPullPointFaultType_FaultCause(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag___any && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_inliteral(soap, "-any", (char**)&a->__any))
				{	soap_flag___any--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _wsnt__UnableToDestroyPullPointFaultType_FaultCause *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__wsnt__UnableToDestroyPullPointFaultType_FaultCause, SOAP_TYPE__wsnt__UnableToDestroyPullPointFaultType_FaultCause, sizeof(struct _wsnt__UnableToDestroyPullPointFaultType_FaultCause), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _wsnt__UnableToDestroyPullPointFaultType_FaultCause * SOAP_FMAC4 soap_new__wsnt__UnableToDestroyPullPointFaultType_FaultCause(struct soap *soap, int n)
{
	struct _wsnt__UnableToDestroyPullPointFaultType_FaultCause *p;
	struct _wsnt__UnableToDestroyPullPointFaultType_FaultCause *a = (struct _wsnt__UnableToDestroyPullPointFaultType_FaultCause*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _wsnt__UnableToDestroyPullPointFaultType_FaultCause));
	for (p = a; p && n--; p++)
		soap_default__wsnt__UnableToDestroyPullPointFaultType_FaultCause(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__wsnt__UnableToDestroyPullPointFaultType_FaultCause(struct soap *soap, const struct _wsnt__UnableToDestroyPullPointFaultType_FaultCause *a, const char *tag, const char *type)
{
	if (soap_out__wsnt__UnableToDestroyPullPointFaultType_FaultCause(soap, tag ? tag : "wsnt:UnableToDestroyPullPointFaultType-FaultCause", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _wsnt__UnableToDestroyPullPointFaultType_FaultCause * SOAP_FMAC4 soap_get__wsnt__UnableToDestroyPullPointFaultType_FaultCause(struct soap *soap, struct _wsnt__UnableToDestroyPullPointFaultType_FaultCause *p, const char *tag, const char *type)
{
	if ((p = soap_in__wsnt__UnableToDestroyPullPointFaultType_FaultCause(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__wsnt__UnableToDestroyPullPointFaultType_Description(struct soap *soap, struct _wsnt__UnableToDestroyPullPointFaultType_Description *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->__item);
	soap_default__xml__lang(soap, &a->xml__lang);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__wsnt__UnableToDestroyPullPointFaultType_Description(struct soap *soap, const struct _wsnt__UnableToDestroyPullPointFaultType_Description *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_string(soap, (char*const*)&a->__item);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__wsnt__UnableToDestroyPullPointFaultType_Description(struct soap *soap, const char *tag, int id, const struct _wsnt__UnableToDestroyPullPointFaultType_Description *a, const char *type)
{
	if (a->xml__lang)
		soap_set_attr(soap, "xml:lang", soap__xml__lang2s(soap, a->xml__lang), 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	return soap_out_string(soap, tag, id, (char*const*)&a->__item, "");
}

SOAP_FMAC3 struct _wsnt__UnableToDestroyPullPointFaultType_Description * SOAP_FMAC4 soap_in__wsnt__UnableToDestroyPullPointFaultType_Description(struct soap *soap, const char *tag, struct _wsnt__UnableToDestroyPullPointFaultType_Description *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	if (!(a = (struct _wsnt__UnableToDestroyPullPointFaultType_Description *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__wsnt__UnableToDestroyPullPointFaultType_Description, sizeof(struct _wsnt__UnableToDestroyPullPointFaultType_Description), NULL, NULL, NULL, NULL)))
		return NULL;
	soap_revert(soap);
	*soap->id = '\0';
	soap_default__wsnt__UnableToDestroyPullPointFaultType_Description(soap, a);
	if (soap_s2_xml__lang(soap, soap_attr_value(soap, "xml:lang", 1, 0), &a->xml__lang))
		return NULL;
	if (!soap_in_string(soap, tag, (char**)&a->__item, ""))
		return NULL;
	return a;
}

SOAP_FMAC3 struct _wsnt__UnableToDestroyPullPointFaultType_Description * SOAP_FMAC4 soap_new__wsnt__UnableToDestroyPullPointFaultType_Description(struct soap *soap, int n)
{
	struct _wsnt__UnableToDestroyPullPointFaultType_Description *p;
	struct _wsnt__UnableToDestroyPullPointFaultType_Description *a = (struct _wsnt__UnableToDestroyPullPointFaultType_Description*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _wsnt__UnableToDestroyPullPointFaultType_Description));
	for (p = a; p && n--; p++)
		soap_default__wsnt__UnableToDestroyPullPointFaultType_Description(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__wsnt__UnableToDestroyPullPointFaultType_Description(struct soap *soap, const struct _wsnt__UnableToDestroyPullPointFaultType_Description *a, const char *tag, const char *type)
{
	if (soap_out__wsnt__UnableToDestroyPullPointFaultType_Description(soap, tag ? tag : "wsnt:UnableToDestroyPullPointFaultType-Description", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _wsnt__UnableToDestroyPullPointFaultType_Description * SOAP_FMAC4 soap_get__wsnt__UnableToDestroyPullPointFaultType_Description(struct soap *soap, struct _wsnt__UnableToDestroyPullPointFaultType_Description *p, const char *tag, const char *type)
{
	if ((p = soap_in__wsnt__UnableToDestroyPullPointFaultType_Description(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__wsnt__UnableToDestroyPullPointFaultType_ErrorCode(struct soap *soap, struct _wsnt__UnableToDestroyPullPointFaultType_ErrorCode *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_xsd__anyURI(soap, &a->dialect);
	a->__mixed = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__wsnt__UnableToDestroyPullPointFaultType_ErrorCode(struct soap *soap, const struct _wsnt__UnableToDestroyPullPointFaultType_ErrorCode *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__wsnt__UnableToDestroyPullPointFaultType_ErrorCode(struct soap *soap, const char *tag, int id, const struct _wsnt__UnableToDestroyPullPointFaultType_ErrorCode *a, const char *type)
{
	soap_set_attr(soap, "dialect", a->dialect ? soap_xsd__anyURI2s(soap, a->dialect) : "", 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__wsnt__UnableToDestroyPullPointFaultType_ErrorCode), type))
		return soap->error;
	if (soap_outliteral(soap, "-mixed", (char*const*)&a->__mixed, NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _wsnt__UnableToDestroyPullPointFaultType_ErrorCode * SOAP_FMAC4 soap_in__wsnt__UnableToDestroyPullPointFaultType_ErrorCode(struct soap *soap, const char *tag, struct _wsnt__UnableToDestroyPullPointFaultType_ErrorCode *a, const char *type)
{
	size_t soap_flag___mixed = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct _wsnt__UnableToDestroyPullPointFaultType_ErrorCode*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__wsnt__UnableToDestroyPullPointFaultType_ErrorCode, sizeof(struct _wsnt__UnableToDestroyPullPointFaultType_ErrorCode), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__wsnt__UnableToDestroyPullPointFaultType_ErrorCode(soap, a);
	if (soap_s2xsd__anyURI(soap, soap_attr_value(soap, "dialect", 4, 1), &a->dialect))
		return NULL;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag___mixed && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_inliteral(soap, "-mixed", (char**)&a->__mixed))
				{	soap_flag___mixed--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _wsnt__UnableToDestroyPullPointFaultType_ErrorCode *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__wsnt__UnableToDestroyPullPointFaultType_ErrorCode, SOAP_TYPE__wsnt__UnableToDestroyPullPointFaultType_ErrorCode, sizeof(struct _wsnt__UnableToDestroyPullPointFaultType_ErrorCode), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _wsnt__UnableToDestroyPullPointFaultType_ErrorCode * SOAP_FMAC4 soap_new__wsnt__UnableToDestroyPullPointFaultType_ErrorCode(struct soap *soap, int n)
{
	struct _wsnt__UnableToDestroyPullPointFaultType_ErrorCode *p;
	struct _wsnt__UnableToDestroyPullPointFaultType_ErrorCode *a = (struct _wsnt__UnableToDestroyPullPointFaultType_ErrorCode*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _wsnt__UnableToDestroyPullPointFaultType_ErrorCode));
	for (p = a; p && n--; p++)
		soap_default__wsnt__UnableToDestroyPullPointFaultType_ErrorCode(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__wsnt__UnableToDestroyPullPointFaultType_ErrorCode(struct soap *soap, const struct _wsnt__UnableToDestroyPullPointFaultType_ErrorCode *a, const char *tag, const char *type)
{
	if (soap_out__wsnt__UnableToDestroyPullPointFaultType_ErrorCode(soap, tag ? tag : "wsnt:UnableToDestroyPullPointFaultType-ErrorCode", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _wsnt__UnableToDestroyPullPointFaultType_ErrorCode * SOAP_FMAC4 soap_get__wsnt__UnableToDestroyPullPointFaultType_ErrorCode(struct soap *soap, struct _wsnt__UnableToDestroyPullPointFaultType_ErrorCode *p, const char *tag, const char *type)
{
	if ((p = soap_in__wsnt__UnableToDestroyPullPointFaultType_ErrorCode(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_wsnt__UnableToDestroyPullPointFaultType(struct soap *soap, struct wsnt__UnableToDestroyPullPointFaultType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__size = 0;
	a->__any = NULL;
	soap_default_dateTime(soap, &a->wsrfbf__Timestamp);
	a->wsrfbf__Originator = NULL;
	a->wsrfbf__ErrorCode = NULL;
	a->__sizeDescription = 0;
	a->wsrfbf__Description = NULL;
	a->wsrfbf__FaultCause = NULL;
	a->__anyAttribute = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_wsnt__UnableToDestroyPullPointFaultType(struct soap *soap, const struct wsnt__UnableToDestroyPullPointFaultType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &a->wsrfbf__Timestamp, SOAP_TYPE_dateTime);
	soap_serialize_PointerTowsa5__EndpointReferenceType(soap, &a->wsrfbf__Originator);
	soap_serialize_PointerTo_wsnt__UnableToDestroyPullPointFaultType_ErrorCode(soap, &a->wsrfbf__ErrorCode);
	if (a->wsrfbf__Description)
	{	int i;
		for (i = 0; i < (int)a->__sizeDescription; i++)
		{
			soap_embedded(soap, a->wsrfbf__Description + i, SOAP_TYPE__wsnt__UnableToDestroyPullPointFaultType_Description);
			soap_serialize__wsnt__UnableToDestroyPullPointFaultType_Description(soap, a->wsrfbf__Description + i);
		}
	}
	soap_serialize_PointerTo_wsnt__UnableToDestroyPullPointFaultType_FaultCause(soap, &a->wsrfbf__FaultCause);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_wsnt__UnableToDestroyPullPointFaultType(struct soap *soap, const char *tag, int id, const struct wsnt__UnableToDestroyPullPointFaultType *a, const char *type)
{
	if (a->__anyAttribute)
		soap_set_attr(soap, "-anyAttribute", a->__anyAttribute, 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_wsnt__UnableToDestroyPullPointFaultType), type))
		return soap->error;
	if (a->__any)
	{	int i;
		for (i = 0; i < (int)a->__size; i++)
			if (soap_outliteral(soap, "-any", (char*const*)(a->__any + i), NULL))
				return soap->error;
	}
	if (soap_out_dateTime(soap, "wsrfbf:Timestamp", -1, &a->wsrfbf__Timestamp, ""))
		return soap->error;
	if (soap_out_PointerTowsa5__EndpointReferenceType(soap, "wsrfbf:Originator", -1, &a->wsrfbf__Originator, ""))
		return soap->error;
	if (soap_out_PointerTo_wsnt__UnableToDestroyPullPointFaultType_ErrorCode(soap, "wsrfbf:ErrorCode", -1, &a->wsrfbf__ErrorCode, ""))
		return soap->error;
	if (a->wsrfbf__Description)
	{	int i;
		for (i = 0; i < (int)a->__sizeDescription; i++)
			if (soap_out__wsnt__UnableToDestroyPullPointFaultType_Description(soap, "wsrfbf:Description", -1, a->wsrfbf__Description + i, ""))
				return soap->error;
	}
	if (soap_out_PointerTo_wsnt__UnableToDestroyPullPointFaultType_FaultCause(soap, "wsrfbf:FaultCause", -1, &a->wsrfbf__FaultCause, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct wsnt__UnableToDestroyPullPointFaultType * SOAP_FMAC4 soap_in_wsnt__UnableToDestroyPullPointFaultType(struct soap *soap, const char *tag, struct wsnt__UnableToDestroyPullPointFaultType *a, const char *type)
{
	struct soap_blist *soap_blist___any = NULL;
	size_t soap_flag_wsrfbf__Timestamp = 1;
	size_t soap_flag_wsrfbf__Originator = 1;
	size_t soap_flag_wsrfbf__ErrorCode = 1;
	struct soap_blist *soap_blist_wsrfbf__Description = NULL;
	size_t soap_flag_wsrfbf__FaultCause = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct wsnt__UnableToDestroyPullPointFaultType*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_wsnt__UnableToDestroyPullPointFaultType, sizeof(struct wsnt__UnableToDestroyPullPointFaultType), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_wsnt__UnableToDestroyPullPointFaultType(soap, a);
	if (soap_s2char(soap, soap_attr_value(soap, "-anyAttribute", 0, 0), &a->__anyAttribute, 0, 0, -1, NULL))
		return NULL;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_wsrfbf__Timestamp && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_dateTime(soap, "wsrfbf:Timestamp", &a->wsrfbf__Timestamp, "xsd:dateTime"))
				{	soap_flag_wsrfbf__Timestamp--;
					continue;
				}
			}
			if (soap_flag_wsrfbf__Originator && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTowsa5__EndpointReferenceType(soap, "wsrfbf:Originator", &a->wsrfbf__Originator, "wsa5:EndpointReferenceType"))
				{	soap_flag_wsrfbf__Originator--;
					continue;
				}
			}
			if (soap_flag_wsrfbf__ErrorCode && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_wsnt__UnableToDestroyPullPointFaultType_ErrorCode(soap, "wsrfbf:ErrorCode", &a->wsrfbf__ErrorCode, ""))
				{	soap_flag_wsrfbf__ErrorCode--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "wsrfbf:Description", 1, NULL))
			{	if (a->wsrfbf__Description == NULL)
				{	if (soap_blist_wsrfbf__Description == NULL)
						soap_blist_wsrfbf__Description = soap_alloc_block(soap);
					a->wsrfbf__Description = (struct _wsnt__UnableToDestroyPullPointFaultType_Description *)soap_push_block_max(soap, soap_blist_wsrfbf__Description, sizeof(struct _wsnt__UnableToDestroyPullPointFaultType_Description));
					if (a->wsrfbf__Description == NULL)
						return NULL;
					soap_default__wsnt__UnableToDestroyPullPointFaultType_Description(soap, a->wsrfbf__Description);
				}
				soap_revert(soap);
				if (soap_in__wsnt__UnableToDestroyPullPointFaultType_Description(soap, "wsrfbf:Description", a->wsrfbf__Description, ""))
				{	a->__sizeDescription++;
					a->wsrfbf__Description = NULL;
					continue;
				}
			}
			if (soap_flag_wsrfbf__FaultCause && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_wsnt__UnableToDestroyPullPointFaultType_FaultCause(soap, "wsrfbf:FaultCause", &a->wsrfbf__FaultCause, ""))
				{	soap_flag_wsrfbf__FaultCause--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	if (a->__any == NULL)
				{	if (soap_blist___any == NULL)
						soap_blist___any = soap_alloc_block(soap);
					a->__any = (char **)soap_push_block_max(soap, soap_blist___any, sizeof(char *));
					if (a->__any == NULL)
						return NULL;
					*a->__any = NULL;
				}
				if (soap_inliteral(soap, "-any", (char**)a->__any))
				{	a->__size++;
					a->__any = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->__any)
			soap_pop_block(soap, soap_blist___any);
		if (a->__size)
		{	a->__any = (char **)soap_save_block(soap, soap_blist___any, NULL, 1);
		}
		else
		{	a->__any = NULL;
			if (soap_blist___any)
				soap_end_block(soap, soap_blist___any);
		}
		if (a->wsrfbf__Description)
			soap_pop_block(soap, soap_blist_wsrfbf__Description);
		if (a->__sizeDescription)
		{	a->wsrfbf__Description = (struct _wsnt__UnableToDestroyPullPointFaultType_Description *)soap_save_block(soap, soap_blist_wsrfbf__Description, NULL, 1);
		}
		else
		{	a->wsrfbf__Description = NULL;
			if (soap_blist_wsrfbf__Description)
				soap_end_block(soap, soap_blist_wsrfbf__Description);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_wsrfbf__Timestamp > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct wsnt__UnableToDestroyPullPointFaultType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_wsnt__UnableToDestroyPullPointFaultType, SOAP_TYPE_wsnt__UnableToDestroyPullPointFaultType, sizeof(struct wsnt__UnableToDestroyPullPointFaultType), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct wsnt__UnableToDestroyPullPointFaultType * SOAP_FMAC4 soap_new_wsnt__UnableToDestroyPullPointFaultType(struct soap *soap, int n)
{
	struct wsnt__UnableToDestroyPullPointFaultType *p;
	struct wsnt__UnableToDestroyPullPointFaultType *a = (struct wsnt__UnableToDestroyPullPointFaultType*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct wsnt__UnableToDestroyPullPointFaultType));
	for (p = a; p && n--; p++)
		soap_default_wsnt__UnableToDestroyPullPointFaultType(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_wsnt__UnableToDestroyPullPointFaultType(struct soap *soap, const struct wsnt__UnableToDestroyPullPointFaultType *a, const char *tag, const char *type)
{
	if (soap_out_wsnt__UnableToDestroyPullPointFaultType(soap, tag ? tag : "wsnt:UnableToDestroyPullPointFaultType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct wsnt__UnableToDestroyPullPointFaultType * SOAP_FMAC4 soap_get_wsnt__UnableToDestroyPullPointFaultType(struct soap *soap, struct wsnt__UnableToDestroyPullPointFaultType *p, const char *tag, const char *type)
{
	if ((p = soap_in_wsnt__UnableToDestroyPullPointFaultType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__wsnt__UnableToGetMessagesFaultType_FaultCause(struct soap *soap, struct _wsnt__UnableToGetMessagesFaultType_FaultCause *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__any = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__wsnt__UnableToGetMessagesFaultType_FaultCause(struct soap *soap, const struct _wsnt__UnableToGetMessagesFaultType_FaultCause *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__wsnt__UnableToGetMessagesFaultType_FaultCause(struct soap *soap, const char *tag, int id, const struct _wsnt__UnableToGetMessagesFaultType_FaultCause *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__wsnt__UnableToGetMessagesFaultType_FaultCause), type))
		return soap->error;
	if (soap_outliteral(soap, "-any", (char*const*)&a->__any, NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _wsnt__UnableToGetMessagesFaultType_FaultCause * SOAP_FMAC4 soap_in__wsnt__UnableToGetMessagesFaultType_FaultCause(struct soap *soap, const char *tag, struct _wsnt__UnableToGetMessagesFaultType_FaultCause *a, const char *type)
{
	size_t soap_flag___any = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct _wsnt__UnableToGetMessagesFaultType_FaultCause*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__wsnt__UnableToGetMessagesFaultType_FaultCause, sizeof(struct _wsnt__UnableToGetMessagesFaultType_FaultCause), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__wsnt__UnableToGetMessagesFaultType_FaultCause(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag___any && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_inliteral(soap, "-any", (char**)&a->__any))
				{	soap_flag___any--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _wsnt__UnableToGetMessagesFaultType_FaultCause *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__wsnt__UnableToGetMessagesFaultType_FaultCause, SOAP_TYPE__wsnt__UnableToGetMessagesFaultType_FaultCause, sizeof(struct _wsnt__UnableToGetMessagesFaultType_FaultCause), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _wsnt__UnableToGetMessagesFaultType_FaultCause * SOAP_FMAC4 soap_new__wsnt__UnableToGetMessagesFaultType_FaultCause(struct soap *soap, int n)
{
	struct _wsnt__UnableToGetMessagesFaultType_FaultCause *p;
	struct _wsnt__UnableToGetMessagesFaultType_FaultCause *a = (struct _wsnt__UnableToGetMessagesFaultType_FaultCause*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _wsnt__UnableToGetMessagesFaultType_FaultCause));
	for (p = a; p && n--; p++)
		soap_default__wsnt__UnableToGetMessagesFaultType_FaultCause(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__wsnt__UnableToGetMessagesFaultType_FaultCause(struct soap *soap, const struct _wsnt__UnableToGetMessagesFaultType_FaultCause *a, const char *tag, const char *type)
{
	if (soap_out__wsnt__UnableToGetMessagesFaultType_FaultCause(soap, tag ? tag : "wsnt:UnableToGetMessagesFaultType-FaultCause", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _wsnt__UnableToGetMessagesFaultType_FaultCause * SOAP_FMAC4 soap_get__wsnt__UnableToGetMessagesFaultType_FaultCause(struct soap *soap, struct _wsnt__UnableToGetMessagesFaultType_FaultCause *p, const char *tag, const char *type)
{
	if ((p = soap_in__wsnt__UnableToGetMessagesFaultType_FaultCause(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__wsnt__UnableToGetMessagesFaultType_Description(struct soap *soap, struct _wsnt__UnableToGetMessagesFaultType_Description *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->__item);
	soap_default__xml__lang(soap, &a->xml__lang);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__wsnt__UnableToGetMessagesFaultType_Description(struct soap *soap, const struct _wsnt__UnableToGetMessagesFaultType_Description *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_string(soap, (char*const*)&a->__item);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__wsnt__UnableToGetMessagesFaultType_Description(struct soap *soap, const char *tag, int id, const struct _wsnt__UnableToGetMessagesFaultType_Description *a, const char *type)
{
	if (a->xml__lang)
		soap_set_attr(soap, "xml:lang", soap__xml__lang2s(soap, a->xml__lang), 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	return soap_out_string(soap, tag, id, (char*const*)&a->__item, "");
}

SOAP_FMAC3 struct _wsnt__UnableToGetMessagesFaultType_Description * SOAP_FMAC4 soap_in__wsnt__UnableToGetMessagesFaultType_Description(struct soap *soap, const char *tag, struct _wsnt__UnableToGetMessagesFaultType_Description *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	if (!(a = (struct _wsnt__UnableToGetMessagesFaultType_Description *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__wsnt__UnableToGetMessagesFaultType_Description, sizeof(struct _wsnt__UnableToGetMessagesFaultType_Description), NULL, NULL, NULL, NULL)))
		return NULL;
	soap_revert(soap);
	*soap->id = '\0';
	soap_default__wsnt__UnableToGetMessagesFaultType_Description(soap, a);
	if (soap_s2_xml__lang(soap, soap_attr_value(soap, "xml:lang", 1, 0), &a->xml__lang))
		return NULL;
	if (!soap_in_string(soap, tag, (char**)&a->__item, ""))
		return NULL;
	return a;
}

SOAP_FMAC3 struct _wsnt__UnableToGetMessagesFaultType_Description * SOAP_FMAC4 soap_new__wsnt__UnableToGetMessagesFaultType_Description(struct soap *soap, int n)
{
	struct _wsnt__UnableToGetMessagesFaultType_Description *p;
	struct _wsnt__UnableToGetMessagesFaultType_Description *a = (struct _wsnt__UnableToGetMessagesFaultType_Description*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _wsnt__UnableToGetMessagesFaultType_Description));
	for (p = a; p && n--; p++)
		soap_default__wsnt__UnableToGetMessagesFaultType_Description(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__wsnt__UnableToGetMessagesFaultType_Description(struct soap *soap, const struct _wsnt__UnableToGetMessagesFaultType_Description *a, const char *tag, const char *type)
{
	if (soap_out__wsnt__UnableToGetMessagesFaultType_Description(soap, tag ? tag : "wsnt:UnableToGetMessagesFaultType-Description", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _wsnt__UnableToGetMessagesFaultType_Description * SOAP_FMAC4 soap_get__wsnt__UnableToGetMessagesFaultType_Description(struct soap *soap, struct _wsnt__UnableToGetMessagesFaultType_Description *p, const char *tag, const char *type)
{
	if ((p = soap_in__wsnt__UnableToGetMessagesFaultType_Description(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__wsnt__UnableToGetMessagesFaultType_ErrorCode(struct soap *soap, struct _wsnt__UnableToGetMessagesFaultType_ErrorCode *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_xsd__anyURI(soap, &a->dialect);
	a->__mixed = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__wsnt__UnableToGetMessagesFaultType_ErrorCode(struct soap *soap, const struct _wsnt__UnableToGetMessagesFaultType_ErrorCode *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__wsnt__UnableToGetMessagesFaultType_ErrorCode(struct soap *soap, const char *tag, int id, const struct _wsnt__UnableToGetMessagesFaultType_ErrorCode *a, const char *type)
{
	soap_set_attr(soap, "dialect", a->dialect ? soap_xsd__anyURI2s(soap, a->dialect) : "", 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__wsnt__UnableToGetMessagesFaultType_ErrorCode), type))
		return soap->error;
	if (soap_outliteral(soap, "-mixed", (char*const*)&a->__mixed, NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _wsnt__UnableToGetMessagesFaultType_ErrorCode * SOAP_FMAC4 soap_in__wsnt__UnableToGetMessagesFaultType_ErrorCode(struct soap *soap, const char *tag, struct _wsnt__UnableToGetMessagesFaultType_ErrorCode *a, const char *type)
{
	size_t soap_flag___mixed = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct _wsnt__UnableToGetMessagesFaultType_ErrorCode*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__wsnt__UnableToGetMessagesFaultType_ErrorCode, sizeof(struct _wsnt__UnableToGetMessagesFaultType_ErrorCode), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__wsnt__UnableToGetMessagesFaultType_ErrorCode(soap, a);
	if (soap_s2xsd__anyURI(soap, soap_attr_value(soap, "dialect", 4, 1), &a->dialect))
		return NULL;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag___mixed && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_inliteral(soap, "-mixed", (char**)&a->__mixed))
				{	soap_flag___mixed--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _wsnt__UnableToGetMessagesFaultType_ErrorCode *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__wsnt__UnableToGetMessagesFaultType_ErrorCode, SOAP_TYPE__wsnt__UnableToGetMessagesFaultType_ErrorCode, sizeof(struct _wsnt__UnableToGetMessagesFaultType_ErrorCode), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _wsnt__UnableToGetMessagesFaultType_ErrorCode * SOAP_FMAC4 soap_new__wsnt__UnableToGetMessagesFaultType_ErrorCode(struct soap *soap, int n)
{
	struct _wsnt__UnableToGetMessagesFaultType_ErrorCode *p;
	struct _wsnt__UnableToGetMessagesFaultType_ErrorCode *a = (struct _wsnt__UnableToGetMessagesFaultType_ErrorCode*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _wsnt__UnableToGetMessagesFaultType_ErrorCode));
	for (p = a; p && n--; p++)
		soap_default__wsnt__UnableToGetMessagesFaultType_ErrorCode(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__wsnt__UnableToGetMessagesFaultType_ErrorCode(struct soap *soap, const struct _wsnt__UnableToGetMessagesFaultType_ErrorCode *a, const char *tag, const char *type)
{
	if (soap_out__wsnt__UnableToGetMessagesFaultType_ErrorCode(soap, tag ? tag : "wsnt:UnableToGetMessagesFaultType-ErrorCode", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _wsnt__UnableToGetMessagesFaultType_ErrorCode * SOAP_FMAC4 soap_get__wsnt__UnableToGetMessagesFaultType_ErrorCode(struct soap *soap, struct _wsnt__UnableToGetMessagesFaultType_ErrorCode *p, const char *tag, const char *type)
{
	if ((p = soap_in__wsnt__UnableToGetMessagesFaultType_ErrorCode(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_wsnt__UnableToGetMessagesFaultType(struct soap *soap, struct wsnt__UnableToGetMessagesFaultType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__size = 0;
	a->__any = NULL;
	soap_default_dateTime(soap, &a->wsrfbf__Timestamp);
	a->wsrfbf__Originator = NULL;
	a->wsrfbf__ErrorCode = NULL;
	a->__sizeDescription = 0;
	a->wsrfbf__Description = NULL;
	a->wsrfbf__FaultCause = NULL;
	a->__anyAttribute = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_wsnt__UnableToGetMessagesFaultType(struct soap *soap, const struct wsnt__UnableToGetMessagesFaultType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &a->wsrfbf__Timestamp, SOAP_TYPE_dateTime);
	soap_serialize_PointerTowsa5__EndpointReferenceType(soap, &a->wsrfbf__Originator);
	soap_serialize_PointerTo_wsnt__UnableToGetMessagesFaultType_ErrorCode(soap, &a->wsrfbf__ErrorCode);
	if (a->wsrfbf__Description)
	{	int i;
		for (i = 0; i < (int)a->__sizeDescription; i++)
		{
			soap_embedded(soap, a->wsrfbf__Description + i, SOAP_TYPE__wsnt__UnableToGetMessagesFaultType_Description);
			soap_serialize__wsnt__UnableToGetMessagesFaultType_Description(soap, a->wsrfbf__Description + i);
		}
	}
	soap_serialize_PointerTo_wsnt__UnableToGetMessagesFaultType_FaultCause(soap, &a->wsrfbf__FaultCause);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_wsnt__UnableToGetMessagesFaultType(struct soap *soap, const char *tag, int id, const struct wsnt__UnableToGetMessagesFaultType *a, const char *type)
{
	if (a->__anyAttribute)
		soap_set_attr(soap, "-anyAttribute", a->__anyAttribute, 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_wsnt__UnableToGetMessagesFaultType), type))
		return soap->error;
	if (a->__any)
	{	int i;
		for (i = 0; i < (int)a->__size; i++)
			if (soap_outliteral(soap, "-any", (char*const*)(a->__any + i), NULL))
				return soap->error;
	}
	if (soap_out_dateTime(soap, "wsrfbf:Timestamp", -1, &a->wsrfbf__Timestamp, ""))
		return soap->error;
	if (soap_out_PointerTowsa5__EndpointReferenceType(soap, "wsrfbf:Originator", -1, &a->wsrfbf__Originator, ""))
		return soap->error;
	if (soap_out_PointerTo_wsnt__UnableToGetMessagesFaultType_ErrorCode(soap, "wsrfbf:ErrorCode", -1, &a->wsrfbf__ErrorCode, ""))
		return soap->error;
	if (a->wsrfbf__Description)
	{	int i;
		for (i = 0; i < (int)a->__sizeDescription; i++)
			if (soap_out__wsnt__UnableToGetMessagesFaultType_Description(soap, "wsrfbf:Description", -1, a->wsrfbf__Description + i, ""))
				return soap->error;
	}
	if (soap_out_PointerTo_wsnt__UnableToGetMessagesFaultType_FaultCause(soap, "wsrfbf:FaultCause", -1, &a->wsrfbf__FaultCause, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct wsnt__UnableToGetMessagesFaultType * SOAP_FMAC4 soap_in_wsnt__UnableToGetMessagesFaultType(struct soap *soap, const char *tag, struct wsnt__UnableToGetMessagesFaultType *a, const char *type)
{
	struct soap_blist *soap_blist___any = NULL;
	size_t soap_flag_wsrfbf__Timestamp = 1;
	size_t soap_flag_wsrfbf__Originator = 1;
	size_t soap_flag_wsrfbf__ErrorCode = 1;
	struct soap_blist *soap_blist_wsrfbf__Description = NULL;
	size_t soap_flag_wsrfbf__FaultCause = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct wsnt__UnableToGetMessagesFaultType*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_wsnt__UnableToGetMessagesFaultType, sizeof(struct wsnt__UnableToGetMessagesFaultType), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_wsnt__UnableToGetMessagesFaultType(soap, a);
	if (soap_s2char(soap, soap_attr_value(soap, "-anyAttribute", 0, 0), &a->__anyAttribute, 0, 0, -1, NULL))
		return NULL;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_wsrfbf__Timestamp && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_dateTime(soap, "wsrfbf:Timestamp", &a->wsrfbf__Timestamp, "xsd:dateTime"))
				{	soap_flag_wsrfbf__Timestamp--;
					continue;
				}
			}
			if (soap_flag_wsrfbf__Originator && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTowsa5__EndpointReferenceType(soap, "wsrfbf:Originator", &a->wsrfbf__Originator, "wsa5:EndpointReferenceType"))
				{	soap_flag_wsrfbf__Originator--;
					continue;
				}
			}
			if (soap_flag_wsrfbf__ErrorCode && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_wsnt__UnableToGetMessagesFaultType_ErrorCode(soap, "wsrfbf:ErrorCode", &a->wsrfbf__ErrorCode, ""))
				{	soap_flag_wsrfbf__ErrorCode--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "wsrfbf:Description", 1, NULL))
			{	if (a->wsrfbf__Description == NULL)
				{	if (soap_blist_wsrfbf__Description == NULL)
						soap_blist_wsrfbf__Description = soap_alloc_block(soap);
					a->wsrfbf__Description = (struct _wsnt__UnableToGetMessagesFaultType_Description *)soap_push_block_max(soap, soap_blist_wsrfbf__Description, sizeof(struct _wsnt__UnableToGetMessagesFaultType_Description));
					if (a->wsrfbf__Description == NULL)
						return NULL;
					soap_default__wsnt__UnableToGetMessagesFaultType_Description(soap, a->wsrfbf__Description);
				}
				soap_revert(soap);
				if (soap_in__wsnt__UnableToGetMessagesFaultType_Description(soap, "wsrfbf:Description", a->wsrfbf__Description, ""))
				{	a->__sizeDescription++;
					a->wsrfbf__Description = NULL;
					continue;
				}
			}
			if (soap_flag_wsrfbf__FaultCause && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_wsnt__UnableToGetMessagesFaultType_FaultCause(soap, "wsrfbf:FaultCause", &a->wsrfbf__FaultCause, ""))
				{	soap_flag_wsrfbf__FaultCause--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	if (a->__any == NULL)
				{	if (soap_blist___any == NULL)
						soap_blist___any = soap_alloc_block(soap);
					a->__any = (char **)soap_push_block_max(soap, soap_blist___any, sizeof(char *));
					if (a->__any == NULL)
						return NULL;
					*a->__any = NULL;
				}
				if (soap_inliteral(soap, "-any", (char**)a->__any))
				{	a->__size++;
					a->__any = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->__any)
			soap_pop_block(soap, soap_blist___any);
		if (a->__size)
		{	a->__any = (char **)soap_save_block(soap, soap_blist___any, NULL, 1);
		}
		else
		{	a->__any = NULL;
			if (soap_blist___any)
				soap_end_block(soap, soap_blist___any);
		}
		if (a->wsrfbf__Description)
			soap_pop_block(soap, soap_blist_wsrfbf__Description);
		if (a->__sizeDescription)
		{	a->wsrfbf__Description = (struct _wsnt__UnableToGetMessagesFaultType_Description *)soap_save_block(soap, soap_blist_wsrfbf__Description, NULL, 1);
		}
		else
		{	a->wsrfbf__Description = NULL;
			if (soap_blist_wsrfbf__Description)
				soap_end_block(soap, soap_blist_wsrfbf__Description);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_wsrfbf__Timestamp > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct wsnt__UnableToGetMessagesFaultType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_wsnt__UnableToGetMessagesFaultType, SOAP_TYPE_wsnt__UnableToGetMessagesFaultType, sizeof(struct wsnt__UnableToGetMessagesFaultType), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct wsnt__UnableToGetMessagesFaultType * SOAP_FMAC4 soap_new_wsnt__UnableToGetMessagesFaultType(struct soap *soap, int n)
{
	struct wsnt__UnableToGetMessagesFaultType *p;
	struct wsnt__UnableToGetMessagesFaultType *a = (struct wsnt__UnableToGetMessagesFaultType*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct wsnt__UnableToGetMessagesFaultType));
	for (p = a; p && n--; p++)
		soap_default_wsnt__UnableToGetMessagesFaultType(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_wsnt__UnableToGetMessagesFaultType(struct soap *soap, const struct wsnt__UnableToGetMessagesFaultType *a, const char *tag, const char *type)
{
	if (soap_out_wsnt__UnableToGetMessagesFaultType(soap, tag ? tag : "wsnt:UnableToGetMessagesFaultType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct wsnt__UnableToGetMessagesFaultType * SOAP_FMAC4 soap_get_wsnt__UnableToGetMessagesFaultType(struct soap *soap, struct wsnt__UnableToGetMessagesFaultType *p, const char *tag, const char *type)
{
	if ((p = soap_in_wsnt__UnableToGetMessagesFaultType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__wsnt__NoCurrentMessageOnTopicFaultType_FaultCause(struct soap *soap, struct _wsnt__NoCurrentMessageOnTopicFaultType_FaultCause *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__any = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__wsnt__NoCurrentMessageOnTopicFaultType_FaultCause(struct soap *soap, const struct _wsnt__NoCurrentMessageOnTopicFaultType_FaultCause *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__wsnt__NoCurrentMessageOnTopicFaultType_FaultCause(struct soap *soap, const char *tag, int id, const struct _wsnt__NoCurrentMessageOnTopicFaultType_FaultCause *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__wsnt__NoCurrentMessageOnTopicFaultType_FaultCause), type))
		return soap->error;
	if (soap_outliteral(soap, "-any", (char*const*)&a->__any, NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _wsnt__NoCurrentMessageOnTopicFaultType_FaultCause * SOAP_FMAC4 soap_in__wsnt__NoCurrentMessageOnTopicFaultType_FaultCause(struct soap *soap, const char *tag, struct _wsnt__NoCurrentMessageOnTopicFaultType_FaultCause *a, const char *type)
{
	size_t soap_flag___any = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct _wsnt__NoCurrentMessageOnTopicFaultType_FaultCause*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__wsnt__NoCurrentMessageOnTopicFaultType_FaultCause, sizeof(struct _wsnt__NoCurrentMessageOnTopicFaultType_FaultCause), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__wsnt__NoCurrentMessageOnTopicFaultType_FaultCause(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag___any && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_inliteral(soap, "-any", (char**)&a->__any))
				{	soap_flag___any--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _wsnt__NoCurrentMessageOnTopicFaultType_FaultCause *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__wsnt__NoCurrentMessageOnTopicFaultType_FaultCause, SOAP_TYPE__wsnt__NoCurrentMessageOnTopicFaultType_FaultCause, sizeof(struct _wsnt__NoCurrentMessageOnTopicFaultType_FaultCause), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _wsnt__NoCurrentMessageOnTopicFaultType_FaultCause * SOAP_FMAC4 soap_new__wsnt__NoCurrentMessageOnTopicFaultType_FaultCause(struct soap *soap, int n)
{
	struct _wsnt__NoCurrentMessageOnTopicFaultType_FaultCause *p;
	struct _wsnt__NoCurrentMessageOnTopicFaultType_FaultCause *a = (struct _wsnt__NoCurrentMessageOnTopicFaultType_FaultCause*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _wsnt__NoCurrentMessageOnTopicFaultType_FaultCause));
	for (p = a; p && n--; p++)
		soap_default__wsnt__NoCurrentMessageOnTopicFaultType_FaultCause(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__wsnt__NoCurrentMessageOnTopicFaultType_FaultCause(struct soap *soap, const struct _wsnt__NoCurrentMessageOnTopicFaultType_FaultCause *a, const char *tag, const char *type)
{
	if (soap_out__wsnt__NoCurrentMessageOnTopicFaultType_FaultCause(soap, tag ? tag : "wsnt:NoCurrentMessageOnTopicFaultType-FaultCause", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _wsnt__NoCurrentMessageOnTopicFaultType_FaultCause * SOAP_FMAC4 soap_get__wsnt__NoCurrentMessageOnTopicFaultType_FaultCause(struct soap *soap, struct _wsnt__NoCurrentMessageOnTopicFaultType_FaultCause *p, const char *tag, const char *type)
{
	if ((p = soap_in__wsnt__NoCurrentMessageOnTopicFaultType_FaultCause(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__wsnt__NoCurrentMessageOnTopicFaultType_Description(struct soap *soap, struct _wsnt__NoCurrentMessageOnTopicFaultType_Description *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->__item);
	soap_default__xml__lang(soap, &a->xml__lang);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__wsnt__NoCurrentMessageOnTopicFaultType_Description(struct soap *soap, const struct _wsnt__NoCurrentMessageOnTopicFaultType_Description *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_string(soap, (char*const*)&a->__item);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__wsnt__NoCurrentMessageOnTopicFaultType_Description(struct soap *soap, const char *tag, int id, const struct _wsnt__NoCurrentMessageOnTopicFaultType_Description *a, const char *type)
{
	if (a->xml__lang)
		soap_set_attr(soap, "xml:lang", soap__xml__lang2s(soap, a->xml__lang), 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	return soap_out_string(soap, tag, id, (char*const*)&a->__item, "");
}

SOAP_FMAC3 struct _wsnt__NoCurrentMessageOnTopicFaultType_Description * SOAP_FMAC4 soap_in__wsnt__NoCurrentMessageOnTopicFaultType_Description(struct soap *soap, const char *tag, struct _wsnt__NoCurrentMessageOnTopicFaultType_Description *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	if (!(a = (struct _wsnt__NoCurrentMessageOnTopicFaultType_Description *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__wsnt__NoCurrentMessageOnTopicFaultType_Description, sizeof(struct _wsnt__NoCurrentMessageOnTopicFaultType_Description), NULL, NULL, NULL, NULL)))
		return NULL;
	soap_revert(soap);
	*soap->id = '\0';
	soap_default__wsnt__NoCurrentMessageOnTopicFaultType_Description(soap, a);
	if (soap_s2_xml__lang(soap, soap_attr_value(soap, "xml:lang", 1, 0), &a->xml__lang))
		return NULL;
	if (!soap_in_string(soap, tag, (char**)&a->__item, ""))
		return NULL;
	return a;
}

SOAP_FMAC3 struct _wsnt__NoCurrentMessageOnTopicFaultType_Description * SOAP_FMAC4 soap_new__wsnt__NoCurrentMessageOnTopicFaultType_Description(struct soap *soap, int n)
{
	struct _wsnt__NoCurrentMessageOnTopicFaultType_Description *p;
	struct _wsnt__NoCurrentMessageOnTopicFaultType_Description *a = (struct _wsnt__NoCurrentMessageOnTopicFaultType_Description*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _wsnt__NoCurrentMessageOnTopicFaultType_Description));
	for (p = a; p && n--; p++)
		soap_default__wsnt__NoCurrentMessageOnTopicFaultType_Description(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__wsnt__NoCurrentMessageOnTopicFaultType_Description(struct soap *soap, const struct _wsnt__NoCurrentMessageOnTopicFaultType_Description *a, const char *tag, const char *type)
{
	if (soap_out__wsnt__NoCurrentMessageOnTopicFaultType_Description(soap, tag ? tag : "wsnt:NoCurrentMessageOnTopicFaultType-Description", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _wsnt__NoCurrentMessageOnTopicFaultType_Description * SOAP_FMAC4 soap_get__wsnt__NoCurrentMessageOnTopicFaultType_Description(struct soap *soap, struct _wsnt__NoCurrentMessageOnTopicFaultType_Description *p, const char *tag, const char *type)
{
	if ((p = soap_in__wsnt__NoCurrentMessageOnTopicFaultType_Description(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__wsnt__NoCurrentMessageOnTopicFaultType_ErrorCode(struct soap *soap, struct _wsnt__NoCurrentMessageOnTopicFaultType_ErrorCode *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_xsd__anyURI(soap, &a->dialect);
	a->__mixed = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__wsnt__NoCurrentMessageOnTopicFaultType_ErrorCode(struct soap *soap, const struct _wsnt__NoCurrentMessageOnTopicFaultType_ErrorCode *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__wsnt__NoCurrentMessageOnTopicFaultType_ErrorCode(struct soap *soap, const char *tag, int id, const struct _wsnt__NoCurrentMessageOnTopicFaultType_ErrorCode *a, const char *type)
{
	soap_set_attr(soap, "dialect", a->dialect ? soap_xsd__anyURI2s(soap, a->dialect) : "", 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__wsnt__NoCurrentMessageOnTopicFaultType_ErrorCode), type))
		return soap->error;
	if (soap_outliteral(soap, "-mixed", (char*const*)&a->__mixed, NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _wsnt__NoCurrentMessageOnTopicFaultType_ErrorCode * SOAP_FMAC4 soap_in__wsnt__NoCurrentMessageOnTopicFaultType_ErrorCode(struct soap *soap, const char *tag, struct _wsnt__NoCurrentMessageOnTopicFaultType_ErrorCode *a, const char *type)
{
	size_t soap_flag___mixed = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct _wsnt__NoCurrentMessageOnTopicFaultType_ErrorCode*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__wsnt__NoCurrentMessageOnTopicFaultType_ErrorCode, sizeof(struct _wsnt__NoCurrentMessageOnTopicFaultType_ErrorCode), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__wsnt__NoCurrentMessageOnTopicFaultType_ErrorCode(soap, a);
	if (soap_s2xsd__anyURI(soap, soap_attr_value(soap, "dialect", 4, 1), &a->dialect))
		return NULL;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag___mixed && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_inliteral(soap, "-mixed", (char**)&a->__mixed))
				{	soap_flag___mixed--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _wsnt__NoCurrentMessageOnTopicFaultType_ErrorCode *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__wsnt__NoCurrentMessageOnTopicFaultType_ErrorCode, SOAP_TYPE__wsnt__NoCurrentMessageOnTopicFaultType_ErrorCode, sizeof(struct _wsnt__NoCurrentMessageOnTopicFaultType_ErrorCode), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _wsnt__NoCurrentMessageOnTopicFaultType_ErrorCode * SOAP_FMAC4 soap_new__wsnt__NoCurrentMessageOnTopicFaultType_ErrorCode(struct soap *soap, int n)
{
	struct _wsnt__NoCurrentMessageOnTopicFaultType_ErrorCode *p;
	struct _wsnt__NoCurrentMessageOnTopicFaultType_ErrorCode *a = (struct _wsnt__NoCurrentMessageOnTopicFaultType_ErrorCode*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _wsnt__NoCurrentMessageOnTopicFaultType_ErrorCode));
	for (p = a; p && n--; p++)
		soap_default__wsnt__NoCurrentMessageOnTopicFaultType_ErrorCode(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__wsnt__NoCurrentMessageOnTopicFaultType_ErrorCode(struct soap *soap, const struct _wsnt__NoCurrentMessageOnTopicFaultType_ErrorCode *a, const char *tag, const char *type)
{
	if (soap_out__wsnt__NoCurrentMessageOnTopicFaultType_ErrorCode(soap, tag ? tag : "wsnt:NoCurrentMessageOnTopicFaultType-ErrorCode", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _wsnt__NoCurrentMessageOnTopicFaultType_ErrorCode * SOAP_FMAC4 soap_get__wsnt__NoCurrentMessageOnTopicFaultType_ErrorCode(struct soap *soap, struct _wsnt__NoCurrentMessageOnTopicFaultType_ErrorCode *p, const char *tag, const char *type)
{
	if ((p = soap_in__wsnt__NoCurrentMessageOnTopicFaultType_ErrorCode(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_wsnt__NoCurrentMessageOnTopicFaultType(struct soap *soap, struct wsnt__NoCurrentMessageOnTopicFaultType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__size = 0;
	a->__any = NULL;
	soap_default_dateTime(soap, &a->wsrfbf__Timestamp);
	a->wsrfbf__Originator = NULL;
	a->wsrfbf__ErrorCode = NULL;
	a->__sizeDescription = 0;
	a->wsrfbf__Description = NULL;
	a->wsrfbf__FaultCause = NULL;
	a->__anyAttribute = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_wsnt__NoCurrentMessageOnTopicFaultType(struct soap *soap, const struct wsnt__NoCurrentMessageOnTopicFaultType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &a->wsrfbf__Timestamp, SOAP_TYPE_dateTime);
	soap_serialize_PointerTowsa5__EndpointReferenceType(soap, &a->wsrfbf__Originator);
	soap_serialize_PointerTo_wsnt__NoCurrentMessageOnTopicFaultType_ErrorCode(soap, &a->wsrfbf__ErrorCode);
	if (a->wsrfbf__Description)
	{	int i;
		for (i = 0; i < (int)a->__sizeDescription; i++)
		{
			soap_embedded(soap, a->wsrfbf__Description + i, SOAP_TYPE__wsnt__NoCurrentMessageOnTopicFaultType_Description);
			soap_serialize__wsnt__NoCurrentMessageOnTopicFaultType_Description(soap, a->wsrfbf__Description + i);
		}
	}
	soap_serialize_PointerTo_wsnt__NoCurrentMessageOnTopicFaultType_FaultCause(soap, &a->wsrfbf__FaultCause);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_wsnt__NoCurrentMessageOnTopicFaultType(struct soap *soap, const char *tag, int id, const struct wsnt__NoCurrentMessageOnTopicFaultType *a, const char *type)
{
	if (a->__anyAttribute)
		soap_set_attr(soap, "-anyAttribute", a->__anyAttribute, 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_wsnt__NoCurrentMessageOnTopicFaultType), type))
		return soap->error;
	if (a->__any)
	{	int i;
		for (i = 0; i < (int)a->__size; i++)
			if (soap_outliteral(soap, "-any", (char*const*)(a->__any + i), NULL))
				return soap->error;
	}
	if (soap_out_dateTime(soap, "wsrfbf:Timestamp", -1, &a->wsrfbf__Timestamp, ""))
		return soap->error;
	if (soap_out_PointerTowsa5__EndpointReferenceType(soap, "wsrfbf:Originator", -1, &a->wsrfbf__Originator, ""))
		return soap->error;
	if (soap_out_PointerTo_wsnt__NoCurrentMessageOnTopicFaultType_ErrorCode(soap, "wsrfbf:ErrorCode", -1, &a->wsrfbf__ErrorCode, ""))
		return soap->error;
	if (a->wsrfbf__Description)
	{	int i;
		for (i = 0; i < (int)a->__sizeDescription; i++)
			if (soap_out__wsnt__NoCurrentMessageOnTopicFaultType_Description(soap, "wsrfbf:Description", -1, a->wsrfbf__Description + i, ""))
				return soap->error;
	}
	if (soap_out_PointerTo_wsnt__NoCurrentMessageOnTopicFaultType_FaultCause(soap, "wsrfbf:FaultCause", -1, &a->wsrfbf__FaultCause, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct wsnt__NoCurrentMessageOnTopicFaultType * SOAP_FMAC4 soap_in_wsnt__NoCurrentMessageOnTopicFaultType(struct soap *soap, const char *tag, struct wsnt__NoCurrentMessageOnTopicFaultType *a, const char *type)
{
	struct soap_blist *soap_blist___any = NULL;
	size_t soap_flag_wsrfbf__Timestamp = 1;
	size_t soap_flag_wsrfbf__Originator = 1;
	size_t soap_flag_wsrfbf__ErrorCode = 1;
	struct soap_blist *soap_blist_wsrfbf__Description = NULL;
	size_t soap_flag_wsrfbf__FaultCause = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct wsnt__NoCurrentMessageOnTopicFaultType*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_wsnt__NoCurrentMessageOnTopicFaultType, sizeof(struct wsnt__NoCurrentMessageOnTopicFaultType), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_wsnt__NoCurrentMessageOnTopicFaultType(soap, a);
	if (soap_s2char(soap, soap_attr_value(soap, "-anyAttribute", 0, 0), &a->__anyAttribute, 0, 0, -1, NULL))
		return NULL;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_wsrfbf__Timestamp && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_dateTime(soap, "wsrfbf:Timestamp", &a->wsrfbf__Timestamp, "xsd:dateTime"))
				{	soap_flag_wsrfbf__Timestamp--;
					continue;
				}
			}
			if (soap_flag_wsrfbf__Originator && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTowsa5__EndpointReferenceType(soap, "wsrfbf:Originator", &a->wsrfbf__Originator, "wsa5:EndpointReferenceType"))
				{	soap_flag_wsrfbf__Originator--;
					continue;
				}
			}
			if (soap_flag_wsrfbf__ErrorCode && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_wsnt__NoCurrentMessageOnTopicFaultType_ErrorCode(soap, "wsrfbf:ErrorCode", &a->wsrfbf__ErrorCode, ""))
				{	soap_flag_wsrfbf__ErrorCode--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "wsrfbf:Description", 1, NULL))
			{	if (a->wsrfbf__Description == NULL)
				{	if (soap_blist_wsrfbf__Description == NULL)
						soap_blist_wsrfbf__Description = soap_alloc_block(soap);
					a->wsrfbf__Description = (struct _wsnt__NoCurrentMessageOnTopicFaultType_Description *)soap_push_block_max(soap, soap_blist_wsrfbf__Description, sizeof(struct _wsnt__NoCurrentMessageOnTopicFaultType_Description));
					if (a->wsrfbf__Description == NULL)
						return NULL;
					soap_default__wsnt__NoCurrentMessageOnTopicFaultType_Description(soap, a->wsrfbf__Description);
				}
				soap_revert(soap);
				if (soap_in__wsnt__NoCurrentMessageOnTopicFaultType_Description(soap, "wsrfbf:Description", a->wsrfbf__Description, ""))
				{	a->__sizeDescription++;
					a->wsrfbf__Description = NULL;
					continue;
				}
			}
			if (soap_flag_wsrfbf__FaultCause && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_wsnt__NoCurrentMessageOnTopicFaultType_FaultCause(soap, "wsrfbf:FaultCause", &a->wsrfbf__FaultCause, ""))
				{	soap_flag_wsrfbf__FaultCause--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	if (a->__any == NULL)
				{	if (soap_blist___any == NULL)
						soap_blist___any = soap_alloc_block(soap);
					a->__any = (char **)soap_push_block_max(soap, soap_blist___any, sizeof(char *));
					if (a->__any == NULL)
						return NULL;
					*a->__any = NULL;
				}
				if (soap_inliteral(soap, "-any", (char**)a->__any))
				{	a->__size++;
					a->__any = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->__any)
			soap_pop_block(soap, soap_blist___any);
		if (a->__size)
		{	a->__any = (char **)soap_save_block(soap, soap_blist___any, NULL, 1);
		}
		else
		{	a->__any = NULL;
			if (soap_blist___any)
				soap_end_block(soap, soap_blist___any);
		}
		if (a->wsrfbf__Description)
			soap_pop_block(soap, soap_blist_wsrfbf__Description);
		if (a->__sizeDescription)
		{	a->wsrfbf__Description = (struct _wsnt__NoCurrentMessageOnTopicFaultType_Description *)soap_save_block(soap, soap_blist_wsrfbf__Description, NULL, 1);
		}
		else
		{	a->wsrfbf__Description = NULL;
			if (soap_blist_wsrfbf__Description)
				soap_end_block(soap, soap_blist_wsrfbf__Description);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_wsrfbf__Timestamp > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct wsnt__NoCurrentMessageOnTopicFaultType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_wsnt__NoCurrentMessageOnTopicFaultType, SOAP_TYPE_wsnt__NoCurrentMessageOnTopicFaultType, sizeof(struct wsnt__NoCurrentMessageOnTopicFaultType), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct wsnt__NoCurrentMessageOnTopicFaultType * SOAP_FMAC4 soap_new_wsnt__NoCurrentMessageOnTopicFaultType(struct soap *soap, int n)
{
	struct wsnt__NoCurrentMessageOnTopicFaultType *p;
	struct wsnt__NoCurrentMessageOnTopicFaultType *a = (struct wsnt__NoCurrentMessageOnTopicFaultType*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct wsnt__NoCurrentMessageOnTopicFaultType));
	for (p = a; p && n--; p++)
		soap_default_wsnt__NoCurrentMessageOnTopicFaultType(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_wsnt__NoCurrentMessageOnTopicFaultType(struct soap *soap, const struct wsnt__NoCurrentMessageOnTopicFaultType *a, const char *tag, const char *type)
{
	if (soap_out_wsnt__NoCurrentMessageOnTopicFaultType(soap, tag ? tag : "wsnt:NoCurrentMessageOnTopicFaultType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct wsnt__NoCurrentMessageOnTopicFaultType * SOAP_FMAC4 soap_get_wsnt__NoCurrentMessageOnTopicFaultType(struct soap *soap, struct wsnt__NoCurrentMessageOnTopicFaultType *p, const char *tag, const char *type)
{
	if ((p = soap_in_wsnt__NoCurrentMessageOnTopicFaultType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__wsnt__UnacceptableInitialTerminationTimeFaultType_FaultCause(struct soap *soap, struct _wsnt__UnacceptableInitialTerminationTimeFaultType_FaultCause *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__any = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__wsnt__UnacceptableInitialTerminationTimeFaultType_FaultCause(struct soap *soap, const struct _wsnt__UnacceptableInitialTerminationTimeFaultType_FaultCause *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__wsnt__UnacceptableInitialTerminationTimeFaultType_FaultCause(struct soap *soap, const char *tag, int id, const struct _wsnt__UnacceptableInitialTerminationTimeFaultType_FaultCause *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__wsnt__UnacceptableInitialTerminationTimeFaultType_FaultCause), type))
		return soap->error;
	if (soap_outliteral(soap, "-any", (char*const*)&a->__any, NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _wsnt__UnacceptableInitialTerminationTimeFaultType_FaultCause * SOAP_FMAC4 soap_in__wsnt__UnacceptableInitialTerminationTimeFaultType_FaultCause(struct soap *soap, const char *tag, struct _wsnt__UnacceptableInitialTerminationTimeFaultType_FaultCause *a, const char *type)
{
	size_t soap_flag___any = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct _wsnt__UnacceptableInitialTerminationTimeFaultType_FaultCause*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__wsnt__UnacceptableInitialTerminationTimeFaultType_FaultCause, sizeof(struct _wsnt__UnacceptableInitialTerminationTimeFaultType_FaultCause), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__wsnt__UnacceptableInitialTerminationTimeFaultType_FaultCause(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag___any && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_inliteral(soap, "-any", (char**)&a->__any))
				{	soap_flag___any--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _wsnt__UnacceptableInitialTerminationTimeFaultType_FaultCause *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__wsnt__UnacceptableInitialTerminationTimeFaultType_FaultCause, SOAP_TYPE__wsnt__UnacceptableInitialTerminationTimeFaultType_FaultCause, sizeof(struct _wsnt__UnacceptableInitialTerminationTimeFaultType_FaultCause), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _wsnt__UnacceptableInitialTerminationTimeFaultType_FaultCause * SOAP_FMAC4 soap_new__wsnt__UnacceptableInitialTerminationTimeFaultType_FaultCause(struct soap *soap, int n)
{
	struct _wsnt__UnacceptableInitialTerminationTimeFaultType_FaultCause *p;
	struct _wsnt__UnacceptableInitialTerminationTimeFaultType_FaultCause *a = (struct _wsnt__UnacceptableInitialTerminationTimeFaultType_FaultCause*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _wsnt__UnacceptableInitialTerminationTimeFaultType_FaultCause));
	for (p = a; p && n--; p++)
		soap_default__wsnt__UnacceptableInitialTerminationTimeFaultType_FaultCause(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__wsnt__UnacceptableInitialTerminationTimeFaultType_FaultCause(struct soap *soap, const struct _wsnt__UnacceptableInitialTerminationTimeFaultType_FaultCause *a, const char *tag, const char *type)
{
	if (soap_out__wsnt__UnacceptableInitialTerminationTimeFaultType_FaultCause(soap, tag ? tag : "wsnt:UnacceptableInitialTerminationTimeFaultType-FaultCause", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _wsnt__UnacceptableInitialTerminationTimeFaultType_FaultCause * SOAP_FMAC4 soap_get__wsnt__UnacceptableInitialTerminationTimeFaultType_FaultCause(struct soap *soap, struct _wsnt__UnacceptableInitialTerminationTimeFaultType_FaultCause *p, const char *tag, const char *type)
{
	if ((p = soap_in__wsnt__UnacceptableInitialTerminationTimeFaultType_FaultCause(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__wsnt__UnacceptableInitialTerminationTimeFaultType_Description(struct soap *soap, struct _wsnt__UnacceptableInitialTerminationTimeFaultType_Description *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->__item);
	soap_default__xml__lang(soap, &a->xml__lang);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__wsnt__UnacceptableInitialTerminationTimeFaultType_Description(struct soap *soap, const struct _wsnt__UnacceptableInitialTerminationTimeFaultType_Description *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_string(soap, (char*const*)&a->__item);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__wsnt__UnacceptableInitialTerminationTimeFaultType_Description(struct soap *soap, const char *tag, int id, const struct _wsnt__UnacceptableInitialTerminationTimeFaultType_Description *a, const char *type)
{
	if (a->xml__lang)
		soap_set_attr(soap, "xml:lang", soap__xml__lang2s(soap, a->xml__lang), 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	return soap_out_string(soap, tag, id, (char*const*)&a->__item, "");
}

SOAP_FMAC3 struct _wsnt__UnacceptableInitialTerminationTimeFaultType_Description * SOAP_FMAC4 soap_in__wsnt__UnacceptableInitialTerminationTimeFaultType_Description(struct soap *soap, const char *tag, struct _wsnt__UnacceptableInitialTerminationTimeFaultType_Description *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	if (!(a = (struct _wsnt__UnacceptableInitialTerminationTimeFaultType_Description *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__wsnt__UnacceptableInitialTerminationTimeFaultType_Description, sizeof(struct _wsnt__UnacceptableInitialTerminationTimeFaultType_Description), NULL, NULL, NULL, NULL)))
		return NULL;
	soap_revert(soap);
	*soap->id = '\0';
	soap_default__wsnt__UnacceptableInitialTerminationTimeFaultType_Description(soap, a);
	if (soap_s2_xml__lang(soap, soap_attr_value(soap, "xml:lang", 1, 0), &a->xml__lang))
		return NULL;
	if (!soap_in_string(soap, tag, (char**)&a->__item, ""))
		return NULL;
	return a;
}

SOAP_FMAC3 struct _wsnt__UnacceptableInitialTerminationTimeFaultType_Description * SOAP_FMAC4 soap_new__wsnt__UnacceptableInitialTerminationTimeFaultType_Description(struct soap *soap, int n)
{
	struct _wsnt__UnacceptableInitialTerminationTimeFaultType_Description *p;
	struct _wsnt__UnacceptableInitialTerminationTimeFaultType_Description *a = (struct _wsnt__UnacceptableInitialTerminationTimeFaultType_Description*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _wsnt__UnacceptableInitialTerminationTimeFaultType_Description));
	for (p = a; p && n--; p++)
		soap_default__wsnt__UnacceptableInitialTerminationTimeFaultType_Description(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__wsnt__UnacceptableInitialTerminationTimeFaultType_Description(struct soap *soap, const struct _wsnt__UnacceptableInitialTerminationTimeFaultType_Description *a, const char *tag, const char *type)
{
	if (soap_out__wsnt__UnacceptableInitialTerminationTimeFaultType_Description(soap, tag ? tag : "wsnt:UnacceptableInitialTerminationTimeFaultType-Description", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _wsnt__UnacceptableInitialTerminationTimeFaultType_Description * SOAP_FMAC4 soap_get__wsnt__UnacceptableInitialTerminationTimeFaultType_Description(struct soap *soap, struct _wsnt__UnacceptableInitialTerminationTimeFaultType_Description *p, const char *tag, const char *type)
{
	if ((p = soap_in__wsnt__UnacceptableInitialTerminationTimeFaultType_Description(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__wsnt__UnacceptableInitialTerminationTimeFaultType_ErrorCode(struct soap *soap, struct _wsnt__UnacceptableInitialTerminationTimeFaultType_ErrorCode *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_xsd__anyURI(soap, &a->dialect);
	a->__mixed = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__wsnt__UnacceptableInitialTerminationTimeFaultType_ErrorCode(struct soap *soap, const struct _wsnt__UnacceptableInitialTerminationTimeFaultType_ErrorCode *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__wsnt__UnacceptableInitialTerminationTimeFaultType_ErrorCode(struct soap *soap, const char *tag, int id, const struct _wsnt__UnacceptableInitialTerminationTimeFaultType_ErrorCode *a, const char *type)
{
	soap_set_attr(soap, "dialect", a->dialect ? soap_xsd__anyURI2s(soap, a->dialect) : "", 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__wsnt__UnacceptableInitialTerminationTimeFaultType_ErrorCode), type))
		return soap->error;
	if (soap_outliteral(soap, "-mixed", (char*const*)&a->__mixed, NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _wsnt__UnacceptableInitialTerminationTimeFaultType_ErrorCode * SOAP_FMAC4 soap_in__wsnt__UnacceptableInitialTerminationTimeFaultType_ErrorCode(struct soap *soap, const char *tag, struct _wsnt__UnacceptableInitialTerminationTimeFaultType_ErrorCode *a, const char *type)
{
	size_t soap_flag___mixed = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct _wsnt__UnacceptableInitialTerminationTimeFaultType_ErrorCode*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__wsnt__UnacceptableInitialTerminationTimeFaultType_ErrorCode, sizeof(struct _wsnt__UnacceptableInitialTerminationTimeFaultType_ErrorCode), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__wsnt__UnacceptableInitialTerminationTimeFaultType_ErrorCode(soap, a);
	if (soap_s2xsd__anyURI(soap, soap_attr_value(soap, "dialect", 4, 1), &a->dialect))
		return NULL;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag___mixed && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_inliteral(soap, "-mixed", (char**)&a->__mixed))
				{	soap_flag___mixed--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _wsnt__UnacceptableInitialTerminationTimeFaultType_ErrorCode *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__wsnt__UnacceptableInitialTerminationTimeFaultType_ErrorCode, SOAP_TYPE__wsnt__UnacceptableInitialTerminationTimeFaultType_ErrorCode, sizeof(struct _wsnt__UnacceptableInitialTerminationTimeFaultType_ErrorCode), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _wsnt__UnacceptableInitialTerminationTimeFaultType_ErrorCode * SOAP_FMAC4 soap_new__wsnt__UnacceptableInitialTerminationTimeFaultType_ErrorCode(struct soap *soap, int n)
{
	struct _wsnt__UnacceptableInitialTerminationTimeFaultType_ErrorCode *p;
	struct _wsnt__UnacceptableInitialTerminationTimeFaultType_ErrorCode *a = (struct _wsnt__UnacceptableInitialTerminationTimeFaultType_ErrorCode*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _wsnt__UnacceptableInitialTerminationTimeFaultType_ErrorCode));
	for (p = a; p && n--; p++)
		soap_default__wsnt__UnacceptableInitialTerminationTimeFaultType_ErrorCode(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__wsnt__UnacceptableInitialTerminationTimeFaultType_ErrorCode(struct soap *soap, const struct _wsnt__UnacceptableInitialTerminationTimeFaultType_ErrorCode *a, const char *tag, const char *type)
{
	if (soap_out__wsnt__UnacceptableInitialTerminationTimeFaultType_ErrorCode(soap, tag ? tag : "wsnt:UnacceptableInitialTerminationTimeFaultType-ErrorCode", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _wsnt__UnacceptableInitialTerminationTimeFaultType_ErrorCode * SOAP_FMAC4 soap_get__wsnt__UnacceptableInitialTerminationTimeFaultType_ErrorCode(struct soap *soap, struct _wsnt__UnacceptableInitialTerminationTimeFaultType_ErrorCode *p, const char *tag, const char *type)
{
	if ((p = soap_in__wsnt__UnacceptableInitialTerminationTimeFaultType_ErrorCode(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_wsnt__UnacceptableInitialTerminationTimeFaultType(struct soap *soap, struct wsnt__UnacceptableInitialTerminationTimeFaultType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__size = 0;
	a->__any = NULL;
	soap_default_dateTime(soap, &a->wsrfbf__Timestamp);
	a->wsrfbf__Originator = NULL;
	a->wsrfbf__ErrorCode = NULL;
	a->__sizeDescription = 0;
	a->wsrfbf__Description = NULL;
	a->wsrfbf__FaultCause = NULL;
	a->__anyAttribute = NULL;
	soap_default_dateTime(soap, &a->MinimumTime);
	a->MaximumTime = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_wsnt__UnacceptableInitialTerminationTimeFaultType(struct soap *soap, const struct wsnt__UnacceptableInitialTerminationTimeFaultType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &a->wsrfbf__Timestamp, SOAP_TYPE_dateTime);
	soap_serialize_PointerTowsa5__EndpointReferenceType(soap, &a->wsrfbf__Originator);
	soap_serialize_PointerTo_wsnt__UnacceptableInitialTerminationTimeFaultType_ErrorCode(soap, &a->wsrfbf__ErrorCode);
	if (a->wsrfbf__Description)
	{	int i;
		for (i = 0; i < (int)a->__sizeDescription; i++)
		{
			soap_embedded(soap, a->wsrfbf__Description + i, SOAP_TYPE__wsnt__UnacceptableInitialTerminationTimeFaultType_Description);
			soap_serialize__wsnt__UnacceptableInitialTerminationTimeFaultType_Description(soap, a->wsrfbf__Description + i);
		}
	}
	soap_serialize_PointerTo_wsnt__UnacceptableInitialTerminationTimeFaultType_FaultCause(soap, &a->wsrfbf__FaultCause);
	soap_embedded(soap, &a->MinimumTime, SOAP_TYPE_dateTime);
	soap_serialize_PointerTodateTime(soap, &a->MaximumTime);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_wsnt__UnacceptableInitialTerminationTimeFaultType(struct soap *soap, const char *tag, int id, const struct wsnt__UnacceptableInitialTerminationTimeFaultType *a, const char *type)
{
	if (a->__anyAttribute)
		soap_set_attr(soap, "-anyAttribute", a->__anyAttribute, 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_wsnt__UnacceptableInitialTerminationTimeFaultType), type))
		return soap->error;
	if (a->__any)
	{	int i;
		for (i = 0; i < (int)a->__size; i++)
			if (soap_outliteral(soap, "-any", (char*const*)(a->__any + i), NULL))
				return soap->error;
	}
	if (soap_out_dateTime(soap, "wsrfbf:Timestamp", -1, &a->wsrfbf__Timestamp, ""))
		return soap->error;
	if (soap_out_PointerTowsa5__EndpointReferenceType(soap, "wsrfbf:Originator", -1, &a->wsrfbf__Originator, ""))
		return soap->error;
	if (soap_out_PointerTo_wsnt__UnacceptableInitialTerminationTimeFaultType_ErrorCode(soap, "wsrfbf:ErrorCode", -1, &a->wsrfbf__ErrorCode, ""))
		return soap->error;
	if (a->wsrfbf__Description)
	{	int i;
		for (i = 0; i < (int)a->__sizeDescription; i++)
			if (soap_out__wsnt__UnacceptableInitialTerminationTimeFaultType_Description(soap, "wsrfbf:Description", -1, a->wsrfbf__Description + i, ""))
				return soap->error;
	}
	if (soap_out_PointerTo_wsnt__UnacceptableInitialTerminationTimeFaultType_FaultCause(soap, "wsrfbf:FaultCause", -1, &a->wsrfbf__FaultCause, ""))
		return soap->error;
	if (soap_out_dateTime(soap, "wsnt:MinimumTime", -1, &a->MinimumTime, ""))
		return soap->error;
	if (soap_out_PointerTodateTime(soap, "wsnt:MaximumTime", -1, &a->MaximumTime, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct wsnt__UnacceptableInitialTerminationTimeFaultType * SOAP_FMAC4 soap_in_wsnt__UnacceptableInitialTerminationTimeFaultType(struct soap *soap, const char *tag, struct wsnt__UnacceptableInitialTerminationTimeFaultType *a, const char *type)
{
	struct soap_blist *soap_blist___any = NULL;
	size_t soap_flag_wsrfbf__Timestamp = 1;
	size_t soap_flag_wsrfbf__Originator = 1;
	size_t soap_flag_wsrfbf__ErrorCode = 1;
	struct soap_blist *soap_blist_wsrfbf__Description = NULL;
	size_t soap_flag_wsrfbf__FaultCause = 1;
	size_t soap_flag_MinimumTime = 1;
	size_t soap_flag_MaximumTime = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct wsnt__UnacceptableInitialTerminationTimeFaultType*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_wsnt__UnacceptableInitialTerminationTimeFaultType, sizeof(struct wsnt__UnacceptableInitialTerminationTimeFaultType), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_wsnt__UnacceptableInitialTerminationTimeFaultType(soap, a);
	if (soap_s2char(soap, soap_attr_value(soap, "-anyAttribute", 0, 0), &a->__anyAttribute, 0, 0, -1, NULL))
		return NULL;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_wsrfbf__Timestamp && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_dateTime(soap, "wsrfbf:Timestamp", &a->wsrfbf__Timestamp, "xsd:dateTime"))
				{	soap_flag_wsrfbf__Timestamp--;
					continue;
				}
			}
			if (soap_flag_wsrfbf__Originator && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTowsa5__EndpointReferenceType(soap, "wsrfbf:Originator", &a->wsrfbf__Originator, "wsa5:EndpointReferenceType"))
				{	soap_flag_wsrfbf__Originator--;
					continue;
				}
			}
			if (soap_flag_wsrfbf__ErrorCode && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_wsnt__UnacceptableInitialTerminationTimeFaultType_ErrorCode(soap, "wsrfbf:ErrorCode", &a->wsrfbf__ErrorCode, ""))
				{	soap_flag_wsrfbf__ErrorCode--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "wsrfbf:Description", 1, NULL))
			{	if (a->wsrfbf__Description == NULL)
				{	if (soap_blist_wsrfbf__Description == NULL)
						soap_blist_wsrfbf__Description = soap_alloc_block(soap);
					a->wsrfbf__Description = (struct _wsnt__UnacceptableInitialTerminationTimeFaultType_Description *)soap_push_block_max(soap, soap_blist_wsrfbf__Description, sizeof(struct _wsnt__UnacceptableInitialTerminationTimeFaultType_Description));
					if (a->wsrfbf__Description == NULL)
						return NULL;
					soap_default__wsnt__UnacceptableInitialTerminationTimeFaultType_Description(soap, a->wsrfbf__Description);
				}
				soap_revert(soap);
				if (soap_in__wsnt__UnacceptableInitialTerminationTimeFaultType_Description(soap, "wsrfbf:Description", a->wsrfbf__Description, ""))
				{	a->__sizeDescription++;
					a->wsrfbf__Description = NULL;
					continue;
				}
			}
			if (soap_flag_wsrfbf__FaultCause && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_wsnt__UnacceptableInitialTerminationTimeFaultType_FaultCause(soap, "wsrfbf:FaultCause", &a->wsrfbf__FaultCause, ""))
				{	soap_flag_wsrfbf__FaultCause--;
					continue;
				}
			}
			if (soap_flag_MinimumTime && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_dateTime(soap, "wsnt:MinimumTime", &a->MinimumTime, "xsd:dateTime"))
				{	soap_flag_MinimumTime--;
					continue;
				}
			}
			if (soap_flag_MaximumTime && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTodateTime(soap, "wsnt:MaximumTime", &a->MaximumTime, "xsd:dateTime"))
				{	soap_flag_MaximumTime--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	if (a->__any == NULL)
				{	if (soap_blist___any == NULL)
						soap_blist___any = soap_alloc_block(soap);
					a->__any = (char **)soap_push_block_max(soap, soap_blist___any, sizeof(char *));
					if (a->__any == NULL)
						return NULL;
					*a->__any = NULL;
				}
				if (soap_inliteral(soap, "-any", (char**)a->__any))
				{	a->__size++;
					a->__any = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->__any)
			soap_pop_block(soap, soap_blist___any);
		if (a->__size)
		{	a->__any = (char **)soap_save_block(soap, soap_blist___any, NULL, 1);
		}
		else
		{	a->__any = NULL;
			if (soap_blist___any)
				soap_end_block(soap, soap_blist___any);
		}
		if (a->wsrfbf__Description)
			soap_pop_block(soap, soap_blist_wsrfbf__Description);
		if (a->__sizeDescription)
		{	a->wsrfbf__Description = (struct _wsnt__UnacceptableInitialTerminationTimeFaultType_Description *)soap_save_block(soap, soap_blist_wsrfbf__Description, NULL, 1);
		}
		else
		{	a->wsrfbf__Description = NULL;
			if (soap_blist_wsrfbf__Description)
				soap_end_block(soap, soap_blist_wsrfbf__Description);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_wsrfbf__Timestamp > 0 || soap_flag_MinimumTime > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct wsnt__UnacceptableInitialTerminationTimeFaultType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_wsnt__UnacceptableInitialTerminationTimeFaultType, SOAP_TYPE_wsnt__UnacceptableInitialTerminationTimeFaultType, sizeof(struct wsnt__UnacceptableInitialTerminationTimeFaultType), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct wsnt__UnacceptableInitialTerminationTimeFaultType * SOAP_FMAC4 soap_new_wsnt__UnacceptableInitialTerminationTimeFaultType(struct soap *soap, int n)
{
	struct wsnt__UnacceptableInitialTerminationTimeFaultType *p;
	struct wsnt__UnacceptableInitialTerminationTimeFaultType *a = (struct wsnt__UnacceptableInitialTerminationTimeFaultType*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct wsnt__UnacceptableInitialTerminationTimeFaultType));
	for (p = a; p && n--; p++)
		soap_default_wsnt__UnacceptableInitialTerminationTimeFaultType(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_wsnt__UnacceptableInitialTerminationTimeFaultType(struct soap *soap, const struct wsnt__UnacceptableInitialTerminationTimeFaultType *a, const char *tag, const char *type)
{
	if (soap_out_wsnt__UnacceptableInitialTerminationTimeFaultType(soap, tag ? tag : "wsnt:UnacceptableInitialTerminationTimeFaultType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct wsnt__UnacceptableInitialTerminationTimeFaultType * SOAP_FMAC4 soap_get_wsnt__UnacceptableInitialTerminationTimeFaultType(struct soap *soap, struct wsnt__UnacceptableInitialTerminationTimeFaultType *p, const char *tag, const char *type)
{
	if ((p = soap_in_wsnt__UnacceptableInitialTerminationTimeFaultType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__wsnt__NotifyMessageNotSupportedFaultType_FaultCause(struct soap *soap, struct _wsnt__NotifyMessageNotSupportedFaultType_FaultCause *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__any = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__wsnt__NotifyMessageNotSupportedFaultType_FaultCause(struct soap *soap, const struct _wsnt__NotifyMessageNotSupportedFaultType_FaultCause *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__wsnt__NotifyMessageNotSupportedFaultType_FaultCause(struct soap *soap, const char *tag, int id, const struct _wsnt__NotifyMessageNotSupportedFaultType_FaultCause *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__wsnt__NotifyMessageNotSupportedFaultType_FaultCause), type))
		return soap->error;
	if (soap_outliteral(soap, "-any", (char*const*)&a->__any, NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _wsnt__NotifyMessageNotSupportedFaultType_FaultCause * SOAP_FMAC4 soap_in__wsnt__NotifyMessageNotSupportedFaultType_FaultCause(struct soap *soap, const char *tag, struct _wsnt__NotifyMessageNotSupportedFaultType_FaultCause *a, const char *type)
{
	size_t soap_flag___any = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct _wsnt__NotifyMessageNotSupportedFaultType_FaultCause*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__wsnt__NotifyMessageNotSupportedFaultType_FaultCause, sizeof(struct _wsnt__NotifyMessageNotSupportedFaultType_FaultCause), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__wsnt__NotifyMessageNotSupportedFaultType_FaultCause(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag___any && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_inliteral(soap, "-any", (char**)&a->__any))
				{	soap_flag___any--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _wsnt__NotifyMessageNotSupportedFaultType_FaultCause *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__wsnt__NotifyMessageNotSupportedFaultType_FaultCause, SOAP_TYPE__wsnt__NotifyMessageNotSupportedFaultType_FaultCause, sizeof(struct _wsnt__NotifyMessageNotSupportedFaultType_FaultCause), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _wsnt__NotifyMessageNotSupportedFaultType_FaultCause * SOAP_FMAC4 soap_new__wsnt__NotifyMessageNotSupportedFaultType_FaultCause(struct soap *soap, int n)
{
	struct _wsnt__NotifyMessageNotSupportedFaultType_FaultCause *p;
	struct _wsnt__NotifyMessageNotSupportedFaultType_FaultCause *a = (struct _wsnt__NotifyMessageNotSupportedFaultType_FaultCause*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _wsnt__NotifyMessageNotSupportedFaultType_FaultCause));
	for (p = a; p && n--; p++)
		soap_default__wsnt__NotifyMessageNotSupportedFaultType_FaultCause(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__wsnt__NotifyMessageNotSupportedFaultType_FaultCause(struct soap *soap, const struct _wsnt__NotifyMessageNotSupportedFaultType_FaultCause *a, const char *tag, const char *type)
{
	if (soap_out__wsnt__NotifyMessageNotSupportedFaultType_FaultCause(soap, tag ? tag : "wsnt:NotifyMessageNotSupportedFaultType-FaultCause", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _wsnt__NotifyMessageNotSupportedFaultType_FaultCause * SOAP_FMAC4 soap_get__wsnt__NotifyMessageNotSupportedFaultType_FaultCause(struct soap *soap, struct _wsnt__NotifyMessageNotSupportedFaultType_FaultCause *p, const char *tag, const char *type)
{
	if ((p = soap_in__wsnt__NotifyMessageNotSupportedFaultType_FaultCause(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__wsnt__NotifyMessageNotSupportedFaultType_Description(struct soap *soap, struct _wsnt__NotifyMessageNotSupportedFaultType_Description *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->__item);
	soap_default__xml__lang(soap, &a->xml__lang);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__wsnt__NotifyMessageNotSupportedFaultType_Description(struct soap *soap, const struct _wsnt__NotifyMessageNotSupportedFaultType_Description *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_string(soap, (char*const*)&a->__item);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__wsnt__NotifyMessageNotSupportedFaultType_Description(struct soap *soap, const char *tag, int id, const struct _wsnt__NotifyMessageNotSupportedFaultType_Description *a, const char *type)
{
	if (a->xml__lang)
		soap_set_attr(soap, "xml:lang", soap__xml__lang2s(soap, a->xml__lang), 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	return soap_out_string(soap, tag, id, (char*const*)&a->__item, "");
}

SOAP_FMAC3 struct _wsnt__NotifyMessageNotSupportedFaultType_Description * SOAP_FMAC4 soap_in__wsnt__NotifyMessageNotSupportedFaultType_Description(struct soap *soap, const char *tag, struct _wsnt__NotifyMessageNotSupportedFaultType_Description *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	if (!(a = (struct _wsnt__NotifyMessageNotSupportedFaultType_Description *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__wsnt__NotifyMessageNotSupportedFaultType_Description, sizeof(struct _wsnt__NotifyMessageNotSupportedFaultType_Description), NULL, NULL, NULL, NULL)))
		return NULL;
	soap_revert(soap);
	*soap->id = '\0';
	soap_default__wsnt__NotifyMessageNotSupportedFaultType_Description(soap, a);
	if (soap_s2_xml__lang(soap, soap_attr_value(soap, "xml:lang", 1, 0), &a->xml__lang))
		return NULL;
	if (!soap_in_string(soap, tag, (char**)&a->__item, ""))
		return NULL;
	return a;
}

SOAP_FMAC3 struct _wsnt__NotifyMessageNotSupportedFaultType_Description * SOAP_FMAC4 soap_new__wsnt__NotifyMessageNotSupportedFaultType_Description(struct soap *soap, int n)
{
	struct _wsnt__NotifyMessageNotSupportedFaultType_Description *p;
	struct _wsnt__NotifyMessageNotSupportedFaultType_Description *a = (struct _wsnt__NotifyMessageNotSupportedFaultType_Description*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _wsnt__NotifyMessageNotSupportedFaultType_Description));
	for (p = a; p && n--; p++)
		soap_default__wsnt__NotifyMessageNotSupportedFaultType_Description(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__wsnt__NotifyMessageNotSupportedFaultType_Description(struct soap *soap, const struct _wsnt__NotifyMessageNotSupportedFaultType_Description *a, const char *tag, const char *type)
{
	if (soap_out__wsnt__NotifyMessageNotSupportedFaultType_Description(soap, tag ? tag : "wsnt:NotifyMessageNotSupportedFaultType-Description", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _wsnt__NotifyMessageNotSupportedFaultType_Description * SOAP_FMAC4 soap_get__wsnt__NotifyMessageNotSupportedFaultType_Description(struct soap *soap, struct _wsnt__NotifyMessageNotSupportedFaultType_Description *p, const char *tag, const char *type)
{
	if ((p = soap_in__wsnt__NotifyMessageNotSupportedFaultType_Description(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__wsnt__NotifyMessageNotSupportedFaultType_ErrorCode(struct soap *soap, struct _wsnt__NotifyMessageNotSupportedFaultType_ErrorCode *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_xsd__anyURI(soap, &a->dialect);
	a->__mixed = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__wsnt__NotifyMessageNotSupportedFaultType_ErrorCode(struct soap *soap, const struct _wsnt__NotifyMessageNotSupportedFaultType_ErrorCode *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__wsnt__NotifyMessageNotSupportedFaultType_ErrorCode(struct soap *soap, const char *tag, int id, const struct _wsnt__NotifyMessageNotSupportedFaultType_ErrorCode *a, const char *type)
{
	soap_set_attr(soap, "dialect", a->dialect ? soap_xsd__anyURI2s(soap, a->dialect) : "", 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__wsnt__NotifyMessageNotSupportedFaultType_ErrorCode), type))
		return soap->error;
	if (soap_outliteral(soap, "-mixed", (char*const*)&a->__mixed, NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _wsnt__NotifyMessageNotSupportedFaultType_ErrorCode * SOAP_FMAC4 soap_in__wsnt__NotifyMessageNotSupportedFaultType_ErrorCode(struct soap *soap, const char *tag, struct _wsnt__NotifyMessageNotSupportedFaultType_ErrorCode *a, const char *type)
{
	size_t soap_flag___mixed = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct _wsnt__NotifyMessageNotSupportedFaultType_ErrorCode*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__wsnt__NotifyMessageNotSupportedFaultType_ErrorCode, sizeof(struct _wsnt__NotifyMessageNotSupportedFaultType_ErrorCode), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__wsnt__NotifyMessageNotSupportedFaultType_ErrorCode(soap, a);
	if (soap_s2xsd__anyURI(soap, soap_attr_value(soap, "dialect", 4, 1), &a->dialect))
		return NULL;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag___mixed && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_inliteral(soap, "-mixed", (char**)&a->__mixed))
				{	soap_flag___mixed--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _wsnt__NotifyMessageNotSupportedFaultType_ErrorCode *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__wsnt__NotifyMessageNotSupportedFaultType_ErrorCode, SOAP_TYPE__wsnt__NotifyMessageNotSupportedFaultType_ErrorCode, sizeof(struct _wsnt__NotifyMessageNotSupportedFaultType_ErrorCode), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _wsnt__NotifyMessageNotSupportedFaultType_ErrorCode * SOAP_FMAC4 soap_new__wsnt__NotifyMessageNotSupportedFaultType_ErrorCode(struct soap *soap, int n)
{
	struct _wsnt__NotifyMessageNotSupportedFaultType_ErrorCode *p;
	struct _wsnt__NotifyMessageNotSupportedFaultType_ErrorCode *a = (struct _wsnt__NotifyMessageNotSupportedFaultType_ErrorCode*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _wsnt__NotifyMessageNotSupportedFaultType_ErrorCode));
	for (p = a; p && n--; p++)
		soap_default__wsnt__NotifyMessageNotSupportedFaultType_ErrorCode(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__wsnt__NotifyMessageNotSupportedFaultType_ErrorCode(struct soap *soap, const struct _wsnt__NotifyMessageNotSupportedFaultType_ErrorCode *a, const char *tag, const char *type)
{
	if (soap_out__wsnt__NotifyMessageNotSupportedFaultType_ErrorCode(soap, tag ? tag : "wsnt:NotifyMessageNotSupportedFaultType-ErrorCode", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _wsnt__NotifyMessageNotSupportedFaultType_ErrorCode * SOAP_FMAC4 soap_get__wsnt__NotifyMessageNotSupportedFaultType_ErrorCode(struct soap *soap, struct _wsnt__NotifyMessageNotSupportedFaultType_ErrorCode *p, const char *tag, const char *type)
{
	if ((p = soap_in__wsnt__NotifyMessageNotSupportedFaultType_ErrorCode(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_wsnt__NotifyMessageNotSupportedFaultType(struct soap *soap, struct wsnt__NotifyMessageNotSupportedFaultType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__size = 0;
	a->__any = NULL;
	soap_default_dateTime(soap, &a->wsrfbf__Timestamp);
	a->wsrfbf__Originator = NULL;
	a->wsrfbf__ErrorCode = NULL;
	a->__sizeDescription = 0;
	a->wsrfbf__Description = NULL;
	a->wsrfbf__FaultCause = NULL;
	a->__anyAttribute = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_wsnt__NotifyMessageNotSupportedFaultType(struct soap *soap, const struct wsnt__NotifyMessageNotSupportedFaultType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &a->wsrfbf__Timestamp, SOAP_TYPE_dateTime);
	soap_serialize_PointerTowsa5__EndpointReferenceType(soap, &a->wsrfbf__Originator);
	soap_serialize_PointerTo_wsnt__NotifyMessageNotSupportedFaultType_ErrorCode(soap, &a->wsrfbf__ErrorCode);
	if (a->wsrfbf__Description)
	{	int i;
		for (i = 0; i < (int)a->__sizeDescription; i++)
		{
			soap_embedded(soap, a->wsrfbf__Description + i, SOAP_TYPE__wsnt__NotifyMessageNotSupportedFaultType_Description);
			soap_serialize__wsnt__NotifyMessageNotSupportedFaultType_Description(soap, a->wsrfbf__Description + i);
		}
	}
	soap_serialize_PointerTo_wsnt__NotifyMessageNotSupportedFaultType_FaultCause(soap, &a->wsrfbf__FaultCause);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_wsnt__NotifyMessageNotSupportedFaultType(struct soap *soap, const char *tag, int id, const struct wsnt__NotifyMessageNotSupportedFaultType *a, const char *type)
{
	if (a->__anyAttribute)
		soap_set_attr(soap, "-anyAttribute", a->__anyAttribute, 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_wsnt__NotifyMessageNotSupportedFaultType), type))
		return soap->error;
	if (a->__any)
	{	int i;
		for (i = 0; i < (int)a->__size; i++)
			if (soap_outliteral(soap, "-any", (char*const*)(a->__any + i), NULL))
				return soap->error;
	}
	if (soap_out_dateTime(soap, "wsrfbf:Timestamp", -1, &a->wsrfbf__Timestamp, ""))
		return soap->error;
	if (soap_out_PointerTowsa5__EndpointReferenceType(soap, "wsrfbf:Originator", -1, &a->wsrfbf__Originator, ""))
		return soap->error;
	if (soap_out_PointerTo_wsnt__NotifyMessageNotSupportedFaultType_ErrorCode(soap, "wsrfbf:ErrorCode", -1, &a->wsrfbf__ErrorCode, ""))
		return soap->error;
	if (a->wsrfbf__Description)
	{	int i;
		for (i = 0; i < (int)a->__sizeDescription; i++)
			if (soap_out__wsnt__NotifyMessageNotSupportedFaultType_Description(soap, "wsrfbf:Description", -1, a->wsrfbf__Description + i, ""))
				return soap->error;
	}
	if (soap_out_PointerTo_wsnt__NotifyMessageNotSupportedFaultType_FaultCause(soap, "wsrfbf:FaultCause", -1, &a->wsrfbf__FaultCause, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct wsnt__NotifyMessageNotSupportedFaultType * SOAP_FMAC4 soap_in_wsnt__NotifyMessageNotSupportedFaultType(struct soap *soap, const char *tag, struct wsnt__NotifyMessageNotSupportedFaultType *a, const char *type)
{
	struct soap_blist *soap_blist___any = NULL;
	size_t soap_flag_wsrfbf__Timestamp = 1;
	size_t soap_flag_wsrfbf__Originator = 1;
	size_t soap_flag_wsrfbf__ErrorCode = 1;
	struct soap_blist *soap_blist_wsrfbf__Description = NULL;
	size_t soap_flag_wsrfbf__FaultCause = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct wsnt__NotifyMessageNotSupportedFaultType*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_wsnt__NotifyMessageNotSupportedFaultType, sizeof(struct wsnt__NotifyMessageNotSupportedFaultType), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_wsnt__NotifyMessageNotSupportedFaultType(soap, a);
	if (soap_s2char(soap, soap_attr_value(soap, "-anyAttribute", 0, 0), &a->__anyAttribute, 0, 0, -1, NULL))
		return NULL;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_wsrfbf__Timestamp && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_dateTime(soap, "wsrfbf:Timestamp", &a->wsrfbf__Timestamp, "xsd:dateTime"))
				{	soap_flag_wsrfbf__Timestamp--;
					continue;
				}
			}
			if (soap_flag_wsrfbf__Originator && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTowsa5__EndpointReferenceType(soap, "wsrfbf:Originator", &a->wsrfbf__Originator, "wsa5:EndpointReferenceType"))
				{	soap_flag_wsrfbf__Originator--;
					continue;
				}
			}
			if (soap_flag_wsrfbf__ErrorCode && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_wsnt__NotifyMessageNotSupportedFaultType_ErrorCode(soap, "wsrfbf:ErrorCode", &a->wsrfbf__ErrorCode, ""))
				{	soap_flag_wsrfbf__ErrorCode--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "wsrfbf:Description", 1, NULL))
			{	if (a->wsrfbf__Description == NULL)
				{	if (soap_blist_wsrfbf__Description == NULL)
						soap_blist_wsrfbf__Description = soap_alloc_block(soap);
					a->wsrfbf__Description = (struct _wsnt__NotifyMessageNotSupportedFaultType_Description *)soap_push_block_max(soap, soap_blist_wsrfbf__Description, sizeof(struct _wsnt__NotifyMessageNotSupportedFaultType_Description));
					if (a->wsrfbf__Description == NULL)
						return NULL;
					soap_default__wsnt__NotifyMessageNotSupportedFaultType_Description(soap, a->wsrfbf__Description);
				}
				soap_revert(soap);
				if (soap_in__wsnt__NotifyMessageNotSupportedFaultType_Description(soap, "wsrfbf:Description", a->wsrfbf__Description, ""))
				{	a->__sizeDescription++;
					a->wsrfbf__Description = NULL;
					continue;
				}
			}
			if (soap_flag_wsrfbf__FaultCause && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_wsnt__NotifyMessageNotSupportedFaultType_FaultCause(soap, "wsrfbf:FaultCause", &a->wsrfbf__FaultCause, ""))
				{	soap_flag_wsrfbf__FaultCause--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	if (a->__any == NULL)
				{	if (soap_blist___any == NULL)
						soap_blist___any = soap_alloc_block(soap);
					a->__any = (char **)soap_push_block_max(soap, soap_blist___any, sizeof(char *));
					if (a->__any == NULL)
						return NULL;
					*a->__any = NULL;
				}
				if (soap_inliteral(soap, "-any", (char**)a->__any))
				{	a->__size++;
					a->__any = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->__any)
			soap_pop_block(soap, soap_blist___any);
		if (a->__size)
		{	a->__any = (char **)soap_save_block(soap, soap_blist___any, NULL, 1);
		}
		else
		{	a->__any = NULL;
			if (soap_blist___any)
				soap_end_block(soap, soap_blist___any);
		}
		if (a->wsrfbf__Description)
			soap_pop_block(soap, soap_blist_wsrfbf__Description);
		if (a->__sizeDescription)
		{	a->wsrfbf__Description = (struct _wsnt__NotifyMessageNotSupportedFaultType_Description *)soap_save_block(soap, soap_blist_wsrfbf__Description, NULL, 1);
		}
		else
		{	a->wsrfbf__Description = NULL;
			if (soap_blist_wsrfbf__Description)
				soap_end_block(soap, soap_blist_wsrfbf__Description);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_wsrfbf__Timestamp > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct wsnt__NotifyMessageNotSupportedFaultType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_wsnt__NotifyMessageNotSupportedFaultType, SOAP_TYPE_wsnt__NotifyMessageNotSupportedFaultType, sizeof(struct wsnt__NotifyMessageNotSupportedFaultType), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct wsnt__NotifyMessageNotSupportedFaultType * SOAP_FMAC4 soap_new_wsnt__NotifyMessageNotSupportedFaultType(struct soap *soap, int n)
{
	struct wsnt__NotifyMessageNotSupportedFaultType *p;
	struct wsnt__NotifyMessageNotSupportedFaultType *a = (struct wsnt__NotifyMessageNotSupportedFaultType*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct wsnt__NotifyMessageNotSupportedFaultType));
	for (p = a; p && n--; p++)
		soap_default_wsnt__NotifyMessageNotSupportedFaultType(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_wsnt__NotifyMessageNotSupportedFaultType(struct soap *soap, const struct wsnt__NotifyMessageNotSupportedFaultType *a, const char *tag, const char *type)
{
	if (soap_out_wsnt__NotifyMessageNotSupportedFaultType(soap, tag ? tag : "wsnt:NotifyMessageNotSupportedFaultType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct wsnt__NotifyMessageNotSupportedFaultType * SOAP_FMAC4 soap_get_wsnt__NotifyMessageNotSupportedFaultType(struct soap *soap, struct wsnt__NotifyMessageNotSupportedFaultType *p, const char *tag, const char *type)
{
	if ((p = soap_in_wsnt__NotifyMessageNotSupportedFaultType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__wsnt__UnsupportedPolicyRequestFaultType_FaultCause(struct soap *soap, struct _wsnt__UnsupportedPolicyRequestFaultType_FaultCause *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__any = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__wsnt__UnsupportedPolicyRequestFaultType_FaultCause(struct soap *soap, const struct _wsnt__UnsupportedPolicyRequestFaultType_FaultCause *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__wsnt__UnsupportedPolicyRequestFaultType_FaultCause(struct soap *soap, const char *tag, int id, const struct _wsnt__UnsupportedPolicyRequestFaultType_FaultCause *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__wsnt__UnsupportedPolicyRequestFaultType_FaultCause), type))
		return soap->error;
	if (soap_outliteral(soap, "-any", (char*const*)&a->__any, NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _wsnt__UnsupportedPolicyRequestFaultType_FaultCause * SOAP_FMAC4 soap_in__wsnt__UnsupportedPolicyRequestFaultType_FaultCause(struct soap *soap, const char *tag, struct _wsnt__UnsupportedPolicyRequestFaultType_FaultCause *a, const char *type)
{
	size_t soap_flag___any = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct _wsnt__UnsupportedPolicyRequestFaultType_FaultCause*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__wsnt__UnsupportedPolicyRequestFaultType_FaultCause, sizeof(struct _wsnt__UnsupportedPolicyRequestFaultType_FaultCause), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__wsnt__UnsupportedPolicyRequestFaultType_FaultCause(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag___any && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_inliteral(soap, "-any", (char**)&a->__any))
				{	soap_flag___any--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _wsnt__UnsupportedPolicyRequestFaultType_FaultCause *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__wsnt__UnsupportedPolicyRequestFaultType_FaultCause, SOAP_TYPE__wsnt__UnsupportedPolicyRequestFaultType_FaultCause, sizeof(struct _wsnt__UnsupportedPolicyRequestFaultType_FaultCause), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _wsnt__UnsupportedPolicyRequestFaultType_FaultCause * SOAP_FMAC4 soap_new__wsnt__UnsupportedPolicyRequestFaultType_FaultCause(struct soap *soap, int n)
{
	struct _wsnt__UnsupportedPolicyRequestFaultType_FaultCause *p;
	struct _wsnt__UnsupportedPolicyRequestFaultType_FaultCause *a = (struct _wsnt__UnsupportedPolicyRequestFaultType_FaultCause*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _wsnt__UnsupportedPolicyRequestFaultType_FaultCause));
	for (p = a; p && n--; p++)
		soap_default__wsnt__UnsupportedPolicyRequestFaultType_FaultCause(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__wsnt__UnsupportedPolicyRequestFaultType_FaultCause(struct soap *soap, const struct _wsnt__UnsupportedPolicyRequestFaultType_FaultCause *a, const char *tag, const char *type)
{
	if (soap_out__wsnt__UnsupportedPolicyRequestFaultType_FaultCause(soap, tag ? tag : "wsnt:UnsupportedPolicyRequestFaultType-FaultCause", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _wsnt__UnsupportedPolicyRequestFaultType_FaultCause * SOAP_FMAC4 soap_get__wsnt__UnsupportedPolicyRequestFaultType_FaultCause(struct soap *soap, struct _wsnt__UnsupportedPolicyRequestFaultType_FaultCause *p, const char *tag, const char *type)
{
	if ((p = soap_in__wsnt__UnsupportedPolicyRequestFaultType_FaultCause(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__wsnt__UnsupportedPolicyRequestFaultType_Description(struct soap *soap, struct _wsnt__UnsupportedPolicyRequestFaultType_Description *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->__item);
	soap_default__xml__lang(soap, &a->xml__lang);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__wsnt__UnsupportedPolicyRequestFaultType_Description(struct soap *soap, const struct _wsnt__UnsupportedPolicyRequestFaultType_Description *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_string(soap, (char*const*)&a->__item);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__wsnt__UnsupportedPolicyRequestFaultType_Description(struct soap *soap, const char *tag, int id, const struct _wsnt__UnsupportedPolicyRequestFaultType_Description *a, const char *type)
{
	if (a->xml__lang)
		soap_set_attr(soap, "xml:lang", soap__xml__lang2s(soap, a->xml__lang), 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	return soap_out_string(soap, tag, id, (char*const*)&a->__item, "");
}

SOAP_FMAC3 struct _wsnt__UnsupportedPolicyRequestFaultType_Description * SOAP_FMAC4 soap_in__wsnt__UnsupportedPolicyRequestFaultType_Description(struct soap *soap, const char *tag, struct _wsnt__UnsupportedPolicyRequestFaultType_Description *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	if (!(a = (struct _wsnt__UnsupportedPolicyRequestFaultType_Description *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__wsnt__UnsupportedPolicyRequestFaultType_Description, sizeof(struct _wsnt__UnsupportedPolicyRequestFaultType_Description), NULL, NULL, NULL, NULL)))
		return NULL;
	soap_revert(soap);
	*soap->id = '\0';
	soap_default__wsnt__UnsupportedPolicyRequestFaultType_Description(soap, a);
	if (soap_s2_xml__lang(soap, soap_attr_value(soap, "xml:lang", 1, 0), &a->xml__lang))
		return NULL;
	if (!soap_in_string(soap, tag, (char**)&a->__item, ""))
		return NULL;
	return a;
}

SOAP_FMAC3 struct _wsnt__UnsupportedPolicyRequestFaultType_Description * SOAP_FMAC4 soap_new__wsnt__UnsupportedPolicyRequestFaultType_Description(struct soap *soap, int n)
{
	struct _wsnt__UnsupportedPolicyRequestFaultType_Description *p;
	struct _wsnt__UnsupportedPolicyRequestFaultType_Description *a = (struct _wsnt__UnsupportedPolicyRequestFaultType_Description*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _wsnt__UnsupportedPolicyRequestFaultType_Description));
	for (p = a; p && n--; p++)
		soap_default__wsnt__UnsupportedPolicyRequestFaultType_Description(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__wsnt__UnsupportedPolicyRequestFaultType_Description(struct soap *soap, const struct _wsnt__UnsupportedPolicyRequestFaultType_Description *a, const char *tag, const char *type)
{
	if (soap_out__wsnt__UnsupportedPolicyRequestFaultType_Description(soap, tag ? tag : "wsnt:UnsupportedPolicyRequestFaultType-Description", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _wsnt__UnsupportedPolicyRequestFaultType_Description * SOAP_FMAC4 soap_get__wsnt__UnsupportedPolicyRequestFaultType_Description(struct soap *soap, struct _wsnt__UnsupportedPolicyRequestFaultType_Description *p, const char *tag, const char *type)
{
	if ((p = soap_in__wsnt__UnsupportedPolicyRequestFaultType_Description(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__wsnt__UnsupportedPolicyRequestFaultType_ErrorCode(struct soap *soap, struct _wsnt__UnsupportedPolicyRequestFaultType_ErrorCode *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_xsd__anyURI(soap, &a->dialect);
	a->__mixed = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__wsnt__UnsupportedPolicyRequestFaultType_ErrorCode(struct soap *soap, const struct _wsnt__UnsupportedPolicyRequestFaultType_ErrorCode *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__wsnt__UnsupportedPolicyRequestFaultType_ErrorCode(struct soap *soap, const char *tag, int id, const struct _wsnt__UnsupportedPolicyRequestFaultType_ErrorCode *a, const char *type)
{
	soap_set_attr(soap, "dialect", a->dialect ? soap_xsd__anyURI2s(soap, a->dialect) : "", 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__wsnt__UnsupportedPolicyRequestFaultType_ErrorCode), type))
		return soap->error;
	if (soap_outliteral(soap, "-mixed", (char*const*)&a->__mixed, NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _wsnt__UnsupportedPolicyRequestFaultType_ErrorCode * SOAP_FMAC4 soap_in__wsnt__UnsupportedPolicyRequestFaultType_ErrorCode(struct soap *soap, const char *tag, struct _wsnt__UnsupportedPolicyRequestFaultType_ErrorCode *a, const char *type)
{
	size_t soap_flag___mixed = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct _wsnt__UnsupportedPolicyRequestFaultType_ErrorCode*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__wsnt__UnsupportedPolicyRequestFaultType_ErrorCode, sizeof(struct _wsnt__UnsupportedPolicyRequestFaultType_ErrorCode), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__wsnt__UnsupportedPolicyRequestFaultType_ErrorCode(soap, a);
	if (soap_s2xsd__anyURI(soap, soap_attr_value(soap, "dialect", 4, 1), &a->dialect))
		return NULL;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag___mixed && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_inliteral(soap, "-mixed", (char**)&a->__mixed))
				{	soap_flag___mixed--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _wsnt__UnsupportedPolicyRequestFaultType_ErrorCode *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__wsnt__UnsupportedPolicyRequestFaultType_ErrorCode, SOAP_TYPE__wsnt__UnsupportedPolicyRequestFaultType_ErrorCode, sizeof(struct _wsnt__UnsupportedPolicyRequestFaultType_ErrorCode), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _wsnt__UnsupportedPolicyRequestFaultType_ErrorCode * SOAP_FMAC4 soap_new__wsnt__UnsupportedPolicyRequestFaultType_ErrorCode(struct soap *soap, int n)
{
	struct _wsnt__UnsupportedPolicyRequestFaultType_ErrorCode *p;
	struct _wsnt__UnsupportedPolicyRequestFaultType_ErrorCode *a = (struct _wsnt__UnsupportedPolicyRequestFaultType_ErrorCode*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _wsnt__UnsupportedPolicyRequestFaultType_ErrorCode));
	for (p = a; p && n--; p++)
		soap_default__wsnt__UnsupportedPolicyRequestFaultType_ErrorCode(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__wsnt__UnsupportedPolicyRequestFaultType_ErrorCode(struct soap *soap, const struct _wsnt__UnsupportedPolicyRequestFaultType_ErrorCode *a, const char *tag, const char *type)
{
	if (soap_out__wsnt__UnsupportedPolicyRequestFaultType_ErrorCode(soap, tag ? tag : "wsnt:UnsupportedPolicyRequestFaultType-ErrorCode", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _wsnt__UnsupportedPolicyRequestFaultType_ErrorCode * SOAP_FMAC4 soap_get__wsnt__UnsupportedPolicyRequestFaultType_ErrorCode(struct soap *soap, struct _wsnt__UnsupportedPolicyRequestFaultType_ErrorCode *p, const char *tag, const char *type)
{
	if ((p = soap_in__wsnt__UnsupportedPolicyRequestFaultType_ErrorCode(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_wsnt__UnsupportedPolicyRequestFaultType(struct soap *soap, struct wsnt__UnsupportedPolicyRequestFaultType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__size = 0;
	a->__any = NULL;
	soap_default_dateTime(soap, &a->wsrfbf__Timestamp);
	a->wsrfbf__Originator = NULL;
	a->wsrfbf__ErrorCode = NULL;
	a->__sizeDescription = 0;
	a->wsrfbf__Description = NULL;
	a->wsrfbf__FaultCause = NULL;
	a->__anyAttribute = NULL;
	a->__sizeUnsupportedPolicy = 0;
	a->UnsupportedPolicy = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_wsnt__UnsupportedPolicyRequestFaultType(struct soap *soap, const struct wsnt__UnsupportedPolicyRequestFaultType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &a->wsrfbf__Timestamp, SOAP_TYPE_dateTime);
	soap_serialize_PointerTowsa5__EndpointReferenceType(soap, &a->wsrfbf__Originator);
	soap_serialize_PointerTo_wsnt__UnsupportedPolicyRequestFaultType_ErrorCode(soap, &a->wsrfbf__ErrorCode);
	if (a->wsrfbf__Description)
	{	int i;
		for (i = 0; i < (int)a->__sizeDescription; i++)
		{
			soap_embedded(soap, a->wsrfbf__Description + i, SOAP_TYPE__wsnt__UnsupportedPolicyRequestFaultType_Description);
			soap_serialize__wsnt__UnsupportedPolicyRequestFaultType_Description(soap, a->wsrfbf__Description + i);
		}
	}
	soap_serialize_PointerTo_wsnt__UnsupportedPolicyRequestFaultType_FaultCause(soap, &a->wsrfbf__FaultCause);
	if (a->UnsupportedPolicy)
	{	int i;
		for (i = 0; i < (int)a->__sizeUnsupportedPolicy; i++)
		{
			soap_serialize__QName(soap, (char*const*)(a->UnsupportedPolicy + i));
		}
	}
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_wsnt__UnsupportedPolicyRequestFaultType(struct soap *soap, const char *tag, int id, const struct wsnt__UnsupportedPolicyRequestFaultType *a, const char *type)
{
	if (a->__anyAttribute)
		soap_set_attr(soap, "-anyAttribute", a->__anyAttribute, 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_wsnt__UnsupportedPolicyRequestFaultType), type))
		return soap->error;
	if (a->__any)
	{	int i;
		for (i = 0; i < (int)a->__size; i++)
			if (soap_outliteral(soap, "-any", (char*const*)(a->__any + i), NULL))
				return soap->error;
	}
	if (soap_out_dateTime(soap, "wsrfbf:Timestamp", -1, &a->wsrfbf__Timestamp, ""))
		return soap->error;
	if (soap_out_PointerTowsa5__EndpointReferenceType(soap, "wsrfbf:Originator", -1, &a->wsrfbf__Originator, ""))
		return soap->error;
	if (soap_out_PointerTo_wsnt__UnsupportedPolicyRequestFaultType_ErrorCode(soap, "wsrfbf:ErrorCode", -1, &a->wsrfbf__ErrorCode, ""))
		return soap->error;
	if (a->wsrfbf__Description)
	{	int i;
		for (i = 0; i < (int)a->__sizeDescription; i++)
			if (soap_out__wsnt__UnsupportedPolicyRequestFaultType_Description(soap, "wsrfbf:Description", -1, a->wsrfbf__Description + i, ""))
				return soap->error;
	}
	if (soap_out_PointerTo_wsnt__UnsupportedPolicyRequestFaultType_FaultCause(soap, "wsrfbf:FaultCause", -1, &a->wsrfbf__FaultCause, ""))
		return soap->error;
	if (a->UnsupportedPolicy)
	{	int i;
		for (i = 0; i < (int)a->__sizeUnsupportedPolicy; i++)
		{	const char *soap_tmp_UnsupportedPolicy = soap_QName2s(soap, a->UnsupportedPolicy[i]);
			if (soap_out__QName(soap, "wsnt:UnsupportedPolicy", -1, (char*const*)(void*)&soap_tmp_UnsupportedPolicy, ""))
				return soap->error;
		}
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct wsnt__UnsupportedPolicyRequestFaultType * SOAP_FMAC4 soap_in_wsnt__UnsupportedPolicyRequestFaultType(struct soap *soap, const char *tag, struct wsnt__UnsupportedPolicyRequestFaultType *a, const char *type)
{
	struct soap_blist *soap_blist___any = NULL;
	size_t soap_flag_wsrfbf__Timestamp = 1;
	size_t soap_flag_wsrfbf__Originator = 1;
	size_t soap_flag_wsrfbf__ErrorCode = 1;
	struct soap_blist *soap_blist_wsrfbf__Description = NULL;
	size_t soap_flag_wsrfbf__FaultCause = 1;
	struct soap_blist *soap_blist_UnsupportedPolicy = NULL;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct wsnt__UnsupportedPolicyRequestFaultType*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_wsnt__UnsupportedPolicyRequestFaultType, sizeof(struct wsnt__UnsupportedPolicyRequestFaultType), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_wsnt__UnsupportedPolicyRequestFaultType(soap, a);
	if (soap_s2char(soap, soap_attr_value(soap, "-anyAttribute", 0, 0), &a->__anyAttribute, 0, 0, -1, NULL))
		return NULL;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_wsrfbf__Timestamp && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_dateTime(soap, "wsrfbf:Timestamp", &a->wsrfbf__Timestamp, "xsd:dateTime"))
				{	soap_flag_wsrfbf__Timestamp--;
					continue;
				}
			}
			if (soap_flag_wsrfbf__Originator && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTowsa5__EndpointReferenceType(soap, "wsrfbf:Originator", &a->wsrfbf__Originator, "wsa5:EndpointReferenceType"))
				{	soap_flag_wsrfbf__Originator--;
					continue;
				}
			}
			if (soap_flag_wsrfbf__ErrorCode && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_wsnt__UnsupportedPolicyRequestFaultType_ErrorCode(soap, "wsrfbf:ErrorCode", &a->wsrfbf__ErrorCode, ""))
				{	soap_flag_wsrfbf__ErrorCode--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "wsrfbf:Description", 1, NULL))
			{	if (a->wsrfbf__Description == NULL)
				{	if (soap_blist_wsrfbf__Description == NULL)
						soap_blist_wsrfbf__Description = soap_alloc_block(soap);
					a->wsrfbf__Description = (struct _wsnt__UnsupportedPolicyRequestFaultType_Description *)soap_push_block_max(soap, soap_blist_wsrfbf__Description, sizeof(struct _wsnt__UnsupportedPolicyRequestFaultType_Description));
					if (a->wsrfbf__Description == NULL)
						return NULL;
					soap_default__wsnt__UnsupportedPolicyRequestFaultType_Description(soap, a->wsrfbf__Description);
				}
				soap_revert(soap);
				if (soap_in__wsnt__UnsupportedPolicyRequestFaultType_Description(soap, "wsrfbf:Description", a->wsrfbf__Description, ""))
				{	a->__sizeDescription++;
					a->wsrfbf__Description = NULL;
					continue;
				}
			}
			if (soap_flag_wsrfbf__FaultCause && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_wsnt__UnsupportedPolicyRequestFaultType_FaultCause(soap, "wsrfbf:FaultCause", &a->wsrfbf__FaultCause, ""))
				{	soap_flag_wsrfbf__FaultCause--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "wsnt:UnsupportedPolicy", 1, NULL))
			{	if (a->UnsupportedPolicy == NULL)
				{	if (soap_blist_UnsupportedPolicy == NULL)
						soap_blist_UnsupportedPolicy = soap_alloc_block(soap);
					a->UnsupportedPolicy = (char **)soap_push_block_max(soap, soap_blist_UnsupportedPolicy, sizeof(char *));
					if (a->UnsupportedPolicy == NULL)
						return NULL;
					*a->UnsupportedPolicy = NULL;
				}
				soap_revert(soap);
				if (soap_in__QName(soap, "wsnt:UnsupportedPolicy", (char**)a->UnsupportedPolicy, "xsd:QName"))
				{	a->__sizeUnsupportedPolicy++;
					a->UnsupportedPolicy = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	if (a->__any == NULL)
				{	if (soap_blist___any == NULL)
						soap_blist___any = soap_alloc_block(soap);
					a->__any = (char **)soap_push_block_max(soap, soap_blist___any, sizeof(char *));
					if (a->__any == NULL)
						return NULL;
					*a->__any = NULL;
				}
				if (soap_inliteral(soap, "-any", (char**)a->__any))
				{	a->__size++;
					a->__any = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->__any)
			soap_pop_block(soap, soap_blist___any);
		if (a->__size)
		{	a->__any = (char **)soap_save_block(soap, soap_blist___any, NULL, 1);
		}
		else
		{	a->__any = NULL;
			if (soap_blist___any)
				soap_end_block(soap, soap_blist___any);
		}
		if (a->wsrfbf__Description)
			soap_pop_block(soap, soap_blist_wsrfbf__Description);
		if (a->__sizeDescription)
		{	a->wsrfbf__Description = (struct _wsnt__UnsupportedPolicyRequestFaultType_Description *)soap_save_block(soap, soap_blist_wsrfbf__Description, NULL, 1);
		}
		else
		{	a->wsrfbf__Description = NULL;
			if (soap_blist_wsrfbf__Description)
				soap_end_block(soap, soap_blist_wsrfbf__Description);
		}
		if (a->UnsupportedPolicy)
			soap_pop_block(soap, soap_blist_UnsupportedPolicy);
		if (a->__sizeUnsupportedPolicy)
		{	a->UnsupportedPolicy = (char **)soap_save_block(soap, soap_blist_UnsupportedPolicy, NULL, 1);
		}
		else
		{	a->UnsupportedPolicy = NULL;
			if (soap_blist_UnsupportedPolicy)
				soap_end_block(soap, soap_blist_UnsupportedPolicy);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_wsrfbf__Timestamp > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct wsnt__UnsupportedPolicyRequestFaultType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_wsnt__UnsupportedPolicyRequestFaultType, SOAP_TYPE_wsnt__UnsupportedPolicyRequestFaultType, sizeof(struct wsnt__UnsupportedPolicyRequestFaultType), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct wsnt__UnsupportedPolicyRequestFaultType * SOAP_FMAC4 soap_new_wsnt__UnsupportedPolicyRequestFaultType(struct soap *soap, int n)
{
	struct wsnt__UnsupportedPolicyRequestFaultType *p;
	struct wsnt__UnsupportedPolicyRequestFaultType *a = (struct wsnt__UnsupportedPolicyRequestFaultType*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct wsnt__UnsupportedPolicyRequestFaultType));
	for (p = a; p && n--; p++)
		soap_default_wsnt__UnsupportedPolicyRequestFaultType(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_wsnt__UnsupportedPolicyRequestFaultType(struct soap *soap, const struct wsnt__UnsupportedPolicyRequestFaultType *a, const char *tag, const char *type)
{
	if (soap_out_wsnt__UnsupportedPolicyRequestFaultType(soap, tag ? tag : "wsnt:UnsupportedPolicyRequestFaultType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct wsnt__UnsupportedPolicyRequestFaultType * SOAP_FMAC4 soap_get_wsnt__UnsupportedPolicyRequestFaultType(struct soap *soap, struct wsnt__UnsupportedPolicyRequestFaultType *p, const char *tag, const char *type)
{
	if ((p = soap_in_wsnt__UnsupportedPolicyRequestFaultType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__wsnt__UnrecognizedPolicyRequestFaultType_FaultCause(struct soap *soap, struct _wsnt__UnrecognizedPolicyRequestFaultType_FaultCause *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__any = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__wsnt__UnrecognizedPolicyRequestFaultType_FaultCause(struct soap *soap, const struct _wsnt__UnrecognizedPolicyRequestFaultType_FaultCause *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__wsnt__UnrecognizedPolicyRequestFaultType_FaultCause(struct soap *soap, const char *tag, int id, const struct _wsnt__UnrecognizedPolicyRequestFaultType_FaultCause *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__wsnt__UnrecognizedPolicyRequestFaultType_FaultCause), type))
		return soap->error;
	if (soap_outliteral(soap, "-any", (char*const*)&a->__any, NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _wsnt__UnrecognizedPolicyRequestFaultType_FaultCause * SOAP_FMAC4 soap_in__wsnt__UnrecognizedPolicyRequestFaultType_FaultCause(struct soap *soap, const char *tag, struct _wsnt__UnrecognizedPolicyRequestFaultType_FaultCause *a, const char *type)
{
	size_t soap_flag___any = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct _wsnt__UnrecognizedPolicyRequestFaultType_FaultCause*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__wsnt__UnrecognizedPolicyRequestFaultType_FaultCause, sizeof(struct _wsnt__UnrecognizedPolicyRequestFaultType_FaultCause), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__wsnt__UnrecognizedPolicyRequestFaultType_FaultCause(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag___any && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_inliteral(soap, "-any", (char**)&a->__any))
				{	soap_flag___any--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _wsnt__UnrecognizedPolicyRequestFaultType_FaultCause *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__wsnt__UnrecognizedPolicyRequestFaultType_FaultCause, SOAP_TYPE__wsnt__UnrecognizedPolicyRequestFaultType_FaultCause, sizeof(struct _wsnt__UnrecognizedPolicyRequestFaultType_FaultCause), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _wsnt__UnrecognizedPolicyRequestFaultType_FaultCause * SOAP_FMAC4 soap_new__wsnt__UnrecognizedPolicyRequestFaultType_FaultCause(struct soap *soap, int n)
{
	struct _wsnt__UnrecognizedPolicyRequestFaultType_FaultCause *p;
	struct _wsnt__UnrecognizedPolicyRequestFaultType_FaultCause *a = (struct _wsnt__UnrecognizedPolicyRequestFaultType_FaultCause*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _wsnt__UnrecognizedPolicyRequestFaultType_FaultCause));
	for (p = a; p && n--; p++)
		soap_default__wsnt__UnrecognizedPolicyRequestFaultType_FaultCause(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__wsnt__UnrecognizedPolicyRequestFaultType_FaultCause(struct soap *soap, const struct _wsnt__UnrecognizedPolicyRequestFaultType_FaultCause *a, const char *tag, const char *type)
{
	if (soap_out__wsnt__UnrecognizedPolicyRequestFaultType_FaultCause(soap, tag ? tag : "wsnt:UnrecognizedPolicyRequestFaultType-FaultCause", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _wsnt__UnrecognizedPolicyRequestFaultType_FaultCause * SOAP_FMAC4 soap_get__wsnt__UnrecognizedPolicyRequestFaultType_FaultCause(struct soap *soap, struct _wsnt__UnrecognizedPolicyRequestFaultType_FaultCause *p, const char *tag, const char *type)
{
	if ((p = soap_in__wsnt__UnrecognizedPolicyRequestFaultType_FaultCause(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__wsnt__UnrecognizedPolicyRequestFaultType_Description(struct soap *soap, struct _wsnt__UnrecognizedPolicyRequestFaultType_Description *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->__item);
	soap_default__xml__lang(soap, &a->xml__lang);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__wsnt__UnrecognizedPolicyRequestFaultType_Description(struct soap *soap, const struct _wsnt__UnrecognizedPolicyRequestFaultType_Description *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_string(soap, (char*const*)&a->__item);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__wsnt__UnrecognizedPolicyRequestFaultType_Description(struct soap *soap, const char *tag, int id, const struct _wsnt__UnrecognizedPolicyRequestFaultType_Description *a, const char *type)
{
	if (a->xml__lang)
		soap_set_attr(soap, "xml:lang", soap__xml__lang2s(soap, a->xml__lang), 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	return soap_out_string(soap, tag, id, (char*const*)&a->__item, "");
}

SOAP_FMAC3 struct _wsnt__UnrecognizedPolicyRequestFaultType_Description * SOAP_FMAC4 soap_in__wsnt__UnrecognizedPolicyRequestFaultType_Description(struct soap *soap, const char *tag, struct _wsnt__UnrecognizedPolicyRequestFaultType_Description *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	if (!(a = (struct _wsnt__UnrecognizedPolicyRequestFaultType_Description *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__wsnt__UnrecognizedPolicyRequestFaultType_Description, sizeof(struct _wsnt__UnrecognizedPolicyRequestFaultType_Description), NULL, NULL, NULL, NULL)))
		return NULL;
	soap_revert(soap);
	*soap->id = '\0';
	soap_default__wsnt__UnrecognizedPolicyRequestFaultType_Description(soap, a);
	if (soap_s2_xml__lang(soap, soap_attr_value(soap, "xml:lang", 1, 0), &a->xml__lang))
		return NULL;
	if (!soap_in_string(soap, tag, (char**)&a->__item, ""))
		return NULL;
	return a;
}

SOAP_FMAC3 struct _wsnt__UnrecognizedPolicyRequestFaultType_Description * SOAP_FMAC4 soap_new__wsnt__UnrecognizedPolicyRequestFaultType_Description(struct soap *soap, int n)
{
	struct _wsnt__UnrecognizedPolicyRequestFaultType_Description *p;
	struct _wsnt__UnrecognizedPolicyRequestFaultType_Description *a = (struct _wsnt__UnrecognizedPolicyRequestFaultType_Description*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _wsnt__UnrecognizedPolicyRequestFaultType_Description));
	for (p = a; p && n--; p++)
		soap_default__wsnt__UnrecognizedPolicyRequestFaultType_Description(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__wsnt__UnrecognizedPolicyRequestFaultType_Description(struct soap *soap, const struct _wsnt__UnrecognizedPolicyRequestFaultType_Description *a, const char *tag, const char *type)
{
	if (soap_out__wsnt__UnrecognizedPolicyRequestFaultType_Description(soap, tag ? tag : "wsnt:UnrecognizedPolicyRequestFaultType-Description", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _wsnt__UnrecognizedPolicyRequestFaultType_Description * SOAP_FMAC4 soap_get__wsnt__UnrecognizedPolicyRequestFaultType_Description(struct soap *soap, struct _wsnt__UnrecognizedPolicyRequestFaultType_Description *p, const char *tag, const char *type)
{
	if ((p = soap_in__wsnt__UnrecognizedPolicyRequestFaultType_Description(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__wsnt__UnrecognizedPolicyRequestFaultType_ErrorCode(struct soap *soap, struct _wsnt__UnrecognizedPolicyRequestFaultType_ErrorCode *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_xsd__anyURI(soap, &a->dialect);
	a->__mixed = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__wsnt__UnrecognizedPolicyRequestFaultType_ErrorCode(struct soap *soap, const struct _wsnt__UnrecognizedPolicyRequestFaultType_ErrorCode *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__wsnt__UnrecognizedPolicyRequestFaultType_ErrorCode(struct soap *soap, const char *tag, int id, const struct _wsnt__UnrecognizedPolicyRequestFaultType_ErrorCode *a, const char *type)
{
	soap_set_attr(soap, "dialect", a->dialect ? soap_xsd__anyURI2s(soap, a->dialect) : "", 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__wsnt__UnrecognizedPolicyRequestFaultType_ErrorCode), type))
		return soap->error;
	if (soap_outliteral(soap, "-mixed", (char*const*)&a->__mixed, NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _wsnt__UnrecognizedPolicyRequestFaultType_ErrorCode * SOAP_FMAC4 soap_in__wsnt__UnrecognizedPolicyRequestFaultType_ErrorCode(struct soap *soap, const char *tag, struct _wsnt__UnrecognizedPolicyRequestFaultType_ErrorCode *a, const char *type)
{
	size_t soap_flag___mixed = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct _wsnt__UnrecognizedPolicyRequestFaultType_ErrorCode*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__wsnt__UnrecognizedPolicyRequestFaultType_ErrorCode, sizeof(struct _wsnt__UnrecognizedPolicyRequestFaultType_ErrorCode), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__wsnt__UnrecognizedPolicyRequestFaultType_ErrorCode(soap, a);
	if (soap_s2xsd__anyURI(soap, soap_attr_value(soap, "dialect", 4, 1), &a->dialect))
		return NULL;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag___mixed && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_inliteral(soap, "-mixed", (char**)&a->__mixed))
				{	soap_flag___mixed--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _wsnt__UnrecognizedPolicyRequestFaultType_ErrorCode *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__wsnt__UnrecognizedPolicyRequestFaultType_ErrorCode, SOAP_TYPE__wsnt__UnrecognizedPolicyRequestFaultType_ErrorCode, sizeof(struct _wsnt__UnrecognizedPolicyRequestFaultType_ErrorCode), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _wsnt__UnrecognizedPolicyRequestFaultType_ErrorCode * SOAP_FMAC4 soap_new__wsnt__UnrecognizedPolicyRequestFaultType_ErrorCode(struct soap *soap, int n)
{
	struct _wsnt__UnrecognizedPolicyRequestFaultType_ErrorCode *p;
	struct _wsnt__UnrecognizedPolicyRequestFaultType_ErrorCode *a = (struct _wsnt__UnrecognizedPolicyRequestFaultType_ErrorCode*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _wsnt__UnrecognizedPolicyRequestFaultType_ErrorCode));
	for (p = a; p && n--; p++)
		soap_default__wsnt__UnrecognizedPolicyRequestFaultType_ErrorCode(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__wsnt__UnrecognizedPolicyRequestFaultType_ErrorCode(struct soap *soap, const struct _wsnt__UnrecognizedPolicyRequestFaultType_ErrorCode *a, const char *tag, const char *type)
{
	if (soap_out__wsnt__UnrecognizedPolicyRequestFaultType_ErrorCode(soap, tag ? tag : "wsnt:UnrecognizedPolicyRequestFaultType-ErrorCode", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _wsnt__UnrecognizedPolicyRequestFaultType_ErrorCode * SOAP_FMAC4 soap_get__wsnt__UnrecognizedPolicyRequestFaultType_ErrorCode(struct soap *soap, struct _wsnt__UnrecognizedPolicyRequestFaultType_ErrorCode *p, const char *tag, const char *type)
{
	if ((p = soap_in__wsnt__UnrecognizedPolicyRequestFaultType_ErrorCode(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_wsnt__UnrecognizedPolicyRequestFaultType(struct soap *soap, struct wsnt__UnrecognizedPolicyRequestFaultType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__size = 0;
	a->__any = NULL;
	soap_default_dateTime(soap, &a->wsrfbf__Timestamp);
	a->wsrfbf__Originator = NULL;
	a->wsrfbf__ErrorCode = NULL;
	a->__sizeDescription = 0;
	a->wsrfbf__Description = NULL;
	a->wsrfbf__FaultCause = NULL;
	a->__anyAttribute = NULL;
	a->__sizeUnrecognizedPolicy = 0;
	a->UnrecognizedPolicy = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_wsnt__UnrecognizedPolicyRequestFaultType(struct soap *soap, const struct wsnt__UnrecognizedPolicyRequestFaultType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &a->wsrfbf__Timestamp, SOAP_TYPE_dateTime);
	soap_serialize_PointerTowsa5__EndpointReferenceType(soap, &a->wsrfbf__Originator);
	soap_serialize_PointerTo_wsnt__UnrecognizedPolicyRequestFaultType_ErrorCode(soap, &a->wsrfbf__ErrorCode);
	if (a->wsrfbf__Description)
	{	int i;
		for (i = 0; i < (int)a->__sizeDescription; i++)
		{
			soap_embedded(soap, a->wsrfbf__Description + i, SOAP_TYPE__wsnt__UnrecognizedPolicyRequestFaultType_Description);
			soap_serialize__wsnt__UnrecognizedPolicyRequestFaultType_Description(soap, a->wsrfbf__Description + i);
		}
	}
	soap_serialize_PointerTo_wsnt__UnrecognizedPolicyRequestFaultType_FaultCause(soap, &a->wsrfbf__FaultCause);
	if (a->UnrecognizedPolicy)
	{	int i;
		for (i = 0; i < (int)a->__sizeUnrecognizedPolicy; i++)
		{
			soap_serialize__QName(soap, (char*const*)(a->UnrecognizedPolicy + i));
		}
	}
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_wsnt__UnrecognizedPolicyRequestFaultType(struct soap *soap, const char *tag, int id, const struct wsnt__UnrecognizedPolicyRequestFaultType *a, const char *type)
{
	if (a->__anyAttribute)
		soap_set_attr(soap, "-anyAttribute", a->__anyAttribute, 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_wsnt__UnrecognizedPolicyRequestFaultType), type))
		return soap->error;
	if (a->__any)
	{	int i;
		for (i = 0; i < (int)a->__size; i++)
			if (soap_outliteral(soap, "-any", (char*const*)(a->__any + i), NULL))
				return soap->error;
	}
	if (soap_out_dateTime(soap, "wsrfbf:Timestamp", -1, &a->wsrfbf__Timestamp, ""))
		return soap->error;
	if (soap_out_PointerTowsa5__EndpointReferenceType(soap, "wsrfbf:Originator", -1, &a->wsrfbf__Originator, ""))
		return soap->error;
	if (soap_out_PointerTo_wsnt__UnrecognizedPolicyRequestFaultType_ErrorCode(soap, "wsrfbf:ErrorCode", -1, &a->wsrfbf__ErrorCode, ""))
		return soap->error;
	if (a->wsrfbf__Description)
	{	int i;
		for (i = 0; i < (int)a->__sizeDescription; i++)
			if (soap_out__wsnt__UnrecognizedPolicyRequestFaultType_Description(soap, "wsrfbf:Description", -1, a->wsrfbf__Description + i, ""))
				return soap->error;
	}
	if (soap_out_PointerTo_wsnt__UnrecognizedPolicyRequestFaultType_FaultCause(soap, "wsrfbf:FaultCause", -1, &a->wsrfbf__FaultCause, ""))
		return soap->error;
	if (a->UnrecognizedPolicy)
	{	int i;
		for (i = 0; i < (int)a->__sizeUnrecognizedPolicy; i++)
		{	const char *soap_tmp_UnrecognizedPolicy = soap_QName2s(soap, a->UnrecognizedPolicy[i]);
			if (soap_out__QName(soap, "wsnt:UnrecognizedPolicy", -1, (char*const*)(void*)&soap_tmp_UnrecognizedPolicy, ""))
				return soap->error;
		}
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct wsnt__UnrecognizedPolicyRequestFaultType * SOAP_FMAC4 soap_in_wsnt__UnrecognizedPolicyRequestFaultType(struct soap *soap, const char *tag, struct wsnt__UnrecognizedPolicyRequestFaultType *a, const char *type)
{
	struct soap_blist *soap_blist___any = NULL;
	size_t soap_flag_wsrfbf__Timestamp = 1;
	size_t soap_flag_wsrfbf__Originator = 1;
	size_t soap_flag_wsrfbf__ErrorCode = 1;
	struct soap_blist *soap_blist_wsrfbf__Description = NULL;
	size_t soap_flag_wsrfbf__FaultCause = 1;
	struct soap_blist *soap_blist_UnrecognizedPolicy = NULL;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct wsnt__UnrecognizedPolicyRequestFaultType*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_wsnt__UnrecognizedPolicyRequestFaultType, sizeof(struct wsnt__UnrecognizedPolicyRequestFaultType), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_wsnt__UnrecognizedPolicyRequestFaultType(soap, a);
	if (soap_s2char(soap, soap_attr_value(soap, "-anyAttribute", 0, 0), &a->__anyAttribute, 0, 0, -1, NULL))
		return NULL;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_wsrfbf__Timestamp && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_dateTime(soap, "wsrfbf:Timestamp", &a->wsrfbf__Timestamp, "xsd:dateTime"))
				{	soap_flag_wsrfbf__Timestamp--;
					continue;
				}
			}
			if (soap_flag_wsrfbf__Originator && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTowsa5__EndpointReferenceType(soap, "wsrfbf:Originator", &a->wsrfbf__Originator, "wsa5:EndpointReferenceType"))
				{	soap_flag_wsrfbf__Originator--;
					continue;
				}
			}
			if (soap_flag_wsrfbf__ErrorCode && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_wsnt__UnrecognizedPolicyRequestFaultType_ErrorCode(soap, "wsrfbf:ErrorCode", &a->wsrfbf__ErrorCode, ""))
				{	soap_flag_wsrfbf__ErrorCode--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "wsrfbf:Description", 1, NULL))
			{	if (a->wsrfbf__Description == NULL)
				{	if (soap_blist_wsrfbf__Description == NULL)
						soap_blist_wsrfbf__Description = soap_alloc_block(soap);
					a->wsrfbf__Description = (struct _wsnt__UnrecognizedPolicyRequestFaultType_Description *)soap_push_block_max(soap, soap_blist_wsrfbf__Description, sizeof(struct _wsnt__UnrecognizedPolicyRequestFaultType_Description));
					if (a->wsrfbf__Description == NULL)
						return NULL;
					soap_default__wsnt__UnrecognizedPolicyRequestFaultType_Description(soap, a->wsrfbf__Description);
				}
				soap_revert(soap);
				if (soap_in__wsnt__UnrecognizedPolicyRequestFaultType_Description(soap, "wsrfbf:Description", a->wsrfbf__Description, ""))
				{	a->__sizeDescription++;
					a->wsrfbf__Description = NULL;
					continue;
				}
			}
			if (soap_flag_wsrfbf__FaultCause && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_wsnt__UnrecognizedPolicyRequestFaultType_FaultCause(soap, "wsrfbf:FaultCause", &a->wsrfbf__FaultCause, ""))
				{	soap_flag_wsrfbf__FaultCause--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "wsnt:UnrecognizedPolicy", 1, NULL))
			{	if (a->UnrecognizedPolicy == NULL)
				{	if (soap_blist_UnrecognizedPolicy == NULL)
						soap_blist_UnrecognizedPolicy = soap_alloc_block(soap);
					a->UnrecognizedPolicy = (char **)soap_push_block_max(soap, soap_blist_UnrecognizedPolicy, sizeof(char *));
					if (a->UnrecognizedPolicy == NULL)
						return NULL;
					*a->UnrecognizedPolicy = NULL;
				}
				soap_revert(soap);
				if (soap_in__QName(soap, "wsnt:UnrecognizedPolicy", (char**)a->UnrecognizedPolicy, "xsd:QName"))
				{	a->__sizeUnrecognizedPolicy++;
					a->UnrecognizedPolicy = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	if (a->__any == NULL)
				{	if (soap_blist___any == NULL)
						soap_blist___any = soap_alloc_block(soap);
					a->__any = (char **)soap_push_block_max(soap, soap_blist___any, sizeof(char *));
					if (a->__any == NULL)
						return NULL;
					*a->__any = NULL;
				}
				if (soap_inliteral(soap, "-any", (char**)a->__any))
				{	a->__size++;
					a->__any = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->__any)
			soap_pop_block(soap, soap_blist___any);
		if (a->__size)
		{	a->__any = (char **)soap_save_block(soap, soap_blist___any, NULL, 1);
		}
		else
		{	a->__any = NULL;
			if (soap_blist___any)
				soap_end_block(soap, soap_blist___any);
		}
		if (a->wsrfbf__Description)
			soap_pop_block(soap, soap_blist_wsrfbf__Description);
		if (a->__sizeDescription)
		{	a->wsrfbf__Description = (struct _wsnt__UnrecognizedPolicyRequestFaultType_Description *)soap_save_block(soap, soap_blist_wsrfbf__Description, NULL, 1);
		}
		else
		{	a->wsrfbf__Description = NULL;
			if (soap_blist_wsrfbf__Description)
				soap_end_block(soap, soap_blist_wsrfbf__Description);
		}
		if (a->UnrecognizedPolicy)
			soap_pop_block(soap, soap_blist_UnrecognizedPolicy);
		if (a->__sizeUnrecognizedPolicy)
		{	a->UnrecognizedPolicy = (char **)soap_save_block(soap, soap_blist_UnrecognizedPolicy, NULL, 1);
		}
		else
		{	a->UnrecognizedPolicy = NULL;
			if (soap_blist_UnrecognizedPolicy)
				soap_end_block(soap, soap_blist_UnrecognizedPolicy);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_wsrfbf__Timestamp > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct wsnt__UnrecognizedPolicyRequestFaultType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_wsnt__UnrecognizedPolicyRequestFaultType, SOAP_TYPE_wsnt__UnrecognizedPolicyRequestFaultType, sizeof(struct wsnt__UnrecognizedPolicyRequestFaultType), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct wsnt__UnrecognizedPolicyRequestFaultType * SOAP_FMAC4 soap_new_wsnt__UnrecognizedPolicyRequestFaultType(struct soap *soap, int n)
{
	struct wsnt__UnrecognizedPolicyRequestFaultType *p;
	struct wsnt__UnrecognizedPolicyRequestFaultType *a = (struct wsnt__UnrecognizedPolicyRequestFaultType*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct wsnt__UnrecognizedPolicyRequestFaultType));
	for (p = a; p && n--; p++)
		soap_default_wsnt__UnrecognizedPolicyRequestFaultType(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_wsnt__UnrecognizedPolicyRequestFaultType(struct soap *soap, const struct wsnt__UnrecognizedPolicyRequestFaultType *a, const char *tag, const char *type)
{
	if (soap_out_wsnt__UnrecognizedPolicyRequestFaultType(soap, tag ? tag : "wsnt:UnrecognizedPolicyRequestFaultType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct wsnt__UnrecognizedPolicyRequestFaultType * SOAP_FMAC4 soap_get_wsnt__UnrecognizedPolicyRequestFaultType(struct soap *soap, struct wsnt__UnrecognizedPolicyRequestFaultType *p, const char *tag, const char *type)
{
	if ((p = soap_in_wsnt__UnrecognizedPolicyRequestFaultType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__wsnt__InvalidMessageContentExpressionFaultType_FaultCause(struct soap *soap, struct _wsnt__InvalidMessageContentExpressionFaultType_FaultCause *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__any = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__wsnt__InvalidMessageContentExpressionFaultType_FaultCause(struct soap *soap, const struct _wsnt__InvalidMessageContentExpressionFaultType_FaultCause *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__wsnt__InvalidMessageContentExpressionFaultType_FaultCause(struct soap *soap, const char *tag, int id, const struct _wsnt__InvalidMessageContentExpressionFaultType_FaultCause *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__wsnt__InvalidMessageContentExpressionFaultType_FaultCause), type))
		return soap->error;
	if (soap_outliteral(soap, "-any", (char*const*)&a->__any, NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _wsnt__InvalidMessageContentExpressionFaultType_FaultCause * SOAP_FMAC4 soap_in__wsnt__InvalidMessageContentExpressionFaultType_FaultCause(struct soap *soap, const char *tag, struct _wsnt__InvalidMessageContentExpressionFaultType_FaultCause *a, const char *type)
{
	size_t soap_flag___any = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct _wsnt__InvalidMessageContentExpressionFaultType_FaultCause*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__wsnt__InvalidMessageContentExpressionFaultType_FaultCause, sizeof(struct _wsnt__InvalidMessageContentExpressionFaultType_FaultCause), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__wsnt__InvalidMessageContentExpressionFaultType_FaultCause(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag___any && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_inliteral(soap, "-any", (char**)&a->__any))
				{	soap_flag___any--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _wsnt__InvalidMessageContentExpressionFaultType_FaultCause *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__wsnt__InvalidMessageContentExpressionFaultType_FaultCause, SOAP_TYPE__wsnt__InvalidMessageContentExpressionFaultType_FaultCause, sizeof(struct _wsnt__InvalidMessageContentExpressionFaultType_FaultCause), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _wsnt__InvalidMessageContentExpressionFaultType_FaultCause * SOAP_FMAC4 soap_new__wsnt__InvalidMessageContentExpressionFaultType_FaultCause(struct soap *soap, int n)
{
	struct _wsnt__InvalidMessageContentExpressionFaultType_FaultCause *p;
	struct _wsnt__InvalidMessageContentExpressionFaultType_FaultCause *a = (struct _wsnt__InvalidMessageContentExpressionFaultType_FaultCause*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _wsnt__InvalidMessageContentExpressionFaultType_FaultCause));
	for (p = a; p && n--; p++)
		soap_default__wsnt__InvalidMessageContentExpressionFaultType_FaultCause(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__wsnt__InvalidMessageContentExpressionFaultType_FaultCause(struct soap *soap, const struct _wsnt__InvalidMessageContentExpressionFaultType_FaultCause *a, const char *tag, const char *type)
{
	if (soap_out__wsnt__InvalidMessageContentExpressionFaultType_FaultCause(soap, tag ? tag : "wsnt:InvalidMessageContentExpressionFaultType-FaultCause", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _wsnt__InvalidMessageContentExpressionFaultType_FaultCause * SOAP_FMAC4 soap_get__wsnt__InvalidMessageContentExpressionFaultType_FaultCause(struct soap *soap, struct _wsnt__InvalidMessageContentExpressionFaultType_FaultCause *p, const char *tag, const char *type)
{
	if ((p = soap_in__wsnt__InvalidMessageContentExpressionFaultType_FaultCause(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__wsnt__InvalidMessageContentExpressionFaultType_Description(struct soap *soap, struct _wsnt__InvalidMessageContentExpressionFaultType_Description *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->__item);
	soap_default__xml__lang(soap, &a->xml__lang);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__wsnt__InvalidMessageContentExpressionFaultType_Description(struct soap *soap, const struct _wsnt__InvalidMessageContentExpressionFaultType_Description *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_string(soap, (char*const*)&a->__item);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__wsnt__InvalidMessageContentExpressionFaultType_Description(struct soap *soap, const char *tag, int id, const struct _wsnt__InvalidMessageContentExpressionFaultType_Description *a, const char *type)
{
	if (a->xml__lang)
		soap_set_attr(soap, "xml:lang", soap__xml__lang2s(soap, a->xml__lang), 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	return soap_out_string(soap, tag, id, (char*const*)&a->__item, "");
}

SOAP_FMAC3 struct _wsnt__InvalidMessageContentExpressionFaultType_Description * SOAP_FMAC4 soap_in__wsnt__InvalidMessageContentExpressionFaultType_Description(struct soap *soap, const char *tag, struct _wsnt__InvalidMessageContentExpressionFaultType_Description *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	if (!(a = (struct _wsnt__InvalidMessageContentExpressionFaultType_Description *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__wsnt__InvalidMessageContentExpressionFaultType_Description, sizeof(struct _wsnt__InvalidMessageContentExpressionFaultType_Description), NULL, NULL, NULL, NULL)))
		return NULL;
	soap_revert(soap);
	*soap->id = '\0';
	soap_default__wsnt__InvalidMessageContentExpressionFaultType_Description(soap, a);
	if (soap_s2_xml__lang(soap, soap_attr_value(soap, "xml:lang", 1, 0), &a->xml__lang))
		return NULL;
	if (!soap_in_string(soap, tag, (char**)&a->__item, ""))
		return NULL;
	return a;
}

SOAP_FMAC3 struct _wsnt__InvalidMessageContentExpressionFaultType_Description * SOAP_FMAC4 soap_new__wsnt__InvalidMessageContentExpressionFaultType_Description(struct soap *soap, int n)
{
	struct _wsnt__InvalidMessageContentExpressionFaultType_Description *p;
	struct _wsnt__InvalidMessageContentExpressionFaultType_Description *a = (struct _wsnt__InvalidMessageContentExpressionFaultType_Description*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _wsnt__InvalidMessageContentExpressionFaultType_Description));
	for (p = a; p && n--; p++)
		soap_default__wsnt__InvalidMessageContentExpressionFaultType_Description(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__wsnt__InvalidMessageContentExpressionFaultType_Description(struct soap *soap, const struct _wsnt__InvalidMessageContentExpressionFaultType_Description *a, const char *tag, const char *type)
{
	if (soap_out__wsnt__InvalidMessageContentExpressionFaultType_Description(soap, tag ? tag : "wsnt:InvalidMessageContentExpressionFaultType-Description", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _wsnt__InvalidMessageContentExpressionFaultType_Description * SOAP_FMAC4 soap_get__wsnt__InvalidMessageContentExpressionFaultType_Description(struct soap *soap, struct _wsnt__InvalidMessageContentExpressionFaultType_Description *p, const char *tag, const char *type)
{
	if ((p = soap_in__wsnt__InvalidMessageContentExpressionFaultType_Description(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__wsnt__InvalidMessageContentExpressionFaultType_ErrorCode(struct soap *soap, struct _wsnt__InvalidMessageContentExpressionFaultType_ErrorCode *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_xsd__anyURI(soap, &a->dialect);
	a->__mixed = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__wsnt__InvalidMessageContentExpressionFaultType_ErrorCode(struct soap *soap, const struct _wsnt__InvalidMessageContentExpressionFaultType_ErrorCode *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__wsnt__InvalidMessageContentExpressionFaultType_ErrorCode(struct soap *soap, const char *tag, int id, const struct _wsnt__InvalidMessageContentExpressionFaultType_ErrorCode *a, const char *type)
{
	soap_set_attr(soap, "dialect", a->dialect ? soap_xsd__anyURI2s(soap, a->dialect) : "", 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__wsnt__InvalidMessageContentExpressionFaultType_ErrorCode), type))
		return soap->error;
	if (soap_outliteral(soap, "-mixed", (char*const*)&a->__mixed, NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _wsnt__InvalidMessageContentExpressionFaultType_ErrorCode * SOAP_FMAC4 soap_in__wsnt__InvalidMessageContentExpressionFaultType_ErrorCode(struct soap *soap, const char *tag, struct _wsnt__InvalidMessageContentExpressionFaultType_ErrorCode *a, const char *type)
{
	size_t soap_flag___mixed = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct _wsnt__InvalidMessageContentExpressionFaultType_ErrorCode*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__wsnt__InvalidMessageContentExpressionFaultType_ErrorCode, sizeof(struct _wsnt__InvalidMessageContentExpressionFaultType_ErrorCode), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__wsnt__InvalidMessageContentExpressionFaultType_ErrorCode(soap, a);
	if (soap_s2xsd__anyURI(soap, soap_attr_value(soap, "dialect", 4, 1), &a->dialect))
		return NULL;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag___mixed && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_inliteral(soap, "-mixed", (char**)&a->__mixed))
				{	soap_flag___mixed--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _wsnt__InvalidMessageContentExpressionFaultType_ErrorCode *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__wsnt__InvalidMessageContentExpressionFaultType_ErrorCode, SOAP_TYPE__wsnt__InvalidMessageContentExpressionFaultType_ErrorCode, sizeof(struct _wsnt__InvalidMessageContentExpressionFaultType_ErrorCode), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _wsnt__InvalidMessageContentExpressionFaultType_ErrorCode * SOAP_FMAC4 soap_new__wsnt__InvalidMessageContentExpressionFaultType_ErrorCode(struct soap *soap, int n)
{
	struct _wsnt__InvalidMessageContentExpressionFaultType_ErrorCode *p;
	struct _wsnt__InvalidMessageContentExpressionFaultType_ErrorCode *a = (struct _wsnt__InvalidMessageContentExpressionFaultType_ErrorCode*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _wsnt__InvalidMessageContentExpressionFaultType_ErrorCode));
	for (p = a; p && n--; p++)
		soap_default__wsnt__InvalidMessageContentExpressionFaultType_ErrorCode(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__wsnt__InvalidMessageContentExpressionFaultType_ErrorCode(struct soap *soap, const struct _wsnt__InvalidMessageContentExpressionFaultType_ErrorCode *a, const char *tag, const char *type)
{
	if (soap_out__wsnt__InvalidMessageContentExpressionFaultType_ErrorCode(soap, tag ? tag : "wsnt:InvalidMessageContentExpressionFaultType-ErrorCode", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _wsnt__InvalidMessageContentExpressionFaultType_ErrorCode * SOAP_FMAC4 soap_get__wsnt__InvalidMessageContentExpressionFaultType_ErrorCode(struct soap *soap, struct _wsnt__InvalidMessageContentExpressionFaultType_ErrorCode *p, const char *tag, const char *type)
{
	if ((p = soap_in__wsnt__InvalidMessageContentExpressionFaultType_ErrorCode(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_wsnt__InvalidMessageContentExpressionFaultType(struct soap *soap, struct wsnt__InvalidMessageContentExpressionFaultType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__size = 0;
	a->__any = NULL;
	soap_default_dateTime(soap, &a->wsrfbf__Timestamp);
	a->wsrfbf__Originator = NULL;
	a->wsrfbf__ErrorCode = NULL;
	a->__sizeDescription = 0;
	a->wsrfbf__Description = NULL;
	a->wsrfbf__FaultCause = NULL;
	a->__anyAttribute = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_wsnt__InvalidMessageContentExpressionFaultType(struct soap *soap, const struct wsnt__InvalidMessageContentExpressionFaultType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &a->wsrfbf__Timestamp, SOAP_TYPE_dateTime);
	soap_serialize_PointerTowsa5__EndpointReferenceType(soap, &a->wsrfbf__Originator);
	soap_serialize_PointerTo_wsnt__InvalidMessageContentExpressionFaultType_ErrorCode(soap, &a->wsrfbf__ErrorCode);
	if (a->wsrfbf__Description)
	{	int i;
		for (i = 0; i < (int)a->__sizeDescription; i++)
		{
			soap_embedded(soap, a->wsrfbf__Description + i, SOAP_TYPE__wsnt__InvalidMessageContentExpressionFaultType_Description);
			soap_serialize__wsnt__InvalidMessageContentExpressionFaultType_Description(soap, a->wsrfbf__Description + i);
		}
	}
	soap_serialize_PointerTo_wsnt__InvalidMessageContentExpressionFaultType_FaultCause(soap, &a->wsrfbf__FaultCause);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_wsnt__InvalidMessageContentExpressionFaultType(struct soap *soap, const char *tag, int id, const struct wsnt__InvalidMessageContentExpressionFaultType *a, const char *type)
{
	if (a->__anyAttribute)
		soap_set_attr(soap, "-anyAttribute", a->__anyAttribute, 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_wsnt__InvalidMessageContentExpressionFaultType), type))
		return soap->error;
	if (a->__any)
	{	int i;
		for (i = 0; i < (int)a->__size; i++)
			if (soap_outliteral(soap, "-any", (char*const*)(a->__any + i), NULL))
				return soap->error;
	}
	if (soap_out_dateTime(soap, "wsrfbf:Timestamp", -1, &a->wsrfbf__Timestamp, ""))
		return soap->error;
	if (soap_out_PointerTowsa5__EndpointReferenceType(soap, "wsrfbf:Originator", -1, &a->wsrfbf__Originator, ""))
		return soap->error;
	if (soap_out_PointerTo_wsnt__InvalidMessageContentExpressionFaultType_ErrorCode(soap, "wsrfbf:ErrorCode", -1, &a->wsrfbf__ErrorCode, ""))
		return soap->error;
	if (a->wsrfbf__Description)
	{	int i;
		for (i = 0; i < (int)a->__sizeDescription; i++)
			if (soap_out__wsnt__InvalidMessageContentExpressionFaultType_Description(soap, "wsrfbf:Description", -1, a->wsrfbf__Description + i, ""))
				return soap->error;
	}
	if (soap_out_PointerTo_wsnt__InvalidMessageContentExpressionFaultType_FaultCause(soap, "wsrfbf:FaultCause", -1, &a->wsrfbf__FaultCause, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct wsnt__InvalidMessageContentExpressionFaultType * SOAP_FMAC4 soap_in_wsnt__InvalidMessageContentExpressionFaultType(struct soap *soap, const char *tag, struct wsnt__InvalidMessageContentExpressionFaultType *a, const char *type)
{
	struct soap_blist *soap_blist___any = NULL;
	size_t soap_flag_wsrfbf__Timestamp = 1;
	size_t soap_flag_wsrfbf__Originator = 1;
	size_t soap_flag_wsrfbf__ErrorCode = 1;
	struct soap_blist *soap_blist_wsrfbf__Description = NULL;
	size_t soap_flag_wsrfbf__FaultCause = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct wsnt__InvalidMessageContentExpressionFaultType*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_wsnt__InvalidMessageContentExpressionFaultType, sizeof(struct wsnt__InvalidMessageContentExpressionFaultType), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_wsnt__InvalidMessageContentExpressionFaultType(soap, a);
	if (soap_s2char(soap, soap_attr_value(soap, "-anyAttribute", 0, 0), &a->__anyAttribute, 0, 0, -1, NULL))
		return NULL;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_wsrfbf__Timestamp && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_dateTime(soap, "wsrfbf:Timestamp", &a->wsrfbf__Timestamp, "xsd:dateTime"))
				{	soap_flag_wsrfbf__Timestamp--;
					continue;
				}
			}
			if (soap_flag_wsrfbf__Originator && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTowsa5__EndpointReferenceType(soap, "wsrfbf:Originator", &a->wsrfbf__Originator, "wsa5:EndpointReferenceType"))
				{	soap_flag_wsrfbf__Originator--;
					continue;
				}
			}
			if (soap_flag_wsrfbf__ErrorCode && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_wsnt__InvalidMessageContentExpressionFaultType_ErrorCode(soap, "wsrfbf:ErrorCode", &a->wsrfbf__ErrorCode, ""))
				{	soap_flag_wsrfbf__ErrorCode--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "wsrfbf:Description", 1, NULL))
			{	if (a->wsrfbf__Description == NULL)
				{	if (soap_blist_wsrfbf__Description == NULL)
						soap_blist_wsrfbf__Description = soap_alloc_block(soap);
					a->wsrfbf__Description = (struct _wsnt__InvalidMessageContentExpressionFaultType_Description *)soap_push_block_max(soap, soap_blist_wsrfbf__Description, sizeof(struct _wsnt__InvalidMessageContentExpressionFaultType_Description));
					if (a->wsrfbf__Description == NULL)
						return NULL;
					soap_default__wsnt__InvalidMessageContentExpressionFaultType_Description(soap, a->wsrfbf__Description);
				}
				soap_revert(soap);
				if (soap_in__wsnt__InvalidMessageContentExpressionFaultType_Description(soap, "wsrfbf:Description", a->wsrfbf__Description, ""))
				{	a->__sizeDescription++;
					a->wsrfbf__Description = NULL;
					continue;
				}
			}
			if (soap_flag_wsrfbf__FaultCause && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_wsnt__InvalidMessageContentExpressionFaultType_FaultCause(soap, "wsrfbf:FaultCause", &a->wsrfbf__FaultCause, ""))
				{	soap_flag_wsrfbf__FaultCause--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	if (a->__any == NULL)
				{	if (soap_blist___any == NULL)
						soap_blist___any = soap_alloc_block(soap);
					a->__any = (char **)soap_push_block_max(soap, soap_blist___any, sizeof(char *));
					if (a->__any == NULL)
						return NULL;
					*a->__any = NULL;
				}
				if (soap_inliteral(soap, "-any", (char**)a->__any))
				{	a->__size++;
					a->__any = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->__any)
			soap_pop_block(soap, soap_blist___any);
		if (a->__size)
		{	a->__any = (char **)soap_save_block(soap, soap_blist___any, NULL, 1);
		}
		else
		{	a->__any = NULL;
			if (soap_blist___any)
				soap_end_block(soap, soap_blist___any);
		}
		if (a->wsrfbf__Description)
			soap_pop_block(soap, soap_blist_wsrfbf__Description);
		if (a->__sizeDescription)
		{	a->wsrfbf__Description = (struct _wsnt__InvalidMessageContentExpressionFaultType_Description *)soap_save_block(soap, soap_blist_wsrfbf__Description, NULL, 1);
		}
		else
		{	a->wsrfbf__Description = NULL;
			if (soap_blist_wsrfbf__Description)
				soap_end_block(soap, soap_blist_wsrfbf__Description);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_wsrfbf__Timestamp > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct wsnt__InvalidMessageContentExpressionFaultType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_wsnt__InvalidMessageContentExpressionFaultType, SOAP_TYPE_wsnt__InvalidMessageContentExpressionFaultType, sizeof(struct wsnt__InvalidMessageContentExpressionFaultType), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct wsnt__InvalidMessageContentExpressionFaultType * SOAP_FMAC4 soap_new_wsnt__InvalidMessageContentExpressionFaultType(struct soap *soap, int n)
{
	struct wsnt__InvalidMessageContentExpressionFaultType *p;
	struct wsnt__InvalidMessageContentExpressionFaultType *a = (struct wsnt__InvalidMessageContentExpressionFaultType*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct wsnt__InvalidMessageContentExpressionFaultType));
	for (p = a; p && n--; p++)
		soap_default_wsnt__InvalidMessageContentExpressionFaultType(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_wsnt__InvalidMessageContentExpressionFaultType(struct soap *soap, const struct wsnt__InvalidMessageContentExpressionFaultType *a, const char *tag, const char *type)
{
	if (soap_out_wsnt__InvalidMessageContentExpressionFaultType(soap, tag ? tag : "wsnt:InvalidMessageContentExpressionFaultType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct wsnt__InvalidMessageContentExpressionFaultType * SOAP_FMAC4 soap_get_wsnt__InvalidMessageContentExpressionFaultType(struct soap *soap, struct wsnt__InvalidMessageContentExpressionFaultType *p, const char *tag, const char *type)
{
	if ((p = soap_in_wsnt__InvalidMessageContentExpressionFaultType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__wsnt__InvalidProducerPropertiesExpressionFaultType_FaultCause(struct soap *soap, struct _wsnt__InvalidProducerPropertiesExpressionFaultType_FaultCause *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__any = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__wsnt__InvalidProducerPropertiesExpressionFaultType_FaultCause(struct soap *soap, const struct _wsnt__InvalidProducerPropertiesExpressionFaultType_FaultCause *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__wsnt__InvalidProducerPropertiesExpressionFaultType_FaultCause(struct soap *soap, const char *tag, int id, const struct _wsnt__InvalidProducerPropertiesExpressionFaultType_FaultCause *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__wsnt__InvalidProducerPropertiesExpressionFaultType_FaultCause), type))
		return soap->error;
	if (soap_outliteral(soap, "-any", (char*const*)&a->__any, NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _wsnt__InvalidProducerPropertiesExpressionFaultType_FaultCause * SOAP_FMAC4 soap_in__wsnt__InvalidProducerPropertiesExpressionFaultType_FaultCause(struct soap *soap, const char *tag, struct _wsnt__InvalidProducerPropertiesExpressionFaultType_FaultCause *a, const char *type)
{
	size_t soap_flag___any = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct _wsnt__InvalidProducerPropertiesExpressionFaultType_FaultCause*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__wsnt__InvalidProducerPropertiesExpressionFaultType_FaultCause, sizeof(struct _wsnt__InvalidProducerPropertiesExpressionFaultType_FaultCause), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__wsnt__InvalidProducerPropertiesExpressionFaultType_FaultCause(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag___any && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_inliteral(soap, "-any", (char**)&a->__any))
				{	soap_flag___any--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _wsnt__InvalidProducerPropertiesExpressionFaultType_FaultCause *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__wsnt__InvalidProducerPropertiesExpressionFaultType_FaultCause, SOAP_TYPE__wsnt__InvalidProducerPropertiesExpressionFaultType_FaultCause, sizeof(struct _wsnt__InvalidProducerPropertiesExpressionFaultType_FaultCause), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _wsnt__InvalidProducerPropertiesExpressionFaultType_FaultCause * SOAP_FMAC4 soap_new__wsnt__InvalidProducerPropertiesExpressionFaultType_FaultCause(struct soap *soap, int n)
{
	struct _wsnt__InvalidProducerPropertiesExpressionFaultType_FaultCause *p;
	struct _wsnt__InvalidProducerPropertiesExpressionFaultType_FaultCause *a = (struct _wsnt__InvalidProducerPropertiesExpressionFaultType_FaultCause*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _wsnt__InvalidProducerPropertiesExpressionFaultType_FaultCause));
	for (p = a; p && n--; p++)
		soap_default__wsnt__InvalidProducerPropertiesExpressionFaultType_FaultCause(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__wsnt__InvalidProducerPropertiesExpressionFaultType_FaultCause(struct soap *soap, const struct _wsnt__InvalidProducerPropertiesExpressionFaultType_FaultCause *a, const char *tag, const char *type)
{
	if (soap_out__wsnt__InvalidProducerPropertiesExpressionFaultType_FaultCause(soap, tag ? tag : "wsnt:InvalidProducerPropertiesExpressionFaultType-FaultCause", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _wsnt__InvalidProducerPropertiesExpressionFaultType_FaultCause * SOAP_FMAC4 soap_get__wsnt__InvalidProducerPropertiesExpressionFaultType_FaultCause(struct soap *soap, struct _wsnt__InvalidProducerPropertiesExpressionFaultType_FaultCause *p, const char *tag, const char *type)
{
	if ((p = soap_in__wsnt__InvalidProducerPropertiesExpressionFaultType_FaultCause(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__wsnt__InvalidProducerPropertiesExpressionFaultType_Description(struct soap *soap, struct _wsnt__InvalidProducerPropertiesExpressionFaultType_Description *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->__item);
	soap_default__xml__lang(soap, &a->xml__lang);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__wsnt__InvalidProducerPropertiesExpressionFaultType_Description(struct soap *soap, const struct _wsnt__InvalidProducerPropertiesExpressionFaultType_Description *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_string(soap, (char*const*)&a->__item);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__wsnt__InvalidProducerPropertiesExpressionFaultType_Description(struct soap *soap, const char *tag, int id, const struct _wsnt__InvalidProducerPropertiesExpressionFaultType_Description *a, const char *type)
{
	if (a->xml__lang)
		soap_set_attr(soap, "xml:lang", soap__xml__lang2s(soap, a->xml__lang), 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	return soap_out_string(soap, tag, id, (char*const*)&a->__item, "");
}

SOAP_FMAC3 struct _wsnt__InvalidProducerPropertiesExpressionFaultType_Description * SOAP_FMAC4 soap_in__wsnt__InvalidProducerPropertiesExpressionFaultType_Description(struct soap *soap, const char *tag, struct _wsnt__InvalidProducerPropertiesExpressionFaultType_Description *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	if (!(a = (struct _wsnt__InvalidProducerPropertiesExpressionFaultType_Description *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__wsnt__InvalidProducerPropertiesExpressionFaultType_Description, sizeof(struct _wsnt__InvalidProducerPropertiesExpressionFaultType_Description), NULL, NULL, NULL, NULL)))
		return NULL;
	soap_revert(soap);
	*soap->id = '\0';
	soap_default__wsnt__InvalidProducerPropertiesExpressionFaultType_Description(soap, a);
	if (soap_s2_xml__lang(soap, soap_attr_value(soap, "xml:lang", 1, 0), &a->xml__lang))
		return NULL;
	if (!soap_in_string(soap, tag, (char**)&a->__item, ""))
		return NULL;
	return a;
}

SOAP_FMAC3 struct _wsnt__InvalidProducerPropertiesExpressionFaultType_Description * SOAP_FMAC4 soap_new__wsnt__InvalidProducerPropertiesExpressionFaultType_Description(struct soap *soap, int n)
{
	struct _wsnt__InvalidProducerPropertiesExpressionFaultType_Description *p;
	struct _wsnt__InvalidProducerPropertiesExpressionFaultType_Description *a = (struct _wsnt__InvalidProducerPropertiesExpressionFaultType_Description*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _wsnt__InvalidProducerPropertiesExpressionFaultType_Description));
	for (p = a; p && n--; p++)
		soap_default__wsnt__InvalidProducerPropertiesExpressionFaultType_Description(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__wsnt__InvalidProducerPropertiesExpressionFaultType_Description(struct soap *soap, const struct _wsnt__InvalidProducerPropertiesExpressionFaultType_Description *a, const char *tag, const char *type)
{
	if (soap_out__wsnt__InvalidProducerPropertiesExpressionFaultType_Description(soap, tag ? tag : "wsnt:InvalidProducerPropertiesExpressionFaultType-Description", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _wsnt__InvalidProducerPropertiesExpressionFaultType_Description * SOAP_FMAC4 soap_get__wsnt__InvalidProducerPropertiesExpressionFaultType_Description(struct soap *soap, struct _wsnt__InvalidProducerPropertiesExpressionFaultType_Description *p, const char *tag, const char *type)
{
	if ((p = soap_in__wsnt__InvalidProducerPropertiesExpressionFaultType_Description(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__wsnt__InvalidProducerPropertiesExpressionFaultType_ErrorCode(struct soap *soap, struct _wsnt__InvalidProducerPropertiesExpressionFaultType_ErrorCode *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_xsd__anyURI(soap, &a->dialect);
	a->__mixed = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__wsnt__InvalidProducerPropertiesExpressionFaultType_ErrorCode(struct soap *soap, const struct _wsnt__InvalidProducerPropertiesExpressionFaultType_ErrorCode *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__wsnt__InvalidProducerPropertiesExpressionFaultType_ErrorCode(struct soap *soap, const char *tag, int id, const struct _wsnt__InvalidProducerPropertiesExpressionFaultType_ErrorCode *a, const char *type)
{
	soap_set_attr(soap, "dialect", a->dialect ? soap_xsd__anyURI2s(soap, a->dialect) : "", 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__wsnt__InvalidProducerPropertiesExpressionFaultType_ErrorCode), type))
		return soap->error;
	if (soap_outliteral(soap, "-mixed", (char*const*)&a->__mixed, NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _wsnt__InvalidProducerPropertiesExpressionFaultType_ErrorCode * SOAP_FMAC4 soap_in__wsnt__InvalidProducerPropertiesExpressionFaultType_ErrorCode(struct soap *soap, const char *tag, struct _wsnt__InvalidProducerPropertiesExpressionFaultType_ErrorCode *a, const char *type)
{
	size_t soap_flag___mixed = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct _wsnt__InvalidProducerPropertiesExpressionFaultType_ErrorCode*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__wsnt__InvalidProducerPropertiesExpressionFaultType_ErrorCode, sizeof(struct _wsnt__InvalidProducerPropertiesExpressionFaultType_ErrorCode), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__wsnt__InvalidProducerPropertiesExpressionFaultType_ErrorCode(soap, a);
	if (soap_s2xsd__anyURI(soap, soap_attr_value(soap, "dialect", 4, 1), &a->dialect))
		return NULL;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag___mixed && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_inliteral(soap, "-mixed", (char**)&a->__mixed))
				{	soap_flag___mixed--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _wsnt__InvalidProducerPropertiesExpressionFaultType_ErrorCode *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__wsnt__InvalidProducerPropertiesExpressionFaultType_ErrorCode, SOAP_TYPE__wsnt__InvalidProducerPropertiesExpressionFaultType_ErrorCode, sizeof(struct _wsnt__InvalidProducerPropertiesExpressionFaultType_ErrorCode), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _wsnt__InvalidProducerPropertiesExpressionFaultType_ErrorCode * SOAP_FMAC4 soap_new__wsnt__InvalidProducerPropertiesExpressionFaultType_ErrorCode(struct soap *soap, int n)
{
	struct _wsnt__InvalidProducerPropertiesExpressionFaultType_ErrorCode *p;
	struct _wsnt__InvalidProducerPropertiesExpressionFaultType_ErrorCode *a = (struct _wsnt__InvalidProducerPropertiesExpressionFaultType_ErrorCode*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _wsnt__InvalidProducerPropertiesExpressionFaultType_ErrorCode));
	for (p = a; p && n--; p++)
		soap_default__wsnt__InvalidProducerPropertiesExpressionFaultType_ErrorCode(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__wsnt__InvalidProducerPropertiesExpressionFaultType_ErrorCode(struct soap *soap, const struct _wsnt__InvalidProducerPropertiesExpressionFaultType_ErrorCode *a, const char *tag, const char *type)
{
	if (soap_out__wsnt__InvalidProducerPropertiesExpressionFaultType_ErrorCode(soap, tag ? tag : "wsnt:InvalidProducerPropertiesExpressionFaultType-ErrorCode", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _wsnt__InvalidProducerPropertiesExpressionFaultType_ErrorCode * SOAP_FMAC4 soap_get__wsnt__InvalidProducerPropertiesExpressionFaultType_ErrorCode(struct soap *soap, struct _wsnt__InvalidProducerPropertiesExpressionFaultType_ErrorCode *p, const char *tag, const char *type)
{
	if ((p = soap_in__wsnt__InvalidProducerPropertiesExpressionFaultType_ErrorCode(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_wsnt__InvalidProducerPropertiesExpressionFaultType(struct soap *soap, struct wsnt__InvalidProducerPropertiesExpressionFaultType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__size = 0;
	a->__any = NULL;
	soap_default_dateTime(soap, &a->wsrfbf__Timestamp);
	a->wsrfbf__Originator = NULL;
	a->wsrfbf__ErrorCode = NULL;
	a->__sizeDescription = 0;
	a->wsrfbf__Description = NULL;
	a->wsrfbf__FaultCause = NULL;
	a->__anyAttribute = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_wsnt__InvalidProducerPropertiesExpressionFaultType(struct soap *soap, const struct wsnt__InvalidProducerPropertiesExpressionFaultType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &a->wsrfbf__Timestamp, SOAP_TYPE_dateTime);
	soap_serialize_PointerTowsa5__EndpointReferenceType(soap, &a->wsrfbf__Originator);
	soap_serialize_PointerTo_wsnt__InvalidProducerPropertiesExpressionFaultType_ErrorCode(soap, &a->wsrfbf__ErrorCode);
	if (a->wsrfbf__Description)
	{	int i;
		for (i = 0; i < (int)a->__sizeDescription; i++)
		{
			soap_embedded(soap, a->wsrfbf__Description + i, SOAP_TYPE__wsnt__InvalidProducerPropertiesExpressionFaultType_Description);
			soap_serialize__wsnt__InvalidProducerPropertiesExpressionFaultType_Description(soap, a->wsrfbf__Description + i);
		}
	}
	soap_serialize_PointerTo_wsnt__InvalidProducerPropertiesExpressionFaultType_FaultCause(soap, &a->wsrfbf__FaultCause);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_wsnt__InvalidProducerPropertiesExpressionFaultType(struct soap *soap, const char *tag, int id, const struct wsnt__InvalidProducerPropertiesExpressionFaultType *a, const char *type)
{
	if (a->__anyAttribute)
		soap_set_attr(soap, "-anyAttribute", a->__anyAttribute, 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_wsnt__InvalidProducerPropertiesExpressionFaultType), type))
		return soap->error;
	if (a->__any)
	{	int i;
		for (i = 0; i < (int)a->__size; i++)
			if (soap_outliteral(soap, "-any", (char*const*)(a->__any + i), NULL))
				return soap->error;
	}
	if (soap_out_dateTime(soap, "wsrfbf:Timestamp", -1, &a->wsrfbf__Timestamp, ""))
		return soap->error;
	if (soap_out_PointerTowsa5__EndpointReferenceType(soap, "wsrfbf:Originator", -1, &a->wsrfbf__Originator, ""))
		return soap->error;
	if (soap_out_PointerTo_wsnt__InvalidProducerPropertiesExpressionFaultType_ErrorCode(soap, "wsrfbf:ErrorCode", -1, &a->wsrfbf__ErrorCode, ""))
		return soap->error;
	if (a->wsrfbf__Description)
	{	int i;
		for (i = 0; i < (int)a->__sizeDescription; i++)
			if (soap_out__wsnt__InvalidProducerPropertiesExpressionFaultType_Description(soap, "wsrfbf:Description", -1, a->wsrfbf__Description + i, ""))
				return soap->error;
	}
	if (soap_out_PointerTo_wsnt__InvalidProducerPropertiesExpressionFaultType_FaultCause(soap, "wsrfbf:FaultCause", -1, &a->wsrfbf__FaultCause, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct wsnt__InvalidProducerPropertiesExpressionFaultType * SOAP_FMAC4 soap_in_wsnt__InvalidProducerPropertiesExpressionFaultType(struct soap *soap, const char *tag, struct wsnt__InvalidProducerPropertiesExpressionFaultType *a, const char *type)
{
	struct soap_blist *soap_blist___any = NULL;
	size_t soap_flag_wsrfbf__Timestamp = 1;
	size_t soap_flag_wsrfbf__Originator = 1;
	size_t soap_flag_wsrfbf__ErrorCode = 1;
	struct soap_blist *soap_blist_wsrfbf__Description = NULL;
	size_t soap_flag_wsrfbf__FaultCause = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct wsnt__InvalidProducerPropertiesExpressionFaultType*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_wsnt__InvalidProducerPropertiesExpressionFaultType, sizeof(struct wsnt__InvalidProducerPropertiesExpressionFaultType), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_wsnt__InvalidProducerPropertiesExpressionFaultType(soap, a);
	if (soap_s2char(soap, soap_attr_value(soap, "-anyAttribute", 0, 0), &a->__anyAttribute, 0, 0, -1, NULL))
		return NULL;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_wsrfbf__Timestamp && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_dateTime(soap, "wsrfbf:Timestamp", &a->wsrfbf__Timestamp, "xsd:dateTime"))
				{	soap_flag_wsrfbf__Timestamp--;
					continue;
				}
			}
			if (soap_flag_wsrfbf__Originator && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTowsa5__EndpointReferenceType(soap, "wsrfbf:Originator", &a->wsrfbf__Originator, "wsa5:EndpointReferenceType"))
				{	soap_flag_wsrfbf__Originator--;
					continue;
				}
			}
			if (soap_flag_wsrfbf__ErrorCode && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_wsnt__InvalidProducerPropertiesExpressionFaultType_ErrorCode(soap, "wsrfbf:ErrorCode", &a->wsrfbf__ErrorCode, ""))
				{	soap_flag_wsrfbf__ErrorCode--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "wsrfbf:Description", 1, NULL))
			{	if (a->wsrfbf__Description == NULL)
				{	if (soap_blist_wsrfbf__Description == NULL)
						soap_blist_wsrfbf__Description = soap_alloc_block(soap);
					a->wsrfbf__Description = (struct _wsnt__InvalidProducerPropertiesExpressionFaultType_Description *)soap_push_block_max(soap, soap_blist_wsrfbf__Description, sizeof(struct _wsnt__InvalidProducerPropertiesExpressionFaultType_Description));
					if (a->wsrfbf__Description == NULL)
						return NULL;
					soap_default__wsnt__InvalidProducerPropertiesExpressionFaultType_Description(soap, a->wsrfbf__Description);
				}
				soap_revert(soap);
				if (soap_in__wsnt__InvalidProducerPropertiesExpressionFaultType_Description(soap, "wsrfbf:Description", a->wsrfbf__Description, ""))
				{	a->__sizeDescription++;
					a->wsrfbf__Description = NULL;
					continue;
				}
			}
			if (soap_flag_wsrfbf__FaultCause && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_wsnt__InvalidProducerPropertiesExpressionFaultType_FaultCause(soap, "wsrfbf:FaultCause", &a->wsrfbf__FaultCause, ""))
				{	soap_flag_wsrfbf__FaultCause--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	if (a->__any == NULL)
				{	if (soap_blist___any == NULL)
						soap_blist___any = soap_alloc_block(soap);
					a->__any = (char **)soap_push_block_max(soap, soap_blist___any, sizeof(char *));
					if (a->__any == NULL)
						return NULL;
					*a->__any = NULL;
				}
				if (soap_inliteral(soap, "-any", (char**)a->__any))
				{	a->__size++;
					a->__any = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->__any)
			soap_pop_block(soap, soap_blist___any);
		if (a->__size)
		{	a->__any = (char **)soap_save_block(soap, soap_blist___any, NULL, 1);
		}
		else
		{	a->__any = NULL;
			if (soap_blist___any)
				soap_end_block(soap, soap_blist___any);
		}
		if (a->wsrfbf__Description)
			soap_pop_block(soap, soap_blist_wsrfbf__Description);
		if (a->__sizeDescription)
		{	a->wsrfbf__Description = (struct _wsnt__InvalidProducerPropertiesExpressionFaultType_Description *)soap_save_block(soap, soap_blist_wsrfbf__Description, NULL, 1);
		}
		else
		{	a->wsrfbf__Description = NULL;
			if (soap_blist_wsrfbf__Description)
				soap_end_block(soap, soap_blist_wsrfbf__Description);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_wsrfbf__Timestamp > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct wsnt__InvalidProducerPropertiesExpressionFaultType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_wsnt__InvalidProducerPropertiesExpressionFaultType, SOAP_TYPE_wsnt__InvalidProducerPropertiesExpressionFaultType, sizeof(struct wsnt__InvalidProducerPropertiesExpressionFaultType), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct wsnt__InvalidProducerPropertiesExpressionFaultType * SOAP_FMAC4 soap_new_wsnt__InvalidProducerPropertiesExpressionFaultType(struct soap *soap, int n)
{
	struct wsnt__InvalidProducerPropertiesExpressionFaultType *p;
	struct wsnt__InvalidProducerPropertiesExpressionFaultType *a = (struct wsnt__InvalidProducerPropertiesExpressionFaultType*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct wsnt__InvalidProducerPropertiesExpressionFaultType));
	for (p = a; p && n--; p++)
		soap_default_wsnt__InvalidProducerPropertiesExpressionFaultType(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_wsnt__InvalidProducerPropertiesExpressionFaultType(struct soap *soap, const struct wsnt__InvalidProducerPropertiesExpressionFaultType *a, const char *tag, const char *type)
{
	if (soap_out_wsnt__InvalidProducerPropertiesExpressionFaultType(soap, tag ? tag : "wsnt:InvalidProducerPropertiesExpressionFaultType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct wsnt__InvalidProducerPropertiesExpressionFaultType * SOAP_FMAC4 soap_get_wsnt__InvalidProducerPropertiesExpressionFaultType(struct soap *soap, struct wsnt__InvalidProducerPropertiesExpressionFaultType *p, const char *tag, const char *type)
{
	if ((p = soap_in_wsnt__InvalidProducerPropertiesExpressionFaultType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__wsnt__MultipleTopicsSpecifiedFaultType_FaultCause(struct soap *soap, struct _wsnt__MultipleTopicsSpecifiedFaultType_FaultCause *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__any = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__wsnt__MultipleTopicsSpecifiedFaultType_FaultCause(struct soap *soap, const struct _wsnt__MultipleTopicsSpecifiedFaultType_FaultCause *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__wsnt__MultipleTopicsSpecifiedFaultType_FaultCause(struct soap *soap, const char *tag, int id, const struct _wsnt__MultipleTopicsSpecifiedFaultType_FaultCause *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__wsnt__MultipleTopicsSpecifiedFaultType_FaultCause), type))
		return soap->error;
	if (soap_outliteral(soap, "-any", (char*const*)&a->__any, NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _wsnt__MultipleTopicsSpecifiedFaultType_FaultCause * SOAP_FMAC4 soap_in__wsnt__MultipleTopicsSpecifiedFaultType_FaultCause(struct soap *soap, const char *tag, struct _wsnt__MultipleTopicsSpecifiedFaultType_FaultCause *a, const char *type)
{
	size_t soap_flag___any = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct _wsnt__MultipleTopicsSpecifiedFaultType_FaultCause*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__wsnt__MultipleTopicsSpecifiedFaultType_FaultCause, sizeof(struct _wsnt__MultipleTopicsSpecifiedFaultType_FaultCause), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__wsnt__MultipleTopicsSpecifiedFaultType_FaultCause(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag___any && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_inliteral(soap, "-any", (char**)&a->__any))
				{	soap_flag___any--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _wsnt__MultipleTopicsSpecifiedFaultType_FaultCause *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__wsnt__MultipleTopicsSpecifiedFaultType_FaultCause, SOAP_TYPE__wsnt__MultipleTopicsSpecifiedFaultType_FaultCause, sizeof(struct _wsnt__MultipleTopicsSpecifiedFaultType_FaultCause), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _wsnt__MultipleTopicsSpecifiedFaultType_FaultCause * SOAP_FMAC4 soap_new__wsnt__MultipleTopicsSpecifiedFaultType_FaultCause(struct soap *soap, int n)
{
	struct _wsnt__MultipleTopicsSpecifiedFaultType_FaultCause *p;
	struct _wsnt__MultipleTopicsSpecifiedFaultType_FaultCause *a = (struct _wsnt__MultipleTopicsSpecifiedFaultType_FaultCause*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _wsnt__MultipleTopicsSpecifiedFaultType_FaultCause));
	for (p = a; p && n--; p++)
		soap_default__wsnt__MultipleTopicsSpecifiedFaultType_FaultCause(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__wsnt__MultipleTopicsSpecifiedFaultType_FaultCause(struct soap *soap, const struct _wsnt__MultipleTopicsSpecifiedFaultType_FaultCause *a, const char *tag, const char *type)
{
	if (soap_out__wsnt__MultipleTopicsSpecifiedFaultType_FaultCause(soap, tag ? tag : "wsnt:MultipleTopicsSpecifiedFaultType-FaultCause", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _wsnt__MultipleTopicsSpecifiedFaultType_FaultCause * SOAP_FMAC4 soap_get__wsnt__MultipleTopicsSpecifiedFaultType_FaultCause(struct soap *soap, struct _wsnt__MultipleTopicsSpecifiedFaultType_FaultCause *p, const char *tag, const char *type)
{
	if ((p = soap_in__wsnt__MultipleTopicsSpecifiedFaultType_FaultCause(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__wsnt__MultipleTopicsSpecifiedFaultType_Description(struct soap *soap, struct _wsnt__MultipleTopicsSpecifiedFaultType_Description *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->__item);
	soap_default__xml__lang(soap, &a->xml__lang);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__wsnt__MultipleTopicsSpecifiedFaultType_Description(struct soap *soap, const struct _wsnt__MultipleTopicsSpecifiedFaultType_Description *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_string(soap, (char*const*)&a->__item);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__wsnt__MultipleTopicsSpecifiedFaultType_Description(struct soap *soap, const char *tag, int id, const struct _wsnt__MultipleTopicsSpecifiedFaultType_Description *a, const char *type)
{
	if (a->xml__lang)
		soap_set_attr(soap, "xml:lang", soap__xml__lang2s(soap, a->xml__lang), 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	return soap_out_string(soap, tag, id, (char*const*)&a->__item, "");
}

SOAP_FMAC3 struct _wsnt__MultipleTopicsSpecifiedFaultType_Description * SOAP_FMAC4 soap_in__wsnt__MultipleTopicsSpecifiedFaultType_Description(struct soap *soap, const char *tag, struct _wsnt__MultipleTopicsSpecifiedFaultType_Description *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	if (!(a = (struct _wsnt__MultipleTopicsSpecifiedFaultType_Description *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__wsnt__MultipleTopicsSpecifiedFaultType_Description, sizeof(struct _wsnt__MultipleTopicsSpecifiedFaultType_Description), NULL, NULL, NULL, NULL)))
		return NULL;
	soap_revert(soap);
	*soap->id = '\0';
	soap_default__wsnt__MultipleTopicsSpecifiedFaultType_Description(soap, a);
	if (soap_s2_xml__lang(soap, soap_attr_value(soap, "xml:lang", 1, 0), &a->xml__lang))
		return NULL;
	if (!soap_in_string(soap, tag, (char**)&a->__item, ""))
		return NULL;
	return a;
}

SOAP_FMAC3 struct _wsnt__MultipleTopicsSpecifiedFaultType_Description * SOAP_FMAC4 soap_new__wsnt__MultipleTopicsSpecifiedFaultType_Description(struct soap *soap, int n)
{
	struct _wsnt__MultipleTopicsSpecifiedFaultType_Description *p;
	struct _wsnt__MultipleTopicsSpecifiedFaultType_Description *a = (struct _wsnt__MultipleTopicsSpecifiedFaultType_Description*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _wsnt__MultipleTopicsSpecifiedFaultType_Description));
	for (p = a; p && n--; p++)
		soap_default__wsnt__MultipleTopicsSpecifiedFaultType_Description(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__wsnt__MultipleTopicsSpecifiedFaultType_Description(struct soap *soap, const struct _wsnt__MultipleTopicsSpecifiedFaultType_Description *a, const char *tag, const char *type)
{
	if (soap_out__wsnt__MultipleTopicsSpecifiedFaultType_Description(soap, tag ? tag : "wsnt:MultipleTopicsSpecifiedFaultType-Description", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _wsnt__MultipleTopicsSpecifiedFaultType_Description * SOAP_FMAC4 soap_get__wsnt__MultipleTopicsSpecifiedFaultType_Description(struct soap *soap, struct _wsnt__MultipleTopicsSpecifiedFaultType_Description *p, const char *tag, const char *type)
{
	if ((p = soap_in__wsnt__MultipleTopicsSpecifiedFaultType_Description(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__wsnt__MultipleTopicsSpecifiedFaultType_ErrorCode(struct soap *soap, struct _wsnt__MultipleTopicsSpecifiedFaultType_ErrorCode *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_xsd__anyURI(soap, &a->dialect);
	a->__mixed = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__wsnt__MultipleTopicsSpecifiedFaultType_ErrorCode(struct soap *soap, const struct _wsnt__MultipleTopicsSpecifiedFaultType_ErrorCode *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__wsnt__MultipleTopicsSpecifiedFaultType_ErrorCode(struct soap *soap, const char *tag, int id, const struct _wsnt__MultipleTopicsSpecifiedFaultType_ErrorCode *a, const char *type)
{
	soap_set_attr(soap, "dialect", a->dialect ? soap_xsd__anyURI2s(soap, a->dialect) : "", 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__wsnt__MultipleTopicsSpecifiedFaultType_ErrorCode), type))
		return soap->error;
	if (soap_outliteral(soap, "-mixed", (char*const*)&a->__mixed, NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _wsnt__MultipleTopicsSpecifiedFaultType_ErrorCode * SOAP_FMAC4 soap_in__wsnt__MultipleTopicsSpecifiedFaultType_ErrorCode(struct soap *soap, const char *tag, struct _wsnt__MultipleTopicsSpecifiedFaultType_ErrorCode *a, const char *type)
{
	size_t soap_flag___mixed = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct _wsnt__MultipleTopicsSpecifiedFaultType_ErrorCode*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__wsnt__MultipleTopicsSpecifiedFaultType_ErrorCode, sizeof(struct _wsnt__MultipleTopicsSpecifiedFaultType_ErrorCode), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__wsnt__MultipleTopicsSpecifiedFaultType_ErrorCode(soap, a);
	if (soap_s2xsd__anyURI(soap, soap_attr_value(soap, "dialect", 4, 1), &a->dialect))
		return NULL;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag___mixed && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_inliteral(soap, "-mixed", (char**)&a->__mixed))
				{	soap_flag___mixed--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _wsnt__MultipleTopicsSpecifiedFaultType_ErrorCode *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__wsnt__MultipleTopicsSpecifiedFaultType_ErrorCode, SOAP_TYPE__wsnt__MultipleTopicsSpecifiedFaultType_ErrorCode, sizeof(struct _wsnt__MultipleTopicsSpecifiedFaultType_ErrorCode), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _wsnt__MultipleTopicsSpecifiedFaultType_ErrorCode * SOAP_FMAC4 soap_new__wsnt__MultipleTopicsSpecifiedFaultType_ErrorCode(struct soap *soap, int n)
{
	struct _wsnt__MultipleTopicsSpecifiedFaultType_ErrorCode *p;
	struct _wsnt__MultipleTopicsSpecifiedFaultType_ErrorCode *a = (struct _wsnt__MultipleTopicsSpecifiedFaultType_ErrorCode*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _wsnt__MultipleTopicsSpecifiedFaultType_ErrorCode));
	for (p = a; p && n--; p++)
		soap_default__wsnt__MultipleTopicsSpecifiedFaultType_ErrorCode(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__wsnt__MultipleTopicsSpecifiedFaultType_ErrorCode(struct soap *soap, const struct _wsnt__MultipleTopicsSpecifiedFaultType_ErrorCode *a, const char *tag, const char *type)
{
	if (soap_out__wsnt__MultipleTopicsSpecifiedFaultType_ErrorCode(soap, tag ? tag : "wsnt:MultipleTopicsSpecifiedFaultType-ErrorCode", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _wsnt__MultipleTopicsSpecifiedFaultType_ErrorCode * SOAP_FMAC4 soap_get__wsnt__MultipleTopicsSpecifiedFaultType_ErrorCode(struct soap *soap, struct _wsnt__MultipleTopicsSpecifiedFaultType_ErrorCode *p, const char *tag, const char *type)
{
	if ((p = soap_in__wsnt__MultipleTopicsSpecifiedFaultType_ErrorCode(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_wsnt__MultipleTopicsSpecifiedFaultType(struct soap *soap, struct wsnt__MultipleTopicsSpecifiedFaultType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__size = 0;
	a->__any = NULL;
	soap_default_dateTime(soap, &a->wsrfbf__Timestamp);
	a->wsrfbf__Originator = NULL;
	a->wsrfbf__ErrorCode = NULL;
	a->__sizeDescription = 0;
	a->wsrfbf__Description = NULL;
	a->wsrfbf__FaultCause = NULL;
	a->__anyAttribute = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_wsnt__MultipleTopicsSpecifiedFaultType(struct soap *soap, const struct wsnt__MultipleTopicsSpecifiedFaultType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &a->wsrfbf__Timestamp, SOAP_TYPE_dateTime);
	soap_serialize_PointerTowsa5__EndpointReferenceType(soap, &a->wsrfbf__Originator);
	soap_serialize_PointerTo_wsnt__MultipleTopicsSpecifiedFaultType_ErrorCode(soap, &a->wsrfbf__ErrorCode);
	if (a->wsrfbf__Description)
	{	int i;
		for (i = 0; i < (int)a->__sizeDescription; i++)
		{
			soap_embedded(soap, a->wsrfbf__Description + i, SOAP_TYPE__wsnt__MultipleTopicsSpecifiedFaultType_Description);
			soap_serialize__wsnt__MultipleTopicsSpecifiedFaultType_Description(soap, a->wsrfbf__Description + i);
		}
	}
	soap_serialize_PointerTo_wsnt__MultipleTopicsSpecifiedFaultType_FaultCause(soap, &a->wsrfbf__FaultCause);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_wsnt__MultipleTopicsSpecifiedFaultType(struct soap *soap, const char *tag, int id, const struct wsnt__MultipleTopicsSpecifiedFaultType *a, const char *type)
{
	if (a->__anyAttribute)
		soap_set_attr(soap, "-anyAttribute", a->__anyAttribute, 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_wsnt__MultipleTopicsSpecifiedFaultType), type))
		return soap->error;
	if (a->__any)
	{	int i;
		for (i = 0; i < (int)a->__size; i++)
			if (soap_outliteral(soap, "-any", (char*const*)(a->__any + i), NULL))
				return soap->error;
	}
	if (soap_out_dateTime(soap, "wsrfbf:Timestamp", -1, &a->wsrfbf__Timestamp, ""))
		return soap->error;
	if (soap_out_PointerTowsa5__EndpointReferenceType(soap, "wsrfbf:Originator", -1, &a->wsrfbf__Originator, ""))
		return soap->error;
	if (soap_out_PointerTo_wsnt__MultipleTopicsSpecifiedFaultType_ErrorCode(soap, "wsrfbf:ErrorCode", -1, &a->wsrfbf__ErrorCode, ""))
		return soap->error;
	if (a->wsrfbf__Description)
	{	int i;
		for (i = 0; i < (int)a->__sizeDescription; i++)
			if (soap_out__wsnt__MultipleTopicsSpecifiedFaultType_Description(soap, "wsrfbf:Description", -1, a->wsrfbf__Description + i, ""))
				return soap->error;
	}
	if (soap_out_PointerTo_wsnt__MultipleTopicsSpecifiedFaultType_FaultCause(soap, "wsrfbf:FaultCause", -1, &a->wsrfbf__FaultCause, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct wsnt__MultipleTopicsSpecifiedFaultType * SOAP_FMAC4 soap_in_wsnt__MultipleTopicsSpecifiedFaultType(struct soap *soap, const char *tag, struct wsnt__MultipleTopicsSpecifiedFaultType *a, const char *type)
{
	struct soap_blist *soap_blist___any = NULL;
	size_t soap_flag_wsrfbf__Timestamp = 1;
	size_t soap_flag_wsrfbf__Originator = 1;
	size_t soap_flag_wsrfbf__ErrorCode = 1;
	struct soap_blist *soap_blist_wsrfbf__Description = NULL;
	size_t soap_flag_wsrfbf__FaultCause = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct wsnt__MultipleTopicsSpecifiedFaultType*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_wsnt__MultipleTopicsSpecifiedFaultType, sizeof(struct wsnt__MultipleTopicsSpecifiedFaultType), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_wsnt__MultipleTopicsSpecifiedFaultType(soap, a);
	if (soap_s2char(soap, soap_attr_value(soap, "-anyAttribute", 0, 0), &a->__anyAttribute, 0, 0, -1, NULL))
		return NULL;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_wsrfbf__Timestamp && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_dateTime(soap, "wsrfbf:Timestamp", &a->wsrfbf__Timestamp, "xsd:dateTime"))
				{	soap_flag_wsrfbf__Timestamp--;
					continue;
				}
			}
			if (soap_flag_wsrfbf__Originator && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTowsa5__EndpointReferenceType(soap, "wsrfbf:Originator", &a->wsrfbf__Originator, "wsa5:EndpointReferenceType"))
				{	soap_flag_wsrfbf__Originator--;
					continue;
				}
			}
			if (soap_flag_wsrfbf__ErrorCode && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_wsnt__MultipleTopicsSpecifiedFaultType_ErrorCode(soap, "wsrfbf:ErrorCode", &a->wsrfbf__ErrorCode, ""))
				{	soap_flag_wsrfbf__ErrorCode--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "wsrfbf:Description", 1, NULL))
			{	if (a->wsrfbf__Description == NULL)
				{	if (soap_blist_wsrfbf__Description == NULL)
						soap_blist_wsrfbf__Description = soap_alloc_block(soap);
					a->wsrfbf__Description = (struct _wsnt__MultipleTopicsSpecifiedFaultType_Description *)soap_push_block_max(soap, soap_blist_wsrfbf__Description, sizeof(struct _wsnt__MultipleTopicsSpecifiedFaultType_Description));
					if (a->wsrfbf__Description == NULL)
						return NULL;
					soap_default__wsnt__MultipleTopicsSpecifiedFaultType_Description(soap, a->wsrfbf__Description);
				}
				soap_revert(soap);
				if (soap_in__wsnt__MultipleTopicsSpecifiedFaultType_Description(soap, "wsrfbf:Description", a->wsrfbf__Description, ""))
				{	a->__sizeDescription++;
					a->wsrfbf__Description = NULL;
					continue;
				}
			}
			if (soap_flag_wsrfbf__FaultCause && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_wsnt__MultipleTopicsSpecifiedFaultType_FaultCause(soap, "wsrfbf:FaultCause", &a->wsrfbf__FaultCause, ""))
				{	soap_flag_wsrfbf__FaultCause--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	if (a->__any == NULL)
				{	if (soap_blist___any == NULL)
						soap_blist___any = soap_alloc_block(soap);
					a->__any = (char **)soap_push_block_max(soap, soap_blist___any, sizeof(char *));
					if (a->__any == NULL)
						return NULL;
					*a->__any = NULL;
				}
				if (soap_inliteral(soap, "-any", (char**)a->__any))
				{	a->__size++;
					a->__any = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->__any)
			soap_pop_block(soap, soap_blist___any);
		if (a->__size)
		{	a->__any = (char **)soap_save_block(soap, soap_blist___any, NULL, 1);
		}
		else
		{	a->__any = NULL;
			if (soap_blist___any)
				soap_end_block(soap, soap_blist___any);
		}
		if (a->wsrfbf__Description)
			soap_pop_block(soap, soap_blist_wsrfbf__Description);
		if (a->__sizeDescription)
		{	a->wsrfbf__Description = (struct _wsnt__MultipleTopicsSpecifiedFaultType_Description *)soap_save_block(soap, soap_blist_wsrfbf__Description, NULL, 1);
		}
		else
		{	a->wsrfbf__Description = NULL;
			if (soap_blist_wsrfbf__Description)
				soap_end_block(soap, soap_blist_wsrfbf__Description);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_wsrfbf__Timestamp > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct wsnt__MultipleTopicsSpecifiedFaultType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_wsnt__MultipleTopicsSpecifiedFaultType, SOAP_TYPE_wsnt__MultipleTopicsSpecifiedFaultType, sizeof(struct wsnt__MultipleTopicsSpecifiedFaultType), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct wsnt__MultipleTopicsSpecifiedFaultType * SOAP_FMAC4 soap_new_wsnt__MultipleTopicsSpecifiedFaultType(struct soap *soap, int n)
{
	struct wsnt__MultipleTopicsSpecifiedFaultType *p;
	struct wsnt__MultipleTopicsSpecifiedFaultType *a = (struct wsnt__MultipleTopicsSpecifiedFaultType*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct wsnt__MultipleTopicsSpecifiedFaultType));
	for (p = a; p && n--; p++)
		soap_default_wsnt__MultipleTopicsSpecifiedFaultType(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_wsnt__MultipleTopicsSpecifiedFaultType(struct soap *soap, const struct wsnt__MultipleTopicsSpecifiedFaultType *a, const char *tag, const char *type)
{
	if (soap_out_wsnt__MultipleTopicsSpecifiedFaultType(soap, tag ? tag : "wsnt:MultipleTopicsSpecifiedFaultType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct wsnt__MultipleTopicsSpecifiedFaultType * SOAP_FMAC4 soap_get_wsnt__MultipleTopicsSpecifiedFaultType(struct soap *soap, struct wsnt__MultipleTopicsSpecifiedFaultType *p, const char *tag, const char *type)
{
	if ((p = soap_in_wsnt__MultipleTopicsSpecifiedFaultType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__wsnt__TopicNotSupportedFaultType_FaultCause(struct soap *soap, struct _wsnt__TopicNotSupportedFaultType_FaultCause *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__any = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__wsnt__TopicNotSupportedFaultType_FaultCause(struct soap *soap, const struct _wsnt__TopicNotSupportedFaultType_FaultCause *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__wsnt__TopicNotSupportedFaultType_FaultCause(struct soap *soap, const char *tag, int id, const struct _wsnt__TopicNotSupportedFaultType_FaultCause *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__wsnt__TopicNotSupportedFaultType_FaultCause), type))
		return soap->error;
	if (soap_outliteral(soap, "-any", (char*const*)&a->__any, NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _wsnt__TopicNotSupportedFaultType_FaultCause * SOAP_FMAC4 soap_in__wsnt__TopicNotSupportedFaultType_FaultCause(struct soap *soap, const char *tag, struct _wsnt__TopicNotSupportedFaultType_FaultCause *a, const char *type)
{
	size_t soap_flag___any = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct _wsnt__TopicNotSupportedFaultType_FaultCause*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__wsnt__TopicNotSupportedFaultType_FaultCause, sizeof(struct _wsnt__TopicNotSupportedFaultType_FaultCause), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__wsnt__TopicNotSupportedFaultType_FaultCause(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag___any && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_inliteral(soap, "-any", (char**)&a->__any))
				{	soap_flag___any--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _wsnt__TopicNotSupportedFaultType_FaultCause *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__wsnt__TopicNotSupportedFaultType_FaultCause, SOAP_TYPE__wsnt__TopicNotSupportedFaultType_FaultCause, sizeof(struct _wsnt__TopicNotSupportedFaultType_FaultCause), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _wsnt__TopicNotSupportedFaultType_FaultCause * SOAP_FMAC4 soap_new__wsnt__TopicNotSupportedFaultType_FaultCause(struct soap *soap, int n)
{
	struct _wsnt__TopicNotSupportedFaultType_FaultCause *p;
	struct _wsnt__TopicNotSupportedFaultType_FaultCause *a = (struct _wsnt__TopicNotSupportedFaultType_FaultCause*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _wsnt__TopicNotSupportedFaultType_FaultCause));
	for (p = a; p && n--; p++)
		soap_default__wsnt__TopicNotSupportedFaultType_FaultCause(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__wsnt__TopicNotSupportedFaultType_FaultCause(struct soap *soap, const struct _wsnt__TopicNotSupportedFaultType_FaultCause *a, const char *tag, const char *type)
{
	if (soap_out__wsnt__TopicNotSupportedFaultType_FaultCause(soap, tag ? tag : "wsnt:TopicNotSupportedFaultType-FaultCause", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _wsnt__TopicNotSupportedFaultType_FaultCause * SOAP_FMAC4 soap_get__wsnt__TopicNotSupportedFaultType_FaultCause(struct soap *soap, struct _wsnt__TopicNotSupportedFaultType_FaultCause *p, const char *tag, const char *type)
{
	if ((p = soap_in__wsnt__TopicNotSupportedFaultType_FaultCause(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__wsnt__TopicNotSupportedFaultType_Description(struct soap *soap, struct _wsnt__TopicNotSupportedFaultType_Description *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->__item);
	soap_default__xml__lang(soap, &a->xml__lang);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__wsnt__TopicNotSupportedFaultType_Description(struct soap *soap, const struct _wsnt__TopicNotSupportedFaultType_Description *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_string(soap, (char*const*)&a->__item);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__wsnt__TopicNotSupportedFaultType_Description(struct soap *soap, const char *tag, int id, const struct _wsnt__TopicNotSupportedFaultType_Description *a, const char *type)
{
	if (a->xml__lang)
		soap_set_attr(soap, "xml:lang", soap__xml__lang2s(soap, a->xml__lang), 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	return soap_out_string(soap, tag, id, (char*const*)&a->__item, "");
}

SOAP_FMAC3 struct _wsnt__TopicNotSupportedFaultType_Description * SOAP_FMAC4 soap_in__wsnt__TopicNotSupportedFaultType_Description(struct soap *soap, const char *tag, struct _wsnt__TopicNotSupportedFaultType_Description *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	if (!(a = (struct _wsnt__TopicNotSupportedFaultType_Description *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__wsnt__TopicNotSupportedFaultType_Description, sizeof(struct _wsnt__TopicNotSupportedFaultType_Description), NULL, NULL, NULL, NULL)))
		return NULL;
	soap_revert(soap);
	*soap->id = '\0';
	soap_default__wsnt__TopicNotSupportedFaultType_Description(soap, a);
	if (soap_s2_xml__lang(soap, soap_attr_value(soap, "xml:lang", 1, 0), &a->xml__lang))
		return NULL;
	if (!soap_in_string(soap, tag, (char**)&a->__item, ""))
		return NULL;
	return a;
}

SOAP_FMAC3 struct _wsnt__TopicNotSupportedFaultType_Description * SOAP_FMAC4 soap_new__wsnt__TopicNotSupportedFaultType_Description(struct soap *soap, int n)
{
	struct _wsnt__TopicNotSupportedFaultType_Description *p;
	struct _wsnt__TopicNotSupportedFaultType_Description *a = (struct _wsnt__TopicNotSupportedFaultType_Description*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _wsnt__TopicNotSupportedFaultType_Description));
	for (p = a; p && n--; p++)
		soap_default__wsnt__TopicNotSupportedFaultType_Description(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__wsnt__TopicNotSupportedFaultType_Description(struct soap *soap, const struct _wsnt__TopicNotSupportedFaultType_Description *a, const char *tag, const char *type)
{
	if (soap_out__wsnt__TopicNotSupportedFaultType_Description(soap, tag ? tag : "wsnt:TopicNotSupportedFaultType-Description", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _wsnt__TopicNotSupportedFaultType_Description * SOAP_FMAC4 soap_get__wsnt__TopicNotSupportedFaultType_Description(struct soap *soap, struct _wsnt__TopicNotSupportedFaultType_Description *p, const char *tag, const char *type)
{
	if ((p = soap_in__wsnt__TopicNotSupportedFaultType_Description(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__wsnt__TopicNotSupportedFaultType_ErrorCode(struct soap *soap, struct _wsnt__TopicNotSupportedFaultType_ErrorCode *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_xsd__anyURI(soap, &a->dialect);
	a->__mixed = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__wsnt__TopicNotSupportedFaultType_ErrorCode(struct soap *soap, const struct _wsnt__TopicNotSupportedFaultType_ErrorCode *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__wsnt__TopicNotSupportedFaultType_ErrorCode(struct soap *soap, const char *tag, int id, const struct _wsnt__TopicNotSupportedFaultType_ErrorCode *a, const char *type)
{
	soap_set_attr(soap, "dialect", a->dialect ? soap_xsd__anyURI2s(soap, a->dialect) : "", 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__wsnt__TopicNotSupportedFaultType_ErrorCode), type))
		return soap->error;
	if (soap_outliteral(soap, "-mixed", (char*const*)&a->__mixed, NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _wsnt__TopicNotSupportedFaultType_ErrorCode * SOAP_FMAC4 soap_in__wsnt__TopicNotSupportedFaultType_ErrorCode(struct soap *soap, const char *tag, struct _wsnt__TopicNotSupportedFaultType_ErrorCode *a, const char *type)
{
	size_t soap_flag___mixed = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct _wsnt__TopicNotSupportedFaultType_ErrorCode*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__wsnt__TopicNotSupportedFaultType_ErrorCode, sizeof(struct _wsnt__TopicNotSupportedFaultType_ErrorCode), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__wsnt__TopicNotSupportedFaultType_ErrorCode(soap, a);
	if (soap_s2xsd__anyURI(soap, soap_attr_value(soap, "dialect", 4, 1), &a->dialect))
		return NULL;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag___mixed && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_inliteral(soap, "-mixed", (char**)&a->__mixed))
				{	soap_flag___mixed--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _wsnt__TopicNotSupportedFaultType_ErrorCode *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__wsnt__TopicNotSupportedFaultType_ErrorCode, SOAP_TYPE__wsnt__TopicNotSupportedFaultType_ErrorCode, sizeof(struct _wsnt__TopicNotSupportedFaultType_ErrorCode), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _wsnt__TopicNotSupportedFaultType_ErrorCode * SOAP_FMAC4 soap_new__wsnt__TopicNotSupportedFaultType_ErrorCode(struct soap *soap, int n)
{
	struct _wsnt__TopicNotSupportedFaultType_ErrorCode *p;
	struct _wsnt__TopicNotSupportedFaultType_ErrorCode *a = (struct _wsnt__TopicNotSupportedFaultType_ErrorCode*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _wsnt__TopicNotSupportedFaultType_ErrorCode));
	for (p = a; p && n--; p++)
		soap_default__wsnt__TopicNotSupportedFaultType_ErrorCode(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__wsnt__TopicNotSupportedFaultType_ErrorCode(struct soap *soap, const struct _wsnt__TopicNotSupportedFaultType_ErrorCode *a, const char *tag, const char *type)
{
	if (soap_out__wsnt__TopicNotSupportedFaultType_ErrorCode(soap, tag ? tag : "wsnt:TopicNotSupportedFaultType-ErrorCode", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _wsnt__TopicNotSupportedFaultType_ErrorCode * SOAP_FMAC4 soap_get__wsnt__TopicNotSupportedFaultType_ErrorCode(struct soap *soap, struct _wsnt__TopicNotSupportedFaultType_ErrorCode *p, const char *tag, const char *type)
{
	if ((p = soap_in__wsnt__TopicNotSupportedFaultType_ErrorCode(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_wsnt__TopicNotSupportedFaultType(struct soap *soap, struct wsnt__TopicNotSupportedFaultType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__size = 0;
	a->__any = NULL;
	soap_default_dateTime(soap, &a->wsrfbf__Timestamp);
	a->wsrfbf__Originator = NULL;
	a->wsrfbf__ErrorCode = NULL;
	a->__sizeDescription = 0;
	a->wsrfbf__Description = NULL;
	a->wsrfbf__FaultCause = NULL;
	a->__anyAttribute = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_wsnt__TopicNotSupportedFaultType(struct soap *soap, const struct wsnt__TopicNotSupportedFaultType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &a->wsrfbf__Timestamp, SOAP_TYPE_dateTime);
	soap_serialize_PointerTowsa5__EndpointReferenceType(soap, &a->wsrfbf__Originator);
	soap_serialize_PointerTo_wsnt__TopicNotSupportedFaultType_ErrorCode(soap, &a->wsrfbf__ErrorCode);
	if (a->wsrfbf__Description)
	{	int i;
		for (i = 0; i < (int)a->__sizeDescription; i++)
		{
			soap_embedded(soap, a->wsrfbf__Description + i, SOAP_TYPE__wsnt__TopicNotSupportedFaultType_Description);
			soap_serialize__wsnt__TopicNotSupportedFaultType_Description(soap, a->wsrfbf__Description + i);
		}
	}
	soap_serialize_PointerTo_wsnt__TopicNotSupportedFaultType_FaultCause(soap, &a->wsrfbf__FaultCause);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_wsnt__TopicNotSupportedFaultType(struct soap *soap, const char *tag, int id, const struct wsnt__TopicNotSupportedFaultType *a, const char *type)
{
	if (a->__anyAttribute)
		soap_set_attr(soap, "-anyAttribute", a->__anyAttribute, 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_wsnt__TopicNotSupportedFaultType), type))
		return soap->error;
	if (a->__any)
	{	int i;
		for (i = 0; i < (int)a->__size; i++)
			if (soap_outliteral(soap, "-any", (char*const*)(a->__any + i), NULL))
				return soap->error;
	}
	if (soap_out_dateTime(soap, "wsrfbf:Timestamp", -1, &a->wsrfbf__Timestamp, ""))
		return soap->error;
	if (soap_out_PointerTowsa5__EndpointReferenceType(soap, "wsrfbf:Originator", -1, &a->wsrfbf__Originator, ""))
		return soap->error;
	if (soap_out_PointerTo_wsnt__TopicNotSupportedFaultType_ErrorCode(soap, "wsrfbf:ErrorCode", -1, &a->wsrfbf__ErrorCode, ""))
		return soap->error;
	if (a->wsrfbf__Description)
	{	int i;
		for (i = 0; i < (int)a->__sizeDescription; i++)
			if (soap_out__wsnt__TopicNotSupportedFaultType_Description(soap, "wsrfbf:Description", -1, a->wsrfbf__Description + i, ""))
				return soap->error;
	}
	if (soap_out_PointerTo_wsnt__TopicNotSupportedFaultType_FaultCause(soap, "wsrfbf:FaultCause", -1, &a->wsrfbf__FaultCause, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct wsnt__TopicNotSupportedFaultType * SOAP_FMAC4 soap_in_wsnt__TopicNotSupportedFaultType(struct soap *soap, const char *tag, struct wsnt__TopicNotSupportedFaultType *a, const char *type)
{
	struct soap_blist *soap_blist___any = NULL;
	size_t soap_flag_wsrfbf__Timestamp = 1;
	size_t soap_flag_wsrfbf__Originator = 1;
	size_t soap_flag_wsrfbf__ErrorCode = 1;
	struct soap_blist *soap_blist_wsrfbf__Description = NULL;
	size_t soap_flag_wsrfbf__FaultCause = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct wsnt__TopicNotSupportedFaultType*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_wsnt__TopicNotSupportedFaultType, sizeof(struct wsnt__TopicNotSupportedFaultType), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_wsnt__TopicNotSupportedFaultType(soap, a);
	if (soap_s2char(soap, soap_attr_value(soap, "-anyAttribute", 0, 0), &a->__anyAttribute, 0, 0, -1, NULL))
		return NULL;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_wsrfbf__Timestamp && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_dateTime(soap, "wsrfbf:Timestamp", &a->wsrfbf__Timestamp, "xsd:dateTime"))
				{	soap_flag_wsrfbf__Timestamp--;
					continue;
				}
			}
			if (soap_flag_wsrfbf__Originator && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTowsa5__EndpointReferenceType(soap, "wsrfbf:Originator", &a->wsrfbf__Originator, "wsa5:EndpointReferenceType"))
				{	soap_flag_wsrfbf__Originator--;
					continue;
				}
			}
			if (soap_flag_wsrfbf__ErrorCode && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_wsnt__TopicNotSupportedFaultType_ErrorCode(soap, "wsrfbf:ErrorCode", &a->wsrfbf__ErrorCode, ""))
				{	soap_flag_wsrfbf__ErrorCode--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "wsrfbf:Description", 1, NULL))
			{	if (a->wsrfbf__Description == NULL)
				{	if (soap_blist_wsrfbf__Description == NULL)
						soap_blist_wsrfbf__Description = soap_alloc_block(soap);
					a->wsrfbf__Description = (struct _wsnt__TopicNotSupportedFaultType_Description *)soap_push_block_max(soap, soap_blist_wsrfbf__Description, sizeof(struct _wsnt__TopicNotSupportedFaultType_Description));
					if (a->wsrfbf__Description == NULL)
						return NULL;
					soap_default__wsnt__TopicNotSupportedFaultType_Description(soap, a->wsrfbf__Description);
				}
				soap_revert(soap);
				if (soap_in__wsnt__TopicNotSupportedFaultType_Description(soap, "wsrfbf:Description", a->wsrfbf__Description, ""))
				{	a->__sizeDescription++;
					a->wsrfbf__Description = NULL;
					continue;
				}
			}
			if (soap_flag_wsrfbf__FaultCause && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_wsnt__TopicNotSupportedFaultType_FaultCause(soap, "wsrfbf:FaultCause", &a->wsrfbf__FaultCause, ""))
				{	soap_flag_wsrfbf__FaultCause--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	if (a->__any == NULL)
				{	if (soap_blist___any == NULL)
						soap_blist___any = soap_alloc_block(soap);
					a->__any = (char **)soap_push_block_max(soap, soap_blist___any, sizeof(char *));
					if (a->__any == NULL)
						return NULL;
					*a->__any = NULL;
				}
				if (soap_inliteral(soap, "-any", (char**)a->__any))
				{	a->__size++;
					a->__any = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->__any)
			soap_pop_block(soap, soap_blist___any);
		if (a->__size)
		{	a->__any = (char **)soap_save_block(soap, soap_blist___any, NULL, 1);
		}
		else
		{	a->__any = NULL;
			if (soap_blist___any)
				soap_end_block(soap, soap_blist___any);
		}
		if (a->wsrfbf__Description)
			soap_pop_block(soap, soap_blist_wsrfbf__Description);
		if (a->__sizeDescription)
		{	a->wsrfbf__Description = (struct _wsnt__TopicNotSupportedFaultType_Description *)soap_save_block(soap, soap_blist_wsrfbf__Description, NULL, 1);
		}
		else
		{	a->wsrfbf__Description = NULL;
			if (soap_blist_wsrfbf__Description)
				soap_end_block(soap, soap_blist_wsrfbf__Description);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_wsrfbf__Timestamp > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct wsnt__TopicNotSupportedFaultType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_wsnt__TopicNotSupportedFaultType, SOAP_TYPE_wsnt__TopicNotSupportedFaultType, sizeof(struct wsnt__TopicNotSupportedFaultType), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct wsnt__TopicNotSupportedFaultType * SOAP_FMAC4 soap_new_wsnt__TopicNotSupportedFaultType(struct soap *soap, int n)
{
	struct wsnt__TopicNotSupportedFaultType *p;
	struct wsnt__TopicNotSupportedFaultType *a = (struct wsnt__TopicNotSupportedFaultType*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct wsnt__TopicNotSupportedFaultType));
	for (p = a; p && n--; p++)
		soap_default_wsnt__TopicNotSupportedFaultType(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_wsnt__TopicNotSupportedFaultType(struct soap *soap, const struct wsnt__TopicNotSupportedFaultType *a, const char *tag, const char *type)
{
	if (soap_out_wsnt__TopicNotSupportedFaultType(soap, tag ? tag : "wsnt:TopicNotSupportedFaultType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct wsnt__TopicNotSupportedFaultType * SOAP_FMAC4 soap_get_wsnt__TopicNotSupportedFaultType(struct soap *soap, struct wsnt__TopicNotSupportedFaultType *p, const char *tag, const char *type)
{
	if ((p = soap_in_wsnt__TopicNotSupportedFaultType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__wsnt__InvalidTopicExpressionFaultType_FaultCause(struct soap *soap, struct _wsnt__InvalidTopicExpressionFaultType_FaultCause *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__any = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__wsnt__InvalidTopicExpressionFaultType_FaultCause(struct soap *soap, const struct _wsnt__InvalidTopicExpressionFaultType_FaultCause *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__wsnt__InvalidTopicExpressionFaultType_FaultCause(struct soap *soap, const char *tag, int id, const struct _wsnt__InvalidTopicExpressionFaultType_FaultCause *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__wsnt__InvalidTopicExpressionFaultType_FaultCause), type))
		return soap->error;
	if (soap_outliteral(soap, "-any", (char*const*)&a->__any, NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _wsnt__InvalidTopicExpressionFaultType_FaultCause * SOAP_FMAC4 soap_in__wsnt__InvalidTopicExpressionFaultType_FaultCause(struct soap *soap, const char *tag, struct _wsnt__InvalidTopicExpressionFaultType_FaultCause *a, const char *type)
{
	size_t soap_flag___any = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct _wsnt__InvalidTopicExpressionFaultType_FaultCause*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__wsnt__InvalidTopicExpressionFaultType_FaultCause, sizeof(struct _wsnt__InvalidTopicExpressionFaultType_FaultCause), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__wsnt__InvalidTopicExpressionFaultType_FaultCause(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag___any && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_inliteral(soap, "-any", (char**)&a->__any))
				{	soap_flag___any--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _wsnt__InvalidTopicExpressionFaultType_FaultCause *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__wsnt__InvalidTopicExpressionFaultType_FaultCause, SOAP_TYPE__wsnt__InvalidTopicExpressionFaultType_FaultCause, sizeof(struct _wsnt__InvalidTopicExpressionFaultType_FaultCause), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _wsnt__InvalidTopicExpressionFaultType_FaultCause * SOAP_FMAC4 soap_new__wsnt__InvalidTopicExpressionFaultType_FaultCause(struct soap *soap, int n)
{
	struct _wsnt__InvalidTopicExpressionFaultType_FaultCause *p;
	struct _wsnt__InvalidTopicExpressionFaultType_FaultCause *a = (struct _wsnt__InvalidTopicExpressionFaultType_FaultCause*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _wsnt__InvalidTopicExpressionFaultType_FaultCause));
	for (p = a; p && n--; p++)
		soap_default__wsnt__InvalidTopicExpressionFaultType_FaultCause(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__wsnt__InvalidTopicExpressionFaultType_FaultCause(struct soap *soap, const struct _wsnt__InvalidTopicExpressionFaultType_FaultCause *a, const char *tag, const char *type)
{
	if (soap_out__wsnt__InvalidTopicExpressionFaultType_FaultCause(soap, tag ? tag : "wsnt:InvalidTopicExpressionFaultType-FaultCause", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _wsnt__InvalidTopicExpressionFaultType_FaultCause * SOAP_FMAC4 soap_get__wsnt__InvalidTopicExpressionFaultType_FaultCause(struct soap *soap, struct _wsnt__InvalidTopicExpressionFaultType_FaultCause *p, const char *tag, const char *type)
{
	if ((p = soap_in__wsnt__InvalidTopicExpressionFaultType_FaultCause(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__wsnt__InvalidTopicExpressionFaultType_Description(struct soap *soap, struct _wsnt__InvalidTopicExpressionFaultType_Description *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->__item);
	soap_default__xml__lang(soap, &a->xml__lang);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__wsnt__InvalidTopicExpressionFaultType_Description(struct soap *soap, const struct _wsnt__InvalidTopicExpressionFaultType_Description *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_string(soap, (char*const*)&a->__item);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__wsnt__InvalidTopicExpressionFaultType_Description(struct soap *soap, const char *tag, int id, const struct _wsnt__InvalidTopicExpressionFaultType_Description *a, const char *type)
{
	if (a->xml__lang)
		soap_set_attr(soap, "xml:lang", soap__xml__lang2s(soap, a->xml__lang), 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	return soap_out_string(soap, tag, id, (char*const*)&a->__item, "");
}

SOAP_FMAC3 struct _wsnt__InvalidTopicExpressionFaultType_Description * SOAP_FMAC4 soap_in__wsnt__InvalidTopicExpressionFaultType_Description(struct soap *soap, const char *tag, struct _wsnt__InvalidTopicExpressionFaultType_Description *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	if (!(a = (struct _wsnt__InvalidTopicExpressionFaultType_Description *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__wsnt__InvalidTopicExpressionFaultType_Description, sizeof(struct _wsnt__InvalidTopicExpressionFaultType_Description), NULL, NULL, NULL, NULL)))
		return NULL;
	soap_revert(soap);
	*soap->id = '\0';
	soap_default__wsnt__InvalidTopicExpressionFaultType_Description(soap, a);
	if (soap_s2_xml__lang(soap, soap_attr_value(soap, "xml:lang", 1, 0), &a->xml__lang))
		return NULL;
	if (!soap_in_string(soap, tag, (char**)&a->__item, ""))
		return NULL;
	return a;
}

SOAP_FMAC3 struct _wsnt__InvalidTopicExpressionFaultType_Description * SOAP_FMAC4 soap_new__wsnt__InvalidTopicExpressionFaultType_Description(struct soap *soap, int n)
{
	struct _wsnt__InvalidTopicExpressionFaultType_Description *p;
	struct _wsnt__InvalidTopicExpressionFaultType_Description *a = (struct _wsnt__InvalidTopicExpressionFaultType_Description*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _wsnt__InvalidTopicExpressionFaultType_Description));
	for (p = a; p && n--; p++)
		soap_default__wsnt__InvalidTopicExpressionFaultType_Description(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__wsnt__InvalidTopicExpressionFaultType_Description(struct soap *soap, const struct _wsnt__InvalidTopicExpressionFaultType_Description *a, const char *tag, const char *type)
{
	if (soap_out__wsnt__InvalidTopicExpressionFaultType_Description(soap, tag ? tag : "wsnt:InvalidTopicExpressionFaultType-Description", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _wsnt__InvalidTopicExpressionFaultType_Description * SOAP_FMAC4 soap_get__wsnt__InvalidTopicExpressionFaultType_Description(struct soap *soap, struct _wsnt__InvalidTopicExpressionFaultType_Description *p, const char *tag, const char *type)
{
	if ((p = soap_in__wsnt__InvalidTopicExpressionFaultType_Description(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__wsnt__InvalidTopicExpressionFaultType_ErrorCode(struct soap *soap, struct _wsnt__InvalidTopicExpressionFaultType_ErrorCode *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_xsd__anyURI(soap, &a->dialect);
	a->__mixed = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__wsnt__InvalidTopicExpressionFaultType_ErrorCode(struct soap *soap, const struct _wsnt__InvalidTopicExpressionFaultType_ErrorCode *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__wsnt__InvalidTopicExpressionFaultType_ErrorCode(struct soap *soap, const char *tag, int id, const struct _wsnt__InvalidTopicExpressionFaultType_ErrorCode *a, const char *type)
{
	soap_set_attr(soap, "dialect", a->dialect ? soap_xsd__anyURI2s(soap, a->dialect) : "", 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__wsnt__InvalidTopicExpressionFaultType_ErrorCode), type))
		return soap->error;
	if (soap_outliteral(soap, "-mixed", (char*const*)&a->__mixed, NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _wsnt__InvalidTopicExpressionFaultType_ErrorCode * SOAP_FMAC4 soap_in__wsnt__InvalidTopicExpressionFaultType_ErrorCode(struct soap *soap, const char *tag, struct _wsnt__InvalidTopicExpressionFaultType_ErrorCode *a, const char *type)
{
	size_t soap_flag___mixed = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct _wsnt__InvalidTopicExpressionFaultType_ErrorCode*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__wsnt__InvalidTopicExpressionFaultType_ErrorCode, sizeof(struct _wsnt__InvalidTopicExpressionFaultType_ErrorCode), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__wsnt__InvalidTopicExpressionFaultType_ErrorCode(soap, a);
	if (soap_s2xsd__anyURI(soap, soap_attr_value(soap, "dialect", 4, 1), &a->dialect))
		return NULL;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag___mixed && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_inliteral(soap, "-mixed", (char**)&a->__mixed))
				{	soap_flag___mixed--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _wsnt__InvalidTopicExpressionFaultType_ErrorCode *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__wsnt__InvalidTopicExpressionFaultType_ErrorCode, SOAP_TYPE__wsnt__InvalidTopicExpressionFaultType_ErrorCode, sizeof(struct _wsnt__InvalidTopicExpressionFaultType_ErrorCode), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _wsnt__InvalidTopicExpressionFaultType_ErrorCode * SOAP_FMAC4 soap_new__wsnt__InvalidTopicExpressionFaultType_ErrorCode(struct soap *soap, int n)
{
	struct _wsnt__InvalidTopicExpressionFaultType_ErrorCode *p;
	struct _wsnt__InvalidTopicExpressionFaultType_ErrorCode *a = (struct _wsnt__InvalidTopicExpressionFaultType_ErrorCode*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _wsnt__InvalidTopicExpressionFaultType_ErrorCode));
	for (p = a; p && n--; p++)
		soap_default__wsnt__InvalidTopicExpressionFaultType_ErrorCode(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__wsnt__InvalidTopicExpressionFaultType_ErrorCode(struct soap *soap, const struct _wsnt__InvalidTopicExpressionFaultType_ErrorCode *a, const char *tag, const char *type)
{
	if (soap_out__wsnt__InvalidTopicExpressionFaultType_ErrorCode(soap, tag ? tag : "wsnt:InvalidTopicExpressionFaultType-ErrorCode", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _wsnt__InvalidTopicExpressionFaultType_ErrorCode * SOAP_FMAC4 soap_get__wsnt__InvalidTopicExpressionFaultType_ErrorCode(struct soap *soap, struct _wsnt__InvalidTopicExpressionFaultType_ErrorCode *p, const char *tag, const char *type)
{
	if ((p = soap_in__wsnt__InvalidTopicExpressionFaultType_ErrorCode(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_wsnt__InvalidTopicExpressionFaultType(struct soap *soap, struct wsnt__InvalidTopicExpressionFaultType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__size = 0;
	a->__any = NULL;
	soap_default_dateTime(soap, &a->wsrfbf__Timestamp);
	a->wsrfbf__Originator = NULL;
	a->wsrfbf__ErrorCode = NULL;
	a->__sizeDescription = 0;
	a->wsrfbf__Description = NULL;
	a->wsrfbf__FaultCause = NULL;
	a->__anyAttribute = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_wsnt__InvalidTopicExpressionFaultType(struct soap *soap, const struct wsnt__InvalidTopicExpressionFaultType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &a->wsrfbf__Timestamp, SOAP_TYPE_dateTime);
	soap_serialize_PointerTowsa5__EndpointReferenceType(soap, &a->wsrfbf__Originator);
	soap_serialize_PointerTo_wsnt__InvalidTopicExpressionFaultType_ErrorCode(soap, &a->wsrfbf__ErrorCode);
	if (a->wsrfbf__Description)
	{	int i;
		for (i = 0; i < (int)a->__sizeDescription; i++)
		{
			soap_embedded(soap, a->wsrfbf__Description + i, SOAP_TYPE__wsnt__InvalidTopicExpressionFaultType_Description);
			soap_serialize__wsnt__InvalidTopicExpressionFaultType_Description(soap, a->wsrfbf__Description + i);
		}
	}
	soap_serialize_PointerTo_wsnt__InvalidTopicExpressionFaultType_FaultCause(soap, &a->wsrfbf__FaultCause);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_wsnt__InvalidTopicExpressionFaultType(struct soap *soap, const char *tag, int id, const struct wsnt__InvalidTopicExpressionFaultType *a, const char *type)
{
	if (a->__anyAttribute)
		soap_set_attr(soap, "-anyAttribute", a->__anyAttribute, 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_wsnt__InvalidTopicExpressionFaultType), type))
		return soap->error;
	if (a->__any)
	{	int i;
		for (i = 0; i < (int)a->__size; i++)
			if (soap_outliteral(soap, "-any", (char*const*)(a->__any + i), NULL))
				return soap->error;
	}
	if (soap_out_dateTime(soap, "wsrfbf:Timestamp", -1, &a->wsrfbf__Timestamp, ""))
		return soap->error;
	if (soap_out_PointerTowsa5__EndpointReferenceType(soap, "wsrfbf:Originator", -1, &a->wsrfbf__Originator, ""))
		return soap->error;
	if (soap_out_PointerTo_wsnt__InvalidTopicExpressionFaultType_ErrorCode(soap, "wsrfbf:ErrorCode", -1, &a->wsrfbf__ErrorCode, ""))
		return soap->error;
	if (a->wsrfbf__Description)
	{	int i;
		for (i = 0; i < (int)a->__sizeDescription; i++)
			if (soap_out__wsnt__InvalidTopicExpressionFaultType_Description(soap, "wsrfbf:Description", -1, a->wsrfbf__Description + i, ""))
				return soap->error;
	}
	if (soap_out_PointerTo_wsnt__InvalidTopicExpressionFaultType_FaultCause(soap, "wsrfbf:FaultCause", -1, &a->wsrfbf__FaultCause, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct wsnt__InvalidTopicExpressionFaultType * SOAP_FMAC4 soap_in_wsnt__InvalidTopicExpressionFaultType(struct soap *soap, const char *tag, struct wsnt__InvalidTopicExpressionFaultType *a, const char *type)
{
	struct soap_blist *soap_blist___any = NULL;
	size_t soap_flag_wsrfbf__Timestamp = 1;
	size_t soap_flag_wsrfbf__Originator = 1;
	size_t soap_flag_wsrfbf__ErrorCode = 1;
	struct soap_blist *soap_blist_wsrfbf__Description = NULL;
	size_t soap_flag_wsrfbf__FaultCause = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct wsnt__InvalidTopicExpressionFaultType*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_wsnt__InvalidTopicExpressionFaultType, sizeof(struct wsnt__InvalidTopicExpressionFaultType), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_wsnt__InvalidTopicExpressionFaultType(soap, a);
	if (soap_s2char(soap, soap_attr_value(soap, "-anyAttribute", 0, 0), &a->__anyAttribute, 0, 0, -1, NULL))
		return NULL;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_wsrfbf__Timestamp && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_dateTime(soap, "wsrfbf:Timestamp", &a->wsrfbf__Timestamp, "xsd:dateTime"))
				{	soap_flag_wsrfbf__Timestamp--;
					continue;
				}
			}
			if (soap_flag_wsrfbf__Originator && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTowsa5__EndpointReferenceType(soap, "wsrfbf:Originator", &a->wsrfbf__Originator, "wsa5:EndpointReferenceType"))
				{	soap_flag_wsrfbf__Originator--;
					continue;
				}
			}
			if (soap_flag_wsrfbf__ErrorCode && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_wsnt__InvalidTopicExpressionFaultType_ErrorCode(soap, "wsrfbf:ErrorCode", &a->wsrfbf__ErrorCode, ""))
				{	soap_flag_wsrfbf__ErrorCode--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "wsrfbf:Description", 1, NULL))
			{	if (a->wsrfbf__Description == NULL)
				{	if (soap_blist_wsrfbf__Description == NULL)
						soap_blist_wsrfbf__Description = soap_alloc_block(soap);
					a->wsrfbf__Description = (struct _wsnt__InvalidTopicExpressionFaultType_Description *)soap_push_block_max(soap, soap_blist_wsrfbf__Description, sizeof(struct _wsnt__InvalidTopicExpressionFaultType_Description));
					if (a->wsrfbf__Description == NULL)
						return NULL;
					soap_default__wsnt__InvalidTopicExpressionFaultType_Description(soap, a->wsrfbf__Description);
				}
				soap_revert(soap);
				if (soap_in__wsnt__InvalidTopicExpressionFaultType_Description(soap, "wsrfbf:Description", a->wsrfbf__Description, ""))
				{	a->__sizeDescription++;
					a->wsrfbf__Description = NULL;
					continue;
				}
			}
			if (soap_flag_wsrfbf__FaultCause && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_wsnt__InvalidTopicExpressionFaultType_FaultCause(soap, "wsrfbf:FaultCause", &a->wsrfbf__FaultCause, ""))
				{	soap_flag_wsrfbf__FaultCause--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	if (a->__any == NULL)
				{	if (soap_blist___any == NULL)
						soap_blist___any = soap_alloc_block(soap);
					a->__any = (char **)soap_push_block_max(soap, soap_blist___any, sizeof(char *));
					if (a->__any == NULL)
						return NULL;
					*a->__any = NULL;
				}
				if (soap_inliteral(soap, "-any", (char**)a->__any))
				{	a->__size++;
					a->__any = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->__any)
			soap_pop_block(soap, soap_blist___any);
		if (a->__size)
		{	a->__any = (char **)soap_save_block(soap, soap_blist___any, NULL, 1);
		}
		else
		{	a->__any = NULL;
			if (soap_blist___any)
				soap_end_block(soap, soap_blist___any);
		}
		if (a->wsrfbf__Description)
			soap_pop_block(soap, soap_blist_wsrfbf__Description);
		if (a->__sizeDescription)
		{	a->wsrfbf__Description = (struct _wsnt__InvalidTopicExpressionFaultType_Description *)soap_save_block(soap, soap_blist_wsrfbf__Description, NULL, 1);
		}
		else
		{	a->wsrfbf__Description = NULL;
			if (soap_blist_wsrfbf__Description)
				soap_end_block(soap, soap_blist_wsrfbf__Description);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_wsrfbf__Timestamp > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct wsnt__InvalidTopicExpressionFaultType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_wsnt__InvalidTopicExpressionFaultType, SOAP_TYPE_wsnt__InvalidTopicExpressionFaultType, sizeof(struct wsnt__InvalidTopicExpressionFaultType), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct wsnt__InvalidTopicExpressionFaultType * SOAP_FMAC4 soap_new_wsnt__InvalidTopicExpressionFaultType(struct soap *soap, int n)
{
	struct wsnt__InvalidTopicExpressionFaultType *p;
	struct wsnt__InvalidTopicExpressionFaultType *a = (struct wsnt__InvalidTopicExpressionFaultType*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct wsnt__InvalidTopicExpressionFaultType));
	for (p = a; p && n--; p++)
		soap_default_wsnt__InvalidTopicExpressionFaultType(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_wsnt__InvalidTopicExpressionFaultType(struct soap *soap, const struct wsnt__InvalidTopicExpressionFaultType *a, const char *tag, const char *type)
{
	if (soap_out_wsnt__InvalidTopicExpressionFaultType(soap, tag ? tag : "wsnt:InvalidTopicExpressionFaultType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct wsnt__InvalidTopicExpressionFaultType * SOAP_FMAC4 soap_get_wsnt__InvalidTopicExpressionFaultType(struct soap *soap, struct wsnt__InvalidTopicExpressionFaultType *p, const char *tag, const char *type)
{
	if ((p = soap_in_wsnt__InvalidTopicExpressionFaultType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__wsnt__TopicExpressionDialectUnknownFaultType_FaultCause(struct soap *soap, struct _wsnt__TopicExpressionDialectUnknownFaultType_FaultCause *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__any = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__wsnt__TopicExpressionDialectUnknownFaultType_FaultCause(struct soap *soap, const struct _wsnt__TopicExpressionDialectUnknownFaultType_FaultCause *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__wsnt__TopicExpressionDialectUnknownFaultType_FaultCause(struct soap *soap, const char *tag, int id, const struct _wsnt__TopicExpressionDialectUnknownFaultType_FaultCause *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__wsnt__TopicExpressionDialectUnknownFaultType_FaultCause), type))
		return soap->error;
	if (soap_outliteral(soap, "-any", (char*const*)&a->__any, NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _wsnt__TopicExpressionDialectUnknownFaultType_FaultCause * SOAP_FMAC4 soap_in__wsnt__TopicExpressionDialectUnknownFaultType_FaultCause(struct soap *soap, const char *tag, struct _wsnt__TopicExpressionDialectUnknownFaultType_FaultCause *a, const char *type)
{
	size_t soap_flag___any = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct _wsnt__TopicExpressionDialectUnknownFaultType_FaultCause*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__wsnt__TopicExpressionDialectUnknownFaultType_FaultCause, sizeof(struct _wsnt__TopicExpressionDialectUnknownFaultType_FaultCause), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__wsnt__TopicExpressionDialectUnknownFaultType_FaultCause(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag___any && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_inliteral(soap, "-any", (char**)&a->__any))
				{	soap_flag___any--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _wsnt__TopicExpressionDialectUnknownFaultType_FaultCause *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__wsnt__TopicExpressionDialectUnknownFaultType_FaultCause, SOAP_TYPE__wsnt__TopicExpressionDialectUnknownFaultType_FaultCause, sizeof(struct _wsnt__TopicExpressionDialectUnknownFaultType_FaultCause), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _wsnt__TopicExpressionDialectUnknownFaultType_FaultCause * SOAP_FMAC4 soap_new__wsnt__TopicExpressionDialectUnknownFaultType_FaultCause(struct soap *soap, int n)
{
	struct _wsnt__TopicExpressionDialectUnknownFaultType_FaultCause *p;
	struct _wsnt__TopicExpressionDialectUnknownFaultType_FaultCause *a = (struct _wsnt__TopicExpressionDialectUnknownFaultType_FaultCause*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _wsnt__TopicExpressionDialectUnknownFaultType_FaultCause));
	for (p = a; p && n--; p++)
		soap_default__wsnt__TopicExpressionDialectUnknownFaultType_FaultCause(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__wsnt__TopicExpressionDialectUnknownFaultType_FaultCause(struct soap *soap, const struct _wsnt__TopicExpressionDialectUnknownFaultType_FaultCause *a, const char *tag, const char *type)
{
	if (soap_out__wsnt__TopicExpressionDialectUnknownFaultType_FaultCause(soap, tag ? tag : "wsnt:TopicExpressionDialectUnknownFaultType-FaultCause", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _wsnt__TopicExpressionDialectUnknownFaultType_FaultCause * SOAP_FMAC4 soap_get__wsnt__TopicExpressionDialectUnknownFaultType_FaultCause(struct soap *soap, struct _wsnt__TopicExpressionDialectUnknownFaultType_FaultCause *p, const char *tag, const char *type)
{
	if ((p = soap_in__wsnt__TopicExpressionDialectUnknownFaultType_FaultCause(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__wsnt__TopicExpressionDialectUnknownFaultType_Description(struct soap *soap, struct _wsnt__TopicExpressionDialectUnknownFaultType_Description *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->__item);
	soap_default__xml__lang(soap, &a->xml__lang);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__wsnt__TopicExpressionDialectUnknownFaultType_Description(struct soap *soap, const struct _wsnt__TopicExpressionDialectUnknownFaultType_Description *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_string(soap, (char*const*)&a->__item);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__wsnt__TopicExpressionDialectUnknownFaultType_Description(struct soap *soap, const char *tag, int id, const struct _wsnt__TopicExpressionDialectUnknownFaultType_Description *a, const char *type)
{
	if (a->xml__lang)
		soap_set_attr(soap, "xml:lang", soap__xml__lang2s(soap, a->xml__lang), 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	return soap_out_string(soap, tag, id, (char*const*)&a->__item, "");
}

SOAP_FMAC3 struct _wsnt__TopicExpressionDialectUnknownFaultType_Description * SOAP_FMAC4 soap_in__wsnt__TopicExpressionDialectUnknownFaultType_Description(struct soap *soap, const char *tag, struct _wsnt__TopicExpressionDialectUnknownFaultType_Description *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	if (!(a = (struct _wsnt__TopicExpressionDialectUnknownFaultType_Description *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__wsnt__TopicExpressionDialectUnknownFaultType_Description, sizeof(struct _wsnt__TopicExpressionDialectUnknownFaultType_Description), NULL, NULL, NULL, NULL)))
		return NULL;
	soap_revert(soap);
	*soap->id = '\0';
	soap_default__wsnt__TopicExpressionDialectUnknownFaultType_Description(soap, a);
	if (soap_s2_xml__lang(soap, soap_attr_value(soap, "xml:lang", 1, 0), &a->xml__lang))
		return NULL;
	if (!soap_in_string(soap, tag, (char**)&a->__item, ""))
		return NULL;
	return a;
}

SOAP_FMAC3 struct _wsnt__TopicExpressionDialectUnknownFaultType_Description * SOAP_FMAC4 soap_new__wsnt__TopicExpressionDialectUnknownFaultType_Description(struct soap *soap, int n)
{
	struct _wsnt__TopicExpressionDialectUnknownFaultType_Description *p;
	struct _wsnt__TopicExpressionDialectUnknownFaultType_Description *a = (struct _wsnt__TopicExpressionDialectUnknownFaultType_Description*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _wsnt__TopicExpressionDialectUnknownFaultType_Description));
	for (p = a; p && n--; p++)
		soap_default__wsnt__TopicExpressionDialectUnknownFaultType_Description(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__wsnt__TopicExpressionDialectUnknownFaultType_Description(struct soap *soap, const struct _wsnt__TopicExpressionDialectUnknownFaultType_Description *a, const char *tag, const char *type)
{
	if (soap_out__wsnt__TopicExpressionDialectUnknownFaultType_Description(soap, tag ? tag : "wsnt:TopicExpressionDialectUnknownFaultType-Description", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _wsnt__TopicExpressionDialectUnknownFaultType_Description * SOAP_FMAC4 soap_get__wsnt__TopicExpressionDialectUnknownFaultType_Description(struct soap *soap, struct _wsnt__TopicExpressionDialectUnknownFaultType_Description *p, const char *tag, const char *type)
{
	if ((p = soap_in__wsnt__TopicExpressionDialectUnknownFaultType_Description(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__wsnt__TopicExpressionDialectUnknownFaultType_ErrorCode(struct soap *soap, struct _wsnt__TopicExpressionDialectUnknownFaultType_ErrorCode *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_xsd__anyURI(soap, &a->dialect);
	a->__mixed = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__wsnt__TopicExpressionDialectUnknownFaultType_ErrorCode(struct soap *soap, const struct _wsnt__TopicExpressionDialectUnknownFaultType_ErrorCode *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__wsnt__TopicExpressionDialectUnknownFaultType_ErrorCode(struct soap *soap, const char *tag, int id, const struct _wsnt__TopicExpressionDialectUnknownFaultType_ErrorCode *a, const char *type)
{
	soap_set_attr(soap, "dialect", a->dialect ? soap_xsd__anyURI2s(soap, a->dialect) : "", 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__wsnt__TopicExpressionDialectUnknownFaultType_ErrorCode), type))
		return soap->error;
	if (soap_outliteral(soap, "-mixed", (char*const*)&a->__mixed, NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _wsnt__TopicExpressionDialectUnknownFaultType_ErrorCode * SOAP_FMAC4 soap_in__wsnt__TopicExpressionDialectUnknownFaultType_ErrorCode(struct soap *soap, const char *tag, struct _wsnt__TopicExpressionDialectUnknownFaultType_ErrorCode *a, const char *type)
{
	size_t soap_flag___mixed = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct _wsnt__TopicExpressionDialectUnknownFaultType_ErrorCode*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__wsnt__TopicExpressionDialectUnknownFaultType_ErrorCode, sizeof(struct _wsnt__TopicExpressionDialectUnknownFaultType_ErrorCode), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__wsnt__TopicExpressionDialectUnknownFaultType_ErrorCode(soap, a);
	if (soap_s2xsd__anyURI(soap, soap_attr_value(soap, "dialect", 4, 1), &a->dialect))
		return NULL;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag___mixed && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_inliteral(soap, "-mixed", (char**)&a->__mixed))
				{	soap_flag___mixed--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _wsnt__TopicExpressionDialectUnknownFaultType_ErrorCode *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__wsnt__TopicExpressionDialectUnknownFaultType_ErrorCode, SOAP_TYPE__wsnt__TopicExpressionDialectUnknownFaultType_ErrorCode, sizeof(struct _wsnt__TopicExpressionDialectUnknownFaultType_ErrorCode), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _wsnt__TopicExpressionDialectUnknownFaultType_ErrorCode * SOAP_FMAC4 soap_new__wsnt__TopicExpressionDialectUnknownFaultType_ErrorCode(struct soap *soap, int n)
{
	struct _wsnt__TopicExpressionDialectUnknownFaultType_ErrorCode *p;
	struct _wsnt__TopicExpressionDialectUnknownFaultType_ErrorCode *a = (struct _wsnt__TopicExpressionDialectUnknownFaultType_ErrorCode*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _wsnt__TopicExpressionDialectUnknownFaultType_ErrorCode));
	for (p = a; p && n--; p++)
		soap_default__wsnt__TopicExpressionDialectUnknownFaultType_ErrorCode(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__wsnt__TopicExpressionDialectUnknownFaultType_ErrorCode(struct soap *soap, const struct _wsnt__TopicExpressionDialectUnknownFaultType_ErrorCode *a, const char *tag, const char *type)
{
	if (soap_out__wsnt__TopicExpressionDialectUnknownFaultType_ErrorCode(soap, tag ? tag : "wsnt:TopicExpressionDialectUnknownFaultType-ErrorCode", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _wsnt__TopicExpressionDialectUnknownFaultType_ErrorCode * SOAP_FMAC4 soap_get__wsnt__TopicExpressionDialectUnknownFaultType_ErrorCode(struct soap *soap, struct _wsnt__TopicExpressionDialectUnknownFaultType_ErrorCode *p, const char *tag, const char *type)
{
	if ((p = soap_in__wsnt__TopicExpressionDialectUnknownFaultType_ErrorCode(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_wsnt__TopicExpressionDialectUnknownFaultType(struct soap *soap, struct wsnt__TopicExpressionDialectUnknownFaultType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__size = 0;
	a->__any = NULL;
	soap_default_dateTime(soap, &a->wsrfbf__Timestamp);
	a->wsrfbf__Originator = NULL;
	a->wsrfbf__ErrorCode = NULL;
	a->__sizeDescription = 0;
	a->wsrfbf__Description = NULL;
	a->wsrfbf__FaultCause = NULL;
	a->__anyAttribute = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_wsnt__TopicExpressionDialectUnknownFaultType(struct soap *soap, const struct wsnt__TopicExpressionDialectUnknownFaultType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &a->wsrfbf__Timestamp, SOAP_TYPE_dateTime);
	soap_serialize_PointerTowsa5__EndpointReferenceType(soap, &a->wsrfbf__Originator);
	soap_serialize_PointerTo_wsnt__TopicExpressionDialectUnknownFaultType_ErrorCode(soap, &a->wsrfbf__ErrorCode);
	if (a->wsrfbf__Description)
	{	int i;
		for (i = 0; i < (int)a->__sizeDescription; i++)
		{
			soap_embedded(soap, a->wsrfbf__Description + i, SOAP_TYPE__wsnt__TopicExpressionDialectUnknownFaultType_Description);
			soap_serialize__wsnt__TopicExpressionDialectUnknownFaultType_Description(soap, a->wsrfbf__Description + i);
		}
	}
	soap_serialize_PointerTo_wsnt__TopicExpressionDialectUnknownFaultType_FaultCause(soap, &a->wsrfbf__FaultCause);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_wsnt__TopicExpressionDialectUnknownFaultType(struct soap *soap, const char *tag, int id, const struct wsnt__TopicExpressionDialectUnknownFaultType *a, const char *type)
{
	if (a->__anyAttribute)
		soap_set_attr(soap, "-anyAttribute", a->__anyAttribute, 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_wsnt__TopicExpressionDialectUnknownFaultType), type))
		return soap->error;
	if (a->__any)
	{	int i;
		for (i = 0; i < (int)a->__size; i++)
			if (soap_outliteral(soap, "-any", (char*const*)(a->__any + i), NULL))
				return soap->error;
	}
	if (soap_out_dateTime(soap, "wsrfbf:Timestamp", -1, &a->wsrfbf__Timestamp, ""))
		return soap->error;
	if (soap_out_PointerTowsa5__EndpointReferenceType(soap, "wsrfbf:Originator", -1, &a->wsrfbf__Originator, ""))
		return soap->error;
	if (soap_out_PointerTo_wsnt__TopicExpressionDialectUnknownFaultType_ErrorCode(soap, "wsrfbf:ErrorCode", -1, &a->wsrfbf__ErrorCode, ""))
		return soap->error;
	if (a->wsrfbf__Description)
	{	int i;
		for (i = 0; i < (int)a->__sizeDescription; i++)
			if (soap_out__wsnt__TopicExpressionDialectUnknownFaultType_Description(soap, "wsrfbf:Description", -1, a->wsrfbf__Description + i, ""))
				return soap->error;
	}
	if (soap_out_PointerTo_wsnt__TopicExpressionDialectUnknownFaultType_FaultCause(soap, "wsrfbf:FaultCause", -1, &a->wsrfbf__FaultCause, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct wsnt__TopicExpressionDialectUnknownFaultType * SOAP_FMAC4 soap_in_wsnt__TopicExpressionDialectUnknownFaultType(struct soap *soap, const char *tag, struct wsnt__TopicExpressionDialectUnknownFaultType *a, const char *type)
{
	struct soap_blist *soap_blist___any = NULL;
	size_t soap_flag_wsrfbf__Timestamp = 1;
	size_t soap_flag_wsrfbf__Originator = 1;
	size_t soap_flag_wsrfbf__ErrorCode = 1;
	struct soap_blist *soap_blist_wsrfbf__Description = NULL;
	size_t soap_flag_wsrfbf__FaultCause = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct wsnt__TopicExpressionDialectUnknownFaultType*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_wsnt__TopicExpressionDialectUnknownFaultType, sizeof(struct wsnt__TopicExpressionDialectUnknownFaultType), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_wsnt__TopicExpressionDialectUnknownFaultType(soap, a);
	if (soap_s2char(soap, soap_attr_value(soap, "-anyAttribute", 0, 0), &a->__anyAttribute, 0, 0, -1, NULL))
		return NULL;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_wsrfbf__Timestamp && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_dateTime(soap, "wsrfbf:Timestamp", &a->wsrfbf__Timestamp, "xsd:dateTime"))
				{	soap_flag_wsrfbf__Timestamp--;
					continue;
				}
			}
			if (soap_flag_wsrfbf__Originator && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTowsa5__EndpointReferenceType(soap, "wsrfbf:Originator", &a->wsrfbf__Originator, "wsa5:EndpointReferenceType"))
				{	soap_flag_wsrfbf__Originator--;
					continue;
				}
			}
			if (soap_flag_wsrfbf__ErrorCode && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_wsnt__TopicExpressionDialectUnknownFaultType_ErrorCode(soap, "wsrfbf:ErrorCode", &a->wsrfbf__ErrorCode, ""))
				{	soap_flag_wsrfbf__ErrorCode--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "wsrfbf:Description", 1, NULL))
			{	if (a->wsrfbf__Description == NULL)
				{	if (soap_blist_wsrfbf__Description == NULL)
						soap_blist_wsrfbf__Description = soap_alloc_block(soap);
					a->wsrfbf__Description = (struct _wsnt__TopicExpressionDialectUnknownFaultType_Description *)soap_push_block_max(soap, soap_blist_wsrfbf__Description, sizeof(struct _wsnt__TopicExpressionDialectUnknownFaultType_Description));
					if (a->wsrfbf__Description == NULL)
						return NULL;
					soap_default__wsnt__TopicExpressionDialectUnknownFaultType_Description(soap, a->wsrfbf__Description);
				}
				soap_revert(soap);
				if (soap_in__wsnt__TopicExpressionDialectUnknownFaultType_Description(soap, "wsrfbf:Description", a->wsrfbf__Description, ""))
				{	a->__sizeDescription++;
					a->wsrfbf__Description = NULL;
					continue;
				}
			}
			if (soap_flag_wsrfbf__FaultCause && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_wsnt__TopicExpressionDialectUnknownFaultType_FaultCause(soap, "wsrfbf:FaultCause", &a->wsrfbf__FaultCause, ""))
				{	soap_flag_wsrfbf__FaultCause--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	if (a->__any == NULL)
				{	if (soap_blist___any == NULL)
						soap_blist___any = soap_alloc_block(soap);
					a->__any = (char **)soap_push_block_max(soap, soap_blist___any, sizeof(char *));
					if (a->__any == NULL)
						return NULL;
					*a->__any = NULL;
				}
				if (soap_inliteral(soap, "-any", (char**)a->__any))
				{	a->__size++;
					a->__any = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->__any)
			soap_pop_block(soap, soap_blist___any);
		if (a->__size)
		{	a->__any = (char **)soap_save_block(soap, soap_blist___any, NULL, 1);
		}
		else
		{	a->__any = NULL;
			if (soap_blist___any)
				soap_end_block(soap, soap_blist___any);
		}
		if (a->wsrfbf__Description)
			soap_pop_block(soap, soap_blist_wsrfbf__Description);
		if (a->__sizeDescription)
		{	a->wsrfbf__Description = (struct _wsnt__TopicExpressionDialectUnknownFaultType_Description *)soap_save_block(soap, soap_blist_wsrfbf__Description, NULL, 1);
		}
		else
		{	a->wsrfbf__Description = NULL;
			if (soap_blist_wsrfbf__Description)
				soap_end_block(soap, soap_blist_wsrfbf__Description);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_wsrfbf__Timestamp > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct wsnt__TopicExpressionDialectUnknownFaultType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_wsnt__TopicExpressionDialectUnknownFaultType, SOAP_TYPE_wsnt__TopicExpressionDialectUnknownFaultType, sizeof(struct wsnt__TopicExpressionDialectUnknownFaultType), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct wsnt__TopicExpressionDialectUnknownFaultType * SOAP_FMAC4 soap_new_wsnt__TopicExpressionDialectUnknownFaultType(struct soap *soap, int n)
{
	struct wsnt__TopicExpressionDialectUnknownFaultType *p;
	struct wsnt__TopicExpressionDialectUnknownFaultType *a = (struct wsnt__TopicExpressionDialectUnknownFaultType*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct wsnt__TopicExpressionDialectUnknownFaultType));
	for (p = a; p && n--; p++)
		soap_default_wsnt__TopicExpressionDialectUnknownFaultType(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_wsnt__TopicExpressionDialectUnknownFaultType(struct soap *soap, const struct wsnt__TopicExpressionDialectUnknownFaultType *a, const char *tag, const char *type)
{
	if (soap_out_wsnt__TopicExpressionDialectUnknownFaultType(soap, tag ? tag : "wsnt:TopicExpressionDialectUnknownFaultType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct wsnt__TopicExpressionDialectUnknownFaultType * SOAP_FMAC4 soap_get_wsnt__TopicExpressionDialectUnknownFaultType(struct soap *soap, struct wsnt__TopicExpressionDialectUnknownFaultType *p, const char *tag, const char *type)
{
	if ((p = soap_in_wsnt__TopicExpressionDialectUnknownFaultType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__wsnt__InvalidFilterFaultType_FaultCause(struct soap *soap, struct _wsnt__InvalidFilterFaultType_FaultCause *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__any = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__wsnt__InvalidFilterFaultType_FaultCause(struct soap *soap, const struct _wsnt__InvalidFilterFaultType_FaultCause *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__wsnt__InvalidFilterFaultType_FaultCause(struct soap *soap, const char *tag, int id, const struct _wsnt__InvalidFilterFaultType_FaultCause *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__wsnt__InvalidFilterFaultType_FaultCause), type))
		return soap->error;
	if (soap_outliteral(soap, "-any", (char*const*)&a->__any, NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _wsnt__InvalidFilterFaultType_FaultCause * SOAP_FMAC4 soap_in__wsnt__InvalidFilterFaultType_FaultCause(struct soap *soap, const char *tag, struct _wsnt__InvalidFilterFaultType_FaultCause *a, const char *type)
{
	size_t soap_flag___any = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct _wsnt__InvalidFilterFaultType_FaultCause*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__wsnt__InvalidFilterFaultType_FaultCause, sizeof(struct _wsnt__InvalidFilterFaultType_FaultCause), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__wsnt__InvalidFilterFaultType_FaultCause(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag___any && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_inliteral(soap, "-any", (char**)&a->__any))
				{	soap_flag___any--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _wsnt__InvalidFilterFaultType_FaultCause *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__wsnt__InvalidFilterFaultType_FaultCause, SOAP_TYPE__wsnt__InvalidFilterFaultType_FaultCause, sizeof(struct _wsnt__InvalidFilterFaultType_FaultCause), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _wsnt__InvalidFilterFaultType_FaultCause * SOAP_FMAC4 soap_new__wsnt__InvalidFilterFaultType_FaultCause(struct soap *soap, int n)
{
	struct _wsnt__InvalidFilterFaultType_FaultCause *p;
	struct _wsnt__InvalidFilterFaultType_FaultCause *a = (struct _wsnt__InvalidFilterFaultType_FaultCause*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _wsnt__InvalidFilterFaultType_FaultCause));
	for (p = a; p && n--; p++)
		soap_default__wsnt__InvalidFilterFaultType_FaultCause(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__wsnt__InvalidFilterFaultType_FaultCause(struct soap *soap, const struct _wsnt__InvalidFilterFaultType_FaultCause *a, const char *tag, const char *type)
{
	if (soap_out__wsnt__InvalidFilterFaultType_FaultCause(soap, tag ? tag : "wsnt:InvalidFilterFaultType-FaultCause", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _wsnt__InvalidFilterFaultType_FaultCause * SOAP_FMAC4 soap_get__wsnt__InvalidFilterFaultType_FaultCause(struct soap *soap, struct _wsnt__InvalidFilterFaultType_FaultCause *p, const char *tag, const char *type)
{
	if ((p = soap_in__wsnt__InvalidFilterFaultType_FaultCause(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__wsnt__InvalidFilterFaultType_Description(struct soap *soap, struct _wsnt__InvalidFilterFaultType_Description *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->__item);
	soap_default__xml__lang(soap, &a->xml__lang);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__wsnt__InvalidFilterFaultType_Description(struct soap *soap, const struct _wsnt__InvalidFilterFaultType_Description *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_string(soap, (char*const*)&a->__item);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__wsnt__InvalidFilterFaultType_Description(struct soap *soap, const char *tag, int id, const struct _wsnt__InvalidFilterFaultType_Description *a, const char *type)
{
	if (a->xml__lang)
		soap_set_attr(soap, "xml:lang", soap__xml__lang2s(soap, a->xml__lang), 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	return soap_out_string(soap, tag, id, (char*const*)&a->__item, "");
}

SOAP_FMAC3 struct _wsnt__InvalidFilterFaultType_Description * SOAP_FMAC4 soap_in__wsnt__InvalidFilterFaultType_Description(struct soap *soap, const char *tag, struct _wsnt__InvalidFilterFaultType_Description *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	if (!(a = (struct _wsnt__InvalidFilterFaultType_Description *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__wsnt__InvalidFilterFaultType_Description, sizeof(struct _wsnt__InvalidFilterFaultType_Description), NULL, NULL, NULL, NULL)))
		return NULL;
	soap_revert(soap);
	*soap->id = '\0';
	soap_default__wsnt__InvalidFilterFaultType_Description(soap, a);
	if (soap_s2_xml__lang(soap, soap_attr_value(soap, "xml:lang", 1, 0), &a->xml__lang))
		return NULL;
	if (!soap_in_string(soap, tag, (char**)&a->__item, ""))
		return NULL;
	return a;
}

SOAP_FMAC3 struct _wsnt__InvalidFilterFaultType_Description * SOAP_FMAC4 soap_new__wsnt__InvalidFilterFaultType_Description(struct soap *soap, int n)
{
	struct _wsnt__InvalidFilterFaultType_Description *p;
	struct _wsnt__InvalidFilterFaultType_Description *a = (struct _wsnt__InvalidFilterFaultType_Description*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _wsnt__InvalidFilterFaultType_Description));
	for (p = a; p && n--; p++)
		soap_default__wsnt__InvalidFilterFaultType_Description(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__wsnt__InvalidFilterFaultType_Description(struct soap *soap, const struct _wsnt__InvalidFilterFaultType_Description *a, const char *tag, const char *type)
{
	if (soap_out__wsnt__InvalidFilterFaultType_Description(soap, tag ? tag : "wsnt:InvalidFilterFaultType-Description", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _wsnt__InvalidFilterFaultType_Description * SOAP_FMAC4 soap_get__wsnt__InvalidFilterFaultType_Description(struct soap *soap, struct _wsnt__InvalidFilterFaultType_Description *p, const char *tag, const char *type)
{
	if ((p = soap_in__wsnt__InvalidFilterFaultType_Description(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__wsnt__InvalidFilterFaultType_ErrorCode(struct soap *soap, struct _wsnt__InvalidFilterFaultType_ErrorCode *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_xsd__anyURI(soap, &a->dialect);
	a->__mixed = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__wsnt__InvalidFilterFaultType_ErrorCode(struct soap *soap, const struct _wsnt__InvalidFilterFaultType_ErrorCode *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__wsnt__InvalidFilterFaultType_ErrorCode(struct soap *soap, const char *tag, int id, const struct _wsnt__InvalidFilterFaultType_ErrorCode *a, const char *type)
{
	soap_set_attr(soap, "dialect", a->dialect ? soap_xsd__anyURI2s(soap, a->dialect) : "", 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__wsnt__InvalidFilterFaultType_ErrorCode), type))
		return soap->error;
	if (soap_outliteral(soap, "-mixed", (char*const*)&a->__mixed, NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _wsnt__InvalidFilterFaultType_ErrorCode * SOAP_FMAC4 soap_in__wsnt__InvalidFilterFaultType_ErrorCode(struct soap *soap, const char *tag, struct _wsnt__InvalidFilterFaultType_ErrorCode *a, const char *type)
{
	size_t soap_flag___mixed = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct _wsnt__InvalidFilterFaultType_ErrorCode*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__wsnt__InvalidFilterFaultType_ErrorCode, sizeof(struct _wsnt__InvalidFilterFaultType_ErrorCode), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__wsnt__InvalidFilterFaultType_ErrorCode(soap, a);
	if (soap_s2xsd__anyURI(soap, soap_attr_value(soap, "dialect", 4, 1), &a->dialect))
		return NULL;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag___mixed && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_inliteral(soap, "-mixed", (char**)&a->__mixed))
				{	soap_flag___mixed--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _wsnt__InvalidFilterFaultType_ErrorCode *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__wsnt__InvalidFilterFaultType_ErrorCode, SOAP_TYPE__wsnt__InvalidFilterFaultType_ErrorCode, sizeof(struct _wsnt__InvalidFilterFaultType_ErrorCode), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _wsnt__InvalidFilterFaultType_ErrorCode * SOAP_FMAC4 soap_new__wsnt__InvalidFilterFaultType_ErrorCode(struct soap *soap, int n)
{
	struct _wsnt__InvalidFilterFaultType_ErrorCode *p;
	struct _wsnt__InvalidFilterFaultType_ErrorCode *a = (struct _wsnt__InvalidFilterFaultType_ErrorCode*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _wsnt__InvalidFilterFaultType_ErrorCode));
	for (p = a; p && n--; p++)
		soap_default__wsnt__InvalidFilterFaultType_ErrorCode(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__wsnt__InvalidFilterFaultType_ErrorCode(struct soap *soap, const struct _wsnt__InvalidFilterFaultType_ErrorCode *a, const char *tag, const char *type)
{
	if (soap_out__wsnt__InvalidFilterFaultType_ErrorCode(soap, tag ? tag : "wsnt:InvalidFilterFaultType-ErrorCode", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _wsnt__InvalidFilterFaultType_ErrorCode * SOAP_FMAC4 soap_get__wsnt__InvalidFilterFaultType_ErrorCode(struct soap *soap, struct _wsnt__InvalidFilterFaultType_ErrorCode *p, const char *tag, const char *type)
{
	if ((p = soap_in__wsnt__InvalidFilterFaultType_ErrorCode(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_wsnt__InvalidFilterFaultType(struct soap *soap, struct wsnt__InvalidFilterFaultType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__size = 0;
	a->__any = NULL;
	soap_default_dateTime(soap, &a->wsrfbf__Timestamp);
	a->wsrfbf__Originator = NULL;
	a->wsrfbf__ErrorCode = NULL;
	a->__sizeDescription = 0;
	a->wsrfbf__Description = NULL;
	a->wsrfbf__FaultCause = NULL;
	a->__anyAttribute = NULL;
	a->__sizeUnknownFilter = 0;
	a->UnknownFilter = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_wsnt__InvalidFilterFaultType(struct soap *soap, const struct wsnt__InvalidFilterFaultType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &a->wsrfbf__Timestamp, SOAP_TYPE_dateTime);
	soap_serialize_PointerTowsa5__EndpointReferenceType(soap, &a->wsrfbf__Originator);
	soap_serialize_PointerTo_wsnt__InvalidFilterFaultType_ErrorCode(soap, &a->wsrfbf__ErrorCode);
	if (a->wsrfbf__Description)
	{	int i;
		for (i = 0; i < (int)a->__sizeDescription; i++)
		{
			soap_embedded(soap, a->wsrfbf__Description + i, SOAP_TYPE__wsnt__InvalidFilterFaultType_Description);
			soap_serialize__wsnt__InvalidFilterFaultType_Description(soap, a->wsrfbf__Description + i);
		}
	}
	soap_serialize_PointerTo_wsnt__InvalidFilterFaultType_FaultCause(soap, &a->wsrfbf__FaultCause);
	if (a->UnknownFilter)
	{	int i;
		for (i = 0; i < (int)a->__sizeUnknownFilter; i++)
		{
			soap_serialize__QName(soap, (char*const*)(a->UnknownFilter + i));
		}
	}
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_wsnt__InvalidFilterFaultType(struct soap *soap, const char *tag, int id, const struct wsnt__InvalidFilterFaultType *a, const char *type)
{
	if (a->__anyAttribute)
		soap_set_attr(soap, "-anyAttribute", a->__anyAttribute, 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_wsnt__InvalidFilterFaultType), type))
		return soap->error;
	if (a->__any)
	{	int i;
		for (i = 0; i < (int)a->__size; i++)
			if (soap_outliteral(soap, "-any", (char*const*)(a->__any + i), NULL))
				return soap->error;
	}
	if (soap_out_dateTime(soap, "wsrfbf:Timestamp", -1, &a->wsrfbf__Timestamp, ""))
		return soap->error;
	if (soap_out_PointerTowsa5__EndpointReferenceType(soap, "wsrfbf:Originator", -1, &a->wsrfbf__Originator, ""))
		return soap->error;
	if (soap_out_PointerTo_wsnt__InvalidFilterFaultType_ErrorCode(soap, "wsrfbf:ErrorCode", -1, &a->wsrfbf__ErrorCode, ""))
		return soap->error;
	if (a->wsrfbf__Description)
	{	int i;
		for (i = 0; i < (int)a->__sizeDescription; i++)
			if (soap_out__wsnt__InvalidFilterFaultType_Description(soap, "wsrfbf:Description", -1, a->wsrfbf__Description + i, ""))
				return soap->error;
	}
	if (soap_out_PointerTo_wsnt__InvalidFilterFaultType_FaultCause(soap, "wsrfbf:FaultCause", -1, &a->wsrfbf__FaultCause, ""))
		return soap->error;
	if (a->UnknownFilter)
	{	int i;
		for (i = 0; i < (int)a->__sizeUnknownFilter; i++)
		{	const char *soap_tmp_UnknownFilter = soap_QName2s(soap, a->UnknownFilter[i]);
			if (soap_out__QName(soap, "wsnt:UnknownFilter", -1, (char*const*)(void*)&soap_tmp_UnknownFilter, ""))
				return soap->error;
		}
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct wsnt__InvalidFilterFaultType * SOAP_FMAC4 soap_in_wsnt__InvalidFilterFaultType(struct soap *soap, const char *tag, struct wsnt__InvalidFilterFaultType *a, const char *type)
{
	struct soap_blist *soap_blist___any = NULL;
	size_t soap_flag_wsrfbf__Timestamp = 1;
	size_t soap_flag_wsrfbf__Originator = 1;
	size_t soap_flag_wsrfbf__ErrorCode = 1;
	struct soap_blist *soap_blist_wsrfbf__Description = NULL;
	size_t soap_flag_wsrfbf__FaultCause = 1;
	struct soap_blist *soap_blist_UnknownFilter = NULL;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct wsnt__InvalidFilterFaultType*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_wsnt__InvalidFilterFaultType, sizeof(struct wsnt__InvalidFilterFaultType), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_wsnt__InvalidFilterFaultType(soap, a);
	if (soap_s2char(soap, soap_attr_value(soap, "-anyAttribute", 0, 0), &a->__anyAttribute, 0, 0, -1, NULL))
		return NULL;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_wsrfbf__Timestamp && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_dateTime(soap, "wsrfbf:Timestamp", &a->wsrfbf__Timestamp, "xsd:dateTime"))
				{	soap_flag_wsrfbf__Timestamp--;
					continue;
				}
			}
			if (soap_flag_wsrfbf__Originator && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTowsa5__EndpointReferenceType(soap, "wsrfbf:Originator", &a->wsrfbf__Originator, "wsa5:EndpointReferenceType"))
				{	soap_flag_wsrfbf__Originator--;
					continue;
				}
			}
			if (soap_flag_wsrfbf__ErrorCode && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_wsnt__InvalidFilterFaultType_ErrorCode(soap, "wsrfbf:ErrorCode", &a->wsrfbf__ErrorCode, ""))
				{	soap_flag_wsrfbf__ErrorCode--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "wsrfbf:Description", 1, NULL))
			{	if (a->wsrfbf__Description == NULL)
				{	if (soap_blist_wsrfbf__Description == NULL)
						soap_blist_wsrfbf__Description = soap_alloc_block(soap);
					a->wsrfbf__Description = (struct _wsnt__InvalidFilterFaultType_Description *)soap_push_block_max(soap, soap_blist_wsrfbf__Description, sizeof(struct _wsnt__InvalidFilterFaultType_Description));
					if (a->wsrfbf__Description == NULL)
						return NULL;
					soap_default__wsnt__InvalidFilterFaultType_Description(soap, a->wsrfbf__Description);
				}
				soap_revert(soap);
				if (soap_in__wsnt__InvalidFilterFaultType_Description(soap, "wsrfbf:Description", a->wsrfbf__Description, ""))
				{	a->__sizeDescription++;
					a->wsrfbf__Description = NULL;
					continue;
				}
			}
			if (soap_flag_wsrfbf__FaultCause && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_wsnt__InvalidFilterFaultType_FaultCause(soap, "wsrfbf:FaultCause", &a->wsrfbf__FaultCause, ""))
				{	soap_flag_wsrfbf__FaultCause--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "wsnt:UnknownFilter", 1, NULL))
			{	if (a->UnknownFilter == NULL)
				{	if (soap_blist_UnknownFilter == NULL)
						soap_blist_UnknownFilter = soap_alloc_block(soap);
					a->UnknownFilter = (char **)soap_push_block_max(soap, soap_blist_UnknownFilter, sizeof(char *));
					if (a->UnknownFilter == NULL)
						return NULL;
					*a->UnknownFilter = NULL;
				}
				soap_revert(soap);
				if (soap_in__QName(soap, "wsnt:UnknownFilter", (char**)a->UnknownFilter, "xsd:QName"))
				{	a->__sizeUnknownFilter++;
					a->UnknownFilter = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	if (a->__any == NULL)
				{	if (soap_blist___any == NULL)
						soap_blist___any = soap_alloc_block(soap);
					a->__any = (char **)soap_push_block_max(soap, soap_blist___any, sizeof(char *));
					if (a->__any == NULL)
						return NULL;
					*a->__any = NULL;
				}
				if (soap_inliteral(soap, "-any", (char**)a->__any))
				{	a->__size++;
					a->__any = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->__any)
			soap_pop_block(soap, soap_blist___any);
		if (a->__size)
		{	a->__any = (char **)soap_save_block(soap, soap_blist___any, NULL, 1);
		}
		else
		{	a->__any = NULL;
			if (soap_blist___any)
				soap_end_block(soap, soap_blist___any);
		}
		if (a->wsrfbf__Description)
			soap_pop_block(soap, soap_blist_wsrfbf__Description);
		if (a->__sizeDescription)
		{	a->wsrfbf__Description = (struct _wsnt__InvalidFilterFaultType_Description *)soap_save_block(soap, soap_blist_wsrfbf__Description, NULL, 1);
		}
		else
		{	a->wsrfbf__Description = NULL;
			if (soap_blist_wsrfbf__Description)
				soap_end_block(soap, soap_blist_wsrfbf__Description);
		}
		if (a->UnknownFilter)
			soap_pop_block(soap, soap_blist_UnknownFilter);
		if (a->__sizeUnknownFilter)
		{	a->UnknownFilter = (char **)soap_save_block(soap, soap_blist_UnknownFilter, NULL, 1);
		}
		else
		{	a->UnknownFilter = NULL;
			if (soap_blist_UnknownFilter)
				soap_end_block(soap, soap_blist_UnknownFilter);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_wsrfbf__Timestamp > 0 || a->__sizeUnknownFilter < 1))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct wsnt__InvalidFilterFaultType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_wsnt__InvalidFilterFaultType, SOAP_TYPE_wsnt__InvalidFilterFaultType, sizeof(struct wsnt__InvalidFilterFaultType), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct wsnt__InvalidFilterFaultType * SOAP_FMAC4 soap_new_wsnt__InvalidFilterFaultType(struct soap *soap, int n)
{
	struct wsnt__InvalidFilterFaultType *p;
	struct wsnt__InvalidFilterFaultType *a = (struct wsnt__InvalidFilterFaultType*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct wsnt__InvalidFilterFaultType));
	for (p = a; p && n--; p++)
		soap_default_wsnt__InvalidFilterFaultType(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_wsnt__InvalidFilterFaultType(struct soap *soap, const struct wsnt__InvalidFilterFaultType *a, const char *tag, const char *type)
{
	if (soap_out_wsnt__InvalidFilterFaultType(soap, tag ? tag : "wsnt:InvalidFilterFaultType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct wsnt__InvalidFilterFaultType * SOAP_FMAC4 soap_get_wsnt__InvalidFilterFaultType(struct soap *soap, struct wsnt__InvalidFilterFaultType *p, const char *tag, const char *type)
{
	if ((p = soap_in_wsnt__InvalidFilterFaultType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__wsnt__SubscribeCreationFailedFaultType_FaultCause(struct soap *soap, struct _wsnt__SubscribeCreationFailedFaultType_FaultCause *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__any = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__wsnt__SubscribeCreationFailedFaultType_FaultCause(struct soap *soap, const struct _wsnt__SubscribeCreationFailedFaultType_FaultCause *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__wsnt__SubscribeCreationFailedFaultType_FaultCause(struct soap *soap, const char *tag, int id, const struct _wsnt__SubscribeCreationFailedFaultType_FaultCause *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__wsnt__SubscribeCreationFailedFaultType_FaultCause), type))
		return soap->error;
	if (soap_outliteral(soap, "-any", (char*const*)&a->__any, NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _wsnt__SubscribeCreationFailedFaultType_FaultCause * SOAP_FMAC4 soap_in__wsnt__SubscribeCreationFailedFaultType_FaultCause(struct soap *soap, const char *tag, struct _wsnt__SubscribeCreationFailedFaultType_FaultCause *a, const char *type)
{
	size_t soap_flag___any = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct _wsnt__SubscribeCreationFailedFaultType_FaultCause*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__wsnt__SubscribeCreationFailedFaultType_FaultCause, sizeof(struct _wsnt__SubscribeCreationFailedFaultType_FaultCause), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__wsnt__SubscribeCreationFailedFaultType_FaultCause(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag___any && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_inliteral(soap, "-any", (char**)&a->__any))
				{	soap_flag___any--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _wsnt__SubscribeCreationFailedFaultType_FaultCause *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__wsnt__SubscribeCreationFailedFaultType_FaultCause, SOAP_TYPE__wsnt__SubscribeCreationFailedFaultType_FaultCause, sizeof(struct _wsnt__SubscribeCreationFailedFaultType_FaultCause), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _wsnt__SubscribeCreationFailedFaultType_FaultCause * SOAP_FMAC4 soap_new__wsnt__SubscribeCreationFailedFaultType_FaultCause(struct soap *soap, int n)
{
	struct _wsnt__SubscribeCreationFailedFaultType_FaultCause *p;
	struct _wsnt__SubscribeCreationFailedFaultType_FaultCause *a = (struct _wsnt__SubscribeCreationFailedFaultType_FaultCause*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _wsnt__SubscribeCreationFailedFaultType_FaultCause));
	for (p = a; p && n--; p++)
		soap_default__wsnt__SubscribeCreationFailedFaultType_FaultCause(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__wsnt__SubscribeCreationFailedFaultType_FaultCause(struct soap *soap, const struct _wsnt__SubscribeCreationFailedFaultType_FaultCause *a, const char *tag, const char *type)
{
	if (soap_out__wsnt__SubscribeCreationFailedFaultType_FaultCause(soap, tag ? tag : "wsnt:SubscribeCreationFailedFaultType-FaultCause", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _wsnt__SubscribeCreationFailedFaultType_FaultCause * SOAP_FMAC4 soap_get__wsnt__SubscribeCreationFailedFaultType_FaultCause(struct soap *soap, struct _wsnt__SubscribeCreationFailedFaultType_FaultCause *p, const char *tag, const char *type)
{
	if ((p = soap_in__wsnt__SubscribeCreationFailedFaultType_FaultCause(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__wsnt__SubscribeCreationFailedFaultType_Description(struct soap *soap, struct _wsnt__SubscribeCreationFailedFaultType_Description *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->__item);
	soap_default__xml__lang(soap, &a->xml__lang);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__wsnt__SubscribeCreationFailedFaultType_Description(struct soap *soap, const struct _wsnt__SubscribeCreationFailedFaultType_Description *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_string(soap, (char*const*)&a->__item);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__wsnt__SubscribeCreationFailedFaultType_Description(struct soap *soap, const char *tag, int id, const struct _wsnt__SubscribeCreationFailedFaultType_Description *a, const char *type)
{
	if (a->xml__lang)
		soap_set_attr(soap, "xml:lang", soap__xml__lang2s(soap, a->xml__lang), 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	return soap_out_string(soap, tag, id, (char*const*)&a->__item, "");
}

SOAP_FMAC3 struct _wsnt__SubscribeCreationFailedFaultType_Description * SOAP_FMAC4 soap_in__wsnt__SubscribeCreationFailedFaultType_Description(struct soap *soap, const char *tag, struct _wsnt__SubscribeCreationFailedFaultType_Description *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	if (!(a = (struct _wsnt__SubscribeCreationFailedFaultType_Description *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__wsnt__SubscribeCreationFailedFaultType_Description, sizeof(struct _wsnt__SubscribeCreationFailedFaultType_Description), NULL, NULL, NULL, NULL)))
		return NULL;
	soap_revert(soap);
	*soap->id = '\0';
	soap_default__wsnt__SubscribeCreationFailedFaultType_Description(soap, a);
	if (soap_s2_xml__lang(soap, soap_attr_value(soap, "xml:lang", 1, 0), &a->xml__lang))
		return NULL;
	if (!soap_in_string(soap, tag, (char**)&a->__item, ""))
		return NULL;
	return a;
}

SOAP_FMAC3 struct _wsnt__SubscribeCreationFailedFaultType_Description * SOAP_FMAC4 soap_new__wsnt__SubscribeCreationFailedFaultType_Description(struct soap *soap, int n)
{
	struct _wsnt__SubscribeCreationFailedFaultType_Description *p;
	struct _wsnt__SubscribeCreationFailedFaultType_Description *a = (struct _wsnt__SubscribeCreationFailedFaultType_Description*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _wsnt__SubscribeCreationFailedFaultType_Description));
	for (p = a; p && n--; p++)
		soap_default__wsnt__SubscribeCreationFailedFaultType_Description(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__wsnt__SubscribeCreationFailedFaultType_Description(struct soap *soap, const struct _wsnt__SubscribeCreationFailedFaultType_Description *a, const char *tag, const char *type)
{
	if (soap_out__wsnt__SubscribeCreationFailedFaultType_Description(soap, tag ? tag : "wsnt:SubscribeCreationFailedFaultType-Description", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _wsnt__SubscribeCreationFailedFaultType_Description * SOAP_FMAC4 soap_get__wsnt__SubscribeCreationFailedFaultType_Description(struct soap *soap, struct _wsnt__SubscribeCreationFailedFaultType_Description *p, const char *tag, const char *type)
{
	if ((p = soap_in__wsnt__SubscribeCreationFailedFaultType_Description(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__wsnt__SubscribeCreationFailedFaultType_ErrorCode(struct soap *soap, struct _wsnt__SubscribeCreationFailedFaultType_ErrorCode *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_xsd__anyURI(soap, &a->dialect);
	a->__mixed = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__wsnt__SubscribeCreationFailedFaultType_ErrorCode(struct soap *soap, const struct _wsnt__SubscribeCreationFailedFaultType_ErrorCode *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__wsnt__SubscribeCreationFailedFaultType_ErrorCode(struct soap *soap, const char *tag, int id, const struct _wsnt__SubscribeCreationFailedFaultType_ErrorCode *a, const char *type)
{
	soap_set_attr(soap, "dialect", a->dialect ? soap_xsd__anyURI2s(soap, a->dialect) : "", 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__wsnt__SubscribeCreationFailedFaultType_ErrorCode), type))
		return soap->error;
	if (soap_outliteral(soap, "-mixed", (char*const*)&a->__mixed, NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _wsnt__SubscribeCreationFailedFaultType_ErrorCode * SOAP_FMAC4 soap_in__wsnt__SubscribeCreationFailedFaultType_ErrorCode(struct soap *soap, const char *tag, struct _wsnt__SubscribeCreationFailedFaultType_ErrorCode *a, const char *type)
{
	size_t soap_flag___mixed = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct _wsnt__SubscribeCreationFailedFaultType_ErrorCode*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__wsnt__SubscribeCreationFailedFaultType_ErrorCode, sizeof(struct _wsnt__SubscribeCreationFailedFaultType_ErrorCode), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__wsnt__SubscribeCreationFailedFaultType_ErrorCode(soap, a);
	if (soap_s2xsd__anyURI(soap, soap_attr_value(soap, "dialect", 4, 1), &a->dialect))
		return NULL;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag___mixed && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_inliteral(soap, "-mixed", (char**)&a->__mixed))
				{	soap_flag___mixed--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _wsnt__SubscribeCreationFailedFaultType_ErrorCode *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__wsnt__SubscribeCreationFailedFaultType_ErrorCode, SOAP_TYPE__wsnt__SubscribeCreationFailedFaultType_ErrorCode, sizeof(struct _wsnt__SubscribeCreationFailedFaultType_ErrorCode), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _wsnt__SubscribeCreationFailedFaultType_ErrorCode * SOAP_FMAC4 soap_new__wsnt__SubscribeCreationFailedFaultType_ErrorCode(struct soap *soap, int n)
{
	struct _wsnt__SubscribeCreationFailedFaultType_ErrorCode *p;
	struct _wsnt__SubscribeCreationFailedFaultType_ErrorCode *a = (struct _wsnt__SubscribeCreationFailedFaultType_ErrorCode*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _wsnt__SubscribeCreationFailedFaultType_ErrorCode));
	for (p = a; p && n--; p++)
		soap_default__wsnt__SubscribeCreationFailedFaultType_ErrorCode(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__wsnt__SubscribeCreationFailedFaultType_ErrorCode(struct soap *soap, const struct _wsnt__SubscribeCreationFailedFaultType_ErrorCode *a, const char *tag, const char *type)
{
	if (soap_out__wsnt__SubscribeCreationFailedFaultType_ErrorCode(soap, tag ? tag : "wsnt:SubscribeCreationFailedFaultType-ErrorCode", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _wsnt__SubscribeCreationFailedFaultType_ErrorCode * SOAP_FMAC4 soap_get__wsnt__SubscribeCreationFailedFaultType_ErrorCode(struct soap *soap, struct _wsnt__SubscribeCreationFailedFaultType_ErrorCode *p, const char *tag, const char *type)
{
	if ((p = soap_in__wsnt__SubscribeCreationFailedFaultType_ErrorCode(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_wsnt__SubscribeCreationFailedFaultType(struct soap *soap, struct wsnt__SubscribeCreationFailedFaultType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__size = 0;
	a->__any = NULL;
	soap_default_dateTime(soap, &a->wsrfbf__Timestamp);
	a->wsrfbf__Originator = NULL;
	a->wsrfbf__ErrorCode = NULL;
	a->__sizeDescription = 0;
	a->wsrfbf__Description = NULL;
	a->wsrfbf__FaultCause = NULL;
	a->__anyAttribute = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_wsnt__SubscribeCreationFailedFaultType(struct soap *soap, const struct wsnt__SubscribeCreationFailedFaultType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &a->wsrfbf__Timestamp, SOAP_TYPE_dateTime);
	soap_serialize_PointerTowsa5__EndpointReferenceType(soap, &a->wsrfbf__Originator);
	soap_serialize_PointerTo_wsnt__SubscribeCreationFailedFaultType_ErrorCode(soap, &a->wsrfbf__ErrorCode);
	if (a->wsrfbf__Description)
	{	int i;
		for (i = 0; i < (int)a->__sizeDescription; i++)
		{
			soap_embedded(soap, a->wsrfbf__Description + i, SOAP_TYPE__wsnt__SubscribeCreationFailedFaultType_Description);
			soap_serialize__wsnt__SubscribeCreationFailedFaultType_Description(soap, a->wsrfbf__Description + i);
		}
	}
	soap_serialize_PointerTo_wsnt__SubscribeCreationFailedFaultType_FaultCause(soap, &a->wsrfbf__FaultCause);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_wsnt__SubscribeCreationFailedFaultType(struct soap *soap, const char *tag, int id, const struct wsnt__SubscribeCreationFailedFaultType *a, const char *type)
{
	if (a->__anyAttribute)
		soap_set_attr(soap, "-anyAttribute", a->__anyAttribute, 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_wsnt__SubscribeCreationFailedFaultType), type))
		return soap->error;
	if (a->__any)
	{	int i;
		for (i = 0; i < (int)a->__size; i++)
			if (soap_outliteral(soap, "-any", (char*const*)(a->__any + i), NULL))
				return soap->error;
	}
	if (soap_out_dateTime(soap, "wsrfbf:Timestamp", -1, &a->wsrfbf__Timestamp, ""))
		return soap->error;
	if (soap_out_PointerTowsa5__EndpointReferenceType(soap, "wsrfbf:Originator", -1, &a->wsrfbf__Originator, ""))
		return soap->error;
	if (soap_out_PointerTo_wsnt__SubscribeCreationFailedFaultType_ErrorCode(soap, "wsrfbf:ErrorCode", -1, &a->wsrfbf__ErrorCode, ""))
		return soap->error;
	if (a->wsrfbf__Description)
	{	int i;
		for (i = 0; i < (int)a->__sizeDescription; i++)
			if (soap_out__wsnt__SubscribeCreationFailedFaultType_Description(soap, "wsrfbf:Description", -1, a->wsrfbf__Description + i, ""))
				return soap->error;
	}
	if (soap_out_PointerTo_wsnt__SubscribeCreationFailedFaultType_FaultCause(soap, "wsrfbf:FaultCause", -1, &a->wsrfbf__FaultCause, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct wsnt__SubscribeCreationFailedFaultType * SOAP_FMAC4 soap_in_wsnt__SubscribeCreationFailedFaultType(struct soap *soap, const char *tag, struct wsnt__SubscribeCreationFailedFaultType *a, const char *type)
{
	struct soap_blist *soap_blist___any = NULL;
	size_t soap_flag_wsrfbf__Timestamp = 1;
	size_t soap_flag_wsrfbf__Originator = 1;
	size_t soap_flag_wsrfbf__ErrorCode = 1;
	struct soap_blist *soap_blist_wsrfbf__Description = NULL;
	size_t soap_flag_wsrfbf__FaultCause = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct wsnt__SubscribeCreationFailedFaultType*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_wsnt__SubscribeCreationFailedFaultType, sizeof(struct wsnt__SubscribeCreationFailedFaultType), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_wsnt__SubscribeCreationFailedFaultType(soap, a);
	if (soap_s2char(soap, soap_attr_value(soap, "-anyAttribute", 0, 0), &a->__anyAttribute, 0, 0, -1, NULL))
		return NULL;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_wsrfbf__Timestamp && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_dateTime(soap, "wsrfbf:Timestamp", &a->wsrfbf__Timestamp, "xsd:dateTime"))
				{	soap_flag_wsrfbf__Timestamp--;
					continue;
				}
			}
			if (soap_flag_wsrfbf__Originator && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTowsa5__EndpointReferenceType(soap, "wsrfbf:Originator", &a->wsrfbf__Originator, "wsa5:EndpointReferenceType"))
				{	soap_flag_wsrfbf__Originator--;
					continue;
				}
			}
			if (soap_flag_wsrfbf__ErrorCode && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_wsnt__SubscribeCreationFailedFaultType_ErrorCode(soap, "wsrfbf:ErrorCode", &a->wsrfbf__ErrorCode, ""))
				{	soap_flag_wsrfbf__ErrorCode--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "wsrfbf:Description", 1, NULL))
			{	if (a->wsrfbf__Description == NULL)
				{	if (soap_blist_wsrfbf__Description == NULL)
						soap_blist_wsrfbf__Description = soap_alloc_block(soap);
					a->wsrfbf__Description = (struct _wsnt__SubscribeCreationFailedFaultType_Description *)soap_push_block_max(soap, soap_blist_wsrfbf__Description, sizeof(struct _wsnt__SubscribeCreationFailedFaultType_Description));
					if (a->wsrfbf__Description == NULL)
						return NULL;
					soap_default__wsnt__SubscribeCreationFailedFaultType_Description(soap, a->wsrfbf__Description);
				}
				soap_revert(soap);
				if (soap_in__wsnt__SubscribeCreationFailedFaultType_Description(soap, "wsrfbf:Description", a->wsrfbf__Description, ""))
				{	a->__sizeDescription++;
					a->wsrfbf__Description = NULL;
					continue;
				}
			}
			if (soap_flag_wsrfbf__FaultCause && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_wsnt__SubscribeCreationFailedFaultType_FaultCause(soap, "wsrfbf:FaultCause", &a->wsrfbf__FaultCause, ""))
				{	soap_flag_wsrfbf__FaultCause--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	if (a->__any == NULL)
				{	if (soap_blist___any == NULL)
						soap_blist___any = soap_alloc_block(soap);
					a->__any = (char **)soap_push_block_max(soap, soap_blist___any, sizeof(char *));
					if (a->__any == NULL)
						return NULL;
					*a->__any = NULL;
				}
				if (soap_inliteral(soap, "-any", (char**)a->__any))
				{	a->__size++;
					a->__any = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->__any)
			soap_pop_block(soap, soap_blist___any);
		if (a->__size)
		{	a->__any = (char **)soap_save_block(soap, soap_blist___any, NULL, 1);
		}
		else
		{	a->__any = NULL;
			if (soap_blist___any)
				soap_end_block(soap, soap_blist___any);
		}
		if (a->wsrfbf__Description)
			soap_pop_block(soap, soap_blist_wsrfbf__Description);
		if (a->__sizeDescription)
		{	a->wsrfbf__Description = (struct _wsnt__SubscribeCreationFailedFaultType_Description *)soap_save_block(soap, soap_blist_wsrfbf__Description, NULL, 1);
		}
		else
		{	a->wsrfbf__Description = NULL;
			if (soap_blist_wsrfbf__Description)
				soap_end_block(soap, soap_blist_wsrfbf__Description);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_wsrfbf__Timestamp > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct wsnt__SubscribeCreationFailedFaultType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_wsnt__SubscribeCreationFailedFaultType, SOAP_TYPE_wsnt__SubscribeCreationFailedFaultType, sizeof(struct wsnt__SubscribeCreationFailedFaultType), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct wsnt__SubscribeCreationFailedFaultType * SOAP_FMAC4 soap_new_wsnt__SubscribeCreationFailedFaultType(struct soap *soap, int n)
{
	struct wsnt__SubscribeCreationFailedFaultType *p;
	struct wsnt__SubscribeCreationFailedFaultType *a = (struct wsnt__SubscribeCreationFailedFaultType*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct wsnt__SubscribeCreationFailedFaultType));
	for (p = a; p && n--; p++)
		soap_default_wsnt__SubscribeCreationFailedFaultType(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_wsnt__SubscribeCreationFailedFaultType(struct soap *soap, const struct wsnt__SubscribeCreationFailedFaultType *a, const char *tag, const char *type)
{
	if (soap_out_wsnt__SubscribeCreationFailedFaultType(soap, tag ? tag : "wsnt:SubscribeCreationFailedFaultType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct wsnt__SubscribeCreationFailedFaultType * SOAP_FMAC4 soap_get_wsnt__SubscribeCreationFailedFaultType(struct soap *soap, struct wsnt__SubscribeCreationFailedFaultType *p, const char *tag, const char *type)
{
	if ((p = soap_in_wsnt__SubscribeCreationFailedFaultType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__trt__GetSnapshotUriResponse(struct soap *soap, struct _trt__GetSnapshotUriResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->MediaUri = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__trt__GetSnapshotUriResponse(struct soap *soap, const struct _trt__GetSnapshotUriResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTott__MediaUri(soap, &a->MediaUri);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__trt__GetSnapshotUriResponse(struct soap *soap, const char *tag, int id, const struct _trt__GetSnapshotUriResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__trt__GetSnapshotUriResponse), type))
		return soap->error;
	if (a->MediaUri)
		soap_element_result(soap, "trt:MediaUri");
	if (!a->MediaUri)
	{	if (soap_element_empty(soap, "trt:MediaUri", 0, NULL))
			return soap->error;
	}
	else if (soap_out_PointerTott__MediaUri(soap, "trt:MediaUri", -1, &a->MediaUri, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _trt__GetSnapshotUriResponse * SOAP_FMAC4 soap_in__trt__GetSnapshotUriResponse(struct soap *soap, const char *tag, struct _trt__GetSnapshotUriResponse *a, const char *type)
{
	size_t soap_flag_MediaUri = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct _trt__GetSnapshotUriResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__trt__GetSnapshotUriResponse, sizeof(struct _trt__GetSnapshotUriResponse), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__trt__GetSnapshotUriResponse(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_MediaUri && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__MediaUri(soap, "trt:MediaUri", &a->MediaUri, "tt:MediaUri"))
				{	soap_flag_MediaUri--;
					continue;
				}
			}
			soap_check_result(soap, "trt:MediaUri");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (!a->MediaUri))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct _trt__GetSnapshotUriResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__trt__GetSnapshotUriResponse, SOAP_TYPE__trt__GetSnapshotUriResponse, sizeof(struct _trt__GetSnapshotUriResponse), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _trt__GetSnapshotUriResponse * SOAP_FMAC4 soap_new__trt__GetSnapshotUriResponse(struct soap *soap, int n)
{
	struct _trt__GetSnapshotUriResponse *p;
	struct _trt__GetSnapshotUriResponse *a = (struct _trt__GetSnapshotUriResponse*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _trt__GetSnapshotUriResponse));
	for (p = a; p && n--; p++)
		soap_default__trt__GetSnapshotUriResponse(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__trt__GetSnapshotUriResponse(struct soap *soap, const struct _trt__GetSnapshotUriResponse *a, const char *tag, const char *type)
{
	if (soap_out__trt__GetSnapshotUriResponse(soap, tag ? tag : "trt:GetSnapshotUriResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _trt__GetSnapshotUriResponse * SOAP_FMAC4 soap_get__trt__GetSnapshotUriResponse(struct soap *soap, struct _trt__GetSnapshotUriResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__trt__GetSnapshotUriResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__trt__GetSnapshotUri(struct soap *soap, struct _trt__GetSnapshotUri *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_tt__ReferenceToken(soap, &a->ProfileToken);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__trt__GetSnapshotUri(struct soap *soap, const struct _trt__GetSnapshotUri *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_tt__ReferenceToken(soap, (char*const*)&a->ProfileToken);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__trt__GetSnapshotUri(struct soap *soap, const char *tag, int id, const struct _trt__GetSnapshotUri *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__trt__GetSnapshotUri), type))
		return soap->error;
	if (!a->ProfileToken)
	{	if (soap_element_empty(soap, "trt:ProfileToken", 0, NULL))
			return soap->error;
	}
	else if (soap_out_tt__ReferenceToken(soap, "trt:ProfileToken", -1, (char*const*)&a->ProfileToken, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _trt__GetSnapshotUri * SOAP_FMAC4 soap_in__trt__GetSnapshotUri(struct soap *soap, const char *tag, struct _trt__GetSnapshotUri *a, const char *type)
{
	size_t soap_flag_ProfileToken = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct _trt__GetSnapshotUri*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__trt__GetSnapshotUri, sizeof(struct _trt__GetSnapshotUri), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__trt__GetSnapshotUri(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ProfileToken && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_tt__ReferenceToken(soap, "trt:ProfileToken", (char**)&a->ProfileToken, "tt:ReferenceToken"))
				{	soap_flag_ProfileToken--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (!a->ProfileToken))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct _trt__GetSnapshotUri *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__trt__GetSnapshotUri, SOAP_TYPE__trt__GetSnapshotUri, sizeof(struct _trt__GetSnapshotUri), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _trt__GetSnapshotUri * SOAP_FMAC4 soap_new__trt__GetSnapshotUri(struct soap *soap, int n)
{
	struct _trt__GetSnapshotUri *p;
	struct _trt__GetSnapshotUri *a = (struct _trt__GetSnapshotUri*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _trt__GetSnapshotUri));
	for (p = a; p && n--; p++)
		soap_default__trt__GetSnapshotUri(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__trt__GetSnapshotUri(struct soap *soap, const struct _trt__GetSnapshotUri *a, const char *tag, const char *type)
{
	if (soap_out__trt__GetSnapshotUri(soap, tag ? tag : "trt:GetSnapshotUri", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _trt__GetSnapshotUri * SOAP_FMAC4 soap_get__trt__GetSnapshotUri(struct soap *soap, struct _trt__GetSnapshotUri *p, const char *tag, const char *type)
{
	if ((p = soap_in__trt__GetSnapshotUri(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__trt__DeleteProfileResponse(struct soap *soap, struct _trt__DeleteProfileResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__trt__DeleteProfileResponse(struct soap *soap, const struct _trt__DeleteProfileResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__trt__DeleteProfileResponse(struct soap *soap, const char *tag, int id, const struct _trt__DeleteProfileResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__trt__DeleteProfileResponse), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _trt__DeleteProfileResponse * SOAP_FMAC4 soap_in__trt__DeleteProfileResponse(struct soap *soap, const char *tag, struct _trt__DeleteProfileResponse *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct _trt__DeleteProfileResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__trt__DeleteProfileResponse, sizeof(struct _trt__DeleteProfileResponse), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__trt__DeleteProfileResponse(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _trt__DeleteProfileResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__trt__DeleteProfileResponse, SOAP_TYPE__trt__DeleteProfileResponse, sizeof(struct _trt__DeleteProfileResponse), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _trt__DeleteProfileResponse * SOAP_FMAC4 soap_new__trt__DeleteProfileResponse(struct soap *soap, int n)
{
	struct _trt__DeleteProfileResponse *p;
	struct _trt__DeleteProfileResponse *a = (struct _trt__DeleteProfileResponse*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _trt__DeleteProfileResponse));
	for (p = a; p && n--; p++)
		soap_default__trt__DeleteProfileResponse(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__trt__DeleteProfileResponse(struct soap *soap, const struct _trt__DeleteProfileResponse *a, const char *tag, const char *type)
{
	if (soap_out__trt__DeleteProfileResponse(soap, tag ? tag : "trt:DeleteProfileResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _trt__DeleteProfileResponse * SOAP_FMAC4 soap_get__trt__DeleteProfileResponse(struct soap *soap, struct _trt__DeleteProfileResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__trt__DeleteProfileResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__trt__DeleteProfile(struct soap *soap, struct _trt__DeleteProfile *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_tt__ReferenceToken(soap, &a->ProfileToken);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__trt__DeleteProfile(struct soap *soap, const struct _trt__DeleteProfile *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_tt__ReferenceToken(soap, (char*const*)&a->ProfileToken);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__trt__DeleteProfile(struct soap *soap, const char *tag, int id, const struct _trt__DeleteProfile *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__trt__DeleteProfile), type))
		return soap->error;
	if (!a->ProfileToken)
	{	if (soap_element_empty(soap, "trt:ProfileToken", 0, NULL))
			return soap->error;
	}
	else if (soap_out_tt__ReferenceToken(soap, "trt:ProfileToken", -1, (char*const*)&a->ProfileToken, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _trt__DeleteProfile * SOAP_FMAC4 soap_in__trt__DeleteProfile(struct soap *soap, const char *tag, struct _trt__DeleteProfile *a, const char *type)
{
	size_t soap_flag_ProfileToken = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct _trt__DeleteProfile*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__trt__DeleteProfile, sizeof(struct _trt__DeleteProfile), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__trt__DeleteProfile(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ProfileToken && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_tt__ReferenceToken(soap, "trt:ProfileToken", (char**)&a->ProfileToken, "tt:ReferenceToken"))
				{	soap_flag_ProfileToken--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (!a->ProfileToken))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct _trt__DeleteProfile *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__trt__DeleteProfile, SOAP_TYPE__trt__DeleteProfile, sizeof(struct _trt__DeleteProfile), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _trt__DeleteProfile * SOAP_FMAC4 soap_new__trt__DeleteProfile(struct soap *soap, int n)
{
	struct _trt__DeleteProfile *p;
	struct _trt__DeleteProfile *a = (struct _trt__DeleteProfile*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _trt__DeleteProfile));
	for (p = a; p && n--; p++)
		soap_default__trt__DeleteProfile(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__trt__DeleteProfile(struct soap *soap, const struct _trt__DeleteProfile *a, const char *tag, const char *type)
{
	if (soap_out__trt__DeleteProfile(soap, tag ? tag : "trt:DeleteProfile", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _trt__DeleteProfile * SOAP_FMAC4 soap_get__trt__DeleteProfile(struct soap *soap, struct _trt__DeleteProfile *p, const char *tag, const char *type)
{
	if ((p = soap_in__trt__DeleteProfile(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__trt__GetProfilesResponse(struct soap *soap, struct _trt__GetProfilesResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__sizeProfiles = 0;
	a->Profiles = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__trt__GetProfilesResponse(struct soap *soap, const struct _trt__GetProfilesResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (a->Profiles)
	{	int i;
		for (i = 0; i < (int)a->__sizeProfiles; i++)
		{
			soap_embedded(soap, a->Profiles + i, SOAP_TYPE_tt__Profile);
			soap_serialize_tt__Profile(soap, a->Profiles + i);
		}
	}
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__trt__GetProfilesResponse(struct soap *soap, const char *tag, int id, const struct _trt__GetProfilesResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__trt__GetProfilesResponse), type))
		return soap->error;
	soap_element_result(soap, "-sizeProfiles");
	if (a->Profiles)
	{	int i;
		for (i = 0; i < (int)a->__sizeProfiles; i++)
			if (soap_out_tt__Profile(soap, "trt:Profiles", -1, a->Profiles + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _trt__GetProfilesResponse * SOAP_FMAC4 soap_in__trt__GetProfilesResponse(struct soap *soap, const char *tag, struct _trt__GetProfilesResponse *a, const char *type)
{
	struct soap_blist *soap_blist_Profiles = NULL;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct _trt__GetProfilesResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__trt__GetProfilesResponse, sizeof(struct _trt__GetProfilesResponse), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__trt__GetProfilesResponse(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "trt:Profiles", 1, NULL))
			{	if (a->Profiles == NULL)
				{	if (soap_blist_Profiles == NULL)
						soap_blist_Profiles = soap_alloc_block(soap);
					a->Profiles = (struct tt__Profile *)soap_push_block_max(soap, soap_blist_Profiles, sizeof(struct tt__Profile));
					if (a->Profiles == NULL)
						return NULL;
					soap_default_tt__Profile(soap, a->Profiles);
				}
				soap_revert(soap);
				if (soap_in_tt__Profile(soap, "trt:Profiles", a->Profiles, "tt:Profile"))
				{	a->__sizeProfiles++;
					a->Profiles = NULL;
					continue;
				}
			}
			soap_check_result(soap, "-sizeProfiles");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->Profiles)
			soap_pop_block(soap, soap_blist_Profiles);
		if (a->__sizeProfiles)
		{	a->Profiles = (struct tt__Profile *)soap_save_block(soap, soap_blist_Profiles, NULL, 1);
		}
		else
		{	a->Profiles = NULL;
			if (soap_blist_Profiles)
				soap_end_block(soap, soap_blist_Profiles);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _trt__GetProfilesResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__trt__GetProfilesResponse, SOAP_TYPE__trt__GetProfilesResponse, sizeof(struct _trt__GetProfilesResponse), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _trt__GetProfilesResponse * SOAP_FMAC4 soap_new__trt__GetProfilesResponse(struct soap *soap, int n)
{
	struct _trt__GetProfilesResponse *p;
	struct _trt__GetProfilesResponse *a = (struct _trt__GetProfilesResponse*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _trt__GetProfilesResponse));
	for (p = a; p && n--; p++)
		soap_default__trt__GetProfilesResponse(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__trt__GetProfilesResponse(struct soap *soap, const struct _trt__GetProfilesResponse *a, const char *tag, const char *type)
{
	if (soap_out__trt__GetProfilesResponse(soap, tag ? tag : "trt:GetProfilesResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _trt__GetProfilesResponse * SOAP_FMAC4 soap_get__trt__GetProfilesResponse(struct soap *soap, struct _trt__GetProfilesResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__trt__GetProfilesResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__trt__GetProfiles(struct soap *soap, struct _trt__GetProfiles *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__trt__GetProfiles(struct soap *soap, const struct _trt__GetProfiles *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__trt__GetProfiles(struct soap *soap, const char *tag, int id, const struct _trt__GetProfiles *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__trt__GetProfiles), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _trt__GetProfiles * SOAP_FMAC4 soap_in__trt__GetProfiles(struct soap *soap, const char *tag, struct _trt__GetProfiles *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct _trt__GetProfiles*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__trt__GetProfiles, sizeof(struct _trt__GetProfiles), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__trt__GetProfiles(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _trt__GetProfiles *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__trt__GetProfiles, SOAP_TYPE__trt__GetProfiles, sizeof(struct _trt__GetProfiles), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _trt__GetProfiles * SOAP_FMAC4 soap_new__trt__GetProfiles(struct soap *soap, int n)
{
	struct _trt__GetProfiles *p;
	struct _trt__GetProfiles *a = (struct _trt__GetProfiles*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _trt__GetProfiles));
	for (p = a; p && n--; p++)
		soap_default__trt__GetProfiles(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__trt__GetProfiles(struct soap *soap, const struct _trt__GetProfiles *a, const char *tag, const char *type)
{
	if (soap_out__trt__GetProfiles(soap, tag ? tag : "trt:GetProfiles", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _trt__GetProfiles * SOAP_FMAC4 soap_get__trt__GetProfiles(struct soap *soap, struct _trt__GetProfiles *p, const char *tag, const char *type)
{
	if ((p = soap_in__trt__GetProfiles(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__trt__GetProfileResponse(struct soap *soap, struct _trt__GetProfileResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->Profile = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__trt__GetProfileResponse(struct soap *soap, const struct _trt__GetProfileResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTott__Profile(soap, &a->Profile);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__trt__GetProfileResponse(struct soap *soap, const char *tag, int id, const struct _trt__GetProfileResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__trt__GetProfileResponse), type))
		return soap->error;
	if (a->Profile)
		soap_element_result(soap, "trt:Profile");
	if (!a->Profile)
	{	if (soap_element_empty(soap, "trt:Profile", 0, NULL))
			return soap->error;
	}
	else if (soap_out_PointerTott__Profile(soap, "trt:Profile", -1, &a->Profile, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _trt__GetProfileResponse * SOAP_FMAC4 soap_in__trt__GetProfileResponse(struct soap *soap, const char *tag, struct _trt__GetProfileResponse *a, const char *type)
{
	size_t soap_flag_Profile = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct _trt__GetProfileResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__trt__GetProfileResponse, sizeof(struct _trt__GetProfileResponse), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__trt__GetProfileResponse(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Profile && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__Profile(soap, "trt:Profile", &a->Profile, "tt:Profile"))
				{	soap_flag_Profile--;
					continue;
				}
			}
			soap_check_result(soap, "trt:Profile");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (!a->Profile))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct _trt__GetProfileResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__trt__GetProfileResponse, SOAP_TYPE__trt__GetProfileResponse, sizeof(struct _trt__GetProfileResponse), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _trt__GetProfileResponse * SOAP_FMAC4 soap_new__trt__GetProfileResponse(struct soap *soap, int n)
{
	struct _trt__GetProfileResponse *p;
	struct _trt__GetProfileResponse *a = (struct _trt__GetProfileResponse*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _trt__GetProfileResponse));
	for (p = a; p && n--; p++)
		soap_default__trt__GetProfileResponse(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__trt__GetProfileResponse(struct soap *soap, const struct _trt__GetProfileResponse *a, const char *tag, const char *type)
{
	if (soap_out__trt__GetProfileResponse(soap, tag ? tag : "trt:GetProfileResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _trt__GetProfileResponse * SOAP_FMAC4 soap_get__trt__GetProfileResponse(struct soap *soap, struct _trt__GetProfileResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__trt__GetProfileResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__trt__GetProfile(struct soap *soap, struct _trt__GetProfile *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_tt__ReferenceToken(soap, &a->ProfileToken);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__trt__GetProfile(struct soap *soap, const struct _trt__GetProfile *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_tt__ReferenceToken(soap, (char*const*)&a->ProfileToken);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__trt__GetProfile(struct soap *soap, const char *tag, int id, const struct _trt__GetProfile *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__trt__GetProfile), type))
		return soap->error;
	if (!a->ProfileToken)
	{	if (soap_element_empty(soap, "trt:ProfileToken", 0, NULL))
			return soap->error;
	}
	else if (soap_out_tt__ReferenceToken(soap, "trt:ProfileToken", -1, (char*const*)&a->ProfileToken, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _trt__GetProfile * SOAP_FMAC4 soap_in__trt__GetProfile(struct soap *soap, const char *tag, struct _trt__GetProfile *a, const char *type)
{
	size_t soap_flag_ProfileToken = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct _trt__GetProfile*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__trt__GetProfile, sizeof(struct _trt__GetProfile), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__trt__GetProfile(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ProfileToken && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_tt__ReferenceToken(soap, "trt:ProfileToken", (char**)&a->ProfileToken, "tt:ReferenceToken"))
				{	soap_flag_ProfileToken--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (!a->ProfileToken))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct _trt__GetProfile *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__trt__GetProfile, SOAP_TYPE__trt__GetProfile, sizeof(struct _trt__GetProfile), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _trt__GetProfile * SOAP_FMAC4 soap_new__trt__GetProfile(struct soap *soap, int n)
{
	struct _trt__GetProfile *p;
	struct _trt__GetProfile *a = (struct _trt__GetProfile*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _trt__GetProfile));
	for (p = a; p && n--; p++)
		soap_default__trt__GetProfile(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__trt__GetProfile(struct soap *soap, const struct _trt__GetProfile *a, const char *tag, const char *type)
{
	if (soap_out__trt__GetProfile(soap, tag ? tag : "trt:GetProfile", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _trt__GetProfile * SOAP_FMAC4 soap_get__trt__GetProfile(struct soap *soap, struct _trt__GetProfile *p, const char *tag, const char *type)
{
	if ((p = soap_in__trt__GetProfile(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__trt__CreateProfileResponse(struct soap *soap, struct _trt__CreateProfileResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->Profile = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__trt__CreateProfileResponse(struct soap *soap, const struct _trt__CreateProfileResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTott__Profile(soap, &a->Profile);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__trt__CreateProfileResponse(struct soap *soap, const char *tag, int id, const struct _trt__CreateProfileResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__trt__CreateProfileResponse), type))
		return soap->error;
	if (a->Profile)
		soap_element_result(soap, "trt:Profile");
	if (!a->Profile)
	{	if (soap_element_empty(soap, "trt:Profile", 0, NULL))
			return soap->error;
	}
	else if (soap_out_PointerTott__Profile(soap, "trt:Profile", -1, &a->Profile, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _trt__CreateProfileResponse * SOAP_FMAC4 soap_in__trt__CreateProfileResponse(struct soap *soap, const char *tag, struct _trt__CreateProfileResponse *a, const char *type)
{
	size_t soap_flag_Profile = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct _trt__CreateProfileResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__trt__CreateProfileResponse, sizeof(struct _trt__CreateProfileResponse), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__trt__CreateProfileResponse(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Profile && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__Profile(soap, "trt:Profile", &a->Profile, "tt:Profile"))
				{	soap_flag_Profile--;
					continue;
				}
			}
			soap_check_result(soap, "trt:Profile");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (!a->Profile))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct _trt__CreateProfileResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__trt__CreateProfileResponse, SOAP_TYPE__trt__CreateProfileResponse, sizeof(struct _trt__CreateProfileResponse), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _trt__CreateProfileResponse * SOAP_FMAC4 soap_new__trt__CreateProfileResponse(struct soap *soap, int n)
{
	struct _trt__CreateProfileResponse *p;
	struct _trt__CreateProfileResponse *a = (struct _trt__CreateProfileResponse*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _trt__CreateProfileResponse));
	for (p = a; p && n--; p++)
		soap_default__trt__CreateProfileResponse(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__trt__CreateProfileResponse(struct soap *soap, const struct _trt__CreateProfileResponse *a, const char *tag, const char *type)
{
	if (soap_out__trt__CreateProfileResponse(soap, tag ? tag : "trt:CreateProfileResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _trt__CreateProfileResponse * SOAP_FMAC4 soap_get__trt__CreateProfileResponse(struct soap *soap, struct _trt__CreateProfileResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__trt__CreateProfileResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__trt__CreateProfile(struct soap *soap, struct _trt__CreateProfile *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_tt__Name(soap, &a->Name);
	soap_default_tt__ReferenceToken(soap, &a->Token);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__trt__CreateProfile(struct soap *soap, const struct _trt__CreateProfile *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_tt__Name(soap, (char*const*)&a->Name);
	soap_serialize_tt__ReferenceToken(soap, (char*const*)&a->Token);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__trt__CreateProfile(struct soap *soap, const char *tag, int id, const struct _trt__CreateProfile *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__trt__CreateProfile), type))
		return soap->error;
	if (!a->Name)
	{	if (soap_element_empty(soap, "trt:Name", 0, NULL))
			return soap->error;
	}
	else if (soap_out_tt__Name(soap, "trt:Name", -1, (char*const*)&a->Name, ""))
		return soap->error;
	if (soap_out_tt__ReferenceToken(soap, "trt:Token", -1, (char*const*)&a->Token, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _trt__CreateProfile * SOAP_FMAC4 soap_in__trt__CreateProfile(struct soap *soap, const char *tag, struct _trt__CreateProfile *a, const char *type)
{
	size_t soap_flag_Name = 1;
	size_t soap_flag_Token = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct _trt__CreateProfile*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__trt__CreateProfile, sizeof(struct _trt__CreateProfile), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__trt__CreateProfile(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Name && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_tt__Name(soap, "trt:Name", (char**)&a->Name, "tt:Name"))
				{	soap_flag_Name--;
					continue;
				}
			}
			if (soap_flag_Token && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_tt__ReferenceToken(soap, "trt:Token", (char**)&a->Token, "tt:ReferenceToken"))
				{	soap_flag_Token--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (!a->Name))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct _trt__CreateProfile *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__trt__CreateProfile, SOAP_TYPE__trt__CreateProfile, sizeof(struct _trt__CreateProfile), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _trt__CreateProfile * SOAP_FMAC4 soap_new__trt__CreateProfile(struct soap *soap, int n)
{
	struct _trt__CreateProfile *p;
	struct _trt__CreateProfile *a = (struct _trt__CreateProfile*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _trt__CreateProfile));
	for (p = a; p && n--; p++)
		soap_default__trt__CreateProfile(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__trt__CreateProfile(struct soap *soap, const struct _trt__CreateProfile *a, const char *tag, const char *type)
{
	if (soap_out__trt__CreateProfile(soap, tag ? tag : "trt:CreateProfile", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _trt__CreateProfile * SOAP_FMAC4 soap_get__trt__CreateProfile(struct soap *soap, struct _trt__CreateProfile *p, const char *tag, const char *type)
{
	if ((p = soap_in__trt__CreateProfile(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__trt__GetServiceCapabilitiesResponse(struct soap *soap, struct _trt__GetServiceCapabilitiesResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->Capabilities = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__trt__GetServiceCapabilitiesResponse(struct soap *soap, const struct _trt__GetServiceCapabilitiesResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTotrt__Capabilities(soap, &a->Capabilities);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__trt__GetServiceCapabilitiesResponse(struct soap *soap, const char *tag, int id, const struct _trt__GetServiceCapabilitiesResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__trt__GetServiceCapabilitiesResponse), type))
		return soap->error;
	if (a->Capabilities)
		soap_element_result(soap, "trt:Capabilities");
	if (!a->Capabilities)
	{	if (soap_element_empty(soap, "trt:Capabilities", 0, NULL))
			return soap->error;
	}
	else if (soap_out_PointerTotrt__Capabilities(soap, "trt:Capabilities", -1, &a->Capabilities, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _trt__GetServiceCapabilitiesResponse * SOAP_FMAC4 soap_in__trt__GetServiceCapabilitiesResponse(struct soap *soap, const char *tag, struct _trt__GetServiceCapabilitiesResponse *a, const char *type)
{
	size_t soap_flag_Capabilities = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct _trt__GetServiceCapabilitiesResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__trt__GetServiceCapabilitiesResponse, sizeof(struct _trt__GetServiceCapabilitiesResponse), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__trt__GetServiceCapabilitiesResponse(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Capabilities && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTotrt__Capabilities(soap, "trt:Capabilities", &a->Capabilities, "trt:Capabilities"))
				{	soap_flag_Capabilities--;
					continue;
				}
			}
			soap_check_result(soap, "trt:Capabilities");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (!a->Capabilities))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct _trt__GetServiceCapabilitiesResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__trt__GetServiceCapabilitiesResponse, SOAP_TYPE__trt__GetServiceCapabilitiesResponse, sizeof(struct _trt__GetServiceCapabilitiesResponse), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _trt__GetServiceCapabilitiesResponse * SOAP_FMAC4 soap_new__trt__GetServiceCapabilitiesResponse(struct soap *soap, int n)
{
	struct _trt__GetServiceCapabilitiesResponse *p;
	struct _trt__GetServiceCapabilitiesResponse *a = (struct _trt__GetServiceCapabilitiesResponse*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _trt__GetServiceCapabilitiesResponse));
	for (p = a; p && n--; p++)
		soap_default__trt__GetServiceCapabilitiesResponse(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__trt__GetServiceCapabilitiesResponse(struct soap *soap, const struct _trt__GetServiceCapabilitiesResponse *a, const char *tag, const char *type)
{
	if (soap_out__trt__GetServiceCapabilitiesResponse(soap, tag ? tag : "trt:GetServiceCapabilitiesResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _trt__GetServiceCapabilitiesResponse * SOAP_FMAC4 soap_get__trt__GetServiceCapabilitiesResponse(struct soap *soap, struct _trt__GetServiceCapabilitiesResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__trt__GetServiceCapabilitiesResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__trt__GetServiceCapabilities(struct soap *soap, struct _trt__GetServiceCapabilities *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__trt__GetServiceCapabilities(struct soap *soap, const struct _trt__GetServiceCapabilities *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__trt__GetServiceCapabilities(struct soap *soap, const char *tag, int id, const struct _trt__GetServiceCapabilities *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__trt__GetServiceCapabilities), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _trt__GetServiceCapabilities * SOAP_FMAC4 soap_in__trt__GetServiceCapabilities(struct soap *soap, const char *tag, struct _trt__GetServiceCapabilities *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct _trt__GetServiceCapabilities*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__trt__GetServiceCapabilities, sizeof(struct _trt__GetServiceCapabilities), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__trt__GetServiceCapabilities(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _trt__GetServiceCapabilities *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__trt__GetServiceCapabilities, SOAP_TYPE__trt__GetServiceCapabilities, sizeof(struct _trt__GetServiceCapabilities), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _trt__GetServiceCapabilities * SOAP_FMAC4 soap_new__trt__GetServiceCapabilities(struct soap *soap, int n)
{
	struct _trt__GetServiceCapabilities *p;
	struct _trt__GetServiceCapabilities *a = (struct _trt__GetServiceCapabilities*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _trt__GetServiceCapabilities));
	for (p = a; p && n--; p++)
		soap_default__trt__GetServiceCapabilities(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__trt__GetServiceCapabilities(struct soap *soap, const struct _trt__GetServiceCapabilities *a, const char *tag, const char *type)
{
	if (soap_out__trt__GetServiceCapabilities(soap, tag ? tag : "trt:GetServiceCapabilities", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _trt__GetServiceCapabilities * SOAP_FMAC4 soap_get__trt__GetServiceCapabilities(struct soap *soap, struct _trt__GetServiceCapabilities *p, const char *tag, const char *type)
{
	if ((p = soap_in__trt__GetServiceCapabilities(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_trt__ProfileCapabilities(struct soap *soap, struct trt__ProfileCapabilities *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__size = 0;
	a->__any = NULL;
	a->MaximumNumberOfProfiles = NULL;
	a->__anyAttribute = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_trt__ProfileCapabilities(struct soap *soap, const struct trt__ProfileCapabilities *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_trt__ProfileCapabilities(struct soap *soap, const char *tag, int id, const struct trt__ProfileCapabilities *a, const char *type)
{
	if (a->MaximumNumberOfProfiles)
	{	soap_set_attr(soap, "MaximumNumberOfProfiles", soap_int2s(soap, *a->MaximumNumberOfProfiles), 1);
	}
	if (a->__anyAttribute)
		soap_set_attr(soap, "-anyAttribute", a->__anyAttribute, 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_trt__ProfileCapabilities), type))
		return soap->error;
	if (a->__any)
	{	int i;
		for (i = 0; i < (int)a->__size; i++)
			if (soap_outliteral(soap, "-any", (char*const*)(a->__any + i), NULL))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct trt__ProfileCapabilities * SOAP_FMAC4 soap_in_trt__ProfileCapabilities(struct soap *soap, const char *tag, struct trt__ProfileCapabilities *a, const char *type)
{
	struct soap_blist *soap_blist___any = NULL;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct trt__ProfileCapabilities*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_trt__ProfileCapabilities, sizeof(struct trt__ProfileCapabilities), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_trt__ProfileCapabilities(soap, a);
	{
		const char *t = soap_attr_value(soap, "MaximumNumberOfProfiles", 5, 0);
		if (t)
		{
			if (!(a->MaximumNumberOfProfiles = (int *)soap_malloc(soap, sizeof(int))))
				return NULL;
			if (soap_s2int(soap, t, a->MaximumNumberOfProfiles))
				return NULL;
		}
		else if (soap->error)
			return NULL;
	}
	if (soap_s2char(soap, soap_attr_value(soap, "-anyAttribute", 0, 0), &a->__anyAttribute, 0, 0, -1, NULL))
		return NULL;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	if (a->__any == NULL)
				{	if (soap_blist___any == NULL)
						soap_blist___any = soap_alloc_block(soap);
					a->__any = (char **)soap_push_block_max(soap, soap_blist___any, sizeof(char *));
					if (a->__any == NULL)
						return NULL;
					*a->__any = NULL;
				}
				if (soap_inliteral(soap, "-any", (char**)a->__any))
				{	a->__size++;
					a->__any = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->__any)
			soap_pop_block(soap, soap_blist___any);
		if (a->__size)
		{	a->__any = (char **)soap_save_block(soap, soap_blist___any, NULL, 1);
		}
		else
		{	a->__any = NULL;
			if (soap_blist___any)
				soap_end_block(soap, soap_blist___any);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct trt__ProfileCapabilities *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_trt__ProfileCapabilities, SOAP_TYPE_trt__ProfileCapabilities, sizeof(struct trt__ProfileCapabilities), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct trt__ProfileCapabilities * SOAP_FMAC4 soap_new_trt__ProfileCapabilities(struct soap *soap, int n)
{
	struct trt__ProfileCapabilities *p;
	struct trt__ProfileCapabilities *a = (struct trt__ProfileCapabilities*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct trt__ProfileCapabilities));
	for (p = a; p && n--; p++)
		soap_default_trt__ProfileCapabilities(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_trt__ProfileCapabilities(struct soap *soap, const struct trt__ProfileCapabilities *a, const char *tag, const char *type)
{
	if (soap_out_trt__ProfileCapabilities(soap, tag ? tag : "trt:ProfileCapabilities", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct trt__ProfileCapabilities * SOAP_FMAC4 soap_get_trt__ProfileCapabilities(struct soap *soap, struct trt__ProfileCapabilities *p, const char *tag, const char *type)
{
	if ((p = soap_in_trt__ProfileCapabilities(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_trt__Capabilities(struct soap *soap, struct trt__Capabilities *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ProfileCapabilities = NULL;
	a->__size = 0;
	a->__any = NULL;
	a->SnapshotUri = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_trt__Capabilities(struct soap *soap, const struct trt__Capabilities *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTotrt__ProfileCapabilities(soap, &a->ProfileCapabilities);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_trt__Capabilities(struct soap *soap, const char *tag, int id, const struct trt__Capabilities *a, const char *type)
{
	if (a->SnapshotUri)
	{	soap_set_attr(soap, "SnapshotUri", soap_xsd__boolean2s(soap, *a->SnapshotUri), 1);
	}
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_trt__Capabilities), type))
		return soap->error;
	if (!a->ProfileCapabilities)
	{	if (soap_element_empty(soap, "trt:ProfileCapabilities", 0, NULL))
			return soap->error;
	}
	else if (soap_out_PointerTotrt__ProfileCapabilities(soap, "trt:ProfileCapabilities", -1, &a->ProfileCapabilities, ""))
		return soap->error;
	if (a->__any)
	{	int i;
		for (i = 0; i < (int)a->__size; i++)
			if (soap_outliteral(soap, "-any", (char*const*)(a->__any + i), NULL))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct trt__Capabilities * SOAP_FMAC4 soap_in_trt__Capabilities(struct soap *soap, const char *tag, struct trt__Capabilities *a, const char *type)
{
	size_t soap_flag_ProfileCapabilities = 1;
	struct soap_blist *soap_blist___any = NULL;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct trt__Capabilities*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_trt__Capabilities, sizeof(struct trt__Capabilities), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_trt__Capabilities(soap, a);
	{
		const char *t = soap_attr_value(soap, "SnapshotUri", 5, 0);
		if (t)
		{
			if (!(a->SnapshotUri = (enum xsd__boolean *)soap_malloc(soap, sizeof(enum xsd__boolean))))
				return NULL;
			if (soap_s2xsd__boolean(soap, t, a->SnapshotUri))
				return NULL;
		}
		else if (soap->error)
			return NULL;
	}
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ProfileCapabilities && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTotrt__ProfileCapabilities(soap, "trt:ProfileCapabilities", &a->ProfileCapabilities, "trt:ProfileCapabilities"))
				{	soap_flag_ProfileCapabilities--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	if (a->__any == NULL)
				{	if (soap_blist___any == NULL)
						soap_blist___any = soap_alloc_block(soap);
					a->__any = (char **)soap_push_block_max(soap, soap_blist___any, sizeof(char *));
					if (a->__any == NULL)
						return NULL;
					*a->__any = NULL;
				}
				if (soap_inliteral(soap, "-any", (char**)a->__any))
				{	a->__size++;
					a->__any = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->__any)
			soap_pop_block(soap, soap_blist___any);
		if (a->__size)
		{	a->__any = (char **)soap_save_block(soap, soap_blist___any, NULL, 1);
		}
		else
		{	a->__any = NULL;
			if (soap_blist___any)
				soap_end_block(soap, soap_blist___any);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (!a->ProfileCapabilities))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct trt__Capabilities *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_trt__Capabilities, SOAP_TYPE_trt__Capabilities, sizeof(struct trt__Capabilities), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct trt__Capabilities * SOAP_FMAC4 soap_new_trt__Capabilities(struct soap *soap, int n)
{
	struct trt__Capabilities *p;
	struct trt__Capabilities *a = (struct trt__Capabilities*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct trt__Capabilities));
	for (p = a; p && n--; p++)
		soap_default_trt__Capabilities(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_trt__Capabilities(struct soap *soap, const struct trt__Capabilities *a, const char *tag, const char *type)
{
	if (soap_out_trt__Capabilities(soap, tag ? tag : "trt:Capabilities", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct trt__Capabilities * SOAP_FMAC4 soap_get_trt__Capabilities(struct soap *soap, struct trt__Capabilities *p, const char *tag, const char *type)
{
	if ((p = soap_in_trt__Capabilities(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_wstop__QueryExpressionType(struct soap *soap, struct wstop__QueryExpressionType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__any = NULL;
	soap_default_xsd__anyURI(soap, &a->Dialect);
	a->__mixed = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_wstop__QueryExpressionType(struct soap *soap, const struct wstop__QueryExpressionType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_wstop__QueryExpressionType(struct soap *soap, const char *tag, int id, const struct wstop__QueryExpressionType *a, const char *type)
{
	soap_set_attr(soap, "Dialect", a->Dialect ? soap_xsd__anyURI2s(soap, a->Dialect) : "", 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_wstop__QueryExpressionType), type))
		return soap->error;
	if (soap_outliteral(soap, "-any", (char*const*)&a->__any, NULL))
		return soap->error;
	if (soap_outliteral(soap, "-mixed", (char*const*)&a->__mixed, NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct wstop__QueryExpressionType * SOAP_FMAC4 soap_in_wstop__QueryExpressionType(struct soap *soap, const char *tag, struct wstop__QueryExpressionType *a, const char *type)
{
	size_t soap_flag___any = 1;
	size_t soap_flag___mixed = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct wstop__QueryExpressionType*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_wstop__QueryExpressionType, sizeof(struct wstop__QueryExpressionType), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_wstop__QueryExpressionType(soap, a);
	if (soap_s2xsd__anyURI(soap, soap_attr_value(soap, "Dialect", 4, 1), &a->Dialect))
		return NULL;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag___any && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_inliteral(soap, "-any", (char**)&a->__any))
				{	soap_flag___any--;
					continue;
				}
			}
			if (soap_flag___mixed && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_inliteral(soap, "-mixed", (char**)&a->__mixed))
				{	soap_flag___mixed--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct wstop__QueryExpressionType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_wstop__QueryExpressionType, SOAP_TYPE_wstop__QueryExpressionType, sizeof(struct wstop__QueryExpressionType), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct wstop__QueryExpressionType * SOAP_FMAC4 soap_new_wstop__QueryExpressionType(struct soap *soap, int n)
{
	struct wstop__QueryExpressionType *p;
	struct wstop__QueryExpressionType *a = (struct wstop__QueryExpressionType*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct wstop__QueryExpressionType));
	for (p = a; p && n--; p++)
		soap_default_wstop__QueryExpressionType(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_wstop__QueryExpressionType(struct soap *soap, const struct wstop__QueryExpressionType *a, const char *tag, const char *type)
{
	if (soap_out_wstop__QueryExpressionType(soap, tag ? tag : "wstop:QueryExpressionType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct wstop__QueryExpressionType * SOAP_FMAC4 soap_get_wstop__QueryExpressionType(struct soap *soap, struct wstop__QueryExpressionType *p, const char *tag, const char *type)
{
	if ((p = soap_in_wstop__QueryExpressionType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_wstop__ExtensibleDocumented(struct soap *soap, struct wstop__ExtensibleDocumented *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->documentation = NULL;
	a->__anyAttribute = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_wstop__ExtensibleDocumented(struct soap *soap, const struct wstop__ExtensibleDocumented *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTowstop__Documentation(soap, &a->documentation);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_wstop__ExtensibleDocumented(struct soap *soap, const char *tag, int id, const struct wstop__ExtensibleDocumented *a, const char *type)
{
	if (a->__anyAttribute)
		soap_set_attr(soap, "-anyAttribute", a->__anyAttribute, 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_wstop__ExtensibleDocumented), type))
		return soap->error;
	if (soap_out_PointerTowstop__Documentation(soap, "wstop:documentation", -1, &a->documentation, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct wstop__ExtensibleDocumented * SOAP_FMAC4 soap_in_wstop__ExtensibleDocumented(struct soap *soap, const char *tag, struct wstop__ExtensibleDocumented *a, const char *type)
{
	size_t soap_flag_documentation = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct wstop__ExtensibleDocumented*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_wstop__ExtensibleDocumented, sizeof(struct wstop__ExtensibleDocumented), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_wstop__ExtensibleDocumented(soap, a);
	if (soap_s2char(soap, soap_attr_value(soap, "-anyAttribute", 0, 0), &a->__anyAttribute, 0, 0, -1, NULL))
		return NULL;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_documentation && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTowstop__Documentation(soap, "wstop:documentation", &a->documentation, "wstop:Documentation"))
				{	soap_flag_documentation--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct wstop__ExtensibleDocumented *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_wstop__ExtensibleDocumented, SOAP_TYPE_wstop__ExtensibleDocumented, sizeof(struct wstop__ExtensibleDocumented), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct wstop__ExtensibleDocumented * SOAP_FMAC4 soap_new_wstop__ExtensibleDocumented(struct soap *soap, int n)
{
	struct wstop__ExtensibleDocumented *p;
	struct wstop__ExtensibleDocumented *a = (struct wstop__ExtensibleDocumented*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct wstop__ExtensibleDocumented));
	for (p = a; p && n--; p++)
		soap_default_wstop__ExtensibleDocumented(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_wstop__ExtensibleDocumented(struct soap *soap, const struct wstop__ExtensibleDocumented *a, const char *tag, const char *type)
{
	if (soap_out_wstop__ExtensibleDocumented(soap, tag ? tag : "wstop:ExtensibleDocumented", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct wstop__ExtensibleDocumented * SOAP_FMAC4 soap_get_wstop__ExtensibleDocumented(struct soap *soap, struct wstop__ExtensibleDocumented *p, const char *tag, const char *type)
{
	if ((p = soap_in_wstop__ExtensibleDocumented(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_wstop__Documentation(struct soap *soap, struct wstop__Documentation *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__size = 0;
	a->__any = NULL;
	a->__mixed = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_wstop__Documentation(struct soap *soap, const struct wstop__Documentation *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_wstop__Documentation(struct soap *soap, const char *tag, int id, const struct wstop__Documentation *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_wstop__Documentation), type))
		return soap->error;
	if (a->__any)
	{	int i;
		for (i = 0; i < (int)a->__size; i++)
			if (soap_outliteral(soap, "-any", (char*const*)(a->__any + i), NULL))
				return soap->error;
	}
	if (soap_outliteral(soap, "-mixed", (char*const*)&a->__mixed, NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct wstop__Documentation * SOAP_FMAC4 soap_in_wstop__Documentation(struct soap *soap, const char *tag, struct wstop__Documentation *a, const char *type)
{
	struct soap_blist *soap_blist___any = NULL;
	size_t soap_flag___mixed = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct wstop__Documentation*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_wstop__Documentation, sizeof(struct wstop__Documentation), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_wstop__Documentation(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	if (a->__any == NULL)
				{	if (soap_blist___any == NULL)
						soap_blist___any = soap_alloc_block(soap);
					a->__any = (char **)soap_push_block_max(soap, soap_blist___any, sizeof(char *));
					if (a->__any == NULL)
						return NULL;
					*a->__any = NULL;
				}
				if (soap_inliteral(soap, "-any", (char**)a->__any))
				{	a->__size++;
					a->__any = NULL;
					continue;
				}
			}
			if (soap_flag___mixed && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_inliteral(soap, "-mixed", (char**)&a->__mixed))
				{	soap_flag___mixed--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->__any)
			soap_pop_block(soap, soap_blist___any);
		if (a->__size)
		{	a->__any = (char **)soap_save_block(soap, soap_blist___any, NULL, 1);
		}
		else
		{	a->__any = NULL;
			if (soap_blist___any)
				soap_end_block(soap, soap_blist___any);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct wstop__Documentation *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_wstop__Documentation, SOAP_TYPE_wstop__Documentation, sizeof(struct wstop__Documentation), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct wstop__Documentation * SOAP_FMAC4 soap_new_wstop__Documentation(struct soap *soap, int n)
{
	struct wstop__Documentation *p;
	struct wstop__Documentation *a = (struct wstop__Documentation*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct wstop__Documentation));
	for (p = a; p && n--; p++)
		soap_default_wstop__Documentation(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_wstop__Documentation(struct soap *soap, const struct wstop__Documentation *a, const char *tag, const char *type)
{
	if (soap_out_wstop__Documentation(soap, tag ? tag : "wstop:Documentation", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct wstop__Documentation * SOAP_FMAC4 soap_get_wstop__Documentation(struct soap *soap, struct wstop__Documentation *p, const char *tag, const char *type)
{
	if ((p = soap_in_wstop__Documentation(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__wsrfbf__BaseFaultType_FaultCause(struct soap *soap, struct _wsrfbf__BaseFaultType_FaultCause *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__any = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__wsrfbf__BaseFaultType_FaultCause(struct soap *soap, const struct _wsrfbf__BaseFaultType_FaultCause *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__wsrfbf__BaseFaultType_FaultCause(struct soap *soap, const char *tag, int id, const struct _wsrfbf__BaseFaultType_FaultCause *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__wsrfbf__BaseFaultType_FaultCause), type))
		return soap->error;
	if (soap_outliteral(soap, "-any", (char*const*)&a->__any, NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _wsrfbf__BaseFaultType_FaultCause * SOAP_FMAC4 soap_in__wsrfbf__BaseFaultType_FaultCause(struct soap *soap, const char *tag, struct _wsrfbf__BaseFaultType_FaultCause *a, const char *type)
{
	size_t soap_flag___any = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct _wsrfbf__BaseFaultType_FaultCause*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__wsrfbf__BaseFaultType_FaultCause, sizeof(struct _wsrfbf__BaseFaultType_FaultCause), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__wsrfbf__BaseFaultType_FaultCause(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag___any && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_inliteral(soap, "-any", (char**)&a->__any))
				{	soap_flag___any--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _wsrfbf__BaseFaultType_FaultCause *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__wsrfbf__BaseFaultType_FaultCause, SOAP_TYPE__wsrfbf__BaseFaultType_FaultCause, sizeof(struct _wsrfbf__BaseFaultType_FaultCause), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _wsrfbf__BaseFaultType_FaultCause * SOAP_FMAC4 soap_new__wsrfbf__BaseFaultType_FaultCause(struct soap *soap, int n)
{
	struct _wsrfbf__BaseFaultType_FaultCause *p;
	struct _wsrfbf__BaseFaultType_FaultCause *a = (struct _wsrfbf__BaseFaultType_FaultCause*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _wsrfbf__BaseFaultType_FaultCause));
	for (p = a; p && n--; p++)
		soap_default__wsrfbf__BaseFaultType_FaultCause(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__wsrfbf__BaseFaultType_FaultCause(struct soap *soap, const struct _wsrfbf__BaseFaultType_FaultCause *a, const char *tag, const char *type)
{
	if (soap_out__wsrfbf__BaseFaultType_FaultCause(soap, tag ? tag : "wsrfbf:BaseFaultType-FaultCause", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _wsrfbf__BaseFaultType_FaultCause * SOAP_FMAC4 soap_get__wsrfbf__BaseFaultType_FaultCause(struct soap *soap, struct _wsrfbf__BaseFaultType_FaultCause *p, const char *tag, const char *type)
{
	if ((p = soap_in__wsrfbf__BaseFaultType_FaultCause(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__wsrfbf__BaseFaultType_Description(struct soap *soap, struct _wsrfbf__BaseFaultType_Description *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->__item);
	soap_default__xml__lang(soap, &a->xml__lang);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__wsrfbf__BaseFaultType_Description(struct soap *soap, const struct _wsrfbf__BaseFaultType_Description *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_string(soap, (char*const*)&a->__item);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__wsrfbf__BaseFaultType_Description(struct soap *soap, const char *tag, int id, const struct _wsrfbf__BaseFaultType_Description *a, const char *type)
{
	if (a->xml__lang)
		soap_set_attr(soap, "xml:lang", soap__xml__lang2s(soap, a->xml__lang), 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	return soap_out_string(soap, tag, id, (char*const*)&a->__item, "");
}

SOAP_FMAC3 struct _wsrfbf__BaseFaultType_Description * SOAP_FMAC4 soap_in__wsrfbf__BaseFaultType_Description(struct soap *soap, const char *tag, struct _wsrfbf__BaseFaultType_Description *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	if (!(a = (struct _wsrfbf__BaseFaultType_Description *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__wsrfbf__BaseFaultType_Description, sizeof(struct _wsrfbf__BaseFaultType_Description), NULL, NULL, NULL, NULL)))
		return NULL;
	soap_revert(soap);
	*soap->id = '\0';
	soap_default__wsrfbf__BaseFaultType_Description(soap, a);
	if (soap_s2_xml__lang(soap, soap_attr_value(soap, "xml:lang", 1, 0), &a->xml__lang))
		return NULL;
	if (!soap_in_string(soap, tag, (char**)&a->__item, ""))
		return NULL;
	return a;
}

SOAP_FMAC3 struct _wsrfbf__BaseFaultType_Description * SOAP_FMAC4 soap_new__wsrfbf__BaseFaultType_Description(struct soap *soap, int n)
{
	struct _wsrfbf__BaseFaultType_Description *p;
	struct _wsrfbf__BaseFaultType_Description *a = (struct _wsrfbf__BaseFaultType_Description*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _wsrfbf__BaseFaultType_Description));
	for (p = a; p && n--; p++)
		soap_default__wsrfbf__BaseFaultType_Description(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__wsrfbf__BaseFaultType_Description(struct soap *soap, const struct _wsrfbf__BaseFaultType_Description *a, const char *tag, const char *type)
{
	if (soap_out__wsrfbf__BaseFaultType_Description(soap, tag ? tag : "wsrfbf:BaseFaultType-Description", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _wsrfbf__BaseFaultType_Description * SOAP_FMAC4 soap_get__wsrfbf__BaseFaultType_Description(struct soap *soap, struct _wsrfbf__BaseFaultType_Description *p, const char *tag, const char *type)
{
	if ((p = soap_in__wsrfbf__BaseFaultType_Description(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__wsrfbf__BaseFaultType_ErrorCode(struct soap *soap, struct _wsrfbf__BaseFaultType_ErrorCode *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_xsd__anyURI(soap, &a->dialect);
	a->__mixed = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__wsrfbf__BaseFaultType_ErrorCode(struct soap *soap, const struct _wsrfbf__BaseFaultType_ErrorCode *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__wsrfbf__BaseFaultType_ErrorCode(struct soap *soap, const char *tag, int id, const struct _wsrfbf__BaseFaultType_ErrorCode *a, const char *type)
{
	soap_set_attr(soap, "dialect", a->dialect ? soap_xsd__anyURI2s(soap, a->dialect) : "", 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__wsrfbf__BaseFaultType_ErrorCode), type))
		return soap->error;
	if (soap_outliteral(soap, "-mixed", (char*const*)&a->__mixed, NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _wsrfbf__BaseFaultType_ErrorCode * SOAP_FMAC4 soap_in__wsrfbf__BaseFaultType_ErrorCode(struct soap *soap, const char *tag, struct _wsrfbf__BaseFaultType_ErrorCode *a, const char *type)
{
	size_t soap_flag___mixed = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct _wsrfbf__BaseFaultType_ErrorCode*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__wsrfbf__BaseFaultType_ErrorCode, sizeof(struct _wsrfbf__BaseFaultType_ErrorCode), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__wsrfbf__BaseFaultType_ErrorCode(soap, a);
	if (soap_s2xsd__anyURI(soap, soap_attr_value(soap, "dialect", 4, 1), &a->dialect))
		return NULL;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag___mixed && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_inliteral(soap, "-mixed", (char**)&a->__mixed))
				{	soap_flag___mixed--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _wsrfbf__BaseFaultType_ErrorCode *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__wsrfbf__BaseFaultType_ErrorCode, SOAP_TYPE__wsrfbf__BaseFaultType_ErrorCode, sizeof(struct _wsrfbf__BaseFaultType_ErrorCode), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _wsrfbf__BaseFaultType_ErrorCode * SOAP_FMAC4 soap_new__wsrfbf__BaseFaultType_ErrorCode(struct soap *soap, int n)
{
	struct _wsrfbf__BaseFaultType_ErrorCode *p;
	struct _wsrfbf__BaseFaultType_ErrorCode *a = (struct _wsrfbf__BaseFaultType_ErrorCode*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _wsrfbf__BaseFaultType_ErrorCode));
	for (p = a; p && n--; p++)
		soap_default__wsrfbf__BaseFaultType_ErrorCode(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__wsrfbf__BaseFaultType_ErrorCode(struct soap *soap, const struct _wsrfbf__BaseFaultType_ErrorCode *a, const char *tag, const char *type)
{
	if (soap_out__wsrfbf__BaseFaultType_ErrorCode(soap, tag ? tag : "wsrfbf:BaseFaultType-ErrorCode", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _wsrfbf__BaseFaultType_ErrorCode * SOAP_FMAC4 soap_get__wsrfbf__BaseFaultType_ErrorCode(struct soap *soap, struct _wsrfbf__BaseFaultType_ErrorCode *p, const char *tag, const char *type)
{
	if ((p = soap_in__wsrfbf__BaseFaultType_ErrorCode(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_wsrfbf__BaseFaultType(struct soap *soap, struct wsrfbf__BaseFaultType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__size = 0;
	a->__any = NULL;
	soap_default_dateTime(soap, &a->Timestamp);
	a->Originator = NULL;
	a->ErrorCode = NULL;
	a->__sizeDescription = 0;
	a->Description = NULL;
	a->FaultCause = NULL;
	a->__anyAttribute = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_wsrfbf__BaseFaultType(struct soap *soap, const struct wsrfbf__BaseFaultType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &a->Timestamp, SOAP_TYPE_dateTime);
	soap_serialize_PointerTowsa5__EndpointReferenceType(soap, &a->Originator);
	soap_serialize_PointerTo_wsrfbf__BaseFaultType_ErrorCode(soap, &a->ErrorCode);
	if (a->Description)
	{	int i;
		for (i = 0; i < (int)a->__sizeDescription; i++)
		{
			soap_embedded(soap, a->Description + i, SOAP_TYPE__wsrfbf__BaseFaultType_Description);
			soap_serialize__wsrfbf__BaseFaultType_Description(soap, a->Description + i);
		}
	}
	soap_serialize_PointerTo_wsrfbf__BaseFaultType_FaultCause(soap, &a->FaultCause);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_wsrfbf__BaseFaultType(struct soap *soap, const char *tag, int id, const struct wsrfbf__BaseFaultType *a, const char *type)
{
	if (a->__anyAttribute)
		soap_set_attr(soap, "-anyAttribute", a->__anyAttribute, 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_wsrfbf__BaseFaultType), type))
		return soap->error;
	if (a->__any)
	{	int i;
		for (i = 0; i < (int)a->__size; i++)
			if (soap_outliteral(soap, "-any", (char*const*)(a->__any + i), NULL))
				return soap->error;
	}
	if (soap_out_dateTime(soap, "wsrfbf:Timestamp", -1, &a->Timestamp, ""))
		return soap->error;
	if (soap_out_PointerTowsa5__EndpointReferenceType(soap, "wsrfbf:Originator", -1, &a->Originator, ""))
		return soap->error;
	if (soap_out_PointerTo_wsrfbf__BaseFaultType_ErrorCode(soap, "wsrfbf:ErrorCode", -1, &a->ErrorCode, ""))
		return soap->error;
	if (a->Description)
	{	int i;
		for (i = 0; i < (int)a->__sizeDescription; i++)
			if (soap_out__wsrfbf__BaseFaultType_Description(soap, "wsrfbf:Description", -1, a->Description + i, ""))
				return soap->error;
	}
	if (soap_out_PointerTo_wsrfbf__BaseFaultType_FaultCause(soap, "wsrfbf:FaultCause", -1, &a->FaultCause, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct wsrfbf__BaseFaultType * SOAP_FMAC4 soap_in_wsrfbf__BaseFaultType(struct soap *soap, const char *tag, struct wsrfbf__BaseFaultType *a, const char *type)
{
	struct soap_blist *soap_blist___any = NULL;
	size_t soap_flag_Timestamp = 1;
	size_t soap_flag_Originator = 1;
	size_t soap_flag_ErrorCode = 1;
	struct soap_blist *soap_blist_Description = NULL;
	size_t soap_flag_FaultCause = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct wsrfbf__BaseFaultType*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_wsrfbf__BaseFaultType, sizeof(struct wsrfbf__BaseFaultType), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_wsrfbf__BaseFaultType(soap, a);
	if (soap_s2char(soap, soap_attr_value(soap, "-anyAttribute", 0, 0), &a->__anyAttribute, 0, 0, -1, NULL))
		return NULL;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Timestamp && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_dateTime(soap, "wsrfbf:Timestamp", &a->Timestamp, "xsd:dateTime"))
				{	soap_flag_Timestamp--;
					continue;
				}
			}
			if (soap_flag_Originator && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTowsa5__EndpointReferenceType(soap, "wsrfbf:Originator", &a->Originator, "wsa5:EndpointReferenceType"))
				{	soap_flag_Originator--;
					continue;
				}
			}
			if (soap_flag_ErrorCode && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_wsrfbf__BaseFaultType_ErrorCode(soap, "wsrfbf:ErrorCode", &a->ErrorCode, ""))
				{	soap_flag_ErrorCode--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "wsrfbf:Description", 1, NULL))
			{	if (a->Description == NULL)
				{	if (soap_blist_Description == NULL)
						soap_blist_Description = soap_alloc_block(soap);
					a->Description = (struct _wsrfbf__BaseFaultType_Description *)soap_push_block_max(soap, soap_blist_Description, sizeof(struct _wsrfbf__BaseFaultType_Description));
					if (a->Description == NULL)
						return NULL;
					soap_default__wsrfbf__BaseFaultType_Description(soap, a->Description);
				}
				soap_revert(soap);
				if (soap_in__wsrfbf__BaseFaultType_Description(soap, "wsrfbf:Description", a->Description, ""))
				{	a->__sizeDescription++;
					a->Description = NULL;
					continue;
				}
			}
			if (soap_flag_FaultCause && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_wsrfbf__BaseFaultType_FaultCause(soap, "wsrfbf:FaultCause", &a->FaultCause, ""))
				{	soap_flag_FaultCause--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	if (a->__any == NULL)
				{	if (soap_blist___any == NULL)
						soap_blist___any = soap_alloc_block(soap);
					a->__any = (char **)soap_push_block_max(soap, soap_blist___any, sizeof(char *));
					if (a->__any == NULL)
						return NULL;
					*a->__any = NULL;
				}
				if (soap_inliteral(soap, "-any", (char**)a->__any))
				{	a->__size++;
					a->__any = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->__any)
			soap_pop_block(soap, soap_blist___any);
		if (a->__size)
		{	a->__any = (char **)soap_save_block(soap, soap_blist___any, NULL, 1);
		}
		else
		{	a->__any = NULL;
			if (soap_blist___any)
				soap_end_block(soap, soap_blist___any);
		}
		if (a->Description)
			soap_pop_block(soap, soap_blist_Description);
		if (a->__sizeDescription)
		{	a->Description = (struct _wsrfbf__BaseFaultType_Description *)soap_save_block(soap, soap_blist_Description, NULL, 1);
		}
		else
		{	a->Description = NULL;
			if (soap_blist_Description)
				soap_end_block(soap, soap_blist_Description);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Timestamp > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct wsrfbf__BaseFaultType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_wsrfbf__BaseFaultType, SOAP_TYPE_wsrfbf__BaseFaultType, sizeof(struct wsrfbf__BaseFaultType), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct wsrfbf__BaseFaultType * SOAP_FMAC4 soap_new_wsrfbf__BaseFaultType(struct soap *soap, int n)
{
	struct wsrfbf__BaseFaultType *p;
	struct wsrfbf__BaseFaultType *a = (struct wsrfbf__BaseFaultType*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct wsrfbf__BaseFaultType));
	for (p = a; p && n--; p++)
		soap_default_wsrfbf__BaseFaultType(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_wsrfbf__BaseFaultType(struct soap *soap, const struct wsrfbf__BaseFaultType *a, const char *tag, const char *type)
{
	if (soap_out_wsrfbf__BaseFaultType(soap, tag ? tag : "wsrfbf:BaseFaultType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct wsrfbf__BaseFaultType * SOAP_FMAC4 soap_get_wsrfbf__BaseFaultType(struct soap *soap, struct wsrfbf__BaseFaultType *p, const char *tag, const char *type)
{
	if ((p = soap_in_wsrfbf__BaseFaultType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__wsnt__ResumeSubscriptionResponse(struct soap *soap, struct _wsnt__ResumeSubscriptionResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__size = 0;
	a->__any = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__wsnt__ResumeSubscriptionResponse(struct soap *soap, const struct _wsnt__ResumeSubscriptionResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__wsnt__ResumeSubscriptionResponse(struct soap *soap, const char *tag, int id, const struct _wsnt__ResumeSubscriptionResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__wsnt__ResumeSubscriptionResponse), type))
		return soap->error;
	if (a->__any)
	{	int i;
		for (i = 0; i < (int)a->__size; i++)
			if (soap_outliteral(soap, "-any", (char*const*)(a->__any + i), NULL))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _wsnt__ResumeSubscriptionResponse * SOAP_FMAC4 soap_in__wsnt__ResumeSubscriptionResponse(struct soap *soap, const char *tag, struct _wsnt__ResumeSubscriptionResponse *a, const char *type)
{
	struct soap_blist *soap_blist___any = NULL;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct _wsnt__ResumeSubscriptionResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__wsnt__ResumeSubscriptionResponse, sizeof(struct _wsnt__ResumeSubscriptionResponse), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__wsnt__ResumeSubscriptionResponse(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	if (a->__any == NULL)
				{	if (soap_blist___any == NULL)
						soap_blist___any = soap_alloc_block(soap);
					a->__any = (char **)soap_push_block_max(soap, soap_blist___any, sizeof(char *));
					if (a->__any == NULL)
						return NULL;
					*a->__any = NULL;
				}
				if (soap_inliteral(soap, "-any", (char**)a->__any))
				{	a->__size++;
					a->__any = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->__any)
			soap_pop_block(soap, soap_blist___any);
		if (a->__size)
		{	a->__any = (char **)soap_save_block(soap, soap_blist___any, NULL, 1);
		}
		else
		{	a->__any = NULL;
			if (soap_blist___any)
				soap_end_block(soap, soap_blist___any);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _wsnt__ResumeSubscriptionResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__wsnt__ResumeSubscriptionResponse, SOAP_TYPE__wsnt__ResumeSubscriptionResponse, sizeof(struct _wsnt__ResumeSubscriptionResponse), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _wsnt__ResumeSubscriptionResponse * SOAP_FMAC4 soap_new__wsnt__ResumeSubscriptionResponse(struct soap *soap, int n)
{
	struct _wsnt__ResumeSubscriptionResponse *p;
	struct _wsnt__ResumeSubscriptionResponse *a = (struct _wsnt__ResumeSubscriptionResponse*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _wsnt__ResumeSubscriptionResponse));
	for (p = a; p && n--; p++)
		soap_default__wsnt__ResumeSubscriptionResponse(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__wsnt__ResumeSubscriptionResponse(struct soap *soap, const struct _wsnt__ResumeSubscriptionResponse *a, const char *tag, const char *type)
{
	if (soap_out__wsnt__ResumeSubscriptionResponse(soap, tag ? tag : "wsnt:ResumeSubscriptionResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _wsnt__ResumeSubscriptionResponse * SOAP_FMAC4 soap_get__wsnt__ResumeSubscriptionResponse(struct soap *soap, struct _wsnt__ResumeSubscriptionResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__wsnt__ResumeSubscriptionResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__wsnt__ResumeSubscription(struct soap *soap, struct _wsnt__ResumeSubscription *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__size = 0;
	a->__any = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__wsnt__ResumeSubscription(struct soap *soap, const struct _wsnt__ResumeSubscription *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__wsnt__ResumeSubscription(struct soap *soap, const char *tag, int id, const struct _wsnt__ResumeSubscription *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__wsnt__ResumeSubscription), type))
		return soap->error;
	if (a->__any)
	{	int i;
		for (i = 0; i < (int)a->__size; i++)
			if (soap_outliteral(soap, "-any", (char*const*)(a->__any + i), NULL))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _wsnt__ResumeSubscription * SOAP_FMAC4 soap_in__wsnt__ResumeSubscription(struct soap *soap, const char *tag, struct _wsnt__ResumeSubscription *a, const char *type)
{
	struct soap_blist *soap_blist___any = NULL;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct _wsnt__ResumeSubscription*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__wsnt__ResumeSubscription, sizeof(struct _wsnt__ResumeSubscription), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__wsnt__ResumeSubscription(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	if (a->__any == NULL)
				{	if (soap_blist___any == NULL)
						soap_blist___any = soap_alloc_block(soap);
					a->__any = (char **)soap_push_block_max(soap, soap_blist___any, sizeof(char *));
					if (a->__any == NULL)
						return NULL;
					*a->__any = NULL;
				}
				if (soap_inliteral(soap, "-any", (char**)a->__any))
				{	a->__size++;
					a->__any = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->__any)
			soap_pop_block(soap, soap_blist___any);
		if (a->__size)
		{	a->__any = (char **)soap_save_block(soap, soap_blist___any, NULL, 1);
		}
		else
		{	a->__any = NULL;
			if (soap_blist___any)
				soap_end_block(soap, soap_blist___any);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _wsnt__ResumeSubscription *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__wsnt__ResumeSubscription, SOAP_TYPE__wsnt__ResumeSubscription, sizeof(struct _wsnt__ResumeSubscription), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _wsnt__ResumeSubscription * SOAP_FMAC4 soap_new__wsnt__ResumeSubscription(struct soap *soap, int n)
{
	struct _wsnt__ResumeSubscription *p;
	struct _wsnt__ResumeSubscription *a = (struct _wsnt__ResumeSubscription*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _wsnt__ResumeSubscription));
	for (p = a; p && n--; p++)
		soap_default__wsnt__ResumeSubscription(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__wsnt__ResumeSubscription(struct soap *soap, const struct _wsnt__ResumeSubscription *a, const char *tag, const char *type)
{
	if (soap_out__wsnt__ResumeSubscription(soap, tag ? tag : "wsnt:ResumeSubscription", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _wsnt__ResumeSubscription * SOAP_FMAC4 soap_get__wsnt__ResumeSubscription(struct soap *soap, struct _wsnt__ResumeSubscription *p, const char *tag, const char *type)
{
	if ((p = soap_in__wsnt__ResumeSubscription(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__wsnt__PauseSubscriptionResponse(struct soap *soap, struct _wsnt__PauseSubscriptionResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__size = 0;
	a->__any = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__wsnt__PauseSubscriptionResponse(struct soap *soap, const struct _wsnt__PauseSubscriptionResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__wsnt__PauseSubscriptionResponse(struct soap *soap, const char *tag, int id, const struct _wsnt__PauseSubscriptionResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__wsnt__PauseSubscriptionResponse), type))
		return soap->error;
	if (a->__any)
	{	int i;
		for (i = 0; i < (int)a->__size; i++)
			if (soap_outliteral(soap, "-any", (char*const*)(a->__any + i), NULL))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _wsnt__PauseSubscriptionResponse * SOAP_FMAC4 soap_in__wsnt__PauseSubscriptionResponse(struct soap *soap, const char *tag, struct _wsnt__PauseSubscriptionResponse *a, const char *type)
{
	struct soap_blist *soap_blist___any = NULL;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct _wsnt__PauseSubscriptionResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__wsnt__PauseSubscriptionResponse, sizeof(struct _wsnt__PauseSubscriptionResponse), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__wsnt__PauseSubscriptionResponse(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	if (a->__any == NULL)
				{	if (soap_blist___any == NULL)
						soap_blist___any = soap_alloc_block(soap);
					a->__any = (char **)soap_push_block_max(soap, soap_blist___any, sizeof(char *));
					if (a->__any == NULL)
						return NULL;
					*a->__any = NULL;
				}
				if (soap_inliteral(soap, "-any", (char**)a->__any))
				{	a->__size++;
					a->__any = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->__any)
			soap_pop_block(soap, soap_blist___any);
		if (a->__size)
		{	a->__any = (char **)soap_save_block(soap, soap_blist___any, NULL, 1);
		}
		else
		{	a->__any = NULL;
			if (soap_blist___any)
				soap_end_block(soap, soap_blist___any);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _wsnt__PauseSubscriptionResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__wsnt__PauseSubscriptionResponse, SOAP_TYPE__wsnt__PauseSubscriptionResponse, sizeof(struct _wsnt__PauseSubscriptionResponse), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _wsnt__PauseSubscriptionResponse * SOAP_FMAC4 soap_new__wsnt__PauseSubscriptionResponse(struct soap *soap, int n)
{
	struct _wsnt__PauseSubscriptionResponse *p;
	struct _wsnt__PauseSubscriptionResponse *a = (struct _wsnt__PauseSubscriptionResponse*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _wsnt__PauseSubscriptionResponse));
	for (p = a; p && n--; p++)
		soap_default__wsnt__PauseSubscriptionResponse(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__wsnt__PauseSubscriptionResponse(struct soap *soap, const struct _wsnt__PauseSubscriptionResponse *a, const char *tag, const char *type)
{
	if (soap_out__wsnt__PauseSubscriptionResponse(soap, tag ? tag : "wsnt:PauseSubscriptionResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _wsnt__PauseSubscriptionResponse * SOAP_FMAC4 soap_get__wsnt__PauseSubscriptionResponse(struct soap *soap, struct _wsnt__PauseSubscriptionResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__wsnt__PauseSubscriptionResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__wsnt__PauseSubscription(struct soap *soap, struct _wsnt__PauseSubscription *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__size = 0;
	a->__any = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__wsnt__PauseSubscription(struct soap *soap, const struct _wsnt__PauseSubscription *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__wsnt__PauseSubscription(struct soap *soap, const char *tag, int id, const struct _wsnt__PauseSubscription *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__wsnt__PauseSubscription), type))
		return soap->error;
	if (a->__any)
	{	int i;
		for (i = 0; i < (int)a->__size; i++)
			if (soap_outliteral(soap, "-any", (char*const*)(a->__any + i), NULL))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _wsnt__PauseSubscription * SOAP_FMAC4 soap_in__wsnt__PauseSubscription(struct soap *soap, const char *tag, struct _wsnt__PauseSubscription *a, const char *type)
{
	struct soap_blist *soap_blist___any = NULL;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct _wsnt__PauseSubscription*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__wsnt__PauseSubscription, sizeof(struct _wsnt__PauseSubscription), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__wsnt__PauseSubscription(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	if (a->__any == NULL)
				{	if (soap_blist___any == NULL)
						soap_blist___any = soap_alloc_block(soap);
					a->__any = (char **)soap_push_block_max(soap, soap_blist___any, sizeof(char *));
					if (a->__any == NULL)
						return NULL;
					*a->__any = NULL;
				}
				if (soap_inliteral(soap, "-any", (char**)a->__any))
				{	a->__size++;
					a->__any = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->__any)
			soap_pop_block(soap, soap_blist___any);
		if (a->__size)
		{	a->__any = (char **)soap_save_block(soap, soap_blist___any, NULL, 1);
		}
		else
		{	a->__any = NULL;
			if (soap_blist___any)
				soap_end_block(soap, soap_blist___any);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _wsnt__PauseSubscription *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__wsnt__PauseSubscription, SOAP_TYPE__wsnt__PauseSubscription, sizeof(struct _wsnt__PauseSubscription), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _wsnt__PauseSubscription * SOAP_FMAC4 soap_new__wsnt__PauseSubscription(struct soap *soap, int n)
{
	struct _wsnt__PauseSubscription *p;
	struct _wsnt__PauseSubscription *a = (struct _wsnt__PauseSubscription*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _wsnt__PauseSubscription));
	for (p = a; p && n--; p++)
		soap_default__wsnt__PauseSubscription(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__wsnt__PauseSubscription(struct soap *soap, const struct _wsnt__PauseSubscription *a, const char *tag, const char *type)
{
	if (soap_out__wsnt__PauseSubscription(soap, tag ? tag : "wsnt:PauseSubscription", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _wsnt__PauseSubscription * SOAP_FMAC4 soap_get__wsnt__PauseSubscription(struct soap *soap, struct _wsnt__PauseSubscription *p, const char *tag, const char *type)
{
	if ((p = soap_in__wsnt__PauseSubscription(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__wsnt__UnsubscribeResponse(struct soap *soap, struct _wsnt__UnsubscribeResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__size = 0;
	a->__any = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__wsnt__UnsubscribeResponse(struct soap *soap, const struct _wsnt__UnsubscribeResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__wsnt__UnsubscribeResponse(struct soap *soap, const char *tag, int id, const struct _wsnt__UnsubscribeResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__wsnt__UnsubscribeResponse), type))
		return soap->error;
	if (a->__any)
	{	int i;
		for (i = 0; i < (int)a->__size; i++)
			if (soap_outliteral(soap, "-any", (char*const*)(a->__any + i), NULL))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _wsnt__UnsubscribeResponse * SOAP_FMAC4 soap_in__wsnt__UnsubscribeResponse(struct soap *soap, const char *tag, struct _wsnt__UnsubscribeResponse *a, const char *type)
{
	struct soap_blist *soap_blist___any = NULL;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct _wsnt__UnsubscribeResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__wsnt__UnsubscribeResponse, sizeof(struct _wsnt__UnsubscribeResponse), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__wsnt__UnsubscribeResponse(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	if (a->__any == NULL)
				{	if (soap_blist___any == NULL)
						soap_blist___any = soap_alloc_block(soap);
					a->__any = (char **)soap_push_block_max(soap, soap_blist___any, sizeof(char *));
					if (a->__any == NULL)
						return NULL;
					*a->__any = NULL;
				}
				if (soap_inliteral(soap, "-any", (char**)a->__any))
				{	a->__size++;
					a->__any = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->__any)
			soap_pop_block(soap, soap_blist___any);
		if (a->__size)
		{	a->__any = (char **)soap_save_block(soap, soap_blist___any, NULL, 1);
		}
		else
		{	a->__any = NULL;
			if (soap_blist___any)
				soap_end_block(soap, soap_blist___any);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _wsnt__UnsubscribeResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__wsnt__UnsubscribeResponse, SOAP_TYPE__wsnt__UnsubscribeResponse, sizeof(struct _wsnt__UnsubscribeResponse), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _wsnt__UnsubscribeResponse * SOAP_FMAC4 soap_new__wsnt__UnsubscribeResponse(struct soap *soap, int n)
{
	struct _wsnt__UnsubscribeResponse *p;
	struct _wsnt__UnsubscribeResponse *a = (struct _wsnt__UnsubscribeResponse*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _wsnt__UnsubscribeResponse));
	for (p = a; p && n--; p++)
		soap_default__wsnt__UnsubscribeResponse(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__wsnt__UnsubscribeResponse(struct soap *soap, const struct _wsnt__UnsubscribeResponse *a, const char *tag, const char *type)
{
	if (soap_out__wsnt__UnsubscribeResponse(soap, tag ? tag : "wsnt:UnsubscribeResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _wsnt__UnsubscribeResponse * SOAP_FMAC4 soap_get__wsnt__UnsubscribeResponse(struct soap *soap, struct _wsnt__UnsubscribeResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__wsnt__UnsubscribeResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__wsnt__Unsubscribe(struct soap *soap, struct _wsnt__Unsubscribe *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__size = 0;
	a->__any = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__wsnt__Unsubscribe(struct soap *soap, const struct _wsnt__Unsubscribe *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__wsnt__Unsubscribe(struct soap *soap, const char *tag, int id, const struct _wsnt__Unsubscribe *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__wsnt__Unsubscribe), type))
		return soap->error;
	if (a->__any)
	{	int i;
		for (i = 0; i < (int)a->__size; i++)
			if (soap_outliteral(soap, "-any", (char*const*)(a->__any + i), NULL))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _wsnt__Unsubscribe * SOAP_FMAC4 soap_in__wsnt__Unsubscribe(struct soap *soap, const char *tag, struct _wsnt__Unsubscribe *a, const char *type)
{
	struct soap_blist *soap_blist___any = NULL;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct _wsnt__Unsubscribe*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__wsnt__Unsubscribe, sizeof(struct _wsnt__Unsubscribe), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__wsnt__Unsubscribe(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	if (a->__any == NULL)
				{	if (soap_blist___any == NULL)
						soap_blist___any = soap_alloc_block(soap);
					a->__any = (char **)soap_push_block_max(soap, soap_blist___any, sizeof(char *));
					if (a->__any == NULL)
						return NULL;
					*a->__any = NULL;
				}
				if (soap_inliteral(soap, "-any", (char**)a->__any))
				{	a->__size++;
					a->__any = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->__any)
			soap_pop_block(soap, soap_blist___any);
		if (a->__size)
		{	a->__any = (char **)soap_save_block(soap, soap_blist___any, NULL, 1);
		}
		else
		{	a->__any = NULL;
			if (soap_blist___any)
				soap_end_block(soap, soap_blist___any);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _wsnt__Unsubscribe *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__wsnt__Unsubscribe, SOAP_TYPE__wsnt__Unsubscribe, sizeof(struct _wsnt__Unsubscribe), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _wsnt__Unsubscribe * SOAP_FMAC4 soap_new__wsnt__Unsubscribe(struct soap *soap, int n)
{
	struct _wsnt__Unsubscribe *p;
	struct _wsnt__Unsubscribe *a = (struct _wsnt__Unsubscribe*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _wsnt__Unsubscribe));
	for (p = a; p && n--; p++)
		soap_default__wsnt__Unsubscribe(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__wsnt__Unsubscribe(struct soap *soap, const struct _wsnt__Unsubscribe *a, const char *tag, const char *type)
{
	if (soap_out__wsnt__Unsubscribe(soap, tag ? tag : "wsnt:Unsubscribe", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _wsnt__Unsubscribe * SOAP_FMAC4 soap_get__wsnt__Unsubscribe(struct soap *soap, struct _wsnt__Unsubscribe *p, const char *tag, const char *type)
{
	if ((p = soap_in__wsnt__Unsubscribe(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__wsnt__RenewResponse(struct soap *soap, struct _wsnt__RenewResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_dateTime(soap, &a->TerminationTime);
	a->CurrentTime = NULL;
	a->__size = 0;
	a->__any = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__wsnt__RenewResponse(struct soap *soap, const struct _wsnt__RenewResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &a->TerminationTime, SOAP_TYPE_dateTime);
	soap_serialize_PointerTodateTime(soap, &a->CurrentTime);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__wsnt__RenewResponse(struct soap *soap, const char *tag, int id, const struct _wsnt__RenewResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__wsnt__RenewResponse), type))
		return soap->error;
	if (soap_out_dateTime(soap, "wsnt:TerminationTime", -1, &a->TerminationTime, ""))
		return soap->error;
	if (soap_out_PointerTodateTime(soap, "wsnt:CurrentTime", -1, &a->CurrentTime, ""))
		return soap->error;
	if (a->__any)
	{	int i;
		for (i = 0; i < (int)a->__size; i++)
			if (soap_outliteral(soap, "-any", (char*const*)(a->__any + i), NULL))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _wsnt__RenewResponse * SOAP_FMAC4 soap_in__wsnt__RenewResponse(struct soap *soap, const char *tag, struct _wsnt__RenewResponse *a, const char *type)
{
	size_t soap_flag_TerminationTime = 1;
	size_t soap_flag_CurrentTime = 1;
	struct soap_blist *soap_blist___any = NULL;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct _wsnt__RenewResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__wsnt__RenewResponse, sizeof(struct _wsnt__RenewResponse), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__wsnt__RenewResponse(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_TerminationTime && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_dateTime(soap, "wsnt:TerminationTime", &a->TerminationTime, "xsd:dateTime"))
				{	soap_flag_TerminationTime--;
					continue;
				}
			}
			if (soap_flag_CurrentTime && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTodateTime(soap, "wsnt:CurrentTime", &a->CurrentTime, "xsd:dateTime"))
				{	soap_flag_CurrentTime--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	if (a->__any == NULL)
				{	if (soap_blist___any == NULL)
						soap_blist___any = soap_alloc_block(soap);
					a->__any = (char **)soap_push_block_max(soap, soap_blist___any, sizeof(char *));
					if (a->__any == NULL)
						return NULL;
					*a->__any = NULL;
				}
				if (soap_inliteral(soap, "-any", (char**)a->__any))
				{	a->__size++;
					a->__any = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->__any)
			soap_pop_block(soap, soap_blist___any);
		if (a->__size)
		{	a->__any = (char **)soap_save_block(soap, soap_blist___any, NULL, 1);
		}
		else
		{	a->__any = NULL;
			if (soap_blist___any)
				soap_end_block(soap, soap_blist___any);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_TerminationTime > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct _wsnt__RenewResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__wsnt__RenewResponse, SOAP_TYPE__wsnt__RenewResponse, sizeof(struct _wsnt__RenewResponse), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _wsnt__RenewResponse * SOAP_FMAC4 soap_new__wsnt__RenewResponse(struct soap *soap, int n)
{
	struct _wsnt__RenewResponse *p;
	struct _wsnt__RenewResponse *a = (struct _wsnt__RenewResponse*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _wsnt__RenewResponse));
	for (p = a; p && n--; p++)
		soap_default__wsnt__RenewResponse(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__wsnt__RenewResponse(struct soap *soap, const struct _wsnt__RenewResponse *a, const char *tag, const char *type)
{
	if (soap_out__wsnt__RenewResponse(soap, tag ? tag : "wsnt:RenewResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _wsnt__RenewResponse * SOAP_FMAC4 soap_get__wsnt__RenewResponse(struct soap *soap, struct _wsnt__RenewResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__wsnt__RenewResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__wsnt__Renew(struct soap *soap, struct _wsnt__Renew *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_wsnt__AbsoluteOrRelativeTimeType(soap, &a->TerminationTime);
	a->__size = 0;
	a->__any = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__wsnt__Renew(struct soap *soap, const struct _wsnt__Renew *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_wsnt__AbsoluteOrRelativeTimeType(soap, (char*const*)&a->TerminationTime);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__wsnt__Renew(struct soap *soap, const char *tag, int id, const struct _wsnt__Renew *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__wsnt__Renew), type))
		return soap->error;
	if (!a->TerminationTime)
	{	if (soap_element_nil(soap, "wsnt:TerminationTime"))
			return soap->error;
	}
	else if (soap_out_wsnt__AbsoluteOrRelativeTimeType(soap, "wsnt:TerminationTime", -1, (char*const*)&a->TerminationTime, ""))
		return soap->error;
	if (a->__any)
	{	int i;
		for (i = 0; i < (int)a->__size; i++)
			if (soap_outliteral(soap, "-any", (char*const*)(a->__any + i), NULL))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _wsnt__Renew * SOAP_FMAC4 soap_in__wsnt__Renew(struct soap *soap, const char *tag, struct _wsnt__Renew *a, const char *type)
{
	size_t soap_flag_TerminationTime = 1;
	struct soap_blist *soap_blist___any = NULL;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct _wsnt__Renew*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__wsnt__Renew, sizeof(struct _wsnt__Renew), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__wsnt__Renew(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_TerminationTime && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_wsnt__AbsoluteOrRelativeTimeType(soap, "wsnt:TerminationTime", (char**)&a->TerminationTime, "wsnt:AbsoluteOrRelativeTimeType"))
				{	soap_flag_TerminationTime--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	if (a->__any == NULL)
				{	if (soap_blist___any == NULL)
						soap_blist___any = soap_alloc_block(soap);
					a->__any = (char **)soap_push_block_max(soap, soap_blist___any, sizeof(char *));
					if (a->__any == NULL)
						return NULL;
					*a->__any = NULL;
				}
				if (soap_inliteral(soap, "-any", (char**)a->__any))
				{	a->__size++;
					a->__any = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->__any)
			soap_pop_block(soap, soap_blist___any);
		if (a->__size)
		{	a->__any = (char **)soap_save_block(soap, soap_blist___any, NULL, 1);
		}
		else
		{	a->__any = NULL;
			if (soap_blist___any)
				soap_end_block(soap, soap_blist___any);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_TerminationTime > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct _wsnt__Renew *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__wsnt__Renew, SOAP_TYPE__wsnt__Renew, sizeof(struct _wsnt__Renew), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _wsnt__Renew * SOAP_FMAC4 soap_new__wsnt__Renew(struct soap *soap, int n)
{
	struct _wsnt__Renew *p;
	struct _wsnt__Renew *a = (struct _wsnt__Renew*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _wsnt__Renew));
	for (p = a; p && n--; p++)
		soap_default__wsnt__Renew(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__wsnt__Renew(struct soap *soap, const struct _wsnt__Renew *a, const char *tag, const char *type)
{
	if (soap_out__wsnt__Renew(soap, tag ? tag : "wsnt:Renew", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _wsnt__Renew * SOAP_FMAC4 soap_get__wsnt__Renew(struct soap *soap, struct _wsnt__Renew *p, const char *tag, const char *type)
{
	if ((p = soap_in__wsnt__Renew(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__wsnt__CreatePullPointResponse(struct soap *soap, struct _wsnt__CreatePullPointResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_wsa5__EndpointReferenceType(soap, &a->PullPoint);
	a->__size = 0;
	a->__any = NULL;
	a->__anyAttribute = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__wsnt__CreatePullPointResponse(struct soap *soap, const struct _wsnt__CreatePullPointResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &a->PullPoint, SOAP_TYPE_wsa5__EndpointReferenceType);
	soap_serialize_wsa5__EndpointReferenceType(soap, &a->PullPoint);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__wsnt__CreatePullPointResponse(struct soap *soap, const char *tag, int id, const struct _wsnt__CreatePullPointResponse *a, const char *type)
{
	if (a->__anyAttribute)
		soap_set_attr(soap, "-anyAttribute", a->__anyAttribute, 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__wsnt__CreatePullPointResponse), type))
		return soap->error;
	if (soap_out_wsa5__EndpointReferenceType(soap, "wsnt:PullPoint", -1, &a->PullPoint, ""))
		return soap->error;
	if (a->__any)
	{	int i;
		for (i = 0; i < (int)a->__size; i++)
			if (soap_outliteral(soap, "-any", (char*const*)(a->__any + i), NULL))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _wsnt__CreatePullPointResponse * SOAP_FMAC4 soap_in__wsnt__CreatePullPointResponse(struct soap *soap, const char *tag, struct _wsnt__CreatePullPointResponse *a, const char *type)
{
	size_t soap_flag_PullPoint = 1;
	struct soap_blist *soap_blist___any = NULL;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct _wsnt__CreatePullPointResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__wsnt__CreatePullPointResponse, sizeof(struct _wsnt__CreatePullPointResponse), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__wsnt__CreatePullPointResponse(soap, a);
	if (soap_s2char(soap, soap_attr_value(soap, "-anyAttribute", 0, 0), &a->__anyAttribute, 0, 0, -1, NULL))
		return NULL;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_PullPoint && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_wsa5__EndpointReferenceType(soap, "wsnt:PullPoint", &a->PullPoint, "wsa5:EndpointReferenceType"))
				{	soap_flag_PullPoint--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	if (a->__any == NULL)
				{	if (soap_blist___any == NULL)
						soap_blist___any = soap_alloc_block(soap);
					a->__any = (char **)soap_push_block_max(soap, soap_blist___any, sizeof(char *));
					if (a->__any == NULL)
						return NULL;
					*a->__any = NULL;
				}
				if (soap_inliteral(soap, "-any", (char**)a->__any))
				{	a->__size++;
					a->__any = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->__any)
			soap_pop_block(soap, soap_blist___any);
		if (a->__size)
		{	a->__any = (char **)soap_save_block(soap, soap_blist___any, NULL, 1);
		}
		else
		{	a->__any = NULL;
			if (soap_blist___any)
				soap_end_block(soap, soap_blist___any);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_PullPoint > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct _wsnt__CreatePullPointResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__wsnt__CreatePullPointResponse, SOAP_TYPE__wsnt__CreatePullPointResponse, sizeof(struct _wsnt__CreatePullPointResponse), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _wsnt__CreatePullPointResponse * SOAP_FMAC4 soap_new__wsnt__CreatePullPointResponse(struct soap *soap, int n)
{
	struct _wsnt__CreatePullPointResponse *p;
	struct _wsnt__CreatePullPointResponse *a = (struct _wsnt__CreatePullPointResponse*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _wsnt__CreatePullPointResponse));
	for (p = a; p && n--; p++)
		soap_default__wsnt__CreatePullPointResponse(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__wsnt__CreatePullPointResponse(struct soap *soap, const struct _wsnt__CreatePullPointResponse *a, const char *tag, const char *type)
{
	if (soap_out__wsnt__CreatePullPointResponse(soap, tag ? tag : "wsnt:CreatePullPointResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _wsnt__CreatePullPointResponse * SOAP_FMAC4 soap_get__wsnt__CreatePullPointResponse(struct soap *soap, struct _wsnt__CreatePullPointResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__wsnt__CreatePullPointResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__wsnt__CreatePullPoint(struct soap *soap, struct _wsnt__CreatePullPoint *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__size = 0;
	a->__any = NULL;
	a->__anyAttribute = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__wsnt__CreatePullPoint(struct soap *soap, const struct _wsnt__CreatePullPoint *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__wsnt__CreatePullPoint(struct soap *soap, const char *tag, int id, const struct _wsnt__CreatePullPoint *a, const char *type)
{
	if (a->__anyAttribute)
		soap_set_attr(soap, "-anyAttribute", a->__anyAttribute, 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__wsnt__CreatePullPoint), type))
		return soap->error;
	if (a->__any)
	{	int i;
		for (i = 0; i < (int)a->__size; i++)
			if (soap_outliteral(soap, "-any", (char*const*)(a->__any + i), NULL))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _wsnt__CreatePullPoint * SOAP_FMAC4 soap_in__wsnt__CreatePullPoint(struct soap *soap, const char *tag, struct _wsnt__CreatePullPoint *a, const char *type)
{
	struct soap_blist *soap_blist___any = NULL;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct _wsnt__CreatePullPoint*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__wsnt__CreatePullPoint, sizeof(struct _wsnt__CreatePullPoint), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__wsnt__CreatePullPoint(soap, a);
	if (soap_s2char(soap, soap_attr_value(soap, "-anyAttribute", 0, 0), &a->__anyAttribute, 0, 0, -1, NULL))
		return NULL;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	if (a->__any == NULL)
				{	if (soap_blist___any == NULL)
						soap_blist___any = soap_alloc_block(soap);
					a->__any = (char **)soap_push_block_max(soap, soap_blist___any, sizeof(char *));
					if (a->__any == NULL)
						return NULL;
					*a->__any = NULL;
				}
				if (soap_inliteral(soap, "-any", (char**)a->__any))
				{	a->__size++;
					a->__any = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->__any)
			soap_pop_block(soap, soap_blist___any);
		if (a->__size)
		{	a->__any = (char **)soap_save_block(soap, soap_blist___any, NULL, 1);
		}
		else
		{	a->__any = NULL;
			if (soap_blist___any)
				soap_end_block(soap, soap_blist___any);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _wsnt__CreatePullPoint *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__wsnt__CreatePullPoint, SOAP_TYPE__wsnt__CreatePullPoint, sizeof(struct _wsnt__CreatePullPoint), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _wsnt__CreatePullPoint * SOAP_FMAC4 soap_new__wsnt__CreatePullPoint(struct soap *soap, int n)
{
	struct _wsnt__CreatePullPoint *p;
	struct _wsnt__CreatePullPoint *a = (struct _wsnt__CreatePullPoint*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _wsnt__CreatePullPoint));
	for (p = a; p && n--; p++)
		soap_default__wsnt__CreatePullPoint(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__wsnt__CreatePullPoint(struct soap *soap, const struct _wsnt__CreatePullPoint *a, const char *tag, const char *type)
{
	if (soap_out__wsnt__CreatePullPoint(soap, tag ? tag : "wsnt:CreatePullPoint", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _wsnt__CreatePullPoint * SOAP_FMAC4 soap_get__wsnt__CreatePullPoint(struct soap *soap, struct _wsnt__CreatePullPoint *p, const char *tag, const char *type)
{
	if ((p = soap_in__wsnt__CreatePullPoint(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__wsnt__DestroyPullPointResponse(struct soap *soap, struct _wsnt__DestroyPullPointResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__size = 0;
	a->__any = NULL;
	a->__anyAttribute = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__wsnt__DestroyPullPointResponse(struct soap *soap, const struct _wsnt__DestroyPullPointResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__wsnt__DestroyPullPointResponse(struct soap *soap, const char *tag, int id, const struct _wsnt__DestroyPullPointResponse *a, const char *type)
{
	if (a->__anyAttribute)
		soap_set_attr(soap, "-anyAttribute", a->__anyAttribute, 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__wsnt__DestroyPullPointResponse), type))
		return soap->error;
	if (a->__any)
	{	int i;
		for (i = 0; i < (int)a->__size; i++)
			if (soap_outliteral(soap, "-any", (char*const*)(a->__any + i), NULL))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _wsnt__DestroyPullPointResponse * SOAP_FMAC4 soap_in__wsnt__DestroyPullPointResponse(struct soap *soap, const char *tag, struct _wsnt__DestroyPullPointResponse *a, const char *type)
{
	struct soap_blist *soap_blist___any = NULL;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct _wsnt__DestroyPullPointResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__wsnt__DestroyPullPointResponse, sizeof(struct _wsnt__DestroyPullPointResponse), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__wsnt__DestroyPullPointResponse(soap, a);
	if (soap_s2char(soap, soap_attr_value(soap, "-anyAttribute", 0, 0), &a->__anyAttribute, 0, 0, -1, NULL))
		return NULL;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	if (a->__any == NULL)
				{	if (soap_blist___any == NULL)
						soap_blist___any = soap_alloc_block(soap);
					a->__any = (char **)soap_push_block_max(soap, soap_blist___any, sizeof(char *));
					if (a->__any == NULL)
						return NULL;
					*a->__any = NULL;
				}
				if (soap_inliteral(soap, "-any", (char**)a->__any))
				{	a->__size++;
					a->__any = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->__any)
			soap_pop_block(soap, soap_blist___any);
		if (a->__size)
		{	a->__any = (char **)soap_save_block(soap, soap_blist___any, NULL, 1);
		}
		else
		{	a->__any = NULL;
			if (soap_blist___any)
				soap_end_block(soap, soap_blist___any);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _wsnt__DestroyPullPointResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__wsnt__DestroyPullPointResponse, SOAP_TYPE__wsnt__DestroyPullPointResponse, sizeof(struct _wsnt__DestroyPullPointResponse), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _wsnt__DestroyPullPointResponse * SOAP_FMAC4 soap_new__wsnt__DestroyPullPointResponse(struct soap *soap, int n)
{
	struct _wsnt__DestroyPullPointResponse *p;
	struct _wsnt__DestroyPullPointResponse *a = (struct _wsnt__DestroyPullPointResponse*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _wsnt__DestroyPullPointResponse));
	for (p = a; p && n--; p++)
		soap_default__wsnt__DestroyPullPointResponse(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__wsnt__DestroyPullPointResponse(struct soap *soap, const struct _wsnt__DestroyPullPointResponse *a, const char *tag, const char *type)
{
	if (soap_out__wsnt__DestroyPullPointResponse(soap, tag ? tag : "wsnt:DestroyPullPointResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _wsnt__DestroyPullPointResponse * SOAP_FMAC4 soap_get__wsnt__DestroyPullPointResponse(struct soap *soap, struct _wsnt__DestroyPullPointResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__wsnt__DestroyPullPointResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__wsnt__DestroyPullPoint(struct soap *soap, struct _wsnt__DestroyPullPoint *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__size = 0;
	a->__any = NULL;
	a->__anyAttribute = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__wsnt__DestroyPullPoint(struct soap *soap, const struct _wsnt__DestroyPullPoint *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__wsnt__DestroyPullPoint(struct soap *soap, const char *tag, int id, const struct _wsnt__DestroyPullPoint *a, const char *type)
{
	if (a->__anyAttribute)
		soap_set_attr(soap, "-anyAttribute", a->__anyAttribute, 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__wsnt__DestroyPullPoint), type))
		return soap->error;
	if (a->__any)
	{	int i;
		for (i = 0; i < (int)a->__size; i++)
			if (soap_outliteral(soap, "-any", (char*const*)(a->__any + i), NULL))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _wsnt__DestroyPullPoint * SOAP_FMAC4 soap_in__wsnt__DestroyPullPoint(struct soap *soap, const char *tag, struct _wsnt__DestroyPullPoint *a, const char *type)
{
	struct soap_blist *soap_blist___any = NULL;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct _wsnt__DestroyPullPoint*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__wsnt__DestroyPullPoint, sizeof(struct _wsnt__DestroyPullPoint), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__wsnt__DestroyPullPoint(soap, a);
	if (soap_s2char(soap, soap_attr_value(soap, "-anyAttribute", 0, 0), &a->__anyAttribute, 0, 0, -1, NULL))
		return NULL;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	if (a->__any == NULL)
				{	if (soap_blist___any == NULL)
						soap_blist___any = soap_alloc_block(soap);
					a->__any = (char **)soap_push_block_max(soap, soap_blist___any, sizeof(char *));
					if (a->__any == NULL)
						return NULL;
					*a->__any = NULL;
				}
				if (soap_inliteral(soap, "-any", (char**)a->__any))
				{	a->__size++;
					a->__any = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->__any)
			soap_pop_block(soap, soap_blist___any);
		if (a->__size)
		{	a->__any = (char **)soap_save_block(soap, soap_blist___any, NULL, 1);
		}
		else
		{	a->__any = NULL;
			if (soap_blist___any)
				soap_end_block(soap, soap_blist___any);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _wsnt__DestroyPullPoint *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__wsnt__DestroyPullPoint, SOAP_TYPE__wsnt__DestroyPullPoint, sizeof(struct _wsnt__DestroyPullPoint), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _wsnt__DestroyPullPoint * SOAP_FMAC4 soap_new__wsnt__DestroyPullPoint(struct soap *soap, int n)
{
	struct _wsnt__DestroyPullPoint *p;
	struct _wsnt__DestroyPullPoint *a = (struct _wsnt__DestroyPullPoint*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _wsnt__DestroyPullPoint));
	for (p = a; p && n--; p++)
		soap_default__wsnt__DestroyPullPoint(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__wsnt__DestroyPullPoint(struct soap *soap, const struct _wsnt__DestroyPullPoint *a, const char *tag, const char *type)
{
	if (soap_out__wsnt__DestroyPullPoint(soap, tag ? tag : "wsnt:DestroyPullPoint", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _wsnt__DestroyPullPoint * SOAP_FMAC4 soap_get__wsnt__DestroyPullPoint(struct soap *soap, struct _wsnt__DestroyPullPoint *p, const char *tag, const char *type)
{
	if ((p = soap_in__wsnt__DestroyPullPoint(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__wsnt__GetMessagesResponse(struct soap *soap, struct _wsnt__GetMessagesResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__sizeNotificationMessage = 0;
	a->NotificationMessage_ = NULL;
	a->__size = 0;
	a->__any = NULL;
	a->__anyAttribute = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__wsnt__GetMessagesResponse(struct soap *soap, const struct _wsnt__GetMessagesResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (a->NotificationMessage_)
	{	int i;
		for (i = 0; i < (int)a->__sizeNotificationMessage; i++)
		{
			soap_embedded(soap, a->NotificationMessage_ + i, SOAP_TYPE_wsnt__NotificationMessageHolderType);
			soap_serialize_wsnt__NotificationMessageHolderType(soap, a->NotificationMessage_ + i);
		}
	}
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__wsnt__GetMessagesResponse(struct soap *soap, const char *tag, int id, const struct _wsnt__GetMessagesResponse *a, const char *type)
{
	if (a->__anyAttribute)
		soap_set_attr(soap, "-anyAttribute", a->__anyAttribute, 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__wsnt__GetMessagesResponse), type))
		return soap->error;
	if (a->NotificationMessage_)
	{	int i;
		for (i = 0; i < (int)a->__sizeNotificationMessage; i++)
			if (soap_out_wsnt__NotificationMessageHolderType(soap, "wsnt:NotificationMessage", -1, a->NotificationMessage_ + i, ""))
				return soap->error;
	}
	if (a->__any)
	{	int i;
		for (i = 0; i < (int)a->__size; i++)
			if (soap_outliteral(soap, "-any", (char*const*)(a->__any + i), NULL))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _wsnt__GetMessagesResponse * SOAP_FMAC4 soap_in__wsnt__GetMessagesResponse(struct soap *soap, const char *tag, struct _wsnt__GetMessagesResponse *a, const char *type)
{
	struct soap_blist *soap_blist_NotificationMessage_ = NULL;
	struct soap_blist *soap_blist___any = NULL;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct _wsnt__GetMessagesResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__wsnt__GetMessagesResponse, sizeof(struct _wsnt__GetMessagesResponse), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__wsnt__GetMessagesResponse(soap, a);
	if (soap_s2char(soap, soap_attr_value(soap, "-anyAttribute", 0, 0), &a->__anyAttribute, 0, 0, -1, NULL))
		return NULL;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "wsnt:NotificationMessage", 1, NULL))
			{	if (a->NotificationMessage_ == NULL)
				{	if (soap_blist_NotificationMessage_ == NULL)
						soap_blist_NotificationMessage_ = soap_alloc_block(soap);
					a->NotificationMessage_ = (struct wsnt__NotificationMessageHolderType *)soap_push_block_max(soap, soap_blist_NotificationMessage_, sizeof(struct wsnt__NotificationMessageHolderType));
					if (a->NotificationMessage_ == NULL)
						return NULL;
					soap_default_wsnt__NotificationMessageHolderType(soap, a->NotificationMessage_);
				}
				soap_revert(soap);
				if (soap_in_wsnt__NotificationMessageHolderType(soap, "wsnt:NotificationMessage", a->NotificationMessage_, "wsnt:NotificationMessageHolderType"))
				{	a->__sizeNotificationMessage++;
					a->NotificationMessage_ = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	if (a->__any == NULL)
				{	if (soap_blist___any == NULL)
						soap_blist___any = soap_alloc_block(soap);
					a->__any = (char **)soap_push_block_max(soap, soap_blist___any, sizeof(char *));
					if (a->__any == NULL)
						return NULL;
					*a->__any = NULL;
				}
				if (soap_inliteral(soap, "-any", (char**)a->__any))
				{	a->__size++;
					a->__any = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->NotificationMessage_)
			soap_pop_block(soap, soap_blist_NotificationMessage_);
		if (a->__sizeNotificationMessage)
		{	a->NotificationMessage_ = (struct wsnt__NotificationMessageHolderType *)soap_save_block(soap, soap_blist_NotificationMessage_, NULL, 1);
		}
		else
		{	a->NotificationMessage_ = NULL;
			if (soap_blist_NotificationMessage_)
				soap_end_block(soap, soap_blist_NotificationMessage_);
		}
		if (a->__any)
			soap_pop_block(soap, soap_blist___any);
		if (a->__size)
		{	a->__any = (char **)soap_save_block(soap, soap_blist___any, NULL, 1);
		}
		else
		{	a->__any = NULL;
			if (soap_blist___any)
				soap_end_block(soap, soap_blist___any);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _wsnt__GetMessagesResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__wsnt__GetMessagesResponse, SOAP_TYPE__wsnt__GetMessagesResponse, sizeof(struct _wsnt__GetMessagesResponse), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _wsnt__GetMessagesResponse * SOAP_FMAC4 soap_new__wsnt__GetMessagesResponse(struct soap *soap, int n)
{
	struct _wsnt__GetMessagesResponse *p;
	struct _wsnt__GetMessagesResponse *a = (struct _wsnt__GetMessagesResponse*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _wsnt__GetMessagesResponse));
	for (p = a; p && n--; p++)
		soap_default__wsnt__GetMessagesResponse(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__wsnt__GetMessagesResponse(struct soap *soap, const struct _wsnt__GetMessagesResponse *a, const char *tag, const char *type)
{
	if (soap_out__wsnt__GetMessagesResponse(soap, tag ? tag : "wsnt:GetMessagesResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _wsnt__GetMessagesResponse * SOAP_FMAC4 soap_get__wsnt__GetMessagesResponse(struct soap *soap, struct _wsnt__GetMessagesResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__wsnt__GetMessagesResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__wsnt__GetMessages(struct soap *soap, struct _wsnt__GetMessages *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_xsd__nonNegativeInteger(soap, &a->MaximumNumber);
	a->__size = 0;
	a->__any = NULL;
	a->__anyAttribute = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__wsnt__GetMessages(struct soap *soap, const struct _wsnt__GetMessages *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_xsd__nonNegativeInteger(soap, (char*const*)&a->MaximumNumber);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__wsnt__GetMessages(struct soap *soap, const char *tag, int id, const struct _wsnt__GetMessages *a, const char *type)
{
	if (a->__anyAttribute)
		soap_set_attr(soap, "-anyAttribute", a->__anyAttribute, 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__wsnt__GetMessages), type))
		return soap->error;
	if (soap_out_xsd__nonNegativeInteger(soap, "wsnt:MaximumNumber", -1, (char*const*)&a->MaximumNumber, ""))
		return soap->error;
	if (a->__any)
	{	int i;
		for (i = 0; i < (int)a->__size; i++)
			if (soap_outliteral(soap, "-any", (char*const*)(a->__any + i), NULL))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _wsnt__GetMessages * SOAP_FMAC4 soap_in__wsnt__GetMessages(struct soap *soap, const char *tag, struct _wsnt__GetMessages *a, const char *type)
{
	size_t soap_flag_MaximumNumber = 1;
	struct soap_blist *soap_blist___any = NULL;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct _wsnt__GetMessages*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__wsnt__GetMessages, sizeof(struct _wsnt__GetMessages), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__wsnt__GetMessages(soap, a);
	if (soap_s2char(soap, soap_attr_value(soap, "-anyAttribute", 0, 0), &a->__anyAttribute, 0, 0, -1, NULL))
		return NULL;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_MaximumNumber && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_xsd__nonNegativeInteger(soap, "wsnt:MaximumNumber", (char**)&a->MaximumNumber, "xsd:nonNegativeInteger"))
				{	soap_flag_MaximumNumber--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	if (a->__any == NULL)
				{	if (soap_blist___any == NULL)
						soap_blist___any = soap_alloc_block(soap);
					a->__any = (char **)soap_push_block_max(soap, soap_blist___any, sizeof(char *));
					if (a->__any == NULL)
						return NULL;
					*a->__any = NULL;
				}
				if (soap_inliteral(soap, "-any", (char**)a->__any))
				{	a->__size++;
					a->__any = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->__any)
			soap_pop_block(soap, soap_blist___any);
		if (a->__size)
		{	a->__any = (char **)soap_save_block(soap, soap_blist___any, NULL, 1);
		}
		else
		{	a->__any = NULL;
			if (soap_blist___any)
				soap_end_block(soap, soap_blist___any);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _wsnt__GetMessages *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__wsnt__GetMessages, SOAP_TYPE__wsnt__GetMessages, sizeof(struct _wsnt__GetMessages), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _wsnt__GetMessages * SOAP_FMAC4 soap_new__wsnt__GetMessages(struct soap *soap, int n)
{
	struct _wsnt__GetMessages *p;
	struct _wsnt__GetMessages *a = (struct _wsnt__GetMessages*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _wsnt__GetMessages));
	for (p = a; p && n--; p++)
		soap_default__wsnt__GetMessages(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__wsnt__GetMessages(struct soap *soap, const struct _wsnt__GetMessages *a, const char *tag, const char *type)
{
	if (soap_out__wsnt__GetMessages(soap, tag ? tag : "wsnt:GetMessages", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _wsnt__GetMessages * SOAP_FMAC4 soap_get__wsnt__GetMessages(struct soap *soap, struct _wsnt__GetMessages *p, const char *tag, const char *type)
{
	if ((p = soap_in__wsnt__GetMessages(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__wsnt__GetCurrentMessageResponse(struct soap *soap, struct _wsnt__GetCurrentMessageResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__size = 0;
	a->__any = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__wsnt__GetCurrentMessageResponse(struct soap *soap, const struct _wsnt__GetCurrentMessageResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__wsnt__GetCurrentMessageResponse(struct soap *soap, const char *tag, int id, const struct _wsnt__GetCurrentMessageResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__wsnt__GetCurrentMessageResponse), type))
		return soap->error;
	if (a->__any)
	{	int i;
		for (i = 0; i < (int)a->__size; i++)
			if (soap_outliteral(soap, "-any", (char*const*)(a->__any + i), NULL))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _wsnt__GetCurrentMessageResponse * SOAP_FMAC4 soap_in__wsnt__GetCurrentMessageResponse(struct soap *soap, const char *tag, struct _wsnt__GetCurrentMessageResponse *a, const char *type)
{
	struct soap_blist *soap_blist___any = NULL;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct _wsnt__GetCurrentMessageResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__wsnt__GetCurrentMessageResponse, sizeof(struct _wsnt__GetCurrentMessageResponse), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__wsnt__GetCurrentMessageResponse(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	if (a->__any == NULL)
				{	if (soap_blist___any == NULL)
						soap_blist___any = soap_alloc_block(soap);
					a->__any = (char **)soap_push_block_max(soap, soap_blist___any, sizeof(char *));
					if (a->__any == NULL)
						return NULL;
					*a->__any = NULL;
				}
				if (soap_inliteral(soap, "-any", (char**)a->__any))
				{	a->__size++;
					a->__any = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->__any)
			soap_pop_block(soap, soap_blist___any);
		if (a->__size)
		{	a->__any = (char **)soap_save_block(soap, soap_blist___any, NULL, 1);
		}
		else
		{	a->__any = NULL;
			if (soap_blist___any)
				soap_end_block(soap, soap_blist___any);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _wsnt__GetCurrentMessageResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__wsnt__GetCurrentMessageResponse, SOAP_TYPE__wsnt__GetCurrentMessageResponse, sizeof(struct _wsnt__GetCurrentMessageResponse), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _wsnt__GetCurrentMessageResponse * SOAP_FMAC4 soap_new__wsnt__GetCurrentMessageResponse(struct soap *soap, int n)
{
	struct _wsnt__GetCurrentMessageResponse *p;
	struct _wsnt__GetCurrentMessageResponse *a = (struct _wsnt__GetCurrentMessageResponse*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _wsnt__GetCurrentMessageResponse));
	for (p = a; p && n--; p++)
		soap_default__wsnt__GetCurrentMessageResponse(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__wsnt__GetCurrentMessageResponse(struct soap *soap, const struct _wsnt__GetCurrentMessageResponse *a, const char *tag, const char *type)
{
	if (soap_out__wsnt__GetCurrentMessageResponse(soap, tag ? tag : "wsnt:GetCurrentMessageResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _wsnt__GetCurrentMessageResponse * SOAP_FMAC4 soap_get__wsnt__GetCurrentMessageResponse(struct soap *soap, struct _wsnt__GetCurrentMessageResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__wsnt__GetCurrentMessageResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__wsnt__GetCurrentMessage(struct soap *soap, struct _wsnt__GetCurrentMessage *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->Topic = NULL;
	a->__size = 0;
	a->__any = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__wsnt__GetCurrentMessage(struct soap *soap, const struct _wsnt__GetCurrentMessage *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTowsnt__TopicExpressionType(soap, &a->Topic);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__wsnt__GetCurrentMessage(struct soap *soap, const char *tag, int id, const struct _wsnt__GetCurrentMessage *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__wsnt__GetCurrentMessage), type))
		return soap->error;
	if (!a->Topic)
	{	if (soap_element_empty(soap, "wsnt:Topic", 0, NULL))
			return soap->error;
	}
	else if (soap_out_PointerTowsnt__TopicExpressionType(soap, "wsnt:Topic", -1, &a->Topic, ""))
		return soap->error;
	if (a->__any)
	{	int i;
		for (i = 0; i < (int)a->__size; i++)
			if (soap_outliteral(soap, "-any", (char*const*)(a->__any + i), NULL))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _wsnt__GetCurrentMessage * SOAP_FMAC4 soap_in__wsnt__GetCurrentMessage(struct soap *soap, const char *tag, struct _wsnt__GetCurrentMessage *a, const char *type)
{
	size_t soap_flag_Topic = 1;
	struct soap_blist *soap_blist___any = NULL;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct _wsnt__GetCurrentMessage*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__wsnt__GetCurrentMessage, sizeof(struct _wsnt__GetCurrentMessage), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__wsnt__GetCurrentMessage(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Topic && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTowsnt__TopicExpressionType(soap, "wsnt:Topic", &a->Topic, "wsnt:TopicExpressionType"))
				{	soap_flag_Topic--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	if (a->__any == NULL)
				{	if (soap_blist___any == NULL)
						soap_blist___any = soap_alloc_block(soap);
					a->__any = (char **)soap_push_block_max(soap, soap_blist___any, sizeof(char *));
					if (a->__any == NULL)
						return NULL;
					*a->__any = NULL;
				}
				if (soap_inliteral(soap, "-any", (char**)a->__any))
				{	a->__size++;
					a->__any = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->__any)
			soap_pop_block(soap, soap_blist___any);
		if (a->__size)
		{	a->__any = (char **)soap_save_block(soap, soap_blist___any, NULL, 1);
		}
		else
		{	a->__any = NULL;
			if (soap_blist___any)
				soap_end_block(soap, soap_blist___any);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (!a->Topic))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct _wsnt__GetCurrentMessage *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__wsnt__GetCurrentMessage, SOAP_TYPE__wsnt__GetCurrentMessage, sizeof(struct _wsnt__GetCurrentMessage), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _wsnt__GetCurrentMessage * SOAP_FMAC4 soap_new__wsnt__GetCurrentMessage(struct soap *soap, int n)
{
	struct _wsnt__GetCurrentMessage *p;
	struct _wsnt__GetCurrentMessage *a = (struct _wsnt__GetCurrentMessage*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _wsnt__GetCurrentMessage));
	for (p = a; p && n--; p++)
		soap_default__wsnt__GetCurrentMessage(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__wsnt__GetCurrentMessage(struct soap *soap, const struct _wsnt__GetCurrentMessage *a, const char *tag, const char *type)
{
	if (soap_out__wsnt__GetCurrentMessage(soap, tag ? tag : "wsnt:GetCurrentMessage", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _wsnt__GetCurrentMessage * SOAP_FMAC4 soap_get__wsnt__GetCurrentMessage(struct soap *soap, struct _wsnt__GetCurrentMessage *p, const char *tag, const char *type)
{
	if ((p = soap_in__wsnt__GetCurrentMessage(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__wsnt__SubscribeResponse(struct soap *soap, struct _wsnt__SubscribeResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_wsa5__EndpointReferenceType(soap, &a->SubscriptionReference);
	a->CurrentTime = NULL;
	a->TerminationTime = NULL;
	a->__size = 0;
	a->__any = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__wsnt__SubscribeResponse(struct soap *soap, const struct _wsnt__SubscribeResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &a->SubscriptionReference, SOAP_TYPE_wsa5__EndpointReferenceType);
	soap_serialize_wsa5__EndpointReferenceType(soap, &a->SubscriptionReference);
	soap_serialize_PointerTodateTime(soap, &a->CurrentTime);
	soap_serialize_PointerTodateTime(soap, &a->TerminationTime);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__wsnt__SubscribeResponse(struct soap *soap, const char *tag, int id, const struct _wsnt__SubscribeResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__wsnt__SubscribeResponse), type))
		return soap->error;
	if (soap_out_wsa5__EndpointReferenceType(soap, "wsnt:SubscriptionReference", -1, &a->SubscriptionReference, ""))
		return soap->error;
	if (soap_out_PointerTodateTime(soap, "wsnt:CurrentTime", -1, &a->CurrentTime, ""))
		return soap->error;
	if (soap_out_PointerTodateTime(soap, "wsnt:TerminationTime", -1, &a->TerminationTime, ""))
		return soap->error;
	if (a->__any)
	{	int i;
		for (i = 0; i < (int)a->__size; i++)
			if (soap_outliteral(soap, "-any", (char*const*)(a->__any + i), NULL))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _wsnt__SubscribeResponse * SOAP_FMAC4 soap_in__wsnt__SubscribeResponse(struct soap *soap, const char *tag, struct _wsnt__SubscribeResponse *a, const char *type)
{
	size_t soap_flag_SubscriptionReference = 1;
	size_t soap_flag_CurrentTime = 1;
	size_t soap_flag_TerminationTime = 1;
	struct soap_blist *soap_blist___any = NULL;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct _wsnt__SubscribeResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__wsnt__SubscribeResponse, sizeof(struct _wsnt__SubscribeResponse), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__wsnt__SubscribeResponse(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_SubscriptionReference && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_wsa5__EndpointReferenceType(soap, "wsnt:SubscriptionReference", &a->SubscriptionReference, "wsa5:EndpointReferenceType"))
				{	soap_flag_SubscriptionReference--;
					continue;
				}
			}
			if (soap_flag_CurrentTime && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTodateTime(soap, "wsnt:CurrentTime", &a->CurrentTime, "xsd:dateTime"))
				{	soap_flag_CurrentTime--;
					continue;
				}
			}
			if (soap_flag_TerminationTime && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTodateTime(soap, "wsnt:TerminationTime", &a->TerminationTime, "xsd:dateTime"))
				{	soap_flag_TerminationTime--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	if (a->__any == NULL)
				{	if (soap_blist___any == NULL)
						soap_blist___any = soap_alloc_block(soap);
					a->__any = (char **)soap_push_block_max(soap, soap_blist___any, sizeof(char *));
					if (a->__any == NULL)
						return NULL;
					*a->__any = NULL;
				}
				if (soap_inliteral(soap, "-any", (char**)a->__any))
				{	a->__size++;
					a->__any = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->__any)
			soap_pop_block(soap, soap_blist___any);
		if (a->__size)
		{	a->__any = (char **)soap_save_block(soap, soap_blist___any, NULL, 1);
		}
		else
		{	a->__any = NULL;
			if (soap_blist___any)
				soap_end_block(soap, soap_blist___any);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_SubscriptionReference > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct _wsnt__SubscribeResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__wsnt__SubscribeResponse, SOAP_TYPE__wsnt__SubscribeResponse, sizeof(struct _wsnt__SubscribeResponse), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _wsnt__SubscribeResponse * SOAP_FMAC4 soap_new__wsnt__SubscribeResponse(struct soap *soap, int n)
{
	struct _wsnt__SubscribeResponse *p;
	struct _wsnt__SubscribeResponse *a = (struct _wsnt__SubscribeResponse*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _wsnt__SubscribeResponse));
	for (p = a; p && n--; p++)
		soap_default__wsnt__SubscribeResponse(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__wsnt__SubscribeResponse(struct soap *soap, const struct _wsnt__SubscribeResponse *a, const char *tag, const char *type)
{
	if (soap_out__wsnt__SubscribeResponse(soap, tag ? tag : "wsnt:SubscribeResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _wsnt__SubscribeResponse * SOAP_FMAC4 soap_get__wsnt__SubscribeResponse(struct soap *soap, struct _wsnt__SubscribeResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__wsnt__SubscribeResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__wsnt__Subscribe_SubscriptionPolicy(struct soap *soap, struct _wsnt__Subscribe_SubscriptionPolicy *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__size = 0;
	a->__any = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__wsnt__Subscribe_SubscriptionPolicy(struct soap *soap, const struct _wsnt__Subscribe_SubscriptionPolicy *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__wsnt__Subscribe_SubscriptionPolicy(struct soap *soap, const char *tag, int id, const struct _wsnt__Subscribe_SubscriptionPolicy *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__wsnt__Subscribe_SubscriptionPolicy), type))
		return soap->error;
	if (a->__any)
	{	int i;
		for (i = 0; i < (int)a->__size; i++)
			if (soap_outliteral(soap, "-any", (char*const*)(a->__any + i), NULL))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _wsnt__Subscribe_SubscriptionPolicy * SOAP_FMAC4 soap_in__wsnt__Subscribe_SubscriptionPolicy(struct soap *soap, const char *tag, struct _wsnt__Subscribe_SubscriptionPolicy *a, const char *type)
{
	struct soap_blist *soap_blist___any = NULL;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct _wsnt__Subscribe_SubscriptionPolicy*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__wsnt__Subscribe_SubscriptionPolicy, sizeof(struct _wsnt__Subscribe_SubscriptionPolicy), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__wsnt__Subscribe_SubscriptionPolicy(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	if (a->__any == NULL)
				{	if (soap_blist___any == NULL)
						soap_blist___any = soap_alloc_block(soap);
					a->__any = (char **)soap_push_block_max(soap, soap_blist___any, sizeof(char *));
					if (a->__any == NULL)
						return NULL;
					*a->__any = NULL;
				}
				if (soap_inliteral(soap, "-any", (char**)a->__any))
				{	a->__size++;
					a->__any = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->__any)
			soap_pop_block(soap, soap_blist___any);
		if (a->__size)
		{	a->__any = (char **)soap_save_block(soap, soap_blist___any, NULL, 1);
		}
		else
		{	a->__any = NULL;
			if (soap_blist___any)
				soap_end_block(soap, soap_blist___any);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _wsnt__Subscribe_SubscriptionPolicy *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__wsnt__Subscribe_SubscriptionPolicy, SOAP_TYPE__wsnt__Subscribe_SubscriptionPolicy, sizeof(struct _wsnt__Subscribe_SubscriptionPolicy), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _wsnt__Subscribe_SubscriptionPolicy * SOAP_FMAC4 soap_new__wsnt__Subscribe_SubscriptionPolicy(struct soap *soap, int n)
{
	struct _wsnt__Subscribe_SubscriptionPolicy *p;
	struct _wsnt__Subscribe_SubscriptionPolicy *a = (struct _wsnt__Subscribe_SubscriptionPolicy*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _wsnt__Subscribe_SubscriptionPolicy));
	for (p = a; p && n--; p++)
		soap_default__wsnt__Subscribe_SubscriptionPolicy(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__wsnt__Subscribe_SubscriptionPolicy(struct soap *soap, const struct _wsnt__Subscribe_SubscriptionPolicy *a, const char *tag, const char *type)
{
	if (soap_out__wsnt__Subscribe_SubscriptionPolicy(soap, tag ? tag : "wsnt:Subscribe-SubscriptionPolicy", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _wsnt__Subscribe_SubscriptionPolicy * SOAP_FMAC4 soap_get__wsnt__Subscribe_SubscriptionPolicy(struct soap *soap, struct _wsnt__Subscribe_SubscriptionPolicy *p, const char *tag, const char *type)
{
	if ((p = soap_in__wsnt__Subscribe_SubscriptionPolicy(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__wsnt__Subscribe(struct soap *soap, struct _wsnt__Subscribe *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_wsa5__EndpointReferenceType(soap, &a->ConsumerReference);
	a->Filter = NULL;
	soap_default_wsnt__AbsoluteOrRelativeTimeType(soap, &a->InitialTerminationTime);
	a->SubscriptionPolicy = NULL;
	a->__size = 0;
	a->__any = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__wsnt__Subscribe(struct soap *soap, const struct _wsnt__Subscribe *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &a->ConsumerReference, SOAP_TYPE_wsa5__EndpointReferenceType);
	soap_serialize_wsa5__EndpointReferenceType(soap, &a->ConsumerReference);
	soap_serialize_PointerTowsnt__FilterType(soap, &a->Filter);
	soap_serialize_wsnt__AbsoluteOrRelativeTimeType(soap, (char*const*)&a->InitialTerminationTime);
	soap_serialize_PointerTo_wsnt__Subscribe_SubscriptionPolicy(soap, &a->SubscriptionPolicy);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__wsnt__Subscribe(struct soap *soap, const char *tag, int id, const struct _wsnt__Subscribe *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__wsnt__Subscribe), type))
		return soap->error;
	if (soap_out_wsa5__EndpointReferenceType(soap, "wsnt:ConsumerReference", -1, &a->ConsumerReference, ""))
		return soap->error;
	if (soap_out_PointerTowsnt__FilterType(soap, "wsnt:Filter", -1, &a->Filter, ""))
		return soap->error;
	if (soap_out_wsnt__AbsoluteOrRelativeTimeType(soap, "wsnt:InitialTerminationTime", -1, (char*const*)&a->InitialTerminationTime, ""))
		return soap->error;
	if (soap_out_PointerTo_wsnt__Subscribe_SubscriptionPolicy(soap, "wsnt:SubscriptionPolicy", -1, &a->SubscriptionPolicy, ""))
		return soap->error;
	if (a->__any)
	{	int i;
		for (i = 0; i < (int)a->__size; i++)
			if (soap_outliteral(soap, "-any", (char*const*)(a->__any + i), NULL))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _wsnt__Subscribe * SOAP_FMAC4 soap_in__wsnt__Subscribe(struct soap *soap, const char *tag, struct _wsnt__Subscribe *a, const char *type)
{
	size_t soap_flag_ConsumerReference = 1;
	size_t soap_flag_Filter = 1;
	size_t soap_flag_InitialTerminationTime = 1;
	size_t soap_flag_SubscriptionPolicy = 1;
	struct soap_blist *soap_blist___any = NULL;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct _wsnt__Subscribe*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__wsnt__Subscribe, sizeof(struct _wsnt__Subscribe), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__wsnt__Subscribe(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ConsumerReference && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_wsa5__EndpointReferenceType(soap, "wsnt:ConsumerReference", &a->ConsumerReference, "wsa5:EndpointReferenceType"))
				{	soap_flag_ConsumerReference--;
					continue;
				}
			}
			if (soap_flag_Filter && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTowsnt__FilterType(soap, "wsnt:Filter", &a->Filter, "wsnt:FilterType"))
				{	soap_flag_Filter--;
					continue;
				}
			}
			if (soap_flag_InitialTerminationTime && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_wsnt__AbsoluteOrRelativeTimeType(soap, "wsnt:InitialTerminationTime", (char**)&a->InitialTerminationTime, "wsnt:AbsoluteOrRelativeTimeType"))
				{	soap_flag_InitialTerminationTime--;
					continue;
				}
			}
			if (soap_flag_SubscriptionPolicy && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_wsnt__Subscribe_SubscriptionPolicy(soap, "wsnt:SubscriptionPolicy", &a->SubscriptionPolicy, ""))
				{	soap_flag_SubscriptionPolicy--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	if (a->__any == NULL)
				{	if (soap_blist___any == NULL)
						soap_blist___any = soap_alloc_block(soap);
					a->__any = (char **)soap_push_block_max(soap, soap_blist___any, sizeof(char *));
					if (a->__any == NULL)
						return NULL;
					*a->__any = NULL;
				}
				if (soap_inliteral(soap, "-any", (char**)a->__any))
				{	a->__size++;
					a->__any = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->__any)
			soap_pop_block(soap, soap_blist___any);
		if (a->__size)
		{	a->__any = (char **)soap_save_block(soap, soap_blist___any, NULL, 1);
		}
		else
		{	a->__any = NULL;
			if (soap_blist___any)
				soap_end_block(soap, soap_blist___any);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_ConsumerReference > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct _wsnt__Subscribe *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__wsnt__Subscribe, SOAP_TYPE__wsnt__Subscribe, sizeof(struct _wsnt__Subscribe), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _wsnt__Subscribe * SOAP_FMAC4 soap_new__wsnt__Subscribe(struct soap *soap, int n)
{
	struct _wsnt__Subscribe *p;
	struct _wsnt__Subscribe *a = (struct _wsnt__Subscribe*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _wsnt__Subscribe));
	for (p = a; p && n--; p++)
		soap_default__wsnt__Subscribe(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__wsnt__Subscribe(struct soap *soap, const struct _wsnt__Subscribe *a, const char *tag, const char *type)
{
	if (soap_out__wsnt__Subscribe(soap, tag ? tag : "wsnt:Subscribe", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _wsnt__Subscribe * SOAP_FMAC4 soap_get__wsnt__Subscribe(struct soap *soap, struct _wsnt__Subscribe *p, const char *tag, const char *type)
{
	if ((p = soap_in__wsnt__Subscribe(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__wsnt__UseRaw(struct soap *soap, struct _wsnt__UseRaw *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__wsnt__UseRaw(struct soap *soap, const struct _wsnt__UseRaw *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__wsnt__UseRaw(struct soap *soap, const char *tag, int id, const struct _wsnt__UseRaw *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__wsnt__UseRaw), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _wsnt__UseRaw * SOAP_FMAC4 soap_in__wsnt__UseRaw(struct soap *soap, const char *tag, struct _wsnt__UseRaw *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct _wsnt__UseRaw*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__wsnt__UseRaw, sizeof(struct _wsnt__UseRaw), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__wsnt__UseRaw(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _wsnt__UseRaw *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__wsnt__UseRaw, SOAP_TYPE__wsnt__UseRaw, sizeof(struct _wsnt__UseRaw), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _wsnt__UseRaw * SOAP_FMAC4 soap_new__wsnt__UseRaw(struct soap *soap, int n)
{
	struct _wsnt__UseRaw *p;
	struct _wsnt__UseRaw *a = (struct _wsnt__UseRaw*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _wsnt__UseRaw));
	for (p = a; p && n--; p++)
		soap_default__wsnt__UseRaw(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__wsnt__UseRaw(struct soap *soap, const struct _wsnt__UseRaw *a, const char *tag, const char *type)
{
	if (soap_out__wsnt__UseRaw(soap, tag ? tag : "wsnt:UseRaw", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _wsnt__UseRaw * SOAP_FMAC4 soap_get__wsnt__UseRaw(struct soap *soap, struct _wsnt__UseRaw *p, const char *tag, const char *type)
{
	if ((p = soap_in__wsnt__UseRaw(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__wsnt__Notify(struct soap *soap, struct _wsnt__Notify *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__sizeNotificationMessage = 0;
	a->NotificationMessage_ = NULL;
	a->__size = 0;
	a->__any = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__wsnt__Notify(struct soap *soap, const struct _wsnt__Notify *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (a->NotificationMessage_)
	{	int i;
		for (i = 0; i < (int)a->__sizeNotificationMessage; i++)
		{
			soap_embedded(soap, a->NotificationMessage_ + i, SOAP_TYPE_wsnt__NotificationMessageHolderType);
			soap_serialize_wsnt__NotificationMessageHolderType(soap, a->NotificationMessage_ + i);
		}
	}
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__wsnt__Notify(struct soap *soap, const char *tag, int id, const struct _wsnt__Notify *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__wsnt__Notify), type))
		return soap->error;
	if (a->NotificationMessage_)
	{	int i;
		for (i = 0; i < (int)a->__sizeNotificationMessage; i++)
			if (soap_out_wsnt__NotificationMessageHolderType(soap, "wsnt:NotificationMessage", -1, a->NotificationMessage_ + i, ""))
				return soap->error;
	}
	if (a->__any)
	{	int i;
		for (i = 0; i < (int)a->__size; i++)
			if (soap_outliteral(soap, "-any", (char*const*)(a->__any + i), NULL))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _wsnt__Notify * SOAP_FMAC4 soap_in__wsnt__Notify(struct soap *soap, const char *tag, struct _wsnt__Notify *a, const char *type)
{
	struct soap_blist *soap_blist_NotificationMessage_ = NULL;
	struct soap_blist *soap_blist___any = NULL;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct _wsnt__Notify*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__wsnt__Notify, sizeof(struct _wsnt__Notify), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__wsnt__Notify(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "wsnt:NotificationMessage", 1, NULL))
			{	if (a->NotificationMessage_ == NULL)
				{	if (soap_blist_NotificationMessage_ == NULL)
						soap_blist_NotificationMessage_ = soap_alloc_block(soap);
					a->NotificationMessage_ = (struct wsnt__NotificationMessageHolderType *)soap_push_block_max(soap, soap_blist_NotificationMessage_, sizeof(struct wsnt__NotificationMessageHolderType));
					if (a->NotificationMessage_ == NULL)
						return NULL;
					soap_default_wsnt__NotificationMessageHolderType(soap, a->NotificationMessage_);
				}
				soap_revert(soap);
				if (soap_in_wsnt__NotificationMessageHolderType(soap, "wsnt:NotificationMessage", a->NotificationMessage_, "wsnt:NotificationMessageHolderType"))
				{	a->__sizeNotificationMessage++;
					a->NotificationMessage_ = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	if (a->__any == NULL)
				{	if (soap_blist___any == NULL)
						soap_blist___any = soap_alloc_block(soap);
					a->__any = (char **)soap_push_block_max(soap, soap_blist___any, sizeof(char *));
					if (a->__any == NULL)
						return NULL;
					*a->__any = NULL;
				}
				if (soap_inliteral(soap, "-any", (char**)a->__any))
				{	a->__size++;
					a->__any = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->NotificationMessage_)
			soap_pop_block(soap, soap_blist_NotificationMessage_);
		if (a->__sizeNotificationMessage)
		{	a->NotificationMessage_ = (struct wsnt__NotificationMessageHolderType *)soap_save_block(soap, soap_blist_NotificationMessage_, NULL, 1);
		}
		else
		{	a->NotificationMessage_ = NULL;
			if (soap_blist_NotificationMessage_)
				soap_end_block(soap, soap_blist_NotificationMessage_);
		}
		if (a->__any)
			soap_pop_block(soap, soap_blist___any);
		if (a->__size)
		{	a->__any = (char **)soap_save_block(soap, soap_blist___any, NULL, 1);
		}
		else
		{	a->__any = NULL;
			if (soap_blist___any)
				soap_end_block(soap, soap_blist___any);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (a->__sizeNotificationMessage < 1))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct _wsnt__Notify *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__wsnt__Notify, SOAP_TYPE__wsnt__Notify, sizeof(struct _wsnt__Notify), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _wsnt__Notify * SOAP_FMAC4 soap_new__wsnt__Notify(struct soap *soap, int n)
{
	struct _wsnt__Notify *p;
	struct _wsnt__Notify *a = (struct _wsnt__Notify*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _wsnt__Notify));
	for (p = a; p && n--; p++)
		soap_default__wsnt__Notify(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__wsnt__Notify(struct soap *soap, const struct _wsnt__Notify *a, const char *tag, const char *type)
{
	if (soap_out__wsnt__Notify(soap, tag ? tag : "wsnt:Notify", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _wsnt__Notify * SOAP_FMAC4 soap_get__wsnt__Notify(struct soap *soap, struct _wsnt__Notify *p, const char *tag, const char *type)
{
	if ((p = soap_in__wsnt__Notify(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__wsnt__SubscriptionManagerRP(struct soap *soap, struct _wsnt__SubscriptionManagerRP *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_wsa5__EndpointReferenceType(soap, &a->ConsumerReference);
	a->Filter = NULL;
	a->SubscriptionPolicy = NULL;
	a->CreationTime = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__wsnt__SubscriptionManagerRP(struct soap *soap, const struct _wsnt__SubscriptionManagerRP *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &a->ConsumerReference, SOAP_TYPE_wsa5__EndpointReferenceType);
	soap_serialize_wsa5__EndpointReferenceType(soap, &a->ConsumerReference);
	soap_serialize_PointerTowsnt__FilterType(soap, &a->Filter);
	soap_serialize_PointerTowsnt__SubscriptionPolicyType(soap, &a->SubscriptionPolicy);
	soap_serialize_PointerTodateTime(soap, &a->CreationTime);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__wsnt__SubscriptionManagerRP(struct soap *soap, const char *tag, int id, const struct _wsnt__SubscriptionManagerRP *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__wsnt__SubscriptionManagerRP), type))
		return soap->error;
	if (soap_out_wsa5__EndpointReferenceType(soap, "wsnt:ConsumerReference", -1, &a->ConsumerReference, ""))
		return soap->error;
	if (soap_out_PointerTowsnt__FilterType(soap, "wsnt:Filter", -1, &a->Filter, ""))
		return soap->error;
	if (soap_out_PointerTowsnt__SubscriptionPolicyType(soap, "wsnt:SubscriptionPolicy", -1, &a->SubscriptionPolicy, ""))
		return soap->error;
	if (soap_out_PointerTodateTime(soap, "wsnt:CreationTime", -1, &a->CreationTime, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _wsnt__SubscriptionManagerRP * SOAP_FMAC4 soap_in__wsnt__SubscriptionManagerRP(struct soap *soap, const char *tag, struct _wsnt__SubscriptionManagerRP *a, const char *type)
{
	size_t soap_flag_ConsumerReference = 1;
	size_t soap_flag_Filter = 1;
	size_t soap_flag_SubscriptionPolicy = 1;
	size_t soap_flag_CreationTime = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct _wsnt__SubscriptionManagerRP*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__wsnt__SubscriptionManagerRP, sizeof(struct _wsnt__SubscriptionManagerRP), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__wsnt__SubscriptionManagerRP(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ConsumerReference && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_wsa5__EndpointReferenceType(soap, "wsnt:ConsumerReference", &a->ConsumerReference, "wsa5:EndpointReferenceType"))
				{	soap_flag_ConsumerReference--;
					continue;
				}
			}
			if (soap_flag_Filter && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTowsnt__FilterType(soap, "wsnt:Filter", &a->Filter, "wsnt:FilterType"))
				{	soap_flag_Filter--;
					continue;
				}
			}
			if (soap_flag_SubscriptionPolicy && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTowsnt__SubscriptionPolicyType(soap, "wsnt:SubscriptionPolicy", &a->SubscriptionPolicy, "wsnt:SubscriptionPolicyType"))
				{	soap_flag_SubscriptionPolicy--;
					continue;
				}
			}
			if (soap_flag_CreationTime && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTodateTime(soap, "wsnt:CreationTime", &a->CreationTime, "xsd:dateTime"))
				{	soap_flag_CreationTime--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_ConsumerReference > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct _wsnt__SubscriptionManagerRP *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__wsnt__SubscriptionManagerRP, SOAP_TYPE__wsnt__SubscriptionManagerRP, sizeof(struct _wsnt__SubscriptionManagerRP), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _wsnt__SubscriptionManagerRP * SOAP_FMAC4 soap_new__wsnt__SubscriptionManagerRP(struct soap *soap, int n)
{
	struct _wsnt__SubscriptionManagerRP *p;
	struct _wsnt__SubscriptionManagerRP *a = (struct _wsnt__SubscriptionManagerRP*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _wsnt__SubscriptionManagerRP));
	for (p = a; p && n--; p++)
		soap_default__wsnt__SubscriptionManagerRP(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__wsnt__SubscriptionManagerRP(struct soap *soap, const struct _wsnt__SubscriptionManagerRP *a, const char *tag, const char *type)
{
	if (soap_out__wsnt__SubscriptionManagerRP(soap, tag ? tag : "wsnt:SubscriptionManagerRP", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _wsnt__SubscriptionManagerRP * SOAP_FMAC4 soap_get__wsnt__SubscriptionManagerRP(struct soap *soap, struct _wsnt__SubscriptionManagerRP *p, const char *tag, const char *type)
{
	if ((p = soap_in__wsnt__SubscriptionManagerRP(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_wstop__TopicSetType(struct soap *soap, struct wstop__TopicSetType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->documentation = NULL;
	a->__anyAttribute = NULL;
	a->__size = 0;
	a->__any = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_wstop__TopicSetType(struct soap *soap, const struct wstop__TopicSetType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTowstop__Documentation(soap, &a->documentation);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_wstop__TopicSetType(struct soap *soap, const char *tag, int id, const struct wstop__TopicSetType *a, const char *type)
{
	if (a->__anyAttribute)
		soap_set_attr(soap, "-anyAttribute", a->__anyAttribute, 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_wstop__TopicSetType), type))
		return soap->error;
	if (soap_out_PointerTowstop__Documentation(soap, "wstop:documentation", -1, &a->documentation, ""))
		return soap->error;
	if (a->__any)
	{	int i;
		for (i = 0; i < (int)a->__size; i++)
			if (soap_outliteral(soap, "-any", (char*const*)(a->__any + i), NULL))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct wstop__TopicSetType * SOAP_FMAC4 soap_in_wstop__TopicSetType(struct soap *soap, const char *tag, struct wstop__TopicSetType *a, const char *type)
{
	size_t soap_flag_documentation = 1;
	struct soap_blist *soap_blist___any = NULL;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct wstop__TopicSetType*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_wstop__TopicSetType, sizeof(struct wstop__TopicSetType), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_wstop__TopicSetType(soap, a);
	if (soap_s2char(soap, soap_attr_value(soap, "-anyAttribute", 0, 0), &a->__anyAttribute, 0, 0, -1, NULL))
		return NULL;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_documentation && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTowstop__Documentation(soap, "wstop:documentation", &a->documentation, "wstop:Documentation"))
				{	soap_flag_documentation--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	if (a->__any == NULL)
				{	if (soap_blist___any == NULL)
						soap_blist___any = soap_alloc_block(soap);
					a->__any = (char **)soap_push_block_max(soap, soap_blist___any, sizeof(char *));
					if (a->__any == NULL)
						return NULL;
					*a->__any = NULL;
				}
				if (soap_inliteral(soap, "-any", (char**)a->__any))
				{	a->__size++;
					a->__any = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->__any)
			soap_pop_block(soap, soap_blist___any);
		if (a->__size)
		{	a->__any = (char **)soap_save_block(soap, soap_blist___any, NULL, 1);
		}
		else
		{	a->__any = NULL;
			if (soap_blist___any)
				soap_end_block(soap, soap_blist___any);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct wstop__TopicSetType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_wstop__TopicSetType, SOAP_TYPE_wstop__TopicSetType, sizeof(struct wstop__TopicSetType), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct wstop__TopicSetType * SOAP_FMAC4 soap_new_wstop__TopicSetType(struct soap *soap, int n)
{
	struct wstop__TopicSetType *p;
	struct wstop__TopicSetType *a = (struct wstop__TopicSetType*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct wstop__TopicSetType));
	for (p = a; p && n--; p++)
		soap_default_wstop__TopicSetType(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_wstop__TopicSetType(struct soap *soap, const struct wstop__TopicSetType *a, const char *tag, const char *type)
{
	if (soap_out_wstop__TopicSetType(soap, tag ? tag : "wstop:TopicSetType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct wstop__TopicSetType * SOAP_FMAC4 soap_get_wstop__TopicSetType(struct soap *soap, struct wstop__TopicSetType *p, const char *tag, const char *type)
{
	if ((p = soap_in_wstop__TopicSetType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__wsnt__NotificationProducerRP(struct soap *soap, struct _wsnt__NotificationProducerRP *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__sizeTopicExpression = 0;
	a->TopicExpression_ = NULL;
	a->FixedTopicSet = NULL;
	a->__sizeTopicExpressionDialect = 0;
	a->TopicExpressionDialect_ = NULL;
	a->wstop__TopicSet = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__wsnt__NotificationProducerRP(struct soap *soap, const struct _wsnt__NotificationProducerRP *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (a->TopicExpression_)
	{	int i;
		for (i = 0; i < (int)a->__sizeTopicExpression; i++)
		{
			soap_embedded(soap, a->TopicExpression_ + i, SOAP_TYPE_wsnt__TopicExpressionType);
			soap_serialize_wsnt__TopicExpressionType(soap, a->TopicExpression_ + i);
		}
	}
	soap_serialize_PointerToxsd__boolean(soap, &a->FixedTopicSet);
	if (a->TopicExpressionDialect_)
	{	int i;
		for (i = 0; i < (int)a->__sizeTopicExpressionDialect; i++)
		{
			soap_serialize_xsd__anyURI(soap, (char*const*)(a->TopicExpressionDialect_ + i));
		}
	}
	soap_serialize_PointerTowstop__TopicSetType(soap, &a->wstop__TopicSet);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__wsnt__NotificationProducerRP(struct soap *soap, const char *tag, int id, const struct _wsnt__NotificationProducerRP *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__wsnt__NotificationProducerRP), type))
		return soap->error;
	if (a->TopicExpression_)
	{	int i;
		for (i = 0; i < (int)a->__sizeTopicExpression; i++)
			if (soap_out_wsnt__TopicExpressionType(soap, "wsnt:TopicExpression", -1, a->TopicExpression_ + i, ""))
				return soap->error;
	}
	if (soap_out_PointerToxsd__boolean(soap, "wsnt:FixedTopicSet", -1, &a->FixedTopicSet, ""))
		return soap->error;
	if (a->TopicExpressionDialect_)
	{	int i;
		for (i = 0; i < (int)a->__sizeTopicExpressionDialect; i++)
			if (soap_out_string(soap, "wsnt:TopicExpressionDialect", -1, (char*const*)(a->TopicExpressionDialect_ + i), ""))
				return soap->error;
	}
	if (soap_out_PointerTowstop__TopicSetType(soap, "wstop:TopicSet", -1, &a->wstop__TopicSet, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _wsnt__NotificationProducerRP * SOAP_FMAC4 soap_in__wsnt__NotificationProducerRP(struct soap *soap, const char *tag, struct _wsnt__NotificationProducerRP *a, const char *type)
{
	struct soap_blist *soap_blist_TopicExpression_ = NULL;
	size_t soap_flag_FixedTopicSet = 1;
	struct soap_blist *soap_blist_TopicExpressionDialect_ = NULL;
	size_t soap_flag_wstop__TopicSet = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct _wsnt__NotificationProducerRP*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__wsnt__NotificationProducerRP, sizeof(struct _wsnt__NotificationProducerRP), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__wsnt__NotificationProducerRP(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "wsnt:TopicExpression", 1, NULL))
			{	if (a->TopicExpression_ == NULL)
				{	if (soap_blist_TopicExpression_ == NULL)
						soap_blist_TopicExpression_ = soap_alloc_block(soap);
					a->TopicExpression_ = (struct wsnt__TopicExpressionType *)soap_push_block_max(soap, soap_blist_TopicExpression_, sizeof(struct wsnt__TopicExpressionType));
					if (a->TopicExpression_ == NULL)
						return NULL;
					soap_default_wsnt__TopicExpressionType(soap, a->TopicExpression_);
				}
				soap_revert(soap);
				if (soap_in_wsnt__TopicExpressionType(soap, "wsnt:TopicExpression", a->TopicExpression_, "wsnt:TopicExpressionType"))
				{	a->__sizeTopicExpression++;
					a->TopicExpression_ = NULL;
					continue;
				}
			}
			if (soap_flag_FixedTopicSet && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerToxsd__boolean(soap, "wsnt:FixedTopicSet", &a->FixedTopicSet, "xsd:boolean"))
				{	soap_flag_FixedTopicSet--;
					continue;
				}
				if (soap->error == SOAP_EMPTY)
				{	if (!(a->FixedTopicSet = (enum xsd__boolean *)soap_malloc(soap, sizeof(enum xsd__boolean))))
						return NULL;
					if (a->FixedTopicSet)
						*a->FixedTopicSet = (enum xsd__boolean)1;
					soap->error = SOAP_OK;
					soap_flag_FixedTopicSet--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "wsnt:TopicExpressionDialect", 1, NULL))
			{	if (a->TopicExpressionDialect_ == NULL)
				{	if (soap_blist_TopicExpressionDialect_ == NULL)
						soap_blist_TopicExpressionDialect_ = soap_alloc_block(soap);
					a->TopicExpressionDialect_ = (char **)soap_push_block_max(soap, soap_blist_TopicExpressionDialect_, sizeof(char *));
					if (a->TopicExpressionDialect_ == NULL)
						return NULL;
					*a->TopicExpressionDialect_ = NULL;
				}
				soap_revert(soap);
				if (soap_in_xsd__anyURI(soap, "wsnt:TopicExpressionDialect", (char**)a->TopicExpressionDialect_, "xsd:anyURI"))
				{	a->__sizeTopicExpressionDialect++;
					a->TopicExpressionDialect_ = NULL;
					continue;
				}
			}
			if (soap_flag_wstop__TopicSet && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTowstop__TopicSetType(soap, "wstop:TopicSet", &a->wstop__TopicSet, "wstop:TopicSetType"))
				{	soap_flag_wstop__TopicSet--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->TopicExpression_)
			soap_pop_block(soap, soap_blist_TopicExpression_);
		if (a->__sizeTopicExpression)
		{	a->TopicExpression_ = (struct wsnt__TopicExpressionType *)soap_save_block(soap, soap_blist_TopicExpression_, NULL, 1);
		}
		else
		{	a->TopicExpression_ = NULL;
			if (soap_blist_TopicExpression_)
				soap_end_block(soap, soap_blist_TopicExpression_);
		}
		if (a->TopicExpressionDialect_)
			soap_pop_block(soap, soap_blist_TopicExpressionDialect_);
		if (a->__sizeTopicExpressionDialect)
		{	a->TopicExpressionDialect_ = (char **)soap_save_block(soap, soap_blist_TopicExpressionDialect_, NULL, 1);
		}
		else
		{	a->TopicExpressionDialect_ = NULL;
			if (soap_blist_TopicExpressionDialect_)
				soap_end_block(soap, soap_blist_TopicExpressionDialect_);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _wsnt__NotificationProducerRP *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__wsnt__NotificationProducerRP, SOAP_TYPE__wsnt__NotificationProducerRP, sizeof(struct _wsnt__NotificationProducerRP), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _wsnt__NotificationProducerRP * SOAP_FMAC4 soap_new__wsnt__NotificationProducerRP(struct soap *soap, int n)
{
	struct _wsnt__NotificationProducerRP *p;
	struct _wsnt__NotificationProducerRP *a = (struct _wsnt__NotificationProducerRP*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _wsnt__NotificationProducerRP));
	for (p = a; p && n--; p++)
		soap_default__wsnt__NotificationProducerRP(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__wsnt__NotificationProducerRP(struct soap *soap, const struct _wsnt__NotificationProducerRP *a, const char *tag, const char *type)
{
	if (soap_out__wsnt__NotificationProducerRP(soap, tag ? tag : "wsnt:NotificationProducerRP", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _wsnt__NotificationProducerRP * SOAP_FMAC4 soap_get__wsnt__NotificationProducerRP(struct soap *soap, struct _wsnt__NotificationProducerRP *p, const char *tag, const char *type)
{
	if ((p = soap_in__wsnt__NotificationProducerRP(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__wsnt__NotificationMessageHolderType_Message(struct soap *soap, struct _wsnt__NotificationMessageHolderType_Message *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__any = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__wsnt__NotificationMessageHolderType_Message(struct soap *soap, const struct _wsnt__NotificationMessageHolderType_Message *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__wsnt__NotificationMessageHolderType_Message(struct soap *soap, const char *tag, int id, const struct _wsnt__NotificationMessageHolderType_Message *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__wsnt__NotificationMessageHolderType_Message), type))
		return soap->error;
	if (soap_outliteral(soap, "-any", (char*const*)&a->__any, NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _wsnt__NotificationMessageHolderType_Message * SOAP_FMAC4 soap_in__wsnt__NotificationMessageHolderType_Message(struct soap *soap, const char *tag, struct _wsnt__NotificationMessageHolderType_Message *a, const char *type)
{
	size_t soap_flag___any = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct _wsnt__NotificationMessageHolderType_Message*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__wsnt__NotificationMessageHolderType_Message, sizeof(struct _wsnt__NotificationMessageHolderType_Message), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__wsnt__NotificationMessageHolderType_Message(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag___any && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_inliteral(soap, "-any", (char**)&a->__any))
				{	soap_flag___any--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _wsnt__NotificationMessageHolderType_Message *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__wsnt__NotificationMessageHolderType_Message, SOAP_TYPE__wsnt__NotificationMessageHolderType_Message, sizeof(struct _wsnt__NotificationMessageHolderType_Message), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _wsnt__NotificationMessageHolderType_Message * SOAP_FMAC4 soap_new__wsnt__NotificationMessageHolderType_Message(struct soap *soap, int n)
{
	struct _wsnt__NotificationMessageHolderType_Message *p;
	struct _wsnt__NotificationMessageHolderType_Message *a = (struct _wsnt__NotificationMessageHolderType_Message*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _wsnt__NotificationMessageHolderType_Message));
	for (p = a; p && n--; p++)
		soap_default__wsnt__NotificationMessageHolderType_Message(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__wsnt__NotificationMessageHolderType_Message(struct soap *soap, const struct _wsnt__NotificationMessageHolderType_Message *a, const char *tag, const char *type)
{
	if (soap_out__wsnt__NotificationMessageHolderType_Message(soap, tag ? tag : "wsnt:NotificationMessageHolderType-Message", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _wsnt__NotificationMessageHolderType_Message * SOAP_FMAC4 soap_get__wsnt__NotificationMessageHolderType_Message(struct soap *soap, struct _wsnt__NotificationMessageHolderType_Message *p, const char *tag, const char *type)
{
	if ((p = soap_in__wsnt__NotificationMessageHolderType_Message(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_wsnt__NotificationMessageHolderType(struct soap *soap, struct wsnt__NotificationMessageHolderType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->SubscriptionReference = NULL;
	a->Topic = NULL;
	a->ProducerReference = NULL;
	soap_default__wsnt__NotificationMessageHolderType_Message(soap, &a->Message);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_wsnt__NotificationMessageHolderType(struct soap *soap, const struct wsnt__NotificationMessageHolderType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTowsa5__EndpointReferenceType(soap, &a->SubscriptionReference);
	soap_serialize_PointerTowsnt__TopicExpressionType(soap, &a->Topic);
	soap_serialize_PointerTowsa5__EndpointReferenceType(soap, &a->ProducerReference);
	soap_serialize__wsnt__NotificationMessageHolderType_Message(soap, &a->Message);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_wsnt__NotificationMessageHolderType(struct soap *soap, const char *tag, int id, const struct wsnt__NotificationMessageHolderType *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_wsnt__NotificationMessageHolderType), type))
		return soap->error;
	if (soap_out_PointerTowsa5__EndpointReferenceType(soap, "wsnt:SubscriptionReference", -1, &a->SubscriptionReference, ""))
		return soap->error;
	if (soap_out_PointerTowsnt__TopicExpressionType(soap, "wsnt:Topic", -1, &a->Topic, ""))
		return soap->error;
	if (soap_out_PointerTowsa5__EndpointReferenceType(soap, "wsnt:ProducerReference", -1, &a->ProducerReference, ""))
		return soap->error;
	if (soap_out__wsnt__NotificationMessageHolderType_Message(soap, "wsnt:Message", -1, &a->Message, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct wsnt__NotificationMessageHolderType * SOAP_FMAC4 soap_in_wsnt__NotificationMessageHolderType(struct soap *soap, const char *tag, struct wsnt__NotificationMessageHolderType *a, const char *type)
{
	size_t soap_flag_SubscriptionReference = 1;
	size_t soap_flag_Topic = 1;
	size_t soap_flag_ProducerReference = 1;
	size_t soap_flag_Message = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct wsnt__NotificationMessageHolderType*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_wsnt__NotificationMessageHolderType, sizeof(struct wsnt__NotificationMessageHolderType), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_wsnt__NotificationMessageHolderType(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_SubscriptionReference && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTowsa5__EndpointReferenceType(soap, "wsnt:SubscriptionReference", &a->SubscriptionReference, "wsa5:EndpointReferenceType"))
				{	soap_flag_SubscriptionReference--;
					continue;
				}
			}
			if (soap_flag_Topic && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTowsnt__TopicExpressionType(soap, "wsnt:Topic", &a->Topic, "wsnt:TopicExpressionType"))
				{	soap_flag_Topic--;
					continue;
				}
			}
			if (soap_flag_ProducerReference && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTowsa5__EndpointReferenceType(soap, "wsnt:ProducerReference", &a->ProducerReference, "wsa5:EndpointReferenceType"))
				{	soap_flag_ProducerReference--;
					continue;
				}
			}
			if (soap_flag_Message && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in__wsnt__NotificationMessageHolderType_Message(soap, "wsnt:Message", &a->Message, ""))
				{	soap_flag_Message--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Message > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct wsnt__NotificationMessageHolderType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_wsnt__NotificationMessageHolderType, SOAP_TYPE_wsnt__NotificationMessageHolderType, sizeof(struct wsnt__NotificationMessageHolderType), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct wsnt__NotificationMessageHolderType * SOAP_FMAC4 soap_new_wsnt__NotificationMessageHolderType(struct soap *soap, int n)
{
	struct wsnt__NotificationMessageHolderType *p;
	struct wsnt__NotificationMessageHolderType *a = (struct wsnt__NotificationMessageHolderType*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct wsnt__NotificationMessageHolderType));
	for (p = a; p && n--; p++)
		soap_default_wsnt__NotificationMessageHolderType(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_wsnt__NotificationMessageHolderType(struct soap *soap, const struct wsnt__NotificationMessageHolderType *a, const char *tag, const char *type)
{
	if (soap_out_wsnt__NotificationMessageHolderType(soap, tag ? tag : "wsnt:NotificationMessageHolderType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct wsnt__NotificationMessageHolderType * SOAP_FMAC4 soap_get_wsnt__NotificationMessageHolderType(struct soap *soap, struct wsnt__NotificationMessageHolderType *p, const char *tag, const char *type)
{
	if ((p = soap_in_wsnt__NotificationMessageHolderType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_wsnt__SubscriptionPolicyType(struct soap *soap, struct wsnt__SubscriptionPolicyType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__size = 0;
	a->__any = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_wsnt__SubscriptionPolicyType(struct soap *soap, const struct wsnt__SubscriptionPolicyType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_wsnt__SubscriptionPolicyType(struct soap *soap, const char *tag, int id, const struct wsnt__SubscriptionPolicyType *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_wsnt__SubscriptionPolicyType), type))
		return soap->error;
	if (a->__any)
	{	int i;
		for (i = 0; i < (int)a->__size; i++)
			if (soap_outliteral(soap, "-any", (char*const*)(a->__any + i), NULL))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct wsnt__SubscriptionPolicyType * SOAP_FMAC4 soap_in_wsnt__SubscriptionPolicyType(struct soap *soap, const char *tag, struct wsnt__SubscriptionPolicyType *a, const char *type)
{
	struct soap_blist *soap_blist___any = NULL;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct wsnt__SubscriptionPolicyType*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_wsnt__SubscriptionPolicyType, sizeof(struct wsnt__SubscriptionPolicyType), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_wsnt__SubscriptionPolicyType(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	if (a->__any == NULL)
				{	if (soap_blist___any == NULL)
						soap_blist___any = soap_alloc_block(soap);
					a->__any = (char **)soap_push_block_max(soap, soap_blist___any, sizeof(char *));
					if (a->__any == NULL)
						return NULL;
					*a->__any = NULL;
				}
				if (soap_inliteral(soap, "-any", (char**)a->__any))
				{	a->__size++;
					a->__any = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->__any)
			soap_pop_block(soap, soap_blist___any);
		if (a->__size)
		{	a->__any = (char **)soap_save_block(soap, soap_blist___any, NULL, 1);
		}
		else
		{	a->__any = NULL;
			if (soap_blist___any)
				soap_end_block(soap, soap_blist___any);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct wsnt__SubscriptionPolicyType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_wsnt__SubscriptionPolicyType, SOAP_TYPE_wsnt__SubscriptionPolicyType, sizeof(struct wsnt__SubscriptionPolicyType), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct wsnt__SubscriptionPolicyType * SOAP_FMAC4 soap_new_wsnt__SubscriptionPolicyType(struct soap *soap, int n)
{
	struct wsnt__SubscriptionPolicyType *p;
	struct wsnt__SubscriptionPolicyType *a = (struct wsnt__SubscriptionPolicyType*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct wsnt__SubscriptionPolicyType));
	for (p = a; p && n--; p++)
		soap_default_wsnt__SubscriptionPolicyType(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_wsnt__SubscriptionPolicyType(struct soap *soap, const struct wsnt__SubscriptionPolicyType *a, const char *tag, const char *type)
{
	if (soap_out_wsnt__SubscriptionPolicyType(soap, tag ? tag : "wsnt:SubscriptionPolicyType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct wsnt__SubscriptionPolicyType * SOAP_FMAC4 soap_get_wsnt__SubscriptionPolicyType(struct soap *soap, struct wsnt__SubscriptionPolicyType *p, const char *tag, const char *type)
{
	if ((p = soap_in_wsnt__SubscriptionPolicyType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_wsnt__FilterType(struct soap *soap, struct wsnt__FilterType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__size = 0;
	a->__any = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_wsnt__FilterType(struct soap *soap, const struct wsnt__FilterType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_wsnt__FilterType(struct soap *soap, const char *tag, int id, const struct wsnt__FilterType *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_wsnt__FilterType), type))
		return soap->error;
	if (a->__any)
	{	int i;
		for (i = 0; i < (int)a->__size; i++)
			if (soap_outliteral(soap, "-any", (char*const*)(a->__any + i), NULL))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct wsnt__FilterType * SOAP_FMAC4 soap_in_wsnt__FilterType(struct soap *soap, const char *tag, struct wsnt__FilterType *a, const char *type)
{
	struct soap_blist *soap_blist___any = NULL;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct wsnt__FilterType*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_wsnt__FilterType, sizeof(struct wsnt__FilterType), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_wsnt__FilterType(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	if (a->__any == NULL)
				{	if (soap_blist___any == NULL)
						soap_blist___any = soap_alloc_block(soap);
					a->__any = (char **)soap_push_block_max(soap, soap_blist___any, sizeof(char *));
					if (a->__any == NULL)
						return NULL;
					*a->__any = NULL;
				}
				if (soap_inliteral(soap, "-any", (char**)a->__any))
				{	a->__size++;
					a->__any = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->__any)
			soap_pop_block(soap, soap_blist___any);
		if (a->__size)
		{	a->__any = (char **)soap_save_block(soap, soap_blist___any, NULL, 1);
		}
		else
		{	a->__any = NULL;
			if (soap_blist___any)
				soap_end_block(soap, soap_blist___any);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct wsnt__FilterType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_wsnt__FilterType, SOAP_TYPE_wsnt__FilterType, sizeof(struct wsnt__FilterType), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct wsnt__FilterType * SOAP_FMAC4 soap_new_wsnt__FilterType(struct soap *soap, int n)
{
	struct wsnt__FilterType *p;
	struct wsnt__FilterType *a = (struct wsnt__FilterType*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct wsnt__FilterType));
	for (p = a; p && n--; p++)
		soap_default_wsnt__FilterType(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_wsnt__FilterType(struct soap *soap, const struct wsnt__FilterType *a, const char *tag, const char *type)
{
	if (soap_out_wsnt__FilterType(soap, tag ? tag : "wsnt:FilterType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct wsnt__FilterType * SOAP_FMAC4 soap_get_wsnt__FilterType(struct soap *soap, struct wsnt__FilterType *p, const char *tag, const char *type)
{
	if ((p = soap_in_wsnt__FilterType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_wsnt__TopicExpressionType(struct soap *soap, struct wsnt__TopicExpressionType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__any = NULL;
	soap_default_xsd__anyURI(soap, &a->Dialect);
	a->__anyAttribute = NULL;
	a->__mixed = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_wsnt__TopicExpressionType(struct soap *soap, const struct wsnt__TopicExpressionType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_wsnt__TopicExpressionType(struct soap *soap, const char *tag, int id, const struct wsnt__TopicExpressionType *a, const char *type)
{
	soap_set_attr(soap, "Dialect", a->Dialect ? soap_xsd__anyURI2s(soap, a->Dialect) : "", 1);
	if (a->__anyAttribute)
		soap_set_attr(soap, "-anyAttribute", a->__anyAttribute, 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_wsnt__TopicExpressionType), type))
		return soap->error;
	if (soap_outliteral(soap, "-any", (char*const*)&a->__any, NULL))
		return soap->error;
	if (soap_outliteral(soap, "-mixed", (char*const*)&a->__mixed, NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct wsnt__TopicExpressionType * SOAP_FMAC4 soap_in_wsnt__TopicExpressionType(struct soap *soap, const char *tag, struct wsnt__TopicExpressionType *a, const char *type)
{
	size_t soap_flag___any = 1;
	size_t soap_flag___mixed = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct wsnt__TopicExpressionType*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_wsnt__TopicExpressionType, sizeof(struct wsnt__TopicExpressionType), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_wsnt__TopicExpressionType(soap, a);
	if (soap_s2xsd__anyURI(soap, soap_attr_value(soap, "Dialect", 4, 1), &a->Dialect))
		return NULL;
	if (soap_s2char(soap, soap_attr_value(soap, "-anyAttribute", 0, 0), &a->__anyAttribute, 0, 0, -1, NULL))
		return NULL;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag___any && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_inliteral(soap, "-any", (char**)&a->__any))
				{	soap_flag___any--;
					continue;
				}
			}
			if (soap_flag___mixed && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_inliteral(soap, "-mixed", (char**)&a->__mixed))
				{	soap_flag___mixed--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct wsnt__TopicExpressionType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_wsnt__TopicExpressionType, SOAP_TYPE_wsnt__TopicExpressionType, sizeof(struct wsnt__TopicExpressionType), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct wsnt__TopicExpressionType * SOAP_FMAC4 soap_new_wsnt__TopicExpressionType(struct soap *soap, int n)
{
	struct wsnt__TopicExpressionType *p;
	struct wsnt__TopicExpressionType *a = (struct wsnt__TopicExpressionType*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct wsnt__TopicExpressionType));
	for (p = a; p && n--; p++)
		soap_default_wsnt__TopicExpressionType(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_wsnt__TopicExpressionType(struct soap *soap, const struct wsnt__TopicExpressionType *a, const char *tag, const char *type)
{
	if (soap_out_wsnt__TopicExpressionType(soap, tag ? tag : "wsnt:TopicExpressionType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct wsnt__TopicExpressionType * SOAP_FMAC4 soap_get_wsnt__TopicExpressionType(struct soap *soap, struct wsnt__TopicExpressionType *p, const char *tag, const char *type)
{
	if ((p = soap_in_wsnt__TopicExpressionType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_wsnt__QueryExpressionType(struct soap *soap, struct wsnt__QueryExpressionType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__any = NULL;
	soap_default_xsd__anyURI(soap, &a->Dialect);
	a->__mixed = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_wsnt__QueryExpressionType(struct soap *soap, const struct wsnt__QueryExpressionType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_wsnt__QueryExpressionType(struct soap *soap, const char *tag, int id, const struct wsnt__QueryExpressionType *a, const char *type)
{
	soap_set_attr(soap, "Dialect", a->Dialect ? soap_xsd__anyURI2s(soap, a->Dialect) : "", 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_wsnt__QueryExpressionType), type))
		return soap->error;
	if (soap_outliteral(soap, "-any", (char*const*)&a->__any, NULL))
		return soap->error;
	if (soap_outliteral(soap, "-mixed", (char*const*)&a->__mixed, NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct wsnt__QueryExpressionType * SOAP_FMAC4 soap_in_wsnt__QueryExpressionType(struct soap *soap, const char *tag, struct wsnt__QueryExpressionType *a, const char *type)
{
	size_t soap_flag___any = 1;
	size_t soap_flag___mixed = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct wsnt__QueryExpressionType*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_wsnt__QueryExpressionType, sizeof(struct wsnt__QueryExpressionType), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_wsnt__QueryExpressionType(soap, a);
	if (soap_s2xsd__anyURI(soap, soap_attr_value(soap, "Dialect", 4, 1), &a->Dialect))
		return NULL;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag___any && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_inliteral(soap, "-any", (char**)&a->__any))
				{	soap_flag___any--;
					continue;
				}
			}
			if (soap_flag___mixed && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_inliteral(soap, "-mixed", (char**)&a->__mixed))
				{	soap_flag___mixed--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct wsnt__QueryExpressionType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_wsnt__QueryExpressionType, SOAP_TYPE_wsnt__QueryExpressionType, sizeof(struct wsnt__QueryExpressionType), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct wsnt__QueryExpressionType * SOAP_FMAC4 soap_new_wsnt__QueryExpressionType(struct soap *soap, int n)
{
	struct wsnt__QueryExpressionType *p;
	struct wsnt__QueryExpressionType *a = (struct wsnt__QueryExpressionType*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct wsnt__QueryExpressionType));
	for (p = a; p && n--; p++)
		soap_default_wsnt__QueryExpressionType(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_wsnt__QueryExpressionType(struct soap *soap, const struct wsnt__QueryExpressionType *a, const char *tag, const char *type)
{
	if (soap_out_wsnt__QueryExpressionType(soap, tag ? tag : "wsnt:QueryExpressionType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct wsnt__QueryExpressionType * SOAP_FMAC4 soap_get_wsnt__QueryExpressionType(struct soap *soap, struct wsnt__QueryExpressionType *p, const char *tag, const char *type)
{
	if ((p = soap_in_wsnt__QueryExpressionType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tt__Message(struct soap *soap, struct _tt__Message *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->Source = NULL;
	a->Key = NULL;
	a->Data = NULL;
	a->Extension = NULL;
	soap_default_dateTime(soap, &a->UtcTime);
	a->PropertyOperation = NULL;
	a->__anyAttribute = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tt__Message(struct soap *soap, const struct _tt__Message *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTott__ItemList(soap, &a->Source);
	soap_serialize_PointerTott__ItemList(soap, &a->Key);
	soap_serialize_PointerTott__ItemList(soap, &a->Data);
	soap_serialize_PointerTott__MessageExtension(soap, &a->Extension);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tt__Message(struct soap *soap, const char *tag, int id, const struct _tt__Message *a, const char *type)
{
	soap_set_attr(soap, "UtcTime", soap_dateTime2s(soap, a->UtcTime), 1);
	if (a->PropertyOperation)
	{	soap_set_attr(soap, "PropertyOperation", soap_tt__PropertyOperation2s(soap, *a->PropertyOperation), 1);
	}
	if (a->__anyAttribute)
		soap_set_attr(soap, "-anyAttribute", a->__anyAttribute, 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tt__Message), type))
		return soap->error;
	if (soap_out_PointerTott__ItemList(soap, "tt:Source", -1, &a->Source, ""))
		return soap->error;
	if (soap_out_PointerTott__ItemList(soap, "tt:Key", -1, &a->Key, ""))
		return soap->error;
	if (soap_out_PointerTott__ItemList(soap, "tt:Data", -1, &a->Data, ""))
		return soap->error;
	if (soap_out_PointerTott__MessageExtension(soap, "tt:Extension", -1, &a->Extension, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tt__Message * SOAP_FMAC4 soap_in__tt__Message(struct soap *soap, const char *tag, struct _tt__Message *a, const char *type)
{
	size_t soap_flag_Source = 1;
	size_t soap_flag_Key = 1;
	size_t soap_flag_Data = 1;
	size_t soap_flag_Extension = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct _tt__Message*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tt__Message, sizeof(struct _tt__Message), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tt__Message(soap, a);
	if (soap_s2dateTime(soap, soap_attr_value(soap, "UtcTime", 5, 1), &a->UtcTime))
		return NULL;
	{
		const char *t = soap_attr_value(soap, "PropertyOperation", 5, 0);
		if (t)
		{
			if (!(a->PropertyOperation = (enum tt__PropertyOperation *)soap_malloc(soap, sizeof(enum tt__PropertyOperation))))
				return NULL;
			if (soap_s2tt__PropertyOperation(soap, t, a->PropertyOperation))
				return NULL;
		}
		else if (soap->error)
			return NULL;
	}
	if (soap_s2char(soap, soap_attr_value(soap, "-anyAttribute", 0, 0), &a->__anyAttribute, 0, 0, -1, NULL))
		return NULL;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Source && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__ItemList(soap, "tt:Source", &a->Source, "tt:ItemList"))
				{	soap_flag_Source--;
					continue;
				}
			}
			if (soap_flag_Key && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__ItemList(soap, "tt:Key", &a->Key, "tt:ItemList"))
				{	soap_flag_Key--;
					continue;
				}
			}
			if (soap_flag_Data && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__ItemList(soap, "tt:Data", &a->Data, "tt:ItemList"))
				{	soap_flag_Data--;
					continue;
				}
			}
			if (soap_flag_Extension && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__MessageExtension(soap, "tt:Extension", &a->Extension, "tt:MessageExtension"))
				{	soap_flag_Extension--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _tt__Message *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tt__Message, SOAP_TYPE__tt__Message, sizeof(struct _tt__Message), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _tt__Message * SOAP_FMAC4 soap_new__tt__Message(struct soap *soap, int n)
{
	struct _tt__Message *p;
	struct _tt__Message *a = (struct _tt__Message*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _tt__Message));
	for (p = a; p && n--; p++)
		soap_default__tt__Message(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tt__Message(struct soap *soap, const struct _tt__Message *a, const char *tag, const char *type)
{
	if (soap_out__tt__Message(soap, tag ? tag : "tt:Message", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tt__Message * SOAP_FMAC4 soap_get__tt__Message(struct soap *soap, struct _tt__Message *p, const char *tag, const char *type)
{
	if ((p = soap_in__tt__Message(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__MediaUri(struct soap *soap, struct tt__MediaUri *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_xsd__anyURI(soap, &a->Uri);
	soap_default_xsd__boolean(soap, &a->InvalidAfterConnect);
	soap_default_xsd__boolean(soap, &a->InvalidAfterReboot);
	soap_default_xsd__duration(soap, &a->Timeout);
	a->__size = 0;
	a->__any = NULL;
	a->__anyAttribute = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__MediaUri(struct soap *soap, const struct tt__MediaUri *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_xsd__anyURI(soap, (char*const*)&a->Uri);
	soap_embedded(soap, &a->InvalidAfterConnect, SOAP_TYPE_xsd__boolean);
	soap_embedded(soap, &a->InvalidAfterReboot, SOAP_TYPE_xsd__boolean);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__MediaUri(struct soap *soap, const char *tag, int id, const struct tt__MediaUri *a, const char *type)
{
	if (a->__anyAttribute)
		soap_set_attr(soap, "-anyAttribute", a->__anyAttribute, 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__MediaUri), type))
		return soap->error;
	if (!a->Uri)
	{	if (soap_element_empty(soap, "tt:Uri", 0, NULL))
			return soap->error;
	}
	else if (soap_out_xsd__anyURI(soap, "tt:Uri", -1, (char*const*)&a->Uri, ""))
		return soap->error;
	if (soap_out_xsd__boolean(soap, "tt:InvalidAfterConnect", -1, &a->InvalidAfterConnect, ""))
		return soap->error;
	if (soap_out_xsd__boolean(soap, "tt:InvalidAfterReboot", -1, &a->InvalidAfterReboot, ""))
		return soap->error;
	if (soap_out_xsd__duration(soap, "tt:Timeout", -1, &a->Timeout, ""))
		return soap->error;
	if (a->__any)
	{	int i;
		for (i = 0; i < (int)a->__size; i++)
			if (soap_outliteral(soap, "-any", (char*const*)(a->__any + i), NULL))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__MediaUri * SOAP_FMAC4 soap_in_tt__MediaUri(struct soap *soap, const char *tag, struct tt__MediaUri *a, const char *type)
{
	size_t soap_flag_Uri = 1;
	size_t soap_flag_InvalidAfterConnect = 1;
	size_t soap_flag_InvalidAfterReboot = 1;
	size_t soap_flag_Timeout = 1;
	struct soap_blist *soap_blist___any = NULL;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct tt__MediaUri*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__MediaUri, sizeof(struct tt__MediaUri), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__MediaUri(soap, a);
	if (soap_s2char(soap, soap_attr_value(soap, "-anyAttribute", 0, 0), &a->__anyAttribute, 0, 0, -1, NULL))
		return NULL;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Uri && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_xsd__anyURI(soap, "tt:Uri", (char**)&a->Uri, "xsd:anyURI"))
				{	soap_flag_Uri--;
					continue;
				}
			}
			if (soap_flag_InvalidAfterConnect && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_xsd__boolean(soap, "tt:InvalidAfterConnect", &a->InvalidAfterConnect, "xsd:boolean"))
				{	soap_flag_InvalidAfterConnect--;
					continue;
				}
			}
			if (soap_flag_InvalidAfterReboot && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_xsd__boolean(soap, "tt:InvalidAfterReboot", &a->InvalidAfterReboot, "xsd:boolean"))
				{	soap_flag_InvalidAfterReboot--;
					continue;
				}
			}
			if (soap_flag_Timeout && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_xsd__duration(soap, "tt:Timeout", &a->Timeout, "xsd:duration"))
				{	soap_flag_Timeout--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	if (a->__any == NULL)
				{	if (soap_blist___any == NULL)
						soap_blist___any = soap_alloc_block(soap);
					a->__any = (char **)soap_push_block_max(soap, soap_blist___any, sizeof(char *));
					if (a->__any == NULL)
						return NULL;
					*a->__any = NULL;
				}
				if (soap_inliteral(soap, "-any", (char**)a->__any))
				{	a->__size++;
					a->__any = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->__any)
			soap_pop_block(soap, soap_blist___any);
		if (a->__size)
		{	a->__any = (char **)soap_save_block(soap, soap_blist___any, NULL, 1);
		}
		else
		{	a->__any = NULL;
			if (soap_blist___any)
				soap_end_block(soap, soap_blist___any);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (!a->Uri || soap_flag_InvalidAfterConnect > 0 || soap_flag_InvalidAfterReboot > 0 || soap_flag_Timeout > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct tt__MediaUri *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__MediaUri, SOAP_TYPE_tt__MediaUri, sizeof(struct tt__MediaUri), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct tt__MediaUri * SOAP_FMAC4 soap_new_tt__MediaUri(struct soap *soap, int n)
{
	struct tt__MediaUri *p;
	struct tt__MediaUri *a = (struct tt__MediaUri*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct tt__MediaUri));
	for (p = a; p && n--; p++)
		soap_default_tt__MediaUri(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__MediaUri(struct soap *soap, const struct tt__MediaUri *a, const char *tag, const char *type)
{
	if (soap_out_tt__MediaUri(soap, tag ? tag : "tt:MediaUri", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__MediaUri * SOAP_FMAC4 soap_get_tt__MediaUri(struct soap *soap, struct tt__MediaUri *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__MediaUri(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__MulticastConfiguration(struct soap *soap, struct tt__MulticastConfiguration *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->Address = NULL;
	soap_default_int(soap, &a->Port);
	soap_default_int(soap, &a->TTL);
	soap_default_xsd__boolean(soap, &a->AutoStart);
	a->__size = 0;
	a->__any = NULL;
	a->__anyAttribute = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__MulticastConfiguration(struct soap *soap, const struct tt__MulticastConfiguration *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTott__IPAddress(soap, &a->Address);
	soap_embedded(soap, &a->Port, SOAP_TYPE_int);
	soap_embedded(soap, &a->TTL, SOAP_TYPE_int);
	soap_embedded(soap, &a->AutoStart, SOAP_TYPE_xsd__boolean);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__MulticastConfiguration(struct soap *soap, const char *tag, int id, const struct tt__MulticastConfiguration *a, const char *type)
{
	if (a->__anyAttribute)
		soap_set_attr(soap, "-anyAttribute", a->__anyAttribute, 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__MulticastConfiguration), type))
		return soap->error;
	if (!a->Address)
	{	if (soap_element_empty(soap, "tt:Address", 0, NULL))
			return soap->error;
	}
	else if (soap_out_PointerTott__IPAddress(soap, "tt:Address", -1, &a->Address, ""))
		return soap->error;
	if (soap_out_int(soap, "tt:Port", -1, &a->Port, ""))
		return soap->error;
	if (soap_out_int(soap, "tt:TTL", -1, &a->TTL, ""))
		return soap->error;
	if (soap_out_xsd__boolean(soap, "tt:AutoStart", -1, &a->AutoStart, ""))
		return soap->error;
	if (a->__any)
	{	int i;
		for (i = 0; i < (int)a->__size; i++)
			if (soap_outliteral(soap, "-any", (char*const*)(a->__any + i), NULL))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__MulticastConfiguration * SOAP_FMAC4 soap_in_tt__MulticastConfiguration(struct soap *soap, const char *tag, struct tt__MulticastConfiguration *a, const char *type)
{
	size_t soap_flag_Address = 1;
	size_t soap_flag_Port = 1;
	size_t soap_flag_TTL = 1;
	size_t soap_flag_AutoStart = 1;
	struct soap_blist *soap_blist___any = NULL;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct tt__MulticastConfiguration*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__MulticastConfiguration, sizeof(struct tt__MulticastConfiguration), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__MulticastConfiguration(soap, a);
	if (soap_s2char(soap, soap_attr_value(soap, "-anyAttribute", 0, 0), &a->__anyAttribute, 0, 0, -1, NULL))
		return NULL;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Address && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__IPAddress(soap, "tt:Address", &a->Address, "tt:IPAddress"))
				{	soap_flag_Address--;
					continue;
				}
			}
			if (soap_flag_Port && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_int(soap, "tt:Port", &a->Port, "xsd:int"))
				{	soap_flag_Port--;
					continue;
				}
			}
			if (soap_flag_TTL && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_int(soap, "tt:TTL", &a->TTL, "xsd:int"))
				{	soap_flag_TTL--;
					continue;
				}
			}
			if (soap_flag_AutoStart && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_xsd__boolean(soap, "tt:AutoStart", &a->AutoStart, "xsd:boolean"))
				{	soap_flag_AutoStart--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	if (a->__any == NULL)
				{	if (soap_blist___any == NULL)
						soap_blist___any = soap_alloc_block(soap);
					a->__any = (char **)soap_push_block_max(soap, soap_blist___any, sizeof(char *));
					if (a->__any == NULL)
						return NULL;
					*a->__any = NULL;
				}
				if (soap_inliteral(soap, "-any", (char**)a->__any))
				{	a->__size++;
					a->__any = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->__any)
			soap_pop_block(soap, soap_blist___any);
		if (a->__size)
		{	a->__any = (char **)soap_save_block(soap, soap_blist___any, NULL, 1);
		}
		else
		{	a->__any = NULL;
			if (soap_blist___any)
				soap_end_block(soap, soap_blist___any);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (!a->Address || soap_flag_Port > 0 || soap_flag_TTL > 0 || soap_flag_AutoStart > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct tt__MulticastConfiguration *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__MulticastConfiguration, SOAP_TYPE_tt__MulticastConfiguration, sizeof(struct tt__MulticastConfiguration), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct tt__MulticastConfiguration * SOAP_FMAC4 soap_new_tt__MulticastConfiguration(struct soap *soap, int n)
{
	struct tt__MulticastConfiguration *p;
	struct tt__MulticastConfiguration *a = (struct tt__MulticastConfiguration*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct tt__MulticastConfiguration));
	for (p = a; p && n--; p++)
		soap_default_tt__MulticastConfiguration(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__MulticastConfiguration(struct soap *soap, const struct tt__MulticastConfiguration *a, const char *tag, const char *type)
{
	if (soap_out_tt__MulticastConfiguration(soap, tag ? tag : "tt:MulticastConfiguration", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__MulticastConfiguration * SOAP_FMAC4 soap_get_tt__MulticastConfiguration(struct soap *soap, struct tt__MulticastConfiguration *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__MulticastConfiguration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__IPAddress(struct soap *soap, struct tt__IPAddress *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_tt__IPType(soap, &a->Type);
	soap_default_tt__IPv4Address(soap, &a->IPv4Address);
	soap_default_tt__IPv6Address(soap, &a->IPv6Address);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__IPAddress(struct soap *soap, const struct tt__IPAddress *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_tt__IPv4Address(soap, (char*const*)&a->IPv4Address);
	soap_serialize_tt__IPv6Address(soap, (char*const*)&a->IPv6Address);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__IPAddress(struct soap *soap, const char *tag, int id, const struct tt__IPAddress *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__IPAddress), type))
		return soap->error;
	if (soap_out_tt__IPType(soap, "tt:Type", -1, &a->Type, ""))
		return soap->error;
	if (soap_out_tt__IPv4Address(soap, "tt:IPv4Address", -1, (char*const*)&a->IPv4Address, ""))
		return soap->error;
	if (soap_out_tt__IPv6Address(soap, "tt:IPv6Address", -1, (char*const*)&a->IPv6Address, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__IPAddress * SOAP_FMAC4 soap_in_tt__IPAddress(struct soap *soap, const char *tag, struct tt__IPAddress *a, const char *type)
{
	size_t soap_flag_Type = 1;
	size_t soap_flag_IPv4Address = 1;
	size_t soap_flag_IPv6Address = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct tt__IPAddress*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__IPAddress, sizeof(struct tt__IPAddress), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__IPAddress(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Type && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_tt__IPType(soap, "tt:Type", &a->Type, "tt:IPType"))
				{	soap_flag_Type--;
					continue;
				}
			}
			if (soap_flag_IPv4Address && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_tt__IPv4Address(soap, "tt:IPv4Address", (char**)&a->IPv4Address, "tt:IPv4Address"))
				{	soap_flag_IPv4Address--;
					continue;
				}
			}
			if (soap_flag_IPv6Address && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_tt__IPv6Address(soap, "tt:IPv6Address", (char**)&a->IPv6Address, "tt:IPv6Address"))
				{	soap_flag_IPv6Address--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Type > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct tt__IPAddress *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__IPAddress, SOAP_TYPE_tt__IPAddress, sizeof(struct tt__IPAddress), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct tt__IPAddress * SOAP_FMAC4 soap_new_tt__IPAddress(struct soap *soap, int n)
{
	struct tt__IPAddress *p;
	struct tt__IPAddress *a = (struct tt__IPAddress*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct tt__IPAddress));
	for (p = a; p && n--; p++)
		soap_default_tt__IPAddress(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__IPAddress(struct soap *soap, const struct tt__IPAddress *a, const char *tag, const char *type)
{
	if (soap_out_tt__IPAddress(soap, tag ? tag : "tt:IPAddress", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__IPAddress * SOAP_FMAC4 soap_get_tt__IPAddress(struct soap *soap, struct tt__IPAddress *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__IPAddress(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__VideoEncoderOptionsExtension2(struct soap *soap, struct tt__VideoEncoderOptionsExtension2 *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__size = 0;
	a->__any = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__VideoEncoderOptionsExtension2(struct soap *soap, const struct tt__VideoEncoderOptionsExtension2 *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__VideoEncoderOptionsExtension2(struct soap *soap, const char *tag, int id, const struct tt__VideoEncoderOptionsExtension2 *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__VideoEncoderOptionsExtension2), type))
		return soap->error;
	if (a->__any)
	{	int i;
		for (i = 0; i < (int)a->__size; i++)
			if (soap_outliteral(soap, "-any", (char*const*)(a->__any + i), NULL))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__VideoEncoderOptionsExtension2 * SOAP_FMAC4 soap_in_tt__VideoEncoderOptionsExtension2(struct soap *soap, const char *tag, struct tt__VideoEncoderOptionsExtension2 *a, const char *type)
{
	struct soap_blist *soap_blist___any = NULL;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct tt__VideoEncoderOptionsExtension2*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__VideoEncoderOptionsExtension2, sizeof(struct tt__VideoEncoderOptionsExtension2), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__VideoEncoderOptionsExtension2(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	if (a->__any == NULL)
				{	if (soap_blist___any == NULL)
						soap_blist___any = soap_alloc_block(soap);
					a->__any = (char **)soap_push_block_max(soap, soap_blist___any, sizeof(char *));
					if (a->__any == NULL)
						return NULL;
					*a->__any = NULL;
				}
				if (soap_inliteral(soap, "-any", (char**)a->__any))
				{	a->__size++;
					a->__any = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->__any)
			soap_pop_block(soap, soap_blist___any);
		if (a->__size)
		{	a->__any = (char **)soap_save_block(soap, soap_blist___any, NULL, 1);
		}
		else
		{	a->__any = NULL;
			if (soap_blist___any)
				soap_end_block(soap, soap_blist___any);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct tt__VideoEncoderOptionsExtension2 *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__VideoEncoderOptionsExtension2, SOAP_TYPE_tt__VideoEncoderOptionsExtension2, sizeof(struct tt__VideoEncoderOptionsExtension2), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct tt__VideoEncoderOptionsExtension2 * SOAP_FMAC4 soap_new_tt__VideoEncoderOptionsExtension2(struct soap *soap, int n)
{
	struct tt__VideoEncoderOptionsExtension2 *p;
	struct tt__VideoEncoderOptionsExtension2 *a = (struct tt__VideoEncoderOptionsExtension2*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct tt__VideoEncoderOptionsExtension2));
	for (p = a; p && n--; p++)
		soap_default_tt__VideoEncoderOptionsExtension2(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__VideoEncoderOptionsExtension2(struct soap *soap, const struct tt__VideoEncoderOptionsExtension2 *a, const char *tag, const char *type)
{
	if (soap_out_tt__VideoEncoderOptionsExtension2(soap, tag ? tag : "tt:VideoEncoderOptionsExtension2", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__VideoEncoderOptionsExtension2 * SOAP_FMAC4 soap_get_tt__VideoEncoderOptionsExtension2(struct soap *soap, struct tt__VideoEncoderOptionsExtension2 *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__VideoEncoderOptionsExtension2(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__H264Options2(struct soap *soap, struct tt__H264Options2 *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__sizeResolutionsAvailable = 0;
	a->ResolutionsAvailable = NULL;
	a->GovLengthRange = NULL;
	a->FrameRateRange = NULL;
	a->EncodingIntervalRange = NULL;
	a->__sizeH264ProfilesSupported = 0;
	a->H264ProfilesSupported = NULL;
	a->BitrateRange = NULL;
	a->__size = 0;
	a->__any = NULL;
	a->__anyAttribute = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__H264Options2(struct soap *soap, const struct tt__H264Options2 *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (a->ResolutionsAvailable)
	{	int i;
		for (i = 0; i < (int)a->__sizeResolutionsAvailable; i++)
		{
			soap_embedded(soap, a->ResolutionsAvailable + i, SOAP_TYPE_tt__VideoResolution);
			soap_serialize_tt__VideoResolution(soap, a->ResolutionsAvailable + i);
		}
	}
	soap_serialize_PointerTott__IntRange(soap, &a->GovLengthRange);
	soap_serialize_PointerTott__IntRange(soap, &a->FrameRateRange);
	soap_serialize_PointerTott__IntRange(soap, &a->EncodingIntervalRange);
	if (a->H264ProfilesSupported)
	{	int i;
		for (i = 0; i < (int)a->__sizeH264ProfilesSupported; i++)
		{
			soap_embedded(soap, a->H264ProfilesSupported + i, SOAP_TYPE_tt__H264Profile);
		}
	}
	soap_serialize_PointerTott__IntRange(soap, &a->BitrateRange);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__H264Options2(struct soap *soap, const char *tag, int id, const struct tt__H264Options2 *a, const char *type)
{
	if (a->__anyAttribute)
		soap_set_attr(soap, "-anyAttribute", a->__anyAttribute, 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__H264Options2), type))
		return soap->error;
	if (a->ResolutionsAvailable)
	{	int i;
		for (i = 0; i < (int)a->__sizeResolutionsAvailable; i++)
			if (soap_out_tt__VideoResolution(soap, "tt:ResolutionsAvailable", -1, a->ResolutionsAvailable + i, ""))
				return soap->error;
	}
	if (!a->GovLengthRange)
	{	if (soap_element_empty(soap, "tt:GovLengthRange", 0, NULL))
			return soap->error;
	}
	else if (soap_out_PointerTott__IntRange(soap, "tt:GovLengthRange", -1, &a->GovLengthRange, ""))
		return soap->error;
	if (!a->FrameRateRange)
	{	if (soap_element_empty(soap, "tt:FrameRateRange", 0, NULL))
			return soap->error;
	}
	else if (soap_out_PointerTott__IntRange(soap, "tt:FrameRateRange", -1, &a->FrameRateRange, ""))
		return soap->error;
	if (!a->EncodingIntervalRange)
	{	if (soap_element_empty(soap, "tt:EncodingIntervalRange", 0, NULL))
			return soap->error;
	}
	else if (soap_out_PointerTott__IntRange(soap, "tt:EncodingIntervalRange", -1, &a->EncodingIntervalRange, ""))
		return soap->error;
	if (a->H264ProfilesSupported)
	{	int i;
		for (i = 0; i < (int)a->__sizeH264ProfilesSupported; i++)
			if (soap_out_tt__H264Profile(soap, "tt:H264ProfilesSupported", -1, a->H264ProfilesSupported + i, ""))
				return soap->error;
	}
	if (!a->BitrateRange)
	{	if (soap_element_empty(soap, "tt:BitrateRange", 0, NULL))
			return soap->error;
	}
	else if (soap_out_PointerTott__IntRange(soap, "tt:BitrateRange", -1, &a->BitrateRange, ""))
		return soap->error;
	if (a->__any)
	{	int i;
		for (i = 0; i < (int)a->__size; i++)
			if (soap_outliteral(soap, "-any", (char*const*)(a->__any + i), NULL))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__H264Options2 * SOAP_FMAC4 soap_in_tt__H264Options2(struct soap *soap, const char *tag, struct tt__H264Options2 *a, const char *type)
{
	struct soap_blist *soap_blist_ResolutionsAvailable = NULL;
	size_t soap_flag_GovLengthRange = 1;
	size_t soap_flag_FrameRateRange = 1;
	size_t soap_flag_EncodingIntervalRange = 1;
	struct soap_blist *soap_blist_H264ProfilesSupported = NULL;
	size_t soap_flag_BitrateRange = 1;
	struct soap_blist *soap_blist___any = NULL;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct tt__H264Options2*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__H264Options2, sizeof(struct tt__H264Options2), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__H264Options2(soap, a);
	if (soap_s2char(soap, soap_attr_value(soap, "-anyAttribute", 0, 0), &a->__anyAttribute, 0, 0, -1, NULL))
		return NULL;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "tt:ResolutionsAvailable", 1, NULL))
			{	if (a->ResolutionsAvailable == NULL)
				{	if (soap_blist_ResolutionsAvailable == NULL)
						soap_blist_ResolutionsAvailable = soap_alloc_block(soap);
					a->ResolutionsAvailable = (struct tt__VideoResolution *)soap_push_block_max(soap, soap_blist_ResolutionsAvailable, sizeof(struct tt__VideoResolution));
					if (a->ResolutionsAvailable == NULL)
						return NULL;
					soap_default_tt__VideoResolution(soap, a->ResolutionsAvailable);
				}
				soap_revert(soap);
				if (soap_in_tt__VideoResolution(soap, "tt:ResolutionsAvailable", a->ResolutionsAvailable, "tt:VideoResolution"))
				{	a->__sizeResolutionsAvailable++;
					a->ResolutionsAvailable = NULL;
					continue;
				}
			}
			if (soap_flag_GovLengthRange && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__IntRange(soap, "tt:GovLengthRange", &a->GovLengthRange, "tt:IntRange"))
				{	soap_flag_GovLengthRange--;
					continue;
				}
			}
			if (soap_flag_FrameRateRange && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__IntRange(soap, "tt:FrameRateRange", &a->FrameRateRange, "tt:IntRange"))
				{	soap_flag_FrameRateRange--;
					continue;
				}
			}
			if (soap_flag_EncodingIntervalRange && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__IntRange(soap, "tt:EncodingIntervalRange", &a->EncodingIntervalRange, "tt:IntRange"))
				{	soap_flag_EncodingIntervalRange--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "tt:H264ProfilesSupported", 1, NULL))
			{	if (a->H264ProfilesSupported == NULL)
				{	if (soap_blist_H264ProfilesSupported == NULL)
						soap_blist_H264ProfilesSupported = soap_alloc_block(soap);
					a->H264ProfilesSupported = (enum tt__H264Profile *)soap_push_block_max(soap, soap_blist_H264ProfilesSupported, sizeof(enum tt__H264Profile));
					if (a->H264ProfilesSupported == NULL)
						return NULL;
					soap_default_tt__H264Profile(soap, a->H264ProfilesSupported);
				}
				soap_revert(soap);
				if (soap_in_tt__H264Profile(soap, "tt:H264ProfilesSupported", a->H264ProfilesSupported, "tt:H264Profile"))
				{	a->__sizeH264ProfilesSupported++;
					a->H264ProfilesSupported = NULL;
					continue;
				}
			}
			if (soap_flag_BitrateRange && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__IntRange(soap, "tt:BitrateRange", &a->BitrateRange, "tt:IntRange"))
				{	soap_flag_BitrateRange--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	if (a->__any == NULL)
				{	if (soap_blist___any == NULL)
						soap_blist___any = soap_alloc_block(soap);
					a->__any = (char **)soap_push_block_max(soap, soap_blist___any, sizeof(char *));
					if (a->__any == NULL)
						return NULL;
					*a->__any = NULL;
				}
				if (soap_inliteral(soap, "-any", (char**)a->__any))
				{	a->__size++;
					a->__any = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->ResolutionsAvailable)
			soap_pop_block(soap, soap_blist_ResolutionsAvailable);
		if (a->__sizeResolutionsAvailable)
		{	a->ResolutionsAvailable = (struct tt__VideoResolution *)soap_save_block(soap, soap_blist_ResolutionsAvailable, NULL, 1);
		}
		else
		{	a->ResolutionsAvailable = NULL;
			if (soap_blist_ResolutionsAvailable)
				soap_end_block(soap, soap_blist_ResolutionsAvailable);
		}
		if (a->H264ProfilesSupported)
			soap_pop_block(soap, soap_blist_H264ProfilesSupported);
		if (a->__sizeH264ProfilesSupported)
		{	a->H264ProfilesSupported = (enum tt__H264Profile *)soap_save_block(soap, soap_blist_H264ProfilesSupported, NULL, 1);
		}
		else
		{	a->H264ProfilesSupported = NULL;
			if (soap_blist_H264ProfilesSupported)
				soap_end_block(soap, soap_blist_H264ProfilesSupported);
		}
		if (a->__any)
			soap_pop_block(soap, soap_blist___any);
		if (a->__size)
		{	a->__any = (char **)soap_save_block(soap, soap_blist___any, NULL, 1);
		}
		else
		{	a->__any = NULL;
			if (soap_blist___any)
				soap_end_block(soap, soap_blist___any);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (a->__sizeResolutionsAvailable < 1 || !a->GovLengthRange || !a->FrameRateRange || !a->EncodingIntervalRange || a->__sizeH264ProfilesSupported < 1 || !a->BitrateRange))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct tt__H264Options2 *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__H264Options2, SOAP_TYPE_tt__H264Options2, sizeof(struct tt__H264Options2), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct tt__H264Options2 * SOAP_FMAC4 soap_new_tt__H264Options2(struct soap *soap, int n)
{
	struct tt__H264Options2 *p;
	struct tt__H264Options2 *a = (struct tt__H264Options2*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct tt__H264Options2));
	for (p = a; p && n--; p++)
		soap_default_tt__H264Options2(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__H264Options2(struct soap *soap, const struct tt__H264Options2 *a, const char *tag, const char *type)
{
	if (soap_out_tt__H264Options2(soap, tag ? tag : "tt:H264Options2", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__H264Options2 * SOAP_FMAC4 soap_get_tt__H264Options2(struct soap *soap, struct tt__H264Options2 *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__H264Options2(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__Mpeg4Options2(struct soap *soap, struct tt__Mpeg4Options2 *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__sizeResolutionsAvailable = 0;
	a->ResolutionsAvailable = NULL;
	a->GovLengthRange = NULL;
	a->FrameRateRange = NULL;
	a->EncodingIntervalRange = NULL;
	a->__sizeMpeg4ProfilesSupported = 0;
	a->Mpeg4ProfilesSupported = NULL;
	a->BitrateRange = NULL;
	a->__size = 0;
	a->__any = NULL;
	a->__anyAttribute = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__Mpeg4Options2(struct soap *soap, const struct tt__Mpeg4Options2 *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (a->ResolutionsAvailable)
	{	int i;
		for (i = 0; i < (int)a->__sizeResolutionsAvailable; i++)
		{
			soap_embedded(soap, a->ResolutionsAvailable + i, SOAP_TYPE_tt__VideoResolution);
			soap_serialize_tt__VideoResolution(soap, a->ResolutionsAvailable + i);
		}
	}
	soap_serialize_PointerTott__IntRange(soap, &a->GovLengthRange);
	soap_serialize_PointerTott__IntRange(soap, &a->FrameRateRange);
	soap_serialize_PointerTott__IntRange(soap, &a->EncodingIntervalRange);
	if (a->Mpeg4ProfilesSupported)
	{	int i;
		for (i = 0; i < (int)a->__sizeMpeg4ProfilesSupported; i++)
		{
			soap_embedded(soap, a->Mpeg4ProfilesSupported + i, SOAP_TYPE_tt__Mpeg4Profile);
		}
	}
	soap_serialize_PointerTott__IntRange(soap, &a->BitrateRange);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__Mpeg4Options2(struct soap *soap, const char *tag, int id, const struct tt__Mpeg4Options2 *a, const char *type)
{
	if (a->__anyAttribute)
		soap_set_attr(soap, "-anyAttribute", a->__anyAttribute, 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__Mpeg4Options2), type))
		return soap->error;
	if (a->ResolutionsAvailable)
	{	int i;
		for (i = 0; i < (int)a->__sizeResolutionsAvailable; i++)
			if (soap_out_tt__VideoResolution(soap, "tt:ResolutionsAvailable", -1, a->ResolutionsAvailable + i, ""))
				return soap->error;
	}
	if (!a->GovLengthRange)
	{	if (soap_element_empty(soap, "tt:GovLengthRange", 0, NULL))
			return soap->error;
	}
	else if (soap_out_PointerTott__IntRange(soap, "tt:GovLengthRange", -1, &a->GovLengthRange, ""))
		return soap->error;
	if (!a->FrameRateRange)
	{	if (soap_element_empty(soap, "tt:FrameRateRange", 0, NULL))
			return soap->error;
	}
	else if (soap_out_PointerTott__IntRange(soap, "tt:FrameRateRange", -1, &a->FrameRateRange, ""))
		return soap->error;
	if (!a->EncodingIntervalRange)
	{	if (soap_element_empty(soap, "tt:EncodingIntervalRange", 0, NULL))
			return soap->error;
	}
	else if (soap_out_PointerTott__IntRange(soap, "tt:EncodingIntervalRange", -1, &a->EncodingIntervalRange, ""))
		return soap->error;
	if (a->Mpeg4ProfilesSupported)
	{	int i;
		for (i = 0; i < (int)a->__sizeMpeg4ProfilesSupported; i++)
			if (soap_out_tt__Mpeg4Profile(soap, "tt:Mpeg4ProfilesSupported", -1, a->Mpeg4ProfilesSupported + i, ""))
				return soap->error;
	}
	if (!a->BitrateRange)
	{	if (soap_element_empty(soap, "tt:BitrateRange", 0, NULL))
			return soap->error;
	}
	else if (soap_out_PointerTott__IntRange(soap, "tt:BitrateRange", -1, &a->BitrateRange, ""))
		return soap->error;
	if (a->__any)
	{	int i;
		for (i = 0; i < (int)a->__size; i++)
			if (soap_outliteral(soap, "-any", (char*const*)(a->__any + i), NULL))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__Mpeg4Options2 * SOAP_FMAC4 soap_in_tt__Mpeg4Options2(struct soap *soap, const char *tag, struct tt__Mpeg4Options2 *a, const char *type)
{
	struct soap_blist *soap_blist_ResolutionsAvailable = NULL;
	size_t soap_flag_GovLengthRange = 1;
	size_t soap_flag_FrameRateRange = 1;
	size_t soap_flag_EncodingIntervalRange = 1;
	struct soap_blist *soap_blist_Mpeg4ProfilesSupported = NULL;
	size_t soap_flag_BitrateRange = 1;
	struct soap_blist *soap_blist___any = NULL;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct tt__Mpeg4Options2*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__Mpeg4Options2, sizeof(struct tt__Mpeg4Options2), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__Mpeg4Options2(soap, a);
	if (soap_s2char(soap, soap_attr_value(soap, "-anyAttribute", 0, 0), &a->__anyAttribute, 0, 0, -1, NULL))
		return NULL;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "tt:ResolutionsAvailable", 1, NULL))
			{	if (a->ResolutionsAvailable == NULL)
				{	if (soap_blist_ResolutionsAvailable == NULL)
						soap_blist_ResolutionsAvailable = soap_alloc_block(soap);
					a->ResolutionsAvailable = (struct tt__VideoResolution *)soap_push_block_max(soap, soap_blist_ResolutionsAvailable, sizeof(struct tt__VideoResolution));
					if (a->ResolutionsAvailable == NULL)
						return NULL;
					soap_default_tt__VideoResolution(soap, a->ResolutionsAvailable);
				}
				soap_revert(soap);
				if (soap_in_tt__VideoResolution(soap, "tt:ResolutionsAvailable", a->ResolutionsAvailable, "tt:VideoResolution"))
				{	a->__sizeResolutionsAvailable++;
					a->ResolutionsAvailable = NULL;
					continue;
				}
			}
			if (soap_flag_GovLengthRange && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__IntRange(soap, "tt:GovLengthRange", &a->GovLengthRange, "tt:IntRange"))
				{	soap_flag_GovLengthRange--;
					continue;
				}
			}
			if (soap_flag_FrameRateRange && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__IntRange(soap, "tt:FrameRateRange", &a->FrameRateRange, "tt:IntRange"))
				{	soap_flag_FrameRateRange--;
					continue;
				}
			}
			if (soap_flag_EncodingIntervalRange && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__IntRange(soap, "tt:EncodingIntervalRange", &a->EncodingIntervalRange, "tt:IntRange"))
				{	soap_flag_EncodingIntervalRange--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "tt:Mpeg4ProfilesSupported", 1, NULL))
			{	if (a->Mpeg4ProfilesSupported == NULL)
				{	if (soap_blist_Mpeg4ProfilesSupported == NULL)
						soap_blist_Mpeg4ProfilesSupported = soap_alloc_block(soap);
					a->Mpeg4ProfilesSupported = (enum tt__Mpeg4Profile *)soap_push_block_max(soap, soap_blist_Mpeg4ProfilesSupported, sizeof(enum tt__Mpeg4Profile));
					if (a->Mpeg4ProfilesSupported == NULL)
						return NULL;
					soap_default_tt__Mpeg4Profile(soap, a->Mpeg4ProfilesSupported);
				}
				soap_revert(soap);
				if (soap_in_tt__Mpeg4Profile(soap, "tt:Mpeg4ProfilesSupported", a->Mpeg4ProfilesSupported, "tt:Mpeg4Profile"))
				{	a->__sizeMpeg4ProfilesSupported++;
					a->Mpeg4ProfilesSupported = NULL;
					continue;
				}
			}
			if (soap_flag_BitrateRange && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__IntRange(soap, "tt:BitrateRange", &a->BitrateRange, "tt:IntRange"))
				{	soap_flag_BitrateRange--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	if (a->__any == NULL)
				{	if (soap_blist___any == NULL)
						soap_blist___any = soap_alloc_block(soap);
					a->__any = (char **)soap_push_block_max(soap, soap_blist___any, sizeof(char *));
					if (a->__any == NULL)
						return NULL;
					*a->__any = NULL;
				}
				if (soap_inliteral(soap, "-any", (char**)a->__any))
				{	a->__size++;
					a->__any = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->ResolutionsAvailable)
			soap_pop_block(soap, soap_blist_ResolutionsAvailable);
		if (a->__sizeResolutionsAvailable)
		{	a->ResolutionsAvailable = (struct tt__VideoResolution *)soap_save_block(soap, soap_blist_ResolutionsAvailable, NULL, 1);
		}
		else
		{	a->ResolutionsAvailable = NULL;
			if (soap_blist_ResolutionsAvailable)
				soap_end_block(soap, soap_blist_ResolutionsAvailable);
		}
		if (a->Mpeg4ProfilesSupported)
			soap_pop_block(soap, soap_blist_Mpeg4ProfilesSupported);
		if (a->__sizeMpeg4ProfilesSupported)
		{	a->Mpeg4ProfilesSupported = (enum tt__Mpeg4Profile *)soap_save_block(soap, soap_blist_Mpeg4ProfilesSupported, NULL, 1);
		}
		else
		{	a->Mpeg4ProfilesSupported = NULL;
			if (soap_blist_Mpeg4ProfilesSupported)
				soap_end_block(soap, soap_blist_Mpeg4ProfilesSupported);
		}
		if (a->__any)
			soap_pop_block(soap, soap_blist___any);
		if (a->__size)
		{	a->__any = (char **)soap_save_block(soap, soap_blist___any, NULL, 1);
		}
		else
		{	a->__any = NULL;
			if (soap_blist___any)
				soap_end_block(soap, soap_blist___any);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (a->__sizeResolutionsAvailable < 1 || !a->GovLengthRange || !a->FrameRateRange || !a->EncodingIntervalRange || a->__sizeMpeg4ProfilesSupported < 1 || !a->BitrateRange))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct tt__Mpeg4Options2 *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__Mpeg4Options2, SOAP_TYPE_tt__Mpeg4Options2, sizeof(struct tt__Mpeg4Options2), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct tt__Mpeg4Options2 * SOAP_FMAC4 soap_new_tt__Mpeg4Options2(struct soap *soap, int n)
{
	struct tt__Mpeg4Options2 *p;
	struct tt__Mpeg4Options2 *a = (struct tt__Mpeg4Options2*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct tt__Mpeg4Options2));
	for (p = a; p && n--; p++)
		soap_default_tt__Mpeg4Options2(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__Mpeg4Options2(struct soap *soap, const struct tt__Mpeg4Options2 *a, const char *tag, const char *type)
{
	if (soap_out_tt__Mpeg4Options2(soap, tag ? tag : "tt:Mpeg4Options2", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__Mpeg4Options2 * SOAP_FMAC4 soap_get_tt__Mpeg4Options2(struct soap *soap, struct tt__Mpeg4Options2 *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__Mpeg4Options2(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__JpegOptions2(struct soap *soap, struct tt__JpegOptions2 *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__sizeResolutionsAvailable = 0;
	a->ResolutionsAvailable = NULL;
	a->FrameRateRange = NULL;
	a->EncodingIntervalRange = NULL;
	a->BitrateRange = NULL;
	a->__size = 0;
	a->__any = NULL;
	a->__anyAttribute = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__JpegOptions2(struct soap *soap, const struct tt__JpegOptions2 *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (a->ResolutionsAvailable)
	{	int i;
		for (i = 0; i < (int)a->__sizeResolutionsAvailable; i++)
		{
			soap_embedded(soap, a->ResolutionsAvailable + i, SOAP_TYPE_tt__VideoResolution);
			soap_serialize_tt__VideoResolution(soap, a->ResolutionsAvailable + i);
		}
	}
	soap_serialize_PointerTott__IntRange(soap, &a->FrameRateRange);
	soap_serialize_PointerTott__IntRange(soap, &a->EncodingIntervalRange);
	soap_serialize_PointerTott__IntRange(soap, &a->BitrateRange);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__JpegOptions2(struct soap *soap, const char *tag, int id, const struct tt__JpegOptions2 *a, const char *type)
{
	if (a->__anyAttribute)
		soap_set_attr(soap, "-anyAttribute", a->__anyAttribute, 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__JpegOptions2), type))
		return soap->error;
	if (a->ResolutionsAvailable)
	{	int i;
		for (i = 0; i < (int)a->__sizeResolutionsAvailable; i++)
			if (soap_out_tt__VideoResolution(soap, "tt:ResolutionsAvailable", -1, a->ResolutionsAvailable + i, ""))
				return soap->error;
	}
	if (!a->FrameRateRange)
	{	if (soap_element_empty(soap, "tt:FrameRateRange", 0, NULL))
			return soap->error;
	}
	else if (soap_out_PointerTott__IntRange(soap, "tt:FrameRateRange", -1, &a->FrameRateRange, ""))
		return soap->error;
	if (!a->EncodingIntervalRange)
	{	if (soap_element_empty(soap, "tt:EncodingIntervalRange", 0, NULL))
			return soap->error;
	}
	else if (soap_out_PointerTott__IntRange(soap, "tt:EncodingIntervalRange", -1, &a->EncodingIntervalRange, ""))
		return soap->error;
	if (!a->BitrateRange)
	{	if (soap_element_empty(soap, "tt:BitrateRange", 0, NULL))
			return soap->error;
	}
	else if (soap_out_PointerTott__IntRange(soap, "tt:BitrateRange", -1, &a->BitrateRange, ""))
		return soap->error;
	if (a->__any)
	{	int i;
		for (i = 0; i < (int)a->__size; i++)
			if (soap_outliteral(soap, "-any", (char*const*)(a->__any + i), NULL))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__JpegOptions2 * SOAP_FMAC4 soap_in_tt__JpegOptions2(struct soap *soap, const char *tag, struct tt__JpegOptions2 *a, const char *type)
{
	struct soap_blist *soap_blist_ResolutionsAvailable = NULL;
	size_t soap_flag_FrameRateRange = 1;
	size_t soap_flag_EncodingIntervalRange = 1;
	size_t soap_flag_BitrateRange = 1;
	struct soap_blist *soap_blist___any = NULL;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct tt__JpegOptions2*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__JpegOptions2, sizeof(struct tt__JpegOptions2), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__JpegOptions2(soap, a);
	if (soap_s2char(soap, soap_attr_value(soap, "-anyAttribute", 0, 0), &a->__anyAttribute, 0, 0, -1, NULL))
		return NULL;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "tt:ResolutionsAvailable", 1, NULL))
			{	if (a->ResolutionsAvailable == NULL)
				{	if (soap_blist_ResolutionsAvailable == NULL)
						soap_blist_ResolutionsAvailable = soap_alloc_block(soap);
					a->ResolutionsAvailable = (struct tt__VideoResolution *)soap_push_block_max(soap, soap_blist_ResolutionsAvailable, sizeof(struct tt__VideoResolution));
					if (a->ResolutionsAvailable == NULL)
						return NULL;
					soap_default_tt__VideoResolution(soap, a->ResolutionsAvailable);
				}
				soap_revert(soap);
				if (soap_in_tt__VideoResolution(soap, "tt:ResolutionsAvailable", a->ResolutionsAvailable, "tt:VideoResolution"))
				{	a->__sizeResolutionsAvailable++;
					a->ResolutionsAvailable = NULL;
					continue;
				}
			}
			if (soap_flag_FrameRateRange && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__IntRange(soap, "tt:FrameRateRange", &a->FrameRateRange, "tt:IntRange"))
				{	soap_flag_FrameRateRange--;
					continue;
				}
			}
			if (soap_flag_EncodingIntervalRange && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__IntRange(soap, "tt:EncodingIntervalRange", &a->EncodingIntervalRange, "tt:IntRange"))
				{	soap_flag_EncodingIntervalRange--;
					continue;
				}
			}
			if (soap_flag_BitrateRange && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__IntRange(soap, "tt:BitrateRange", &a->BitrateRange, "tt:IntRange"))
				{	soap_flag_BitrateRange--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	if (a->__any == NULL)
				{	if (soap_blist___any == NULL)
						soap_blist___any = soap_alloc_block(soap);
					a->__any = (char **)soap_push_block_max(soap, soap_blist___any, sizeof(char *));
					if (a->__any == NULL)
						return NULL;
					*a->__any = NULL;
				}
				if (soap_inliteral(soap, "-any", (char**)a->__any))
				{	a->__size++;
					a->__any = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->ResolutionsAvailable)
			soap_pop_block(soap, soap_blist_ResolutionsAvailable);
		if (a->__sizeResolutionsAvailable)
		{	a->ResolutionsAvailable = (struct tt__VideoResolution *)soap_save_block(soap, soap_blist_ResolutionsAvailable, NULL, 1);
		}
		else
		{	a->ResolutionsAvailable = NULL;
			if (soap_blist_ResolutionsAvailable)
				soap_end_block(soap, soap_blist_ResolutionsAvailable);
		}
		if (a->__any)
			soap_pop_block(soap, soap_blist___any);
		if (a->__size)
		{	a->__any = (char **)soap_save_block(soap, soap_blist___any, NULL, 1);
		}
		else
		{	a->__any = NULL;
			if (soap_blist___any)
				soap_end_block(soap, soap_blist___any);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (a->__sizeResolutionsAvailable < 1 || !a->FrameRateRange || !a->EncodingIntervalRange || !a->BitrateRange))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct tt__JpegOptions2 *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__JpegOptions2, SOAP_TYPE_tt__JpegOptions2, sizeof(struct tt__JpegOptions2), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct tt__JpegOptions2 * SOAP_FMAC4 soap_new_tt__JpegOptions2(struct soap *soap, int n)
{
	struct tt__JpegOptions2 *p;
	struct tt__JpegOptions2 *a = (struct tt__JpegOptions2*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct tt__JpegOptions2));
	for (p = a; p && n--; p++)
		soap_default_tt__JpegOptions2(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__JpegOptions2(struct soap *soap, const struct tt__JpegOptions2 *a, const char *tag, const char *type)
{
	if (soap_out_tt__JpegOptions2(soap, tag ? tag : "tt:JpegOptions2", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__JpegOptions2 * SOAP_FMAC4 soap_get_tt__JpegOptions2(struct soap *soap, struct tt__JpegOptions2 *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__JpegOptions2(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__VideoEncoderOptionsExtension(struct soap *soap, struct tt__VideoEncoderOptionsExtension *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__size = 0;
	a->__any = NULL;
	a->JPEG = NULL;
	a->MPEG4 = NULL;
	a->H264 = NULL;
	a->Extension = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__VideoEncoderOptionsExtension(struct soap *soap, const struct tt__VideoEncoderOptionsExtension *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTott__JpegOptions2(soap, &a->JPEG);
	soap_serialize_PointerTott__Mpeg4Options2(soap, &a->MPEG4);
	soap_serialize_PointerTott__H264Options2(soap, &a->H264);
	soap_serialize_PointerTott__VideoEncoderOptionsExtension2(soap, &a->Extension);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__VideoEncoderOptionsExtension(struct soap *soap, const char *tag, int id, const struct tt__VideoEncoderOptionsExtension *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__VideoEncoderOptionsExtension), type))
		return soap->error;
	if (a->__any)
	{	int i;
		for (i = 0; i < (int)a->__size; i++)
			if (soap_outliteral(soap, "-any", (char*const*)(a->__any + i), NULL))
				return soap->error;
	}
	if (soap_out_PointerTott__JpegOptions2(soap, "tt:JPEG", -1, &a->JPEG, ""))
		return soap->error;
	if (soap_out_PointerTott__Mpeg4Options2(soap, "tt:MPEG4", -1, &a->MPEG4, ""))
		return soap->error;
	if (soap_out_PointerTott__H264Options2(soap, "tt:H264", -1, &a->H264, ""))
		return soap->error;
	if (soap_out_PointerTott__VideoEncoderOptionsExtension2(soap, "tt:Extension", -1, &a->Extension, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__VideoEncoderOptionsExtension * SOAP_FMAC4 soap_in_tt__VideoEncoderOptionsExtension(struct soap *soap, const char *tag, struct tt__VideoEncoderOptionsExtension *a, const char *type)
{
	struct soap_blist *soap_blist___any = NULL;
	size_t soap_flag_JPEG = 1;
	size_t soap_flag_MPEG4 = 1;
	size_t soap_flag_H264 = 1;
	size_t soap_flag_Extension = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct tt__VideoEncoderOptionsExtension*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__VideoEncoderOptionsExtension, sizeof(struct tt__VideoEncoderOptionsExtension), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__VideoEncoderOptionsExtension(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_JPEG && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__JpegOptions2(soap, "tt:JPEG", &a->JPEG, "tt:JpegOptions2"))
				{	soap_flag_JPEG--;
					continue;
				}
			}
			if (soap_flag_MPEG4 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__Mpeg4Options2(soap, "tt:MPEG4", &a->MPEG4, "tt:Mpeg4Options2"))
				{	soap_flag_MPEG4--;
					continue;
				}
			}
			if (soap_flag_H264 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__H264Options2(soap, "tt:H264", &a->H264, "tt:H264Options2"))
				{	soap_flag_H264--;
					continue;
				}
			}
			if (soap_flag_Extension && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__VideoEncoderOptionsExtension2(soap, "tt:Extension", &a->Extension, "tt:VideoEncoderOptionsExtension2"))
				{	soap_flag_Extension--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	if (a->__any == NULL)
				{	if (soap_blist___any == NULL)
						soap_blist___any = soap_alloc_block(soap);
					a->__any = (char **)soap_push_block_max(soap, soap_blist___any, sizeof(char *));
					if (a->__any == NULL)
						return NULL;
					*a->__any = NULL;
				}
				if (soap_inliteral(soap, "-any", (char**)a->__any))
				{	a->__size++;
					a->__any = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->__any)
			soap_pop_block(soap, soap_blist___any);
		if (a->__size)
		{	a->__any = (char **)soap_save_block(soap, soap_blist___any, NULL, 1);
		}
		else
		{	a->__any = NULL;
			if (soap_blist___any)
				soap_end_block(soap, soap_blist___any);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct tt__VideoEncoderOptionsExtension *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__VideoEncoderOptionsExtension, SOAP_TYPE_tt__VideoEncoderOptionsExtension, sizeof(struct tt__VideoEncoderOptionsExtension), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct tt__VideoEncoderOptionsExtension * SOAP_FMAC4 soap_new_tt__VideoEncoderOptionsExtension(struct soap *soap, int n)
{
	struct tt__VideoEncoderOptionsExtension *p;
	struct tt__VideoEncoderOptionsExtension *a = (struct tt__VideoEncoderOptionsExtension*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct tt__VideoEncoderOptionsExtension));
	for (p = a; p && n--; p++)
		soap_default_tt__VideoEncoderOptionsExtension(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__VideoEncoderOptionsExtension(struct soap *soap, const struct tt__VideoEncoderOptionsExtension *a, const char *tag, const char *type)
{
	if (soap_out_tt__VideoEncoderOptionsExtension(soap, tag ? tag : "tt:VideoEncoderOptionsExtension", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__VideoEncoderOptionsExtension * SOAP_FMAC4 soap_get_tt__VideoEncoderOptionsExtension(struct soap *soap, struct tt__VideoEncoderOptionsExtension *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__VideoEncoderOptionsExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__H264Options(struct soap *soap, struct tt__H264Options *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__sizeResolutionsAvailable = 0;
	a->ResolutionsAvailable = NULL;
	a->GovLengthRange = NULL;
	a->FrameRateRange = NULL;
	a->EncodingIntervalRange = NULL;
	a->__sizeH264ProfilesSupported = 0;
	a->H264ProfilesSupported = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__H264Options(struct soap *soap, const struct tt__H264Options *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (a->ResolutionsAvailable)
	{	int i;
		for (i = 0; i < (int)a->__sizeResolutionsAvailable; i++)
		{
			soap_embedded(soap, a->ResolutionsAvailable + i, SOAP_TYPE_tt__VideoResolution);
			soap_serialize_tt__VideoResolution(soap, a->ResolutionsAvailable + i);
		}
	}
	soap_serialize_PointerTott__IntRange(soap, &a->GovLengthRange);
	soap_serialize_PointerTott__IntRange(soap, &a->FrameRateRange);
	soap_serialize_PointerTott__IntRange(soap, &a->EncodingIntervalRange);
	if (a->H264ProfilesSupported)
	{	int i;
		for (i = 0; i < (int)a->__sizeH264ProfilesSupported; i++)
		{
			soap_embedded(soap, a->H264ProfilesSupported + i, SOAP_TYPE_tt__H264Profile);
		}
	}
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__H264Options(struct soap *soap, const char *tag, int id, const struct tt__H264Options *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__H264Options), type))
		return soap->error;
	if (a->ResolutionsAvailable)
	{	int i;
		for (i = 0; i < (int)a->__sizeResolutionsAvailable; i++)
			if (soap_out_tt__VideoResolution(soap, "tt:ResolutionsAvailable", -1, a->ResolutionsAvailable + i, ""))
				return soap->error;
	}
	if (!a->GovLengthRange)
	{	if (soap_element_empty(soap, "tt:GovLengthRange", 0, NULL))
			return soap->error;
	}
	else if (soap_out_PointerTott__IntRange(soap, "tt:GovLengthRange", -1, &a->GovLengthRange, ""))
		return soap->error;
	if (!a->FrameRateRange)
	{	if (soap_element_empty(soap, "tt:FrameRateRange", 0, NULL))
			return soap->error;
	}
	else if (soap_out_PointerTott__IntRange(soap, "tt:FrameRateRange", -1, &a->FrameRateRange, ""))
		return soap->error;
	if (!a->EncodingIntervalRange)
	{	if (soap_element_empty(soap, "tt:EncodingIntervalRange", 0, NULL))
			return soap->error;
	}
	else if (soap_out_PointerTott__IntRange(soap, "tt:EncodingIntervalRange", -1, &a->EncodingIntervalRange, ""))
		return soap->error;
	if (a->H264ProfilesSupported)
	{	int i;
		for (i = 0; i < (int)a->__sizeH264ProfilesSupported; i++)
			if (soap_out_tt__H264Profile(soap, "tt:H264ProfilesSupported", -1, a->H264ProfilesSupported + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__H264Options * SOAP_FMAC4 soap_in_tt__H264Options(struct soap *soap, const char *tag, struct tt__H264Options *a, const char *type)
{
	struct soap_blist *soap_blist_ResolutionsAvailable = NULL;
	size_t soap_flag_GovLengthRange = 1;
	size_t soap_flag_FrameRateRange = 1;
	size_t soap_flag_EncodingIntervalRange = 1;
	struct soap_blist *soap_blist_H264ProfilesSupported = NULL;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct tt__H264Options*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__H264Options, sizeof(struct tt__H264Options), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__H264Options(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "tt:ResolutionsAvailable", 1, NULL))
			{	if (a->ResolutionsAvailable == NULL)
				{	if (soap_blist_ResolutionsAvailable == NULL)
						soap_blist_ResolutionsAvailable = soap_alloc_block(soap);
					a->ResolutionsAvailable = (struct tt__VideoResolution *)soap_push_block_max(soap, soap_blist_ResolutionsAvailable, sizeof(struct tt__VideoResolution));
					if (a->ResolutionsAvailable == NULL)
						return NULL;
					soap_default_tt__VideoResolution(soap, a->ResolutionsAvailable);
				}
				soap_revert(soap);
				if (soap_in_tt__VideoResolution(soap, "tt:ResolutionsAvailable", a->ResolutionsAvailable, "tt:VideoResolution"))
				{	a->__sizeResolutionsAvailable++;
					a->ResolutionsAvailable = NULL;
					continue;
				}
			}
			if (soap_flag_GovLengthRange && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__IntRange(soap, "tt:GovLengthRange", &a->GovLengthRange, "tt:IntRange"))
				{	soap_flag_GovLengthRange--;
					continue;
				}
			}
			if (soap_flag_FrameRateRange && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__IntRange(soap, "tt:FrameRateRange", &a->FrameRateRange, "tt:IntRange"))
				{	soap_flag_FrameRateRange--;
					continue;
				}
			}
			if (soap_flag_EncodingIntervalRange && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__IntRange(soap, "tt:EncodingIntervalRange", &a->EncodingIntervalRange, "tt:IntRange"))
				{	soap_flag_EncodingIntervalRange--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "tt:H264ProfilesSupported", 1, NULL))
			{	if (a->H264ProfilesSupported == NULL)
				{	if (soap_blist_H264ProfilesSupported == NULL)
						soap_blist_H264ProfilesSupported = soap_alloc_block(soap);
					a->H264ProfilesSupported = (enum tt__H264Profile *)soap_push_block_max(soap, soap_blist_H264ProfilesSupported, sizeof(enum tt__H264Profile));
					if (a->H264ProfilesSupported == NULL)
						return NULL;
					soap_default_tt__H264Profile(soap, a->H264ProfilesSupported);
				}
				soap_revert(soap);
				if (soap_in_tt__H264Profile(soap, "tt:H264ProfilesSupported", a->H264ProfilesSupported, "tt:H264Profile"))
				{	a->__sizeH264ProfilesSupported++;
					a->H264ProfilesSupported = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->ResolutionsAvailable)
			soap_pop_block(soap, soap_blist_ResolutionsAvailable);
		if (a->__sizeResolutionsAvailable)
		{	a->ResolutionsAvailable = (struct tt__VideoResolution *)soap_save_block(soap, soap_blist_ResolutionsAvailable, NULL, 1);
		}
		else
		{	a->ResolutionsAvailable = NULL;
			if (soap_blist_ResolutionsAvailable)
				soap_end_block(soap, soap_blist_ResolutionsAvailable);
		}
		if (a->H264ProfilesSupported)
			soap_pop_block(soap, soap_blist_H264ProfilesSupported);
		if (a->__sizeH264ProfilesSupported)
		{	a->H264ProfilesSupported = (enum tt__H264Profile *)soap_save_block(soap, soap_blist_H264ProfilesSupported, NULL, 1);
		}
		else
		{	a->H264ProfilesSupported = NULL;
			if (soap_blist_H264ProfilesSupported)
				soap_end_block(soap, soap_blist_H264ProfilesSupported);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (a->__sizeResolutionsAvailable < 1 || !a->GovLengthRange || !a->FrameRateRange || !a->EncodingIntervalRange || a->__sizeH264ProfilesSupported < 1))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct tt__H264Options *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__H264Options, SOAP_TYPE_tt__H264Options, sizeof(struct tt__H264Options), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct tt__H264Options * SOAP_FMAC4 soap_new_tt__H264Options(struct soap *soap, int n)
{
	struct tt__H264Options *p;
	struct tt__H264Options *a = (struct tt__H264Options*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct tt__H264Options));
	for (p = a; p && n--; p++)
		soap_default_tt__H264Options(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__H264Options(struct soap *soap, const struct tt__H264Options *a, const char *tag, const char *type)
{
	if (soap_out_tt__H264Options(soap, tag ? tag : "tt:H264Options", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__H264Options * SOAP_FMAC4 soap_get_tt__H264Options(struct soap *soap, struct tt__H264Options *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__H264Options(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__Mpeg4Options(struct soap *soap, struct tt__Mpeg4Options *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__sizeResolutionsAvailable = 0;
	a->ResolutionsAvailable = NULL;
	a->GovLengthRange = NULL;
	a->FrameRateRange = NULL;
	a->EncodingIntervalRange = NULL;
	a->__sizeMpeg4ProfilesSupported = 0;
	a->Mpeg4ProfilesSupported = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__Mpeg4Options(struct soap *soap, const struct tt__Mpeg4Options *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (a->ResolutionsAvailable)
	{	int i;
		for (i = 0; i < (int)a->__sizeResolutionsAvailable; i++)
		{
			soap_embedded(soap, a->ResolutionsAvailable + i, SOAP_TYPE_tt__VideoResolution);
			soap_serialize_tt__VideoResolution(soap, a->ResolutionsAvailable + i);
		}
	}
	soap_serialize_PointerTott__IntRange(soap, &a->GovLengthRange);
	soap_serialize_PointerTott__IntRange(soap, &a->FrameRateRange);
	soap_serialize_PointerTott__IntRange(soap, &a->EncodingIntervalRange);
	if (a->Mpeg4ProfilesSupported)
	{	int i;
		for (i = 0; i < (int)a->__sizeMpeg4ProfilesSupported; i++)
		{
			soap_embedded(soap, a->Mpeg4ProfilesSupported + i, SOAP_TYPE_tt__Mpeg4Profile);
		}
	}
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__Mpeg4Options(struct soap *soap, const char *tag, int id, const struct tt__Mpeg4Options *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__Mpeg4Options), type))
		return soap->error;
	if (a->ResolutionsAvailable)
	{	int i;
		for (i = 0; i < (int)a->__sizeResolutionsAvailable; i++)
			if (soap_out_tt__VideoResolution(soap, "tt:ResolutionsAvailable", -1, a->ResolutionsAvailable + i, ""))
				return soap->error;
	}
	if (!a->GovLengthRange)
	{	if (soap_element_empty(soap, "tt:GovLengthRange", 0, NULL))
			return soap->error;
	}
	else if (soap_out_PointerTott__IntRange(soap, "tt:GovLengthRange", -1, &a->GovLengthRange, ""))
		return soap->error;
	if (!a->FrameRateRange)
	{	if (soap_element_empty(soap, "tt:FrameRateRange", 0, NULL))
			return soap->error;
	}
	else if (soap_out_PointerTott__IntRange(soap, "tt:FrameRateRange", -1, &a->FrameRateRange, ""))
		return soap->error;
	if (!a->EncodingIntervalRange)
	{	if (soap_element_empty(soap, "tt:EncodingIntervalRange", 0, NULL))
			return soap->error;
	}
	else if (soap_out_PointerTott__IntRange(soap, "tt:EncodingIntervalRange", -1, &a->EncodingIntervalRange, ""))
		return soap->error;
	if (a->Mpeg4ProfilesSupported)
	{	int i;
		for (i = 0; i < (int)a->__sizeMpeg4ProfilesSupported; i++)
			if (soap_out_tt__Mpeg4Profile(soap, "tt:Mpeg4ProfilesSupported", -1, a->Mpeg4ProfilesSupported + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__Mpeg4Options * SOAP_FMAC4 soap_in_tt__Mpeg4Options(struct soap *soap, const char *tag, struct tt__Mpeg4Options *a, const char *type)
{
	struct soap_blist *soap_blist_ResolutionsAvailable = NULL;
	size_t soap_flag_GovLengthRange = 1;
	size_t soap_flag_FrameRateRange = 1;
	size_t soap_flag_EncodingIntervalRange = 1;
	struct soap_blist *soap_blist_Mpeg4ProfilesSupported = NULL;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct tt__Mpeg4Options*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__Mpeg4Options, sizeof(struct tt__Mpeg4Options), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__Mpeg4Options(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "tt:ResolutionsAvailable", 1, NULL))
			{	if (a->ResolutionsAvailable == NULL)
				{	if (soap_blist_ResolutionsAvailable == NULL)
						soap_blist_ResolutionsAvailable = soap_alloc_block(soap);
					a->ResolutionsAvailable = (struct tt__VideoResolution *)soap_push_block_max(soap, soap_blist_ResolutionsAvailable, sizeof(struct tt__VideoResolution));
					if (a->ResolutionsAvailable == NULL)
						return NULL;
					soap_default_tt__VideoResolution(soap, a->ResolutionsAvailable);
				}
				soap_revert(soap);
				if (soap_in_tt__VideoResolution(soap, "tt:ResolutionsAvailable", a->ResolutionsAvailable, "tt:VideoResolution"))
				{	a->__sizeResolutionsAvailable++;
					a->ResolutionsAvailable = NULL;
					continue;
				}
			}
			if (soap_flag_GovLengthRange && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__IntRange(soap, "tt:GovLengthRange", &a->GovLengthRange, "tt:IntRange"))
				{	soap_flag_GovLengthRange--;
					continue;
				}
			}
			if (soap_flag_FrameRateRange && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__IntRange(soap, "tt:FrameRateRange", &a->FrameRateRange, "tt:IntRange"))
				{	soap_flag_FrameRateRange--;
					continue;
				}
			}
			if (soap_flag_EncodingIntervalRange && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__IntRange(soap, "tt:EncodingIntervalRange", &a->EncodingIntervalRange, "tt:IntRange"))
				{	soap_flag_EncodingIntervalRange--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "tt:Mpeg4ProfilesSupported", 1, NULL))
			{	if (a->Mpeg4ProfilesSupported == NULL)
				{	if (soap_blist_Mpeg4ProfilesSupported == NULL)
						soap_blist_Mpeg4ProfilesSupported = soap_alloc_block(soap);
					a->Mpeg4ProfilesSupported = (enum tt__Mpeg4Profile *)soap_push_block_max(soap, soap_blist_Mpeg4ProfilesSupported, sizeof(enum tt__Mpeg4Profile));
					if (a->Mpeg4ProfilesSupported == NULL)
						return NULL;
					soap_default_tt__Mpeg4Profile(soap, a->Mpeg4ProfilesSupported);
				}
				soap_revert(soap);
				if (soap_in_tt__Mpeg4Profile(soap, "tt:Mpeg4ProfilesSupported", a->Mpeg4ProfilesSupported, "tt:Mpeg4Profile"))
				{	a->__sizeMpeg4ProfilesSupported++;
					a->Mpeg4ProfilesSupported = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->ResolutionsAvailable)
			soap_pop_block(soap, soap_blist_ResolutionsAvailable);
		if (a->__sizeResolutionsAvailable)
		{	a->ResolutionsAvailable = (struct tt__VideoResolution *)soap_save_block(soap, soap_blist_ResolutionsAvailable, NULL, 1);
		}
		else
		{	a->ResolutionsAvailable = NULL;
			if (soap_blist_ResolutionsAvailable)
				soap_end_block(soap, soap_blist_ResolutionsAvailable);
		}
		if (a->Mpeg4ProfilesSupported)
			soap_pop_block(soap, soap_blist_Mpeg4ProfilesSupported);
		if (a->__sizeMpeg4ProfilesSupported)
		{	a->Mpeg4ProfilesSupported = (enum tt__Mpeg4Profile *)soap_save_block(soap, soap_blist_Mpeg4ProfilesSupported, NULL, 1);
		}
		else
		{	a->Mpeg4ProfilesSupported = NULL;
			if (soap_blist_Mpeg4ProfilesSupported)
				soap_end_block(soap, soap_blist_Mpeg4ProfilesSupported);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (a->__sizeResolutionsAvailable < 1 || !a->GovLengthRange || !a->FrameRateRange || !a->EncodingIntervalRange || a->__sizeMpeg4ProfilesSupported < 1))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct tt__Mpeg4Options *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__Mpeg4Options, SOAP_TYPE_tt__Mpeg4Options, sizeof(struct tt__Mpeg4Options), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct tt__Mpeg4Options * SOAP_FMAC4 soap_new_tt__Mpeg4Options(struct soap *soap, int n)
{
	struct tt__Mpeg4Options *p;
	struct tt__Mpeg4Options *a = (struct tt__Mpeg4Options*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct tt__Mpeg4Options));
	for (p = a; p && n--; p++)
		soap_default_tt__Mpeg4Options(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__Mpeg4Options(struct soap *soap, const struct tt__Mpeg4Options *a, const char *tag, const char *type)
{
	if (soap_out_tt__Mpeg4Options(soap, tag ? tag : "tt:Mpeg4Options", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__Mpeg4Options * SOAP_FMAC4 soap_get_tt__Mpeg4Options(struct soap *soap, struct tt__Mpeg4Options *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__Mpeg4Options(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__JpegOptions(struct soap *soap, struct tt__JpegOptions *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__sizeResolutionsAvailable = 0;
	a->ResolutionsAvailable = NULL;
	a->FrameRateRange = NULL;
	a->EncodingIntervalRange = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__JpegOptions(struct soap *soap, const struct tt__JpegOptions *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (a->ResolutionsAvailable)
	{	int i;
		for (i = 0; i < (int)a->__sizeResolutionsAvailable; i++)
		{
			soap_embedded(soap, a->ResolutionsAvailable + i, SOAP_TYPE_tt__VideoResolution);
			soap_serialize_tt__VideoResolution(soap, a->ResolutionsAvailable + i);
		}
	}
	soap_serialize_PointerTott__IntRange(soap, &a->FrameRateRange);
	soap_serialize_PointerTott__IntRange(soap, &a->EncodingIntervalRange);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__JpegOptions(struct soap *soap, const char *tag, int id, const struct tt__JpegOptions *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__JpegOptions), type))
		return soap->error;
	if (a->ResolutionsAvailable)
	{	int i;
		for (i = 0; i < (int)a->__sizeResolutionsAvailable; i++)
			if (soap_out_tt__VideoResolution(soap, "tt:ResolutionsAvailable", -1, a->ResolutionsAvailable + i, ""))
				return soap->error;
	}
	if (!a->FrameRateRange)
	{	if (soap_element_empty(soap, "tt:FrameRateRange", 0, NULL))
			return soap->error;
	}
	else if (soap_out_PointerTott__IntRange(soap, "tt:FrameRateRange", -1, &a->FrameRateRange, ""))
		return soap->error;
	if (!a->EncodingIntervalRange)
	{	if (soap_element_empty(soap, "tt:EncodingIntervalRange", 0, NULL))
			return soap->error;
	}
	else if (soap_out_PointerTott__IntRange(soap, "tt:EncodingIntervalRange", -1, &a->EncodingIntervalRange, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__JpegOptions * SOAP_FMAC4 soap_in_tt__JpegOptions(struct soap *soap, const char *tag, struct tt__JpegOptions *a, const char *type)
{
	struct soap_blist *soap_blist_ResolutionsAvailable = NULL;
	size_t soap_flag_FrameRateRange = 1;
	size_t soap_flag_EncodingIntervalRange = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct tt__JpegOptions*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__JpegOptions, sizeof(struct tt__JpegOptions), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__JpegOptions(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "tt:ResolutionsAvailable", 1, NULL))
			{	if (a->ResolutionsAvailable == NULL)
				{	if (soap_blist_ResolutionsAvailable == NULL)
						soap_blist_ResolutionsAvailable = soap_alloc_block(soap);
					a->ResolutionsAvailable = (struct tt__VideoResolution *)soap_push_block_max(soap, soap_blist_ResolutionsAvailable, sizeof(struct tt__VideoResolution));
					if (a->ResolutionsAvailable == NULL)
						return NULL;
					soap_default_tt__VideoResolution(soap, a->ResolutionsAvailable);
				}
				soap_revert(soap);
				if (soap_in_tt__VideoResolution(soap, "tt:ResolutionsAvailable", a->ResolutionsAvailable, "tt:VideoResolution"))
				{	a->__sizeResolutionsAvailable++;
					a->ResolutionsAvailable = NULL;
					continue;
				}
			}
			if (soap_flag_FrameRateRange && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__IntRange(soap, "tt:FrameRateRange", &a->FrameRateRange, "tt:IntRange"))
				{	soap_flag_FrameRateRange--;
					continue;
				}
			}
			if (soap_flag_EncodingIntervalRange && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__IntRange(soap, "tt:EncodingIntervalRange", &a->EncodingIntervalRange, "tt:IntRange"))
				{	soap_flag_EncodingIntervalRange--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->ResolutionsAvailable)
			soap_pop_block(soap, soap_blist_ResolutionsAvailable);
		if (a->__sizeResolutionsAvailable)
		{	a->ResolutionsAvailable = (struct tt__VideoResolution *)soap_save_block(soap, soap_blist_ResolutionsAvailable, NULL, 1);
		}
		else
		{	a->ResolutionsAvailable = NULL;
			if (soap_blist_ResolutionsAvailable)
				soap_end_block(soap, soap_blist_ResolutionsAvailable);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (a->__sizeResolutionsAvailable < 1 || !a->FrameRateRange || !a->EncodingIntervalRange))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct tt__JpegOptions *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__JpegOptions, SOAP_TYPE_tt__JpegOptions, sizeof(struct tt__JpegOptions), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct tt__JpegOptions * SOAP_FMAC4 soap_new_tt__JpegOptions(struct soap *soap, int n)
{
	struct tt__JpegOptions *p;
	struct tt__JpegOptions *a = (struct tt__JpegOptions*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct tt__JpegOptions));
	for (p = a; p && n--; p++)
		soap_default_tt__JpegOptions(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__JpegOptions(struct soap *soap, const struct tt__JpegOptions *a, const char *tag, const char *type)
{
	if (soap_out_tt__JpegOptions(soap, tag ? tag : "tt:JpegOptions", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__JpegOptions * SOAP_FMAC4 soap_get_tt__JpegOptions(struct soap *soap, struct tt__JpegOptions *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__JpegOptions(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__VideoEncoderConfigurationOptions(struct soap *soap, struct tt__VideoEncoderConfigurationOptions *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->QualityRange = NULL;
	a->JPEG = NULL;
	a->MPEG4 = NULL;
	a->H264 = NULL;
	a->Extension = NULL;
	a->GuaranteedFrameRateSupported = NULL;
	a->__anyAttribute = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__VideoEncoderConfigurationOptions(struct soap *soap, const struct tt__VideoEncoderConfigurationOptions *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTott__IntRange(soap, &a->QualityRange);
	soap_serialize_PointerTott__JpegOptions(soap, &a->JPEG);
	soap_serialize_PointerTott__Mpeg4Options(soap, &a->MPEG4);
	soap_serialize_PointerTott__H264Options(soap, &a->H264);
	soap_serialize_PointerTott__VideoEncoderOptionsExtension(soap, &a->Extension);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__VideoEncoderConfigurationOptions(struct soap *soap, const char *tag, int id, const struct tt__VideoEncoderConfigurationOptions *a, const char *type)
{
	if (a->GuaranteedFrameRateSupported)
	{	soap_set_attr(soap, "GuaranteedFrameRateSupported", soap_xsd__boolean2s(soap, *a->GuaranteedFrameRateSupported), 1);
	}
	if (a->__anyAttribute)
		soap_set_attr(soap, "-anyAttribute", a->__anyAttribute, 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__VideoEncoderConfigurationOptions), type))
		return soap->error;
	if (!a->QualityRange)
	{	if (soap_element_empty(soap, "tt:QualityRange", 0, NULL))
			return soap->error;
	}
	else if (soap_out_PointerTott__IntRange(soap, "tt:QualityRange", -1, &a->QualityRange, ""))
		return soap->error;
	if (soap_out_PointerTott__JpegOptions(soap, "tt:JPEG", -1, &a->JPEG, ""))
		return soap->error;
	if (soap_out_PointerTott__Mpeg4Options(soap, "tt:MPEG4", -1, &a->MPEG4, ""))
		return soap->error;
	if (soap_out_PointerTott__H264Options(soap, "tt:H264", -1, &a->H264, ""))
		return soap->error;
	if (soap_out_PointerTott__VideoEncoderOptionsExtension(soap, "tt:Extension", -1, &a->Extension, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__VideoEncoderConfigurationOptions * SOAP_FMAC4 soap_in_tt__VideoEncoderConfigurationOptions(struct soap *soap, const char *tag, struct tt__VideoEncoderConfigurationOptions *a, const char *type)
{
	size_t soap_flag_QualityRange = 1;
	size_t soap_flag_JPEG = 1;
	size_t soap_flag_MPEG4 = 1;
	size_t soap_flag_H264 = 1;
	size_t soap_flag_Extension = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct tt__VideoEncoderConfigurationOptions*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__VideoEncoderConfigurationOptions, sizeof(struct tt__VideoEncoderConfigurationOptions), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__VideoEncoderConfigurationOptions(soap, a);
	{
		const char *t = soap_attr_value(soap, "GuaranteedFrameRateSupported", 5, 0);
		if (t)
		{
			if (!(a->GuaranteedFrameRateSupported = (enum xsd__boolean *)soap_malloc(soap, sizeof(enum xsd__boolean))))
				return NULL;
			if (soap_s2xsd__boolean(soap, t, a->GuaranteedFrameRateSupported))
				return NULL;
		}
		else if (soap->error)
			return NULL;
	}
	if (soap_s2char(soap, soap_attr_value(soap, "-anyAttribute", 0, 0), &a->__anyAttribute, 0, 0, -1, NULL))
		return NULL;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_QualityRange && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__IntRange(soap, "tt:QualityRange", &a->QualityRange, "tt:IntRange"))
				{	soap_flag_QualityRange--;
					continue;
				}
			}
			if (soap_flag_JPEG && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__JpegOptions(soap, "tt:JPEG", &a->JPEG, "tt:JpegOptions"))
				{	soap_flag_JPEG--;
					continue;
				}
			}
			if (soap_flag_MPEG4 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__Mpeg4Options(soap, "tt:MPEG4", &a->MPEG4, "tt:Mpeg4Options"))
				{	soap_flag_MPEG4--;
					continue;
				}
			}
			if (soap_flag_H264 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__H264Options(soap, "tt:H264", &a->H264, "tt:H264Options"))
				{	soap_flag_H264--;
					continue;
				}
			}
			if (soap_flag_Extension && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__VideoEncoderOptionsExtension(soap, "tt:Extension", &a->Extension, "tt:VideoEncoderOptionsExtension"))
				{	soap_flag_Extension--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (!a->QualityRange))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct tt__VideoEncoderConfigurationOptions *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__VideoEncoderConfigurationOptions, SOAP_TYPE_tt__VideoEncoderConfigurationOptions, sizeof(struct tt__VideoEncoderConfigurationOptions), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct tt__VideoEncoderConfigurationOptions * SOAP_FMAC4 soap_new_tt__VideoEncoderConfigurationOptions(struct soap *soap, int n)
{
	struct tt__VideoEncoderConfigurationOptions *p;
	struct tt__VideoEncoderConfigurationOptions *a = (struct tt__VideoEncoderConfigurationOptions*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct tt__VideoEncoderConfigurationOptions));
	for (p = a; p && n--; p++)
		soap_default_tt__VideoEncoderConfigurationOptions(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__VideoEncoderConfigurationOptions(struct soap *soap, const struct tt__VideoEncoderConfigurationOptions *a, const char *tag, const char *type)
{
	if (soap_out_tt__VideoEncoderConfigurationOptions(soap, tag ? tag : "tt:VideoEncoderConfigurationOptions", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__VideoEncoderConfigurationOptions * SOAP_FMAC4 soap_get_tt__VideoEncoderConfigurationOptions(struct soap *soap, struct tt__VideoEncoderConfigurationOptions *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__VideoEncoderConfigurationOptions(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__H264Configuration(struct soap *soap, struct tt__H264Configuration *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_int(soap, &a->GovLength);
	soap_default_tt__H264Profile(soap, &a->H264Profile);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__H264Configuration(struct soap *soap, const struct tt__H264Configuration *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &a->GovLength, SOAP_TYPE_int);
	soap_embedded(soap, &a->H264Profile, SOAP_TYPE_tt__H264Profile);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__H264Configuration(struct soap *soap, const char *tag, int id, const struct tt__H264Configuration *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__H264Configuration), type))
		return soap->error;
	if (soap_out_int(soap, "tt:GovLength", -1, &a->GovLength, ""))
		return soap->error;
	if (soap_out_tt__H264Profile(soap, "tt:H264Profile", -1, &a->H264Profile, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__H264Configuration * SOAP_FMAC4 soap_in_tt__H264Configuration(struct soap *soap, const char *tag, struct tt__H264Configuration *a, const char *type)
{
	size_t soap_flag_GovLength = 1;
	size_t soap_flag_H264Profile = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct tt__H264Configuration*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__H264Configuration, sizeof(struct tt__H264Configuration), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__H264Configuration(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_GovLength && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_int(soap, "tt:GovLength", &a->GovLength, "xsd:int"))
				{	soap_flag_GovLength--;
					continue;
				}
			}
			if (soap_flag_H264Profile && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_tt__H264Profile(soap, "tt:H264Profile", &a->H264Profile, "tt:H264Profile"))
				{	soap_flag_H264Profile--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_GovLength > 0 || soap_flag_H264Profile > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct tt__H264Configuration *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__H264Configuration, SOAP_TYPE_tt__H264Configuration, sizeof(struct tt__H264Configuration), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct tt__H264Configuration * SOAP_FMAC4 soap_new_tt__H264Configuration(struct soap *soap, int n)
{
	struct tt__H264Configuration *p;
	struct tt__H264Configuration *a = (struct tt__H264Configuration*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct tt__H264Configuration));
	for (p = a; p && n--; p++)
		soap_default_tt__H264Configuration(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__H264Configuration(struct soap *soap, const struct tt__H264Configuration *a, const char *tag, const char *type)
{
	if (soap_out_tt__H264Configuration(soap, tag ? tag : "tt:H264Configuration", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__H264Configuration * SOAP_FMAC4 soap_get_tt__H264Configuration(struct soap *soap, struct tt__H264Configuration *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__H264Configuration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__Mpeg4Configuration(struct soap *soap, struct tt__Mpeg4Configuration *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_int(soap, &a->GovLength);
	soap_default_tt__Mpeg4Profile(soap, &a->Mpeg4Profile);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__Mpeg4Configuration(struct soap *soap, const struct tt__Mpeg4Configuration *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &a->GovLength, SOAP_TYPE_int);
	soap_embedded(soap, &a->Mpeg4Profile, SOAP_TYPE_tt__Mpeg4Profile);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__Mpeg4Configuration(struct soap *soap, const char *tag, int id, const struct tt__Mpeg4Configuration *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__Mpeg4Configuration), type))
		return soap->error;
	if (soap_out_int(soap, "tt:GovLength", -1, &a->GovLength, ""))
		return soap->error;
	if (soap_out_tt__Mpeg4Profile(soap, "tt:Mpeg4Profile", -1, &a->Mpeg4Profile, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__Mpeg4Configuration * SOAP_FMAC4 soap_in_tt__Mpeg4Configuration(struct soap *soap, const char *tag, struct tt__Mpeg4Configuration *a, const char *type)
{
	size_t soap_flag_GovLength = 1;
	size_t soap_flag_Mpeg4Profile = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct tt__Mpeg4Configuration*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__Mpeg4Configuration, sizeof(struct tt__Mpeg4Configuration), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__Mpeg4Configuration(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_GovLength && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_int(soap, "tt:GovLength", &a->GovLength, "xsd:int"))
				{	soap_flag_GovLength--;
					continue;
				}
			}
			if (soap_flag_Mpeg4Profile && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_tt__Mpeg4Profile(soap, "tt:Mpeg4Profile", &a->Mpeg4Profile, "tt:Mpeg4Profile"))
				{	soap_flag_Mpeg4Profile--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_GovLength > 0 || soap_flag_Mpeg4Profile > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct tt__Mpeg4Configuration *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__Mpeg4Configuration, SOAP_TYPE_tt__Mpeg4Configuration, sizeof(struct tt__Mpeg4Configuration), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct tt__Mpeg4Configuration * SOAP_FMAC4 soap_new_tt__Mpeg4Configuration(struct soap *soap, int n)
{
	struct tt__Mpeg4Configuration *p;
	struct tt__Mpeg4Configuration *a = (struct tt__Mpeg4Configuration*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct tt__Mpeg4Configuration));
	for (p = a; p && n--; p++)
		soap_default_tt__Mpeg4Configuration(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__Mpeg4Configuration(struct soap *soap, const struct tt__Mpeg4Configuration *a, const char *tag, const char *type)
{
	if (soap_out_tt__Mpeg4Configuration(soap, tag ? tag : "tt:Mpeg4Configuration", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__Mpeg4Configuration * SOAP_FMAC4 soap_get_tt__Mpeg4Configuration(struct soap *soap, struct tt__Mpeg4Configuration *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__Mpeg4Configuration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__VideoRateControl(struct soap *soap, struct tt__VideoRateControl *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_int(soap, &a->FrameRateLimit);
	soap_default_int(soap, &a->EncodingInterval);
	soap_default_int(soap, &a->BitrateLimit);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__VideoRateControl(struct soap *soap, const struct tt__VideoRateControl *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &a->FrameRateLimit, SOAP_TYPE_int);
	soap_embedded(soap, &a->EncodingInterval, SOAP_TYPE_int);
	soap_embedded(soap, &a->BitrateLimit, SOAP_TYPE_int);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__VideoRateControl(struct soap *soap, const char *tag, int id, const struct tt__VideoRateControl *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__VideoRateControl), type))
		return soap->error;
	if (soap_out_int(soap, "tt:FrameRateLimit", -1, &a->FrameRateLimit, ""))
		return soap->error;
	if (soap_out_int(soap, "tt:EncodingInterval", -1, &a->EncodingInterval, ""))
		return soap->error;
	if (soap_out_int(soap, "tt:BitrateLimit", -1, &a->BitrateLimit, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__VideoRateControl * SOAP_FMAC4 soap_in_tt__VideoRateControl(struct soap *soap, const char *tag, struct tt__VideoRateControl *a, const char *type)
{
	size_t soap_flag_FrameRateLimit = 1;
	size_t soap_flag_EncodingInterval = 1;
	size_t soap_flag_BitrateLimit = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct tt__VideoRateControl*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__VideoRateControl, sizeof(struct tt__VideoRateControl), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__VideoRateControl(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_FrameRateLimit && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_int(soap, "tt:FrameRateLimit", &a->FrameRateLimit, "xsd:int"))
				{	soap_flag_FrameRateLimit--;
					continue;
				}
			}
			if (soap_flag_EncodingInterval && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_int(soap, "tt:EncodingInterval", &a->EncodingInterval, "xsd:int"))
				{	soap_flag_EncodingInterval--;
					continue;
				}
			}
			if (soap_flag_BitrateLimit && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_int(soap, "tt:BitrateLimit", &a->BitrateLimit, "xsd:int"))
				{	soap_flag_BitrateLimit--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_FrameRateLimit > 0 || soap_flag_EncodingInterval > 0 || soap_flag_BitrateLimit > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct tt__VideoRateControl *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__VideoRateControl, SOAP_TYPE_tt__VideoRateControl, sizeof(struct tt__VideoRateControl), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct tt__VideoRateControl * SOAP_FMAC4 soap_new_tt__VideoRateControl(struct soap *soap, int n)
{
	struct tt__VideoRateControl *p;
	struct tt__VideoRateControl *a = (struct tt__VideoRateControl*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct tt__VideoRateControl));
	for (p = a; p && n--; p++)
		soap_default_tt__VideoRateControl(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__VideoRateControl(struct soap *soap, const struct tt__VideoRateControl *a, const char *tag, const char *type)
{
	if (soap_out_tt__VideoRateControl(soap, tag ? tag : "tt:VideoRateControl", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__VideoRateControl * SOAP_FMAC4 soap_get_tt__VideoRateControl(struct soap *soap, struct tt__VideoRateControl *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__VideoRateControl(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__VideoResolution(struct soap *soap, struct tt__VideoResolution *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_int(soap, &a->Width);
	soap_default_int(soap, &a->Height);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__VideoResolution(struct soap *soap, const struct tt__VideoResolution *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &a->Width, SOAP_TYPE_int);
	soap_embedded(soap, &a->Height, SOAP_TYPE_int);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__VideoResolution(struct soap *soap, const char *tag, int id, const struct tt__VideoResolution *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__VideoResolution), type))
		return soap->error;
	if (soap_out_int(soap, "tt:Width", -1, &a->Width, ""))
		return soap->error;
	if (soap_out_int(soap, "tt:Height", -1, &a->Height, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__VideoResolution * SOAP_FMAC4 soap_in_tt__VideoResolution(struct soap *soap, const char *tag, struct tt__VideoResolution *a, const char *type)
{
	size_t soap_flag_Width = 1;
	size_t soap_flag_Height = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct tt__VideoResolution*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__VideoResolution, sizeof(struct tt__VideoResolution), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__VideoResolution(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Width && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_int(soap, "tt:Width", &a->Width, "xsd:int"))
				{	soap_flag_Width--;
					continue;
				}
			}
			if (soap_flag_Height && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_int(soap, "tt:Height", &a->Height, "xsd:int"))
				{	soap_flag_Height--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Width > 0 || soap_flag_Height > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct tt__VideoResolution *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__VideoResolution, SOAP_TYPE_tt__VideoResolution, sizeof(struct tt__VideoResolution), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct tt__VideoResolution * SOAP_FMAC4 soap_new_tt__VideoResolution(struct soap *soap, int n)
{
	struct tt__VideoResolution *p;
	struct tt__VideoResolution *a = (struct tt__VideoResolution*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct tt__VideoResolution));
	for (p = a; p && n--; p++)
		soap_default_tt__VideoResolution(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__VideoResolution(struct soap *soap, const struct tt__VideoResolution *a, const char *tag, const char *type)
{
	if (soap_out_tt__VideoResolution(soap, tag ? tag : "tt:VideoResolution", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__VideoResolution * SOAP_FMAC4 soap_get_tt__VideoResolution(struct soap *soap, struct tt__VideoResolution *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__VideoResolution(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__ItemListDescriptionExtension(struct soap *soap, struct tt__ItemListDescriptionExtension *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__size = 0;
	a->__any = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__ItemListDescriptionExtension(struct soap *soap, const struct tt__ItemListDescriptionExtension *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__ItemListDescriptionExtension(struct soap *soap, const char *tag, int id, const struct tt__ItemListDescriptionExtension *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__ItemListDescriptionExtension), type))
		return soap->error;
	if (a->__any)
	{	int i;
		for (i = 0; i < (int)a->__size; i++)
			if (soap_outliteral(soap, "-any", (char*const*)(a->__any + i), NULL))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__ItemListDescriptionExtension * SOAP_FMAC4 soap_in_tt__ItemListDescriptionExtension(struct soap *soap, const char *tag, struct tt__ItemListDescriptionExtension *a, const char *type)
{
	struct soap_blist *soap_blist___any = NULL;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct tt__ItemListDescriptionExtension*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__ItemListDescriptionExtension, sizeof(struct tt__ItemListDescriptionExtension), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__ItemListDescriptionExtension(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	if (a->__any == NULL)
				{	if (soap_blist___any == NULL)
						soap_blist___any = soap_alloc_block(soap);
					a->__any = (char **)soap_push_block_max(soap, soap_blist___any, sizeof(char *));
					if (a->__any == NULL)
						return NULL;
					*a->__any = NULL;
				}
				if (soap_inliteral(soap, "-any", (char**)a->__any))
				{	a->__size++;
					a->__any = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->__any)
			soap_pop_block(soap, soap_blist___any);
		if (a->__size)
		{	a->__any = (char **)soap_save_block(soap, soap_blist___any, NULL, 1);
		}
		else
		{	a->__any = NULL;
			if (soap_blist___any)
				soap_end_block(soap, soap_blist___any);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct tt__ItemListDescriptionExtension *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__ItemListDescriptionExtension, SOAP_TYPE_tt__ItemListDescriptionExtension, sizeof(struct tt__ItemListDescriptionExtension), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct tt__ItemListDescriptionExtension * SOAP_FMAC4 soap_new_tt__ItemListDescriptionExtension(struct soap *soap, int n)
{
	struct tt__ItemListDescriptionExtension *p;
	struct tt__ItemListDescriptionExtension *a = (struct tt__ItemListDescriptionExtension*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct tt__ItemListDescriptionExtension));
	for (p = a; p && n--; p++)
		soap_default_tt__ItemListDescriptionExtension(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__ItemListDescriptionExtension(struct soap *soap, const struct tt__ItemListDescriptionExtension *a, const char *tag, const char *type)
{
	if (soap_out_tt__ItemListDescriptionExtension(soap, tag ? tag : "tt:ItemListDescriptionExtension", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__ItemListDescriptionExtension * SOAP_FMAC4 soap_get_tt__ItemListDescriptionExtension(struct soap *soap, struct tt__ItemListDescriptionExtension *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__ItemListDescriptionExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tt__ItemListDescription_ElementItemDescription(struct soap *soap, struct _tt__ItemListDescription_ElementItemDescription *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->Name);
	soap_default__QName(soap, &a->Type);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tt__ItemListDescription_ElementItemDescription(struct soap *soap, const struct _tt__ItemListDescription_ElementItemDescription *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tt__ItemListDescription_ElementItemDescription(struct soap *soap, const char *tag, int id, const struct _tt__ItemListDescription_ElementItemDescription *a, const char *type)
{
	soap_set_attr(soap, "Name", a->Name ? soap_string2s(soap, a->Name) : "", 1);
	soap_set_attr(soap, "Type", a->Type ? soap__QName2s(soap, a->Type) : "", 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tt__ItemListDescription_ElementItemDescription), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tt__ItemListDescription_ElementItemDescription * SOAP_FMAC4 soap_in__tt__ItemListDescription_ElementItemDescription(struct soap *soap, const char *tag, struct _tt__ItemListDescription_ElementItemDescription *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct _tt__ItemListDescription_ElementItemDescription*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tt__ItemListDescription_ElementItemDescription, sizeof(struct _tt__ItemListDescription_ElementItemDescription), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tt__ItemListDescription_ElementItemDescription(soap, a);
	if (soap_s2string(soap, soap_attr_value(soap, "Name", 1, 1), &a->Name))
		return NULL;
	if (soap_s2_QName(soap, soap_attr_value(soap, "Type", 2, 1), &a->Type))
		return NULL;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _tt__ItemListDescription_ElementItemDescription *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tt__ItemListDescription_ElementItemDescription, SOAP_TYPE__tt__ItemListDescription_ElementItemDescription, sizeof(struct _tt__ItemListDescription_ElementItemDescription), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _tt__ItemListDescription_ElementItemDescription * SOAP_FMAC4 soap_new__tt__ItemListDescription_ElementItemDescription(struct soap *soap, int n)
{
	struct _tt__ItemListDescription_ElementItemDescription *p;
	struct _tt__ItemListDescription_ElementItemDescription *a = (struct _tt__ItemListDescription_ElementItemDescription*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _tt__ItemListDescription_ElementItemDescription));
	for (p = a; p && n--; p++)
		soap_default__tt__ItemListDescription_ElementItemDescription(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tt__ItemListDescription_ElementItemDescription(struct soap *soap, const struct _tt__ItemListDescription_ElementItemDescription *a, const char *tag, const char *type)
{
	if (soap_out__tt__ItemListDescription_ElementItemDescription(soap, tag ? tag : "tt:ItemListDescription-ElementItemDescription", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tt__ItemListDescription_ElementItemDescription * SOAP_FMAC4 soap_get__tt__ItemListDescription_ElementItemDescription(struct soap *soap, struct _tt__ItemListDescription_ElementItemDescription *p, const char *tag, const char *type)
{
	if ((p = soap_in__tt__ItemListDescription_ElementItemDescription(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tt__ItemListDescription_SimpleItemDescription(struct soap *soap, struct _tt__ItemListDescription_SimpleItemDescription *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->Name);
	soap_default__QName(soap, &a->Type);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tt__ItemListDescription_SimpleItemDescription(struct soap *soap, const struct _tt__ItemListDescription_SimpleItemDescription *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tt__ItemListDescription_SimpleItemDescription(struct soap *soap, const char *tag, int id, const struct _tt__ItemListDescription_SimpleItemDescription *a, const char *type)
{
	soap_set_attr(soap, "Name", a->Name ? soap_string2s(soap, a->Name) : "", 1);
	soap_set_attr(soap, "Type", a->Type ? soap__QName2s(soap, a->Type) : "", 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tt__ItemListDescription_SimpleItemDescription), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tt__ItemListDescription_SimpleItemDescription * SOAP_FMAC4 soap_in__tt__ItemListDescription_SimpleItemDescription(struct soap *soap, const char *tag, struct _tt__ItemListDescription_SimpleItemDescription *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct _tt__ItemListDescription_SimpleItemDescription*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tt__ItemListDescription_SimpleItemDescription, sizeof(struct _tt__ItemListDescription_SimpleItemDescription), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tt__ItemListDescription_SimpleItemDescription(soap, a);
	if (soap_s2string(soap, soap_attr_value(soap, "Name", 1, 1), &a->Name))
		return NULL;
	if (soap_s2_QName(soap, soap_attr_value(soap, "Type", 2, 1), &a->Type))
		return NULL;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _tt__ItemListDescription_SimpleItemDescription *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tt__ItemListDescription_SimpleItemDescription, SOAP_TYPE__tt__ItemListDescription_SimpleItemDescription, sizeof(struct _tt__ItemListDescription_SimpleItemDescription), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _tt__ItemListDescription_SimpleItemDescription * SOAP_FMAC4 soap_new__tt__ItemListDescription_SimpleItemDescription(struct soap *soap, int n)
{
	struct _tt__ItemListDescription_SimpleItemDescription *p;
	struct _tt__ItemListDescription_SimpleItemDescription *a = (struct _tt__ItemListDescription_SimpleItemDescription*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _tt__ItemListDescription_SimpleItemDescription));
	for (p = a; p && n--; p++)
		soap_default__tt__ItemListDescription_SimpleItemDescription(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tt__ItemListDescription_SimpleItemDescription(struct soap *soap, const struct _tt__ItemListDescription_SimpleItemDescription *a, const char *tag, const char *type)
{
	if (soap_out__tt__ItemListDescription_SimpleItemDescription(soap, tag ? tag : "tt:ItemListDescription-SimpleItemDescription", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tt__ItemListDescription_SimpleItemDescription * SOAP_FMAC4 soap_get__tt__ItemListDescription_SimpleItemDescription(struct soap *soap, struct _tt__ItemListDescription_SimpleItemDescription *p, const char *tag, const char *type)
{
	if ((p = soap_in__tt__ItemListDescription_SimpleItemDescription(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__MessageDescriptionExtension(struct soap *soap, struct tt__MessageDescriptionExtension *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__size = 0;
	a->__any = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__MessageDescriptionExtension(struct soap *soap, const struct tt__MessageDescriptionExtension *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__MessageDescriptionExtension(struct soap *soap, const char *tag, int id, const struct tt__MessageDescriptionExtension *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__MessageDescriptionExtension), type))
		return soap->error;
	if (a->__any)
	{	int i;
		for (i = 0; i < (int)a->__size; i++)
			if (soap_outliteral(soap, "-any", (char*const*)(a->__any + i), NULL))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__MessageDescriptionExtension * SOAP_FMAC4 soap_in_tt__MessageDescriptionExtension(struct soap *soap, const char *tag, struct tt__MessageDescriptionExtension *a, const char *type)
{
	struct soap_blist *soap_blist___any = NULL;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct tt__MessageDescriptionExtension*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__MessageDescriptionExtension, sizeof(struct tt__MessageDescriptionExtension), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__MessageDescriptionExtension(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	if (a->__any == NULL)
				{	if (soap_blist___any == NULL)
						soap_blist___any = soap_alloc_block(soap);
					a->__any = (char **)soap_push_block_max(soap, soap_blist___any, sizeof(char *));
					if (a->__any == NULL)
						return NULL;
					*a->__any = NULL;
				}
				if (soap_inliteral(soap, "-any", (char**)a->__any))
				{	a->__size++;
					a->__any = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->__any)
			soap_pop_block(soap, soap_blist___any);
		if (a->__size)
		{	a->__any = (char **)soap_save_block(soap, soap_blist___any, NULL, 1);
		}
		else
		{	a->__any = NULL;
			if (soap_blist___any)
				soap_end_block(soap, soap_blist___any);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct tt__MessageDescriptionExtension *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__MessageDescriptionExtension, SOAP_TYPE_tt__MessageDescriptionExtension, sizeof(struct tt__MessageDescriptionExtension), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct tt__MessageDescriptionExtension * SOAP_FMAC4 soap_new_tt__MessageDescriptionExtension(struct soap *soap, int n)
{
	struct tt__MessageDescriptionExtension *p;
	struct tt__MessageDescriptionExtension *a = (struct tt__MessageDescriptionExtension*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct tt__MessageDescriptionExtension));
	for (p = a; p && n--; p++)
		soap_default_tt__MessageDescriptionExtension(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__MessageDescriptionExtension(struct soap *soap, const struct tt__MessageDescriptionExtension *a, const char *tag, const char *type)
{
	if (soap_out_tt__MessageDescriptionExtension(soap, tag ? tag : "tt:MessageDescriptionExtension", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__MessageDescriptionExtension * SOAP_FMAC4 soap_get_tt__MessageDescriptionExtension(struct soap *soap, struct tt__MessageDescriptionExtension *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__MessageDescriptionExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__ItemListDescription(struct soap *soap, struct tt__ItemListDescription *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__sizeSimpleItemDescription = 0;
	a->SimpleItemDescription = NULL;
	a->__sizeElementItemDescription = 0;
	a->ElementItemDescription = NULL;
	a->Extension = NULL;
	a->__anyAttribute = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__ItemListDescription(struct soap *soap, const struct tt__ItemListDescription *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (a->SimpleItemDescription)
	{	int i;
		for (i = 0; i < (int)a->__sizeSimpleItemDescription; i++)
		{
			soap_embedded(soap, a->SimpleItemDescription + i, SOAP_TYPE__tt__ItemListDescription_SimpleItemDescription);
			soap_serialize__tt__ItemListDescription_SimpleItemDescription(soap, a->SimpleItemDescription + i);
		}
	}
	if (a->ElementItemDescription)
	{	int i;
		for (i = 0; i < (int)a->__sizeElementItemDescription; i++)
		{
			soap_embedded(soap, a->ElementItemDescription + i, SOAP_TYPE__tt__ItemListDescription_ElementItemDescription);
			soap_serialize__tt__ItemListDescription_ElementItemDescription(soap, a->ElementItemDescription + i);
		}
	}
	soap_serialize_PointerTott__ItemListDescriptionExtension(soap, &a->Extension);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__ItemListDescription(struct soap *soap, const char *tag, int id, const struct tt__ItemListDescription *a, const char *type)
{
	if (a->__anyAttribute)
		soap_set_attr(soap, "-anyAttribute", a->__anyAttribute, 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__ItemListDescription), type))
		return soap->error;
	if (a->SimpleItemDescription)
	{	int i;
		for (i = 0; i < (int)a->__sizeSimpleItemDescription; i++)
			if (soap_out__tt__ItemListDescription_SimpleItemDescription(soap, "tt:SimpleItemDescription", -1, a->SimpleItemDescription + i, ""))
				return soap->error;
	}
	if (a->ElementItemDescription)
	{	int i;
		for (i = 0; i < (int)a->__sizeElementItemDescription; i++)
			if (soap_out__tt__ItemListDescription_ElementItemDescription(soap, "tt:ElementItemDescription", -1, a->ElementItemDescription + i, ""))
				return soap->error;
	}
	if (soap_out_PointerTott__ItemListDescriptionExtension(soap, "tt:Extension", -1, &a->Extension, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__ItemListDescription * SOAP_FMAC4 soap_in_tt__ItemListDescription(struct soap *soap, const char *tag, struct tt__ItemListDescription *a, const char *type)
{
	struct soap_blist *soap_blist_SimpleItemDescription = NULL;
	struct soap_blist *soap_blist_ElementItemDescription = NULL;
	size_t soap_flag_Extension = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct tt__ItemListDescription*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__ItemListDescription, sizeof(struct tt__ItemListDescription), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__ItemListDescription(soap, a);
	if (soap_s2char(soap, soap_attr_value(soap, "-anyAttribute", 0, 0), &a->__anyAttribute, 0, 0, -1, NULL))
		return NULL;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "tt:SimpleItemDescription", 1, NULL))
			{	if (a->SimpleItemDescription == NULL)
				{	if (soap_blist_SimpleItemDescription == NULL)
						soap_blist_SimpleItemDescription = soap_alloc_block(soap);
					a->SimpleItemDescription = (struct _tt__ItemListDescription_SimpleItemDescription *)soap_push_block_max(soap, soap_blist_SimpleItemDescription, sizeof(struct _tt__ItemListDescription_SimpleItemDescription));
					if (a->SimpleItemDescription == NULL)
						return NULL;
					soap_default__tt__ItemListDescription_SimpleItemDescription(soap, a->SimpleItemDescription);
				}
				soap_revert(soap);
				if (soap_in__tt__ItemListDescription_SimpleItemDescription(soap, "tt:SimpleItemDescription", a->SimpleItemDescription, ""))
				{	a->__sizeSimpleItemDescription++;
					a->SimpleItemDescription = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "tt:ElementItemDescription", 1, NULL))
			{	if (a->ElementItemDescription == NULL)
				{	if (soap_blist_ElementItemDescription == NULL)
						soap_blist_ElementItemDescription = soap_alloc_block(soap);
					a->ElementItemDescription = (struct _tt__ItemListDescription_ElementItemDescription *)soap_push_block_max(soap, soap_blist_ElementItemDescription, sizeof(struct _tt__ItemListDescription_ElementItemDescription));
					if (a->ElementItemDescription == NULL)
						return NULL;
					soap_default__tt__ItemListDescription_ElementItemDescription(soap, a->ElementItemDescription);
				}
				soap_revert(soap);
				if (soap_in__tt__ItemListDescription_ElementItemDescription(soap, "tt:ElementItemDescription", a->ElementItemDescription, ""))
				{	a->__sizeElementItemDescription++;
					a->ElementItemDescription = NULL;
					continue;
				}
			}
			if (soap_flag_Extension && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__ItemListDescriptionExtension(soap, "tt:Extension", &a->Extension, "tt:ItemListDescriptionExtension"))
				{	soap_flag_Extension--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->SimpleItemDescription)
			soap_pop_block(soap, soap_blist_SimpleItemDescription);
		if (a->__sizeSimpleItemDescription)
		{	a->SimpleItemDescription = (struct _tt__ItemListDescription_SimpleItemDescription *)soap_save_block(soap, soap_blist_SimpleItemDescription, NULL, 1);
		}
		else
		{	a->SimpleItemDescription = NULL;
			if (soap_blist_SimpleItemDescription)
				soap_end_block(soap, soap_blist_SimpleItemDescription);
		}
		if (a->ElementItemDescription)
			soap_pop_block(soap, soap_blist_ElementItemDescription);
		if (a->__sizeElementItemDescription)
		{	a->ElementItemDescription = (struct _tt__ItemListDescription_ElementItemDescription *)soap_save_block(soap, soap_blist_ElementItemDescription, NULL, 1);
		}
		else
		{	a->ElementItemDescription = NULL;
			if (soap_blist_ElementItemDescription)
				soap_end_block(soap, soap_blist_ElementItemDescription);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct tt__ItemListDescription *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__ItemListDescription, SOAP_TYPE_tt__ItemListDescription, sizeof(struct tt__ItemListDescription), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct tt__ItemListDescription * SOAP_FMAC4 soap_new_tt__ItemListDescription(struct soap *soap, int n)
{
	struct tt__ItemListDescription *p;
	struct tt__ItemListDescription *a = (struct tt__ItemListDescription*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct tt__ItemListDescription));
	for (p = a; p && n--; p++)
		soap_default_tt__ItemListDescription(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__ItemListDescription(struct soap *soap, const struct tt__ItemListDescription *a, const char *tag, const char *type)
{
	if (soap_out_tt__ItemListDescription(soap, tag ? tag : "tt:ItemListDescription", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__ItemListDescription * SOAP_FMAC4 soap_get_tt__ItemListDescription(struct soap *soap, struct tt__ItemListDescription *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__ItemListDescription(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__MessageDescription(struct soap *soap, struct tt__MessageDescription *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->Source = NULL;
	a->Key = NULL;
	a->Data = NULL;
	a->Extension = NULL;
	a->IsProperty = NULL;
	a->__anyAttribute = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__MessageDescription(struct soap *soap, const struct tt__MessageDescription *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTott__ItemListDescription(soap, &a->Source);
	soap_serialize_PointerTott__ItemListDescription(soap, &a->Key);
	soap_serialize_PointerTott__ItemListDescription(soap, &a->Data);
	soap_serialize_PointerTott__MessageDescriptionExtension(soap, &a->Extension);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__MessageDescription(struct soap *soap, const char *tag, int id, const struct tt__MessageDescription *a, const char *type)
{
	if (a->IsProperty)
	{	soap_set_attr(soap, "IsProperty", soap_xsd__boolean2s(soap, *a->IsProperty), 1);
	}
	if (a->__anyAttribute)
		soap_set_attr(soap, "-anyAttribute", a->__anyAttribute, 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__MessageDescription), type))
		return soap->error;
	if (soap_out_PointerTott__ItemListDescription(soap, "tt:Source", -1, &a->Source, ""))
		return soap->error;
	if (soap_out_PointerTott__ItemListDescription(soap, "tt:Key", -1, &a->Key, ""))
		return soap->error;
	if (soap_out_PointerTott__ItemListDescription(soap, "tt:Data", -1, &a->Data, ""))
		return soap->error;
	if (soap_out_PointerTott__MessageDescriptionExtension(soap, "tt:Extension", -1, &a->Extension, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__MessageDescription * SOAP_FMAC4 soap_in_tt__MessageDescription(struct soap *soap, const char *tag, struct tt__MessageDescription *a, const char *type)
{
	size_t soap_flag_Source = 1;
	size_t soap_flag_Key = 1;
	size_t soap_flag_Data = 1;
	size_t soap_flag_Extension = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct tt__MessageDescription*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__MessageDescription, sizeof(struct tt__MessageDescription), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__MessageDescription(soap, a);
	{
		const char *t = soap_attr_value(soap, "IsProperty", 5, 0);
		if (t)
		{
			if (!(a->IsProperty = (enum xsd__boolean *)soap_malloc(soap, sizeof(enum xsd__boolean))))
				return NULL;
			if (soap_s2xsd__boolean(soap, t, a->IsProperty))
				return NULL;
		}
		else if (soap->error)
			return NULL;
	}
	if (soap_s2char(soap, soap_attr_value(soap, "-anyAttribute", 0, 0), &a->__anyAttribute, 0, 0, -1, NULL))
		return NULL;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Source && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__ItemListDescription(soap, "tt:Source", &a->Source, "tt:ItemListDescription"))
				{	soap_flag_Source--;
					continue;
				}
			}
			if (soap_flag_Key && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__ItemListDescription(soap, "tt:Key", &a->Key, "tt:ItemListDescription"))
				{	soap_flag_Key--;
					continue;
				}
			}
			if (soap_flag_Data && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__ItemListDescription(soap, "tt:Data", &a->Data, "tt:ItemListDescription"))
				{	soap_flag_Data--;
					continue;
				}
			}
			if (soap_flag_Extension && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__MessageDescriptionExtension(soap, "tt:Extension", &a->Extension, "tt:MessageDescriptionExtension"))
				{	soap_flag_Extension--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct tt__MessageDescription *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__MessageDescription, SOAP_TYPE_tt__MessageDescription, sizeof(struct tt__MessageDescription), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct tt__MessageDescription * SOAP_FMAC4 soap_new_tt__MessageDescription(struct soap *soap, int n)
{
	struct tt__MessageDescription *p;
	struct tt__MessageDescription *a = (struct tt__MessageDescription*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct tt__MessageDescription));
	for (p = a; p && n--; p++)
		soap_default_tt__MessageDescription(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__MessageDescription(struct soap *soap, const struct tt__MessageDescription *a, const char *tag, const char *type)
{
	if (soap_out_tt__MessageDescription(soap, tag ? tag : "tt:MessageDescription", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__MessageDescription * SOAP_FMAC4 soap_get_tt__MessageDescription(struct soap *soap, struct tt__MessageDescription *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__MessageDescription(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__ItemListExtension(struct soap *soap, struct tt__ItemListExtension *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__size = 0;
	a->__any = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__ItemListExtension(struct soap *soap, const struct tt__ItemListExtension *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__ItemListExtension(struct soap *soap, const char *tag, int id, const struct tt__ItemListExtension *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__ItemListExtension), type))
		return soap->error;
	if (a->__any)
	{	int i;
		for (i = 0; i < (int)a->__size; i++)
			if (soap_outliteral(soap, "-any", (char*const*)(a->__any + i), NULL))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__ItemListExtension * SOAP_FMAC4 soap_in_tt__ItemListExtension(struct soap *soap, const char *tag, struct tt__ItemListExtension *a, const char *type)
{
	struct soap_blist *soap_blist___any = NULL;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct tt__ItemListExtension*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__ItemListExtension, sizeof(struct tt__ItemListExtension), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__ItemListExtension(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	if (a->__any == NULL)
				{	if (soap_blist___any == NULL)
						soap_blist___any = soap_alloc_block(soap);
					a->__any = (char **)soap_push_block_max(soap, soap_blist___any, sizeof(char *));
					if (a->__any == NULL)
						return NULL;
					*a->__any = NULL;
				}
				if (soap_inliteral(soap, "-any", (char**)a->__any))
				{	a->__size++;
					a->__any = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->__any)
			soap_pop_block(soap, soap_blist___any);
		if (a->__size)
		{	a->__any = (char **)soap_save_block(soap, soap_blist___any, NULL, 1);
		}
		else
		{	a->__any = NULL;
			if (soap_blist___any)
				soap_end_block(soap, soap_blist___any);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct tt__ItemListExtension *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__ItemListExtension, SOAP_TYPE_tt__ItemListExtension, sizeof(struct tt__ItemListExtension), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct tt__ItemListExtension * SOAP_FMAC4 soap_new_tt__ItemListExtension(struct soap *soap, int n)
{
	struct tt__ItemListExtension *p;
	struct tt__ItemListExtension *a = (struct tt__ItemListExtension*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct tt__ItemListExtension));
	for (p = a; p && n--; p++)
		soap_default_tt__ItemListExtension(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__ItemListExtension(struct soap *soap, const struct tt__ItemListExtension *a, const char *tag, const char *type)
{
	if (soap_out_tt__ItemListExtension(soap, tag ? tag : "tt:ItemListExtension", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__ItemListExtension * SOAP_FMAC4 soap_get_tt__ItemListExtension(struct soap *soap, struct tt__ItemListExtension *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__ItemListExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tt__ItemList_ElementItem(struct soap *soap, struct _tt__ItemList_ElementItem *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__any = NULL;
	soap_default_string(soap, &a->Name);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tt__ItemList_ElementItem(struct soap *soap, const struct _tt__ItemList_ElementItem *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tt__ItemList_ElementItem(struct soap *soap, const char *tag, int id, const struct _tt__ItemList_ElementItem *a, const char *type)
{
	soap_set_attr(soap, "Name", a->Name ? soap_string2s(soap, a->Name) : "", 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tt__ItemList_ElementItem), type))
		return soap->error;
	if (soap_outliteral(soap, "-any", (char*const*)&a->__any, NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tt__ItemList_ElementItem * SOAP_FMAC4 soap_in__tt__ItemList_ElementItem(struct soap *soap, const char *tag, struct _tt__ItemList_ElementItem *a, const char *type)
{
	size_t soap_flag___any = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct _tt__ItemList_ElementItem*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tt__ItemList_ElementItem, sizeof(struct _tt__ItemList_ElementItem), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tt__ItemList_ElementItem(soap, a);
	if (soap_s2string(soap, soap_attr_value(soap, "Name", 1, 1), &a->Name))
		return NULL;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag___any && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_inliteral(soap, "-any", (char**)&a->__any))
				{	soap_flag___any--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _tt__ItemList_ElementItem *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tt__ItemList_ElementItem, SOAP_TYPE__tt__ItemList_ElementItem, sizeof(struct _tt__ItemList_ElementItem), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _tt__ItemList_ElementItem * SOAP_FMAC4 soap_new__tt__ItemList_ElementItem(struct soap *soap, int n)
{
	struct _tt__ItemList_ElementItem *p;
	struct _tt__ItemList_ElementItem *a = (struct _tt__ItemList_ElementItem*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _tt__ItemList_ElementItem));
	for (p = a; p && n--; p++)
		soap_default__tt__ItemList_ElementItem(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tt__ItemList_ElementItem(struct soap *soap, const struct _tt__ItemList_ElementItem *a, const char *tag, const char *type)
{
	if (soap_out__tt__ItemList_ElementItem(soap, tag ? tag : "tt:ItemList-ElementItem", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tt__ItemList_ElementItem * SOAP_FMAC4 soap_get__tt__ItemList_ElementItem(struct soap *soap, struct _tt__ItemList_ElementItem *p, const char *tag, const char *type)
{
	if ((p = soap_in__tt__ItemList_ElementItem(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tt__ItemList_SimpleItem(struct soap *soap, struct _tt__ItemList_SimpleItem *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->Name);
	soap_default_xsd__anySimpleType(soap, &a->Value);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tt__ItemList_SimpleItem(struct soap *soap, const struct _tt__ItemList_SimpleItem *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tt__ItemList_SimpleItem(struct soap *soap, const char *tag, int id, const struct _tt__ItemList_SimpleItem *a, const char *type)
{
	soap_set_attr(soap, "Name", a->Name ? soap_string2s(soap, a->Name) : "", 1);
	soap_set_attr(soap, "Value", a->Value ? soap_xsd__anySimpleType2s(soap, a->Value) : "", 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tt__ItemList_SimpleItem), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tt__ItemList_SimpleItem * SOAP_FMAC4 soap_in__tt__ItemList_SimpleItem(struct soap *soap, const char *tag, struct _tt__ItemList_SimpleItem *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct _tt__ItemList_SimpleItem*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tt__ItemList_SimpleItem, sizeof(struct _tt__ItemList_SimpleItem), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tt__ItemList_SimpleItem(soap, a);
	if (soap_s2string(soap, soap_attr_value(soap, "Name", 1, 1), &a->Name))
		return NULL;
	if (soap_s2xsd__anySimpleType(soap, soap_attr_value(soap, "Value", 1, 1), &a->Value))
		return NULL;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _tt__ItemList_SimpleItem *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tt__ItemList_SimpleItem, SOAP_TYPE__tt__ItemList_SimpleItem, sizeof(struct _tt__ItemList_SimpleItem), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _tt__ItemList_SimpleItem * SOAP_FMAC4 soap_new__tt__ItemList_SimpleItem(struct soap *soap, int n)
{
	struct _tt__ItemList_SimpleItem *p;
	struct _tt__ItemList_SimpleItem *a = (struct _tt__ItemList_SimpleItem*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _tt__ItemList_SimpleItem));
	for (p = a; p && n--; p++)
		soap_default__tt__ItemList_SimpleItem(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tt__ItemList_SimpleItem(struct soap *soap, const struct _tt__ItemList_SimpleItem *a, const char *tag, const char *type)
{
	if (soap_out__tt__ItemList_SimpleItem(soap, tag ? tag : "tt:ItemList-SimpleItem", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tt__ItemList_SimpleItem * SOAP_FMAC4 soap_get__tt__ItemList_SimpleItem(struct soap *soap, struct _tt__ItemList_SimpleItem *p, const char *tag, const char *type)
{
	if ((p = soap_in__tt__ItemList_SimpleItem(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__ItemList(struct soap *soap, struct tt__ItemList *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__sizeSimpleItem = 0;
	a->SimpleItem = NULL;
	a->__sizeElementItem = 0;
	a->ElementItem = NULL;
	a->Extension = NULL;
	a->__anyAttribute = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__ItemList(struct soap *soap, const struct tt__ItemList *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (a->SimpleItem)
	{	int i;
		for (i = 0; i < (int)a->__sizeSimpleItem; i++)
		{
			soap_embedded(soap, a->SimpleItem + i, SOAP_TYPE__tt__ItemList_SimpleItem);
			soap_serialize__tt__ItemList_SimpleItem(soap, a->SimpleItem + i);
		}
	}
	if (a->ElementItem)
	{	int i;
		for (i = 0; i < (int)a->__sizeElementItem; i++)
		{
			soap_embedded(soap, a->ElementItem + i, SOAP_TYPE__tt__ItemList_ElementItem);
			soap_serialize__tt__ItemList_ElementItem(soap, a->ElementItem + i);
		}
	}
	soap_serialize_PointerTott__ItemListExtension(soap, &a->Extension);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__ItemList(struct soap *soap, const char *tag, int id, const struct tt__ItemList *a, const char *type)
{
	if (a->__anyAttribute)
		soap_set_attr(soap, "-anyAttribute", a->__anyAttribute, 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__ItemList), type))
		return soap->error;
	if (a->SimpleItem)
	{	int i;
		for (i = 0; i < (int)a->__sizeSimpleItem; i++)
			if (soap_out__tt__ItemList_SimpleItem(soap, "tt:SimpleItem", -1, a->SimpleItem + i, ""))
				return soap->error;
	}
	if (a->ElementItem)
	{	int i;
		for (i = 0; i < (int)a->__sizeElementItem; i++)
			if (soap_out__tt__ItemList_ElementItem(soap, "tt:ElementItem", -1, a->ElementItem + i, ""))
				return soap->error;
	}
	if (soap_out_PointerTott__ItemListExtension(soap, "tt:Extension", -1, &a->Extension, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__ItemList * SOAP_FMAC4 soap_in_tt__ItemList(struct soap *soap, const char *tag, struct tt__ItemList *a, const char *type)
{
	struct soap_blist *soap_blist_SimpleItem = NULL;
	struct soap_blist *soap_blist_ElementItem = NULL;
	size_t soap_flag_Extension = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct tt__ItemList*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__ItemList, sizeof(struct tt__ItemList), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__ItemList(soap, a);
	if (soap_s2char(soap, soap_attr_value(soap, "-anyAttribute", 0, 0), &a->__anyAttribute, 0, 0, -1, NULL))
		return NULL;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "tt:SimpleItem", 1, NULL))
			{	if (a->SimpleItem == NULL)
				{	if (soap_blist_SimpleItem == NULL)
						soap_blist_SimpleItem = soap_alloc_block(soap);
					a->SimpleItem = (struct _tt__ItemList_SimpleItem *)soap_push_block_max(soap, soap_blist_SimpleItem, sizeof(struct _tt__ItemList_SimpleItem));
					if (a->SimpleItem == NULL)
						return NULL;
					soap_default__tt__ItemList_SimpleItem(soap, a->SimpleItem);
				}
				soap_revert(soap);
				if (soap_in__tt__ItemList_SimpleItem(soap, "tt:SimpleItem", a->SimpleItem, ""))
				{	a->__sizeSimpleItem++;
					a->SimpleItem = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "tt:ElementItem", 1, NULL))
			{	if (a->ElementItem == NULL)
				{	if (soap_blist_ElementItem == NULL)
						soap_blist_ElementItem = soap_alloc_block(soap);
					a->ElementItem = (struct _tt__ItemList_ElementItem *)soap_push_block_max(soap, soap_blist_ElementItem, sizeof(struct _tt__ItemList_ElementItem));
					if (a->ElementItem == NULL)
						return NULL;
					soap_default__tt__ItemList_ElementItem(soap, a->ElementItem);
				}
				soap_revert(soap);
				if (soap_in__tt__ItemList_ElementItem(soap, "tt:ElementItem", a->ElementItem, ""))
				{	a->__sizeElementItem++;
					a->ElementItem = NULL;
					continue;
				}
			}
			if (soap_flag_Extension && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__ItemListExtension(soap, "tt:Extension", &a->Extension, "tt:ItemListExtension"))
				{	soap_flag_Extension--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->SimpleItem)
			soap_pop_block(soap, soap_blist_SimpleItem);
		if (a->__sizeSimpleItem)
		{	a->SimpleItem = (struct _tt__ItemList_SimpleItem *)soap_save_block(soap, soap_blist_SimpleItem, NULL, 1);
		}
		else
		{	a->SimpleItem = NULL;
			if (soap_blist_SimpleItem)
				soap_end_block(soap, soap_blist_SimpleItem);
		}
		if (a->ElementItem)
			soap_pop_block(soap, soap_blist_ElementItem);
		if (a->__sizeElementItem)
		{	a->ElementItem = (struct _tt__ItemList_ElementItem *)soap_save_block(soap, soap_blist_ElementItem, NULL, 1);
		}
		else
		{	a->ElementItem = NULL;
			if (soap_blist_ElementItem)
				soap_end_block(soap, soap_blist_ElementItem);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct tt__ItemList *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__ItemList, SOAP_TYPE_tt__ItemList, sizeof(struct tt__ItemList), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct tt__ItemList * SOAP_FMAC4 soap_new_tt__ItemList(struct soap *soap, int n)
{
	struct tt__ItemList *p;
	struct tt__ItemList *a = (struct tt__ItemList*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct tt__ItemList));
	for (p = a; p && n--; p++)
		soap_default_tt__ItemList(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__ItemList(struct soap *soap, const struct tt__ItemList *a, const char *tag, const char *type)
{
	if (soap_out_tt__ItemList(soap, tag ? tag : "tt:ItemList", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__ItemList * SOAP_FMAC4 soap_get_tt__ItemList(struct soap *soap, struct tt__ItemList *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__ItemList(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__MessageExtension(struct soap *soap, struct tt__MessageExtension *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__size = 0;
	a->__any = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__MessageExtension(struct soap *soap, const struct tt__MessageExtension *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__MessageExtension(struct soap *soap, const char *tag, int id, const struct tt__MessageExtension *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__MessageExtension), type))
		return soap->error;
	if (a->__any)
	{	int i;
		for (i = 0; i < (int)a->__size; i++)
			if (soap_outliteral(soap, "-any", (char*const*)(a->__any + i), NULL))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__MessageExtension * SOAP_FMAC4 soap_in_tt__MessageExtension(struct soap *soap, const char *tag, struct tt__MessageExtension *a, const char *type)
{
	struct soap_blist *soap_blist___any = NULL;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct tt__MessageExtension*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__MessageExtension, sizeof(struct tt__MessageExtension), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__MessageExtension(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	if (a->__any == NULL)
				{	if (soap_blist___any == NULL)
						soap_blist___any = soap_alloc_block(soap);
					a->__any = (char **)soap_push_block_max(soap, soap_blist___any, sizeof(char *));
					if (a->__any == NULL)
						return NULL;
					*a->__any = NULL;
				}
				if (soap_inliteral(soap, "-any", (char**)a->__any))
				{	a->__size++;
					a->__any = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->__any)
			soap_pop_block(soap, soap_blist___any);
		if (a->__size)
		{	a->__any = (char **)soap_save_block(soap, soap_blist___any, NULL, 1);
		}
		else
		{	a->__any = NULL;
			if (soap_blist___any)
				soap_end_block(soap, soap_blist___any);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct tt__MessageExtension *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__MessageExtension, SOAP_TYPE_tt__MessageExtension, sizeof(struct tt__MessageExtension), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct tt__MessageExtension * SOAP_FMAC4 soap_new_tt__MessageExtension(struct soap *soap, int n)
{
	struct tt__MessageExtension *p;
	struct tt__MessageExtension *a = (struct tt__MessageExtension*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct tt__MessageExtension));
	for (p = a; p && n--; p++)
		soap_default_tt__MessageExtension(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__MessageExtension(struct soap *soap, const struct tt__MessageExtension *a, const char *tag, const char *type)
{
	if (soap_out_tt__MessageExtension(soap, tag ? tag : "tt:MessageExtension", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__MessageExtension * SOAP_FMAC4 soap_get_tt__MessageExtension(struct soap *soap, struct tt__MessageExtension *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__MessageExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__PTZMoveStatus(struct soap *soap, struct tt__PTZMoveStatus *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->PanTilt = NULL;
	a->Zoom = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__PTZMoveStatus(struct soap *soap, const struct tt__PTZMoveStatus *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTott__MoveStatus(soap, &a->PanTilt);
	soap_serialize_PointerTott__MoveStatus(soap, &a->Zoom);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__PTZMoveStatus(struct soap *soap, const char *tag, int id, const struct tt__PTZMoveStatus *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__PTZMoveStatus), type))
		return soap->error;
	if (soap_out_PointerTott__MoveStatus(soap, "tt:PanTilt", -1, &a->PanTilt, ""))
		return soap->error;
	if (soap_out_PointerTott__MoveStatus(soap, "tt:Zoom", -1, &a->Zoom, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__PTZMoveStatus * SOAP_FMAC4 soap_in_tt__PTZMoveStatus(struct soap *soap, const char *tag, struct tt__PTZMoveStatus *a, const char *type)
{
	size_t soap_flag_PanTilt = 1;
	size_t soap_flag_Zoom = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct tt__PTZMoveStatus*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__PTZMoveStatus, sizeof(struct tt__PTZMoveStatus), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__PTZMoveStatus(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_PanTilt && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__MoveStatus(soap, "tt:PanTilt", &a->PanTilt, "tt:MoveStatus"))
				{	soap_flag_PanTilt--;
					continue;
				}
			}
			if (soap_flag_Zoom && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__MoveStatus(soap, "tt:Zoom", &a->Zoom, "tt:MoveStatus"))
				{	soap_flag_Zoom--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct tt__PTZMoveStatus *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__PTZMoveStatus, SOAP_TYPE_tt__PTZMoveStatus, sizeof(struct tt__PTZMoveStatus), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct tt__PTZMoveStatus * SOAP_FMAC4 soap_new_tt__PTZMoveStatus(struct soap *soap, int n)
{
	struct tt__PTZMoveStatus *p;
	struct tt__PTZMoveStatus *a = (struct tt__PTZMoveStatus*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct tt__PTZMoveStatus));
	for (p = a; p && n--; p++)
		soap_default_tt__PTZMoveStatus(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__PTZMoveStatus(struct soap *soap, const struct tt__PTZMoveStatus *a, const char *tag, const char *type)
{
	if (soap_out_tt__PTZMoveStatus(soap, tag ? tag : "tt:PTZMoveStatus", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__PTZMoveStatus * SOAP_FMAC4 soap_get_tt__PTZMoveStatus(struct soap *soap, struct tt__PTZMoveStatus *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__PTZMoveStatus(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__PTZPreset(struct soap *soap, struct tt__PTZPreset *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_tt__Name(soap, &a->Name);
	a->PTZPosition = NULL;
	soap_default_tt__ReferenceToken(soap, &a->token);
	a->__anyAttribute = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__PTZPreset(struct soap *soap, const struct tt__PTZPreset *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_tt__Name(soap, (char*const*)&a->Name);
	soap_serialize_PointerTott__PTZVector(soap, &a->PTZPosition);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__PTZPreset(struct soap *soap, const char *tag, int id, const struct tt__PTZPreset *a, const char *type)
{
	if (a->token)
		soap_set_attr(soap, "token", soap_tt__ReferenceToken2s(soap, a->token), 1);
	if (a->__anyAttribute)
		soap_set_attr(soap, "-anyAttribute", a->__anyAttribute, 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__PTZPreset), type))
		return soap->error;
	if (soap_out_tt__Name(soap, "tt:Name", -1, (char*const*)&a->Name, ""))
		return soap->error;
	if (soap_out_PointerTott__PTZVector(soap, "tt:PTZPosition", -1, &a->PTZPosition, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__PTZPreset * SOAP_FMAC4 soap_in_tt__PTZPreset(struct soap *soap, const char *tag, struct tt__PTZPreset *a, const char *type)
{
	size_t soap_flag_Name = 1;
	size_t soap_flag_PTZPosition = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct tt__PTZPreset*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__PTZPreset, sizeof(struct tt__PTZPreset), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__PTZPreset(soap, a);
	if (soap_s2tt__ReferenceToken(soap, soap_attr_value(soap, "token", 1, 0), &a->token))
		return NULL;
	if (soap_s2char(soap, soap_attr_value(soap, "-anyAttribute", 0, 0), &a->__anyAttribute, 0, 0, -1, NULL))
		return NULL;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Name && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_tt__Name(soap, "tt:Name", (char**)&a->Name, "tt:Name"))
				{	soap_flag_Name--;
					continue;
				}
			}
			if (soap_flag_PTZPosition && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__PTZVector(soap, "tt:PTZPosition", &a->PTZPosition, "tt:PTZVector"))
				{	soap_flag_PTZPosition--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct tt__PTZPreset *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__PTZPreset, SOAP_TYPE_tt__PTZPreset, sizeof(struct tt__PTZPreset), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct tt__PTZPreset * SOAP_FMAC4 soap_new_tt__PTZPreset(struct soap *soap, int n)
{
	struct tt__PTZPreset *p;
	struct tt__PTZPreset *a = (struct tt__PTZPreset*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct tt__PTZPreset));
	for (p = a; p && n--; p++)
		soap_default_tt__PTZPreset(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__PTZPreset(struct soap *soap, const struct tt__PTZPreset *a, const char *tag, const char *type)
{
	if (soap_out_tt__PTZPreset(soap, tag ? tag : "tt:PTZPreset", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__PTZPreset * SOAP_FMAC4 soap_get_tt__PTZPreset(struct soap *soap, struct tt__PTZPreset *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__PTZPreset(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__PTZSpeed(struct soap *soap, struct tt__PTZSpeed *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->PanTilt = NULL;
	a->Zoom = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__PTZSpeed(struct soap *soap, const struct tt__PTZSpeed *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTott__Vector2D(soap, &a->PanTilt);
	soap_serialize_PointerTott__Vector1D(soap, &a->Zoom);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__PTZSpeed(struct soap *soap, const char *tag, int id, const struct tt__PTZSpeed *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__PTZSpeed), type))
		return soap->error;
	if (soap_out_PointerTott__Vector2D(soap, "tt:PanTilt", -1, &a->PanTilt, ""))
		return soap->error;
	if (soap_out_PointerTott__Vector1D(soap, "tt:Zoom", -1, &a->Zoom, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__PTZSpeed * SOAP_FMAC4 soap_in_tt__PTZSpeed(struct soap *soap, const char *tag, struct tt__PTZSpeed *a, const char *type)
{
	size_t soap_flag_PanTilt = 1;
	size_t soap_flag_Zoom = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct tt__PTZSpeed*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__PTZSpeed, sizeof(struct tt__PTZSpeed), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__PTZSpeed(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_PanTilt && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__Vector2D(soap, "tt:PanTilt", &a->PanTilt, "tt:Vector2D"))
				{	soap_flag_PanTilt--;
					continue;
				}
			}
			if (soap_flag_Zoom && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__Vector1D(soap, "tt:Zoom", &a->Zoom, "tt:Vector1D"))
				{	soap_flag_Zoom--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct tt__PTZSpeed *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__PTZSpeed, SOAP_TYPE_tt__PTZSpeed, sizeof(struct tt__PTZSpeed), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct tt__PTZSpeed * SOAP_FMAC4 soap_new_tt__PTZSpeed(struct soap *soap, int n)
{
	struct tt__PTZSpeed *p;
	struct tt__PTZSpeed *a = (struct tt__PTZSpeed*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct tt__PTZSpeed));
	for (p = a; p && n--; p++)
		soap_default_tt__PTZSpeed(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__PTZSpeed(struct soap *soap, const struct tt__PTZSpeed *a, const char *tag, const char *type)
{
	if (soap_out_tt__PTZSpeed(soap, tag ? tag : "tt:PTZSpeed", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__PTZSpeed * SOAP_FMAC4 soap_get_tt__PTZSpeed(struct soap *soap, struct tt__PTZSpeed *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__PTZSpeed(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__PTZVector(struct soap *soap, struct tt__PTZVector *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->PanTilt = NULL;
	a->Zoom = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__PTZVector(struct soap *soap, const struct tt__PTZVector *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTott__Vector2D(soap, &a->PanTilt);
	soap_serialize_PointerTott__Vector1D(soap, &a->Zoom);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__PTZVector(struct soap *soap, const char *tag, int id, const struct tt__PTZVector *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__PTZVector), type))
		return soap->error;
	if (soap_out_PointerTott__Vector2D(soap, "tt:PanTilt", -1, &a->PanTilt, ""))
		return soap->error;
	if (soap_out_PointerTott__Vector1D(soap, "tt:Zoom", -1, &a->Zoom, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__PTZVector * SOAP_FMAC4 soap_in_tt__PTZVector(struct soap *soap, const char *tag, struct tt__PTZVector *a, const char *type)
{
	size_t soap_flag_PanTilt = 1;
	size_t soap_flag_Zoom = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct tt__PTZVector*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__PTZVector, sizeof(struct tt__PTZVector), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__PTZVector(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_PanTilt && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__Vector2D(soap, "tt:PanTilt", &a->PanTilt, "tt:Vector2D"))
				{	soap_flag_PanTilt--;
					continue;
				}
			}
			if (soap_flag_Zoom && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__Vector1D(soap, "tt:Zoom", &a->Zoom, "tt:Vector1D"))
				{	soap_flag_Zoom--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct tt__PTZVector *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__PTZVector, SOAP_TYPE_tt__PTZVector, sizeof(struct tt__PTZVector), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct tt__PTZVector * SOAP_FMAC4 soap_new_tt__PTZVector(struct soap *soap, int n)
{
	struct tt__PTZVector *p;
	struct tt__PTZVector *a = (struct tt__PTZVector*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct tt__PTZVector));
	for (p = a; p && n--; p++)
		soap_default_tt__PTZVector(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__PTZVector(struct soap *soap, const struct tt__PTZVector *a, const char *tag, const char *type)
{
	if (soap_out_tt__PTZVector(soap, tag ? tag : "tt:PTZVector", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__PTZVector * SOAP_FMAC4 soap_get_tt__PTZVector(struct soap *soap, struct tt__PTZVector *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__PTZVector(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__Vector1D(struct soap *soap, struct tt__Vector1D *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_float(soap, &a->x);
	soap_default_xsd__anyURI(soap, &a->space);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__Vector1D(struct soap *soap, const struct tt__Vector1D *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__Vector1D(struct soap *soap, const char *tag, int id, const struct tt__Vector1D *a, const char *type)
{
	soap_set_attr(soap, "x", soap_float2s(soap, a->x), 1);
	if (a->space)
		soap_set_attr(soap, "space", soap_xsd__anyURI2s(soap, a->space), 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__Vector1D), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__Vector1D * SOAP_FMAC4 soap_in_tt__Vector1D(struct soap *soap, const char *tag, struct tt__Vector1D *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct tt__Vector1D*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__Vector1D, sizeof(struct tt__Vector1D), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__Vector1D(soap, a);
	if (soap_s2float(soap, soap_attr_value(soap, "x", 5, 1), &a->x))
		return NULL;
	if (soap_s2xsd__anyURI(soap, soap_attr_value(soap, "space", 4, 0), &a->space))
		return NULL;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct tt__Vector1D *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__Vector1D, SOAP_TYPE_tt__Vector1D, sizeof(struct tt__Vector1D), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct tt__Vector1D * SOAP_FMAC4 soap_new_tt__Vector1D(struct soap *soap, int n)
{
	struct tt__Vector1D *p;
	struct tt__Vector1D *a = (struct tt__Vector1D*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct tt__Vector1D));
	for (p = a; p && n--; p++)
		soap_default_tt__Vector1D(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__Vector1D(struct soap *soap, const struct tt__Vector1D *a, const char *tag, const char *type)
{
	if (soap_out_tt__Vector1D(soap, tag ? tag : "tt:Vector1D", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__Vector1D * SOAP_FMAC4 soap_get_tt__Vector1D(struct soap *soap, struct tt__Vector1D *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__Vector1D(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__Vector2D(struct soap *soap, struct tt__Vector2D *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_float(soap, &a->x);
	soap_default_float(soap, &a->y);
	soap_default_xsd__anyURI(soap, &a->space);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__Vector2D(struct soap *soap, const struct tt__Vector2D *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__Vector2D(struct soap *soap, const char *tag, int id, const struct tt__Vector2D *a, const char *type)
{
	soap_set_attr(soap, "x", soap_float2s(soap, a->x), 1);
	soap_set_attr(soap, "y", soap_float2s(soap, a->y), 1);
	if (a->space)
		soap_set_attr(soap, "space", soap_xsd__anyURI2s(soap, a->space), 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__Vector2D), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__Vector2D * SOAP_FMAC4 soap_in_tt__Vector2D(struct soap *soap, const char *tag, struct tt__Vector2D *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct tt__Vector2D*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__Vector2D, sizeof(struct tt__Vector2D), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__Vector2D(soap, a);
	if (soap_s2float(soap, soap_attr_value(soap, "x", 5, 1), &a->x))
		return NULL;
	if (soap_s2float(soap, soap_attr_value(soap, "y", 5, 1), &a->y))
		return NULL;
	if (soap_s2xsd__anyURI(soap, soap_attr_value(soap, "space", 4, 0), &a->space))
		return NULL;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct tt__Vector2D *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__Vector2D, SOAP_TYPE_tt__Vector2D, sizeof(struct tt__Vector2D), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct tt__Vector2D * SOAP_FMAC4 soap_new_tt__Vector2D(struct soap *soap, int n)
{
	struct tt__Vector2D *p;
	struct tt__Vector2D *a = (struct tt__Vector2D*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct tt__Vector2D));
	for (p = a; p && n--; p++)
		soap_default_tt__Vector2D(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__Vector2D(struct soap *soap, const struct tt__Vector2D *a, const char *tag, const char *type)
{
	if (soap_out_tt__Vector2D(soap, tag ? tag : "tt:Vector2D", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__Vector2D * SOAP_FMAC4 soap_get_tt__Vector2D(struct soap *soap, struct tt__Vector2D *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__Vector2D(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__PTZSpaces(struct soap *soap, struct tt__PTZSpaces *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__sizeContinuousPanTiltVelocitySpace = 0;
	a->ContinuousPanTiltVelocitySpace = NULL;
	a->__sizeContinuousZoomVelocitySpace = 0;
	a->ContinuousZoomVelocitySpace = NULL;
	a->__sizePanTiltSpeedSpace = 0;
	a->PanTiltSpeedSpace = NULL;
	a->__sizeZoomSpeedSpace = 0;
	a->ZoomSpeedSpace = NULL;
	a->__anyAttribute = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__PTZSpaces(struct soap *soap, const struct tt__PTZSpaces *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (a->ContinuousPanTiltVelocitySpace)
	{	int i;
		for (i = 0; i < (int)a->__sizeContinuousPanTiltVelocitySpace; i++)
		{
			soap_embedded(soap, a->ContinuousPanTiltVelocitySpace + i, SOAP_TYPE_tt__Space2DDescription);
			soap_serialize_tt__Space2DDescription(soap, a->ContinuousPanTiltVelocitySpace + i);
		}
	}
	if (a->ContinuousZoomVelocitySpace)
	{	int i;
		for (i = 0; i < (int)a->__sizeContinuousZoomVelocitySpace; i++)
		{
			soap_embedded(soap, a->ContinuousZoomVelocitySpace + i, SOAP_TYPE_tt__Space1DDescription);
			soap_serialize_tt__Space1DDescription(soap, a->ContinuousZoomVelocitySpace + i);
		}
	}
	if (a->PanTiltSpeedSpace)
	{	int i;
		for (i = 0; i < (int)a->__sizePanTiltSpeedSpace; i++)
		{
			soap_embedded(soap, a->PanTiltSpeedSpace + i, SOAP_TYPE_tt__Space1DDescription);
			soap_serialize_tt__Space1DDescription(soap, a->PanTiltSpeedSpace + i);
		}
	}
	if (a->ZoomSpeedSpace)
	{	int i;
		for (i = 0; i < (int)a->__sizeZoomSpeedSpace; i++)
		{
			soap_embedded(soap, a->ZoomSpeedSpace + i, SOAP_TYPE_tt__Space1DDescription);
			soap_serialize_tt__Space1DDescription(soap, a->ZoomSpeedSpace + i);
		}
	}
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__PTZSpaces(struct soap *soap, const char *tag, int id, const struct tt__PTZSpaces *a, const char *type)
{
	if (a->__anyAttribute)
		soap_set_attr(soap, "-anyAttribute", a->__anyAttribute, 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__PTZSpaces), type))
		return soap->error;
	if (a->ContinuousPanTiltVelocitySpace)
	{	int i;
		for (i = 0; i < (int)a->__sizeContinuousPanTiltVelocitySpace; i++)
			if (soap_out_tt__Space2DDescription(soap, "tt:ContinuousPanTiltVelocitySpace", -1, a->ContinuousPanTiltVelocitySpace + i, ""))
				return soap->error;
	}
	if (a->ContinuousZoomVelocitySpace)
	{	int i;
		for (i = 0; i < (int)a->__sizeContinuousZoomVelocitySpace; i++)
			if (soap_out_tt__Space1DDescription(soap, "tt:ContinuousZoomVelocitySpace", -1, a->ContinuousZoomVelocitySpace + i, ""))
				return soap->error;
	}
	if (a->PanTiltSpeedSpace)
	{	int i;
		for (i = 0; i < (int)a->__sizePanTiltSpeedSpace; i++)
			if (soap_out_tt__Space1DDescription(soap, "tt:PanTiltSpeedSpace", -1, a->PanTiltSpeedSpace + i, ""))
				return soap->error;
	}
	if (a->ZoomSpeedSpace)
	{	int i;
		for (i = 0; i < (int)a->__sizeZoomSpeedSpace; i++)
			if (soap_out_tt__Space1DDescription(soap, "tt:ZoomSpeedSpace", -1, a->ZoomSpeedSpace + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__PTZSpaces * SOAP_FMAC4 soap_in_tt__PTZSpaces(struct soap *soap, const char *tag, struct tt__PTZSpaces *a, const char *type)
{
	struct soap_blist *soap_blist_ContinuousPanTiltVelocitySpace = NULL;
	struct soap_blist *soap_blist_ContinuousZoomVelocitySpace = NULL;
	struct soap_blist *soap_blist_PanTiltSpeedSpace = NULL;
	struct soap_blist *soap_blist_ZoomSpeedSpace = NULL;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct tt__PTZSpaces*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__PTZSpaces, sizeof(struct tt__PTZSpaces), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__PTZSpaces(soap, a);
	if (soap_s2char(soap, soap_attr_value(soap, "-anyAttribute", 0, 0), &a->__anyAttribute, 0, 0, -1, NULL))
		return NULL;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "tt:ContinuousPanTiltVelocitySpace", 1, NULL))
			{	if (a->ContinuousPanTiltVelocitySpace == NULL)
				{	if (soap_blist_ContinuousPanTiltVelocitySpace == NULL)
						soap_blist_ContinuousPanTiltVelocitySpace = soap_alloc_block(soap);
					a->ContinuousPanTiltVelocitySpace = (struct tt__Space2DDescription *)soap_push_block_max(soap, soap_blist_ContinuousPanTiltVelocitySpace, sizeof(struct tt__Space2DDescription));
					if (a->ContinuousPanTiltVelocitySpace == NULL)
						return NULL;
					soap_default_tt__Space2DDescription(soap, a->ContinuousPanTiltVelocitySpace);
				}
				soap_revert(soap);
				if (soap_in_tt__Space2DDescription(soap, "tt:ContinuousPanTiltVelocitySpace", a->ContinuousPanTiltVelocitySpace, "tt:Space2DDescription"))
				{	a->__sizeContinuousPanTiltVelocitySpace++;
					a->ContinuousPanTiltVelocitySpace = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "tt:ContinuousZoomVelocitySpace", 1, NULL))
			{	if (a->ContinuousZoomVelocitySpace == NULL)
				{	if (soap_blist_ContinuousZoomVelocitySpace == NULL)
						soap_blist_ContinuousZoomVelocitySpace = soap_alloc_block(soap);
					a->ContinuousZoomVelocitySpace = (struct tt__Space1DDescription *)soap_push_block_max(soap, soap_blist_ContinuousZoomVelocitySpace, sizeof(struct tt__Space1DDescription));
					if (a->ContinuousZoomVelocitySpace == NULL)
						return NULL;
					soap_default_tt__Space1DDescription(soap, a->ContinuousZoomVelocitySpace);
				}
				soap_revert(soap);
				if (soap_in_tt__Space1DDescription(soap, "tt:ContinuousZoomVelocitySpace", a->ContinuousZoomVelocitySpace, "tt:Space1DDescription"))
				{	a->__sizeContinuousZoomVelocitySpace++;
					a->ContinuousZoomVelocitySpace = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "tt:PanTiltSpeedSpace", 1, NULL))
			{	if (a->PanTiltSpeedSpace == NULL)
				{	if (soap_blist_PanTiltSpeedSpace == NULL)
						soap_blist_PanTiltSpeedSpace = soap_alloc_block(soap);
					a->PanTiltSpeedSpace = (struct tt__Space1DDescription *)soap_push_block_max(soap, soap_blist_PanTiltSpeedSpace, sizeof(struct tt__Space1DDescription));
					if (a->PanTiltSpeedSpace == NULL)
						return NULL;
					soap_default_tt__Space1DDescription(soap, a->PanTiltSpeedSpace);
				}
				soap_revert(soap);
				if (soap_in_tt__Space1DDescription(soap, "tt:PanTiltSpeedSpace", a->PanTiltSpeedSpace, "tt:Space1DDescription"))
				{	a->__sizePanTiltSpeedSpace++;
					a->PanTiltSpeedSpace = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "tt:ZoomSpeedSpace", 1, NULL))
			{	if (a->ZoomSpeedSpace == NULL)
				{	if (soap_blist_ZoomSpeedSpace == NULL)
						soap_blist_ZoomSpeedSpace = soap_alloc_block(soap);
					a->ZoomSpeedSpace = (struct tt__Space1DDescription *)soap_push_block_max(soap, soap_blist_ZoomSpeedSpace, sizeof(struct tt__Space1DDescription));
					if (a->ZoomSpeedSpace == NULL)
						return NULL;
					soap_default_tt__Space1DDescription(soap, a->ZoomSpeedSpace);
				}
				soap_revert(soap);
				if (soap_in_tt__Space1DDescription(soap, "tt:ZoomSpeedSpace", a->ZoomSpeedSpace, "tt:Space1DDescription"))
				{	a->__sizeZoomSpeedSpace++;
					a->ZoomSpeedSpace = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->ContinuousPanTiltVelocitySpace)
			soap_pop_block(soap, soap_blist_ContinuousPanTiltVelocitySpace);
		if (a->__sizeContinuousPanTiltVelocitySpace)
		{	a->ContinuousPanTiltVelocitySpace = (struct tt__Space2DDescription *)soap_save_block(soap, soap_blist_ContinuousPanTiltVelocitySpace, NULL, 1);
		}
		else
		{	a->ContinuousPanTiltVelocitySpace = NULL;
			if (soap_blist_ContinuousPanTiltVelocitySpace)
				soap_end_block(soap, soap_blist_ContinuousPanTiltVelocitySpace);
		}
		if (a->ContinuousZoomVelocitySpace)
			soap_pop_block(soap, soap_blist_ContinuousZoomVelocitySpace);
		if (a->__sizeContinuousZoomVelocitySpace)
		{	a->ContinuousZoomVelocitySpace = (struct tt__Space1DDescription *)soap_save_block(soap, soap_blist_ContinuousZoomVelocitySpace, NULL, 1);
		}
		else
		{	a->ContinuousZoomVelocitySpace = NULL;
			if (soap_blist_ContinuousZoomVelocitySpace)
				soap_end_block(soap, soap_blist_ContinuousZoomVelocitySpace);
		}
		if (a->PanTiltSpeedSpace)
			soap_pop_block(soap, soap_blist_PanTiltSpeedSpace);
		if (a->__sizePanTiltSpeedSpace)
		{	a->PanTiltSpeedSpace = (struct tt__Space1DDescription *)soap_save_block(soap, soap_blist_PanTiltSpeedSpace, NULL, 1);
		}
		else
		{	a->PanTiltSpeedSpace = NULL;
			if (soap_blist_PanTiltSpeedSpace)
				soap_end_block(soap, soap_blist_PanTiltSpeedSpace);
		}
		if (a->ZoomSpeedSpace)
			soap_pop_block(soap, soap_blist_ZoomSpeedSpace);
		if (a->__sizeZoomSpeedSpace)
		{	a->ZoomSpeedSpace = (struct tt__Space1DDescription *)soap_save_block(soap, soap_blist_ZoomSpeedSpace, NULL, 1);
		}
		else
		{	a->ZoomSpeedSpace = NULL;
			if (soap_blist_ZoomSpeedSpace)
				soap_end_block(soap, soap_blist_ZoomSpeedSpace);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct tt__PTZSpaces *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__PTZSpaces, SOAP_TYPE_tt__PTZSpaces, sizeof(struct tt__PTZSpaces), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct tt__PTZSpaces * SOAP_FMAC4 soap_new_tt__PTZSpaces(struct soap *soap, int n)
{
	struct tt__PTZSpaces *p;
	struct tt__PTZSpaces *a = (struct tt__PTZSpaces*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct tt__PTZSpaces));
	for (p = a; p && n--; p++)
		soap_default_tt__PTZSpaces(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__PTZSpaces(struct soap *soap, const struct tt__PTZSpaces *a, const char *tag, const char *type)
{
	if (soap_out_tt__PTZSpaces(soap, tag ? tag : "tt:PTZSpaces", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__PTZSpaces * SOAP_FMAC4 soap_get_tt__PTZSpaces(struct soap *soap, struct tt__PTZSpaces *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__PTZSpaces(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__Space1DDescription(struct soap *soap, struct tt__Space1DDescription *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_xsd__anyURI(soap, &a->URI);
	a->XRange = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__Space1DDescription(struct soap *soap, const struct tt__Space1DDescription *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_xsd__anyURI(soap, (char*const*)&a->URI);
	soap_serialize_PointerTott__FloatRange(soap, &a->XRange);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__Space1DDescription(struct soap *soap, const char *tag, int id, const struct tt__Space1DDescription *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__Space1DDescription), type))
		return soap->error;
	if (!a->URI)
	{	if (soap_element_empty(soap, "tt:URI", 0, NULL))
			return soap->error;
	}
	else if (soap_out_xsd__anyURI(soap, "tt:URI", -1, (char*const*)&a->URI, ""))
		return soap->error;
	if (!a->XRange)
	{	if (soap_element_empty(soap, "tt:XRange", 0, NULL))
			return soap->error;
	}
	else if (soap_out_PointerTott__FloatRange(soap, "tt:XRange", -1, &a->XRange, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__Space1DDescription * SOAP_FMAC4 soap_in_tt__Space1DDescription(struct soap *soap, const char *tag, struct tt__Space1DDescription *a, const char *type)
{
	size_t soap_flag_URI = 1;
	size_t soap_flag_XRange = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct tt__Space1DDescription*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__Space1DDescription, sizeof(struct tt__Space1DDescription), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__Space1DDescription(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_URI && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_xsd__anyURI(soap, "tt:URI", (char**)&a->URI, "xsd:anyURI"))
				{	soap_flag_URI--;
					continue;
				}
			}
			if (soap_flag_XRange && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__FloatRange(soap, "tt:XRange", &a->XRange, "tt:FloatRange"))
				{	soap_flag_XRange--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (!a->URI || !a->XRange))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct tt__Space1DDescription *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__Space1DDescription, SOAP_TYPE_tt__Space1DDescription, sizeof(struct tt__Space1DDescription), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct tt__Space1DDescription * SOAP_FMAC4 soap_new_tt__Space1DDescription(struct soap *soap, int n)
{
	struct tt__Space1DDescription *p;
	struct tt__Space1DDescription *a = (struct tt__Space1DDescription*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct tt__Space1DDescription));
	for (p = a; p && n--; p++)
		soap_default_tt__Space1DDescription(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__Space1DDescription(struct soap *soap, const struct tt__Space1DDescription *a, const char *tag, const char *type)
{
	if (soap_out_tt__Space1DDescription(soap, tag ? tag : "tt:Space1DDescription", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__Space1DDescription * SOAP_FMAC4 soap_get_tt__Space1DDescription(struct soap *soap, struct tt__Space1DDescription *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__Space1DDescription(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__ZoomLimits(struct soap *soap, struct tt__ZoomLimits *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->Range = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__ZoomLimits(struct soap *soap, const struct tt__ZoomLimits *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTott__Space1DDescription(soap, &a->Range);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__ZoomLimits(struct soap *soap, const char *tag, int id, const struct tt__ZoomLimits *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__ZoomLimits), type))
		return soap->error;
	if (!a->Range)
	{	if (soap_element_empty(soap, "tt:Range", 0, NULL))
			return soap->error;
	}
	else if (soap_out_PointerTott__Space1DDescription(soap, "tt:Range", -1, &a->Range, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__ZoomLimits * SOAP_FMAC4 soap_in_tt__ZoomLimits(struct soap *soap, const char *tag, struct tt__ZoomLimits *a, const char *type)
{
	size_t soap_flag_Range = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct tt__ZoomLimits*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__ZoomLimits, sizeof(struct tt__ZoomLimits), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__ZoomLimits(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Range && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__Space1DDescription(soap, "tt:Range", &a->Range, "tt:Space1DDescription"))
				{	soap_flag_Range--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (!a->Range))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct tt__ZoomLimits *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__ZoomLimits, SOAP_TYPE_tt__ZoomLimits, sizeof(struct tt__ZoomLimits), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct tt__ZoomLimits * SOAP_FMAC4 soap_new_tt__ZoomLimits(struct soap *soap, int n)
{
	struct tt__ZoomLimits *p;
	struct tt__ZoomLimits *a = (struct tt__ZoomLimits*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct tt__ZoomLimits));
	for (p = a; p && n--; p++)
		soap_default_tt__ZoomLimits(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__ZoomLimits(struct soap *soap, const struct tt__ZoomLimits *a, const char *tag, const char *type)
{
	if (soap_out_tt__ZoomLimits(soap, tag ? tag : "tt:ZoomLimits", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__ZoomLimits * SOAP_FMAC4 soap_get_tt__ZoomLimits(struct soap *soap, struct tt__ZoomLimits *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__ZoomLimits(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__Space2DDescription(struct soap *soap, struct tt__Space2DDescription *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_xsd__anyURI(soap, &a->URI);
	a->XRange = NULL;
	a->YRange = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__Space2DDescription(struct soap *soap, const struct tt__Space2DDescription *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_xsd__anyURI(soap, (char*const*)&a->URI);
	soap_serialize_PointerTott__FloatRange(soap, &a->XRange);
	soap_serialize_PointerTott__FloatRange(soap, &a->YRange);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__Space2DDescription(struct soap *soap, const char *tag, int id, const struct tt__Space2DDescription *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__Space2DDescription), type))
		return soap->error;
	if (!a->URI)
	{	if (soap_element_empty(soap, "tt:URI", 0, NULL))
			return soap->error;
	}
	else if (soap_out_xsd__anyURI(soap, "tt:URI", -1, (char*const*)&a->URI, ""))
		return soap->error;
	if (!a->XRange)
	{	if (soap_element_empty(soap, "tt:XRange", 0, NULL))
			return soap->error;
	}
	else if (soap_out_PointerTott__FloatRange(soap, "tt:XRange", -1, &a->XRange, ""))
		return soap->error;
	if (!a->YRange)
	{	if (soap_element_empty(soap, "tt:YRange", 0, NULL))
			return soap->error;
	}
	else if (soap_out_PointerTott__FloatRange(soap, "tt:YRange", -1, &a->YRange, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__Space2DDescription * SOAP_FMAC4 soap_in_tt__Space2DDescription(struct soap *soap, const char *tag, struct tt__Space2DDescription *a, const char *type)
{
	size_t soap_flag_URI = 1;
	size_t soap_flag_XRange = 1;
	size_t soap_flag_YRange = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct tt__Space2DDescription*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__Space2DDescription, sizeof(struct tt__Space2DDescription), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__Space2DDescription(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_URI && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_xsd__anyURI(soap, "tt:URI", (char**)&a->URI, "xsd:anyURI"))
				{	soap_flag_URI--;
					continue;
				}
			}
			if (soap_flag_XRange && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__FloatRange(soap, "tt:XRange", &a->XRange, "tt:FloatRange"))
				{	soap_flag_XRange--;
					continue;
				}
			}
			if (soap_flag_YRange && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__FloatRange(soap, "tt:YRange", &a->YRange, "tt:FloatRange"))
				{	soap_flag_YRange--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (!a->URI || !a->XRange || !a->YRange))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct tt__Space2DDescription *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__Space2DDescription, SOAP_TYPE_tt__Space2DDescription, sizeof(struct tt__Space2DDescription), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct tt__Space2DDescription * SOAP_FMAC4 soap_new_tt__Space2DDescription(struct soap *soap, int n)
{
	struct tt__Space2DDescription *p;
	struct tt__Space2DDescription *a = (struct tt__Space2DDescription*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct tt__Space2DDescription));
	for (p = a; p && n--; p++)
		soap_default_tt__Space2DDescription(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__Space2DDescription(struct soap *soap, const struct tt__Space2DDescription *a, const char *tag, const char *type)
{
	if (soap_out_tt__Space2DDescription(soap, tag ? tag : "tt:Space2DDescription", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__Space2DDescription * SOAP_FMAC4 soap_get_tt__Space2DDescription(struct soap *soap, struct tt__Space2DDescription *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__Space2DDescription(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__PanTiltLimits(struct soap *soap, struct tt__PanTiltLimits *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->Range = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__PanTiltLimits(struct soap *soap, const struct tt__PanTiltLimits *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTott__Space2DDescription(soap, &a->Range);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__PanTiltLimits(struct soap *soap, const char *tag, int id, const struct tt__PanTiltLimits *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__PanTiltLimits), type))
		return soap->error;
	if (!a->Range)
	{	if (soap_element_empty(soap, "tt:Range", 0, NULL))
			return soap->error;
	}
	else if (soap_out_PointerTott__Space2DDescription(soap, "tt:Range", -1, &a->Range, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__PanTiltLimits * SOAP_FMAC4 soap_in_tt__PanTiltLimits(struct soap *soap, const char *tag, struct tt__PanTiltLimits *a, const char *type)
{
	size_t soap_flag_Range = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct tt__PanTiltLimits*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__PanTiltLimits, sizeof(struct tt__PanTiltLimits), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__PanTiltLimits(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Range && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__Space2DDescription(soap, "tt:Range", &a->Range, "tt:Space2DDescription"))
				{	soap_flag_Range--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (!a->Range))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct tt__PanTiltLimits *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__PanTiltLimits, SOAP_TYPE_tt__PanTiltLimits, sizeof(struct tt__PanTiltLimits), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct tt__PanTiltLimits * SOAP_FMAC4 soap_new_tt__PanTiltLimits(struct soap *soap, int n)
{
	struct tt__PanTiltLimits *p;
	struct tt__PanTiltLimits *a = (struct tt__PanTiltLimits*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct tt__PanTiltLimits));
	for (p = a; p && n--; p++)
		soap_default_tt__PanTiltLimits(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__PanTiltLimits(struct soap *soap, const struct tt__PanTiltLimits *a, const char *tag, const char *type)
{
	if (soap_out_tt__PanTiltLimits(soap, tag ? tag : "tt:PanTiltLimits", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__PanTiltLimits * SOAP_FMAC4 soap_get_tt__PanTiltLimits(struct soap *soap, struct tt__PanTiltLimits *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__PanTiltLimits(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__ProfileCapabilities(struct soap *soap, struct tt__ProfileCapabilities *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_int(soap, &a->MaximumNumberOfProfiles);
	a->__size = 0;
	a->__any = NULL;
	a->__anyAttribute = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__ProfileCapabilities(struct soap *soap, const struct tt__ProfileCapabilities *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &a->MaximumNumberOfProfiles, SOAP_TYPE_int);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__ProfileCapabilities(struct soap *soap, const char *tag, int id, const struct tt__ProfileCapabilities *a, const char *type)
{
	if (a->__anyAttribute)
		soap_set_attr(soap, "-anyAttribute", a->__anyAttribute, 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__ProfileCapabilities), type))
		return soap->error;
	if (soap_out_int(soap, "tt:MaximumNumberOfProfiles", -1, &a->MaximumNumberOfProfiles, ""))
		return soap->error;
	if (a->__any)
	{	int i;
		for (i = 0; i < (int)a->__size; i++)
			if (soap_outliteral(soap, "-any", (char*const*)(a->__any + i), NULL))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__ProfileCapabilities * SOAP_FMAC4 soap_in_tt__ProfileCapabilities(struct soap *soap, const char *tag, struct tt__ProfileCapabilities *a, const char *type)
{
	size_t soap_flag_MaximumNumberOfProfiles = 1;
	struct soap_blist *soap_blist___any = NULL;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct tt__ProfileCapabilities*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__ProfileCapabilities, sizeof(struct tt__ProfileCapabilities), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__ProfileCapabilities(soap, a);
	if (soap_s2char(soap, soap_attr_value(soap, "-anyAttribute", 0, 0), &a->__anyAttribute, 0, 0, -1, NULL))
		return NULL;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_MaximumNumberOfProfiles && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_int(soap, "tt:MaximumNumberOfProfiles", &a->MaximumNumberOfProfiles, "xsd:int"))
				{	soap_flag_MaximumNumberOfProfiles--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	if (a->__any == NULL)
				{	if (soap_blist___any == NULL)
						soap_blist___any = soap_alloc_block(soap);
					a->__any = (char **)soap_push_block_max(soap, soap_blist___any, sizeof(char *));
					if (a->__any == NULL)
						return NULL;
					*a->__any = NULL;
				}
				if (soap_inliteral(soap, "-any", (char**)a->__any))
				{	a->__size++;
					a->__any = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->__any)
			soap_pop_block(soap, soap_blist___any);
		if (a->__size)
		{	a->__any = (char **)soap_save_block(soap, soap_blist___any, NULL, 1);
		}
		else
		{	a->__any = NULL;
			if (soap_blist___any)
				soap_end_block(soap, soap_blist___any);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_MaximumNumberOfProfiles > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct tt__ProfileCapabilities *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__ProfileCapabilities, SOAP_TYPE_tt__ProfileCapabilities, sizeof(struct tt__ProfileCapabilities), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct tt__ProfileCapabilities * SOAP_FMAC4 soap_new_tt__ProfileCapabilities(struct soap *soap, int n)
{
	struct tt__ProfileCapabilities *p;
	struct tt__ProfileCapabilities *a = (struct tt__ProfileCapabilities*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct tt__ProfileCapabilities));
	for (p = a; p && n--; p++)
		soap_default_tt__ProfileCapabilities(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__ProfileCapabilities(struct soap *soap, const struct tt__ProfileCapabilities *a, const char *tag, const char *type)
{
	if (soap_out_tt__ProfileCapabilities(soap, tag ? tag : "tt:ProfileCapabilities", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__ProfileCapabilities * SOAP_FMAC4 soap_get_tt__ProfileCapabilities(struct soap *soap, struct tt__ProfileCapabilities *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__ProfileCapabilities(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__MediaCapabilitiesExtension(struct soap *soap, struct tt__MediaCapabilitiesExtension *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ProfileCapabilities = NULL;
	a->__size = 0;
	a->__any = NULL;
	a->__anyAttribute = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__MediaCapabilitiesExtension(struct soap *soap, const struct tt__MediaCapabilitiesExtension *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTott__ProfileCapabilities(soap, &a->ProfileCapabilities);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__MediaCapabilitiesExtension(struct soap *soap, const char *tag, int id, const struct tt__MediaCapabilitiesExtension *a, const char *type)
{
	if (a->__anyAttribute)
		soap_set_attr(soap, "-anyAttribute", a->__anyAttribute, 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__MediaCapabilitiesExtension), type))
		return soap->error;
	if (!a->ProfileCapabilities)
	{	if (soap_element_empty(soap, "tt:ProfileCapabilities", 0, NULL))
			return soap->error;
	}
	else if (soap_out_PointerTott__ProfileCapabilities(soap, "tt:ProfileCapabilities", -1, &a->ProfileCapabilities, ""))
		return soap->error;
	if (a->__any)
	{	int i;
		for (i = 0; i < (int)a->__size; i++)
			if (soap_outliteral(soap, "-any", (char*const*)(a->__any + i), NULL))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__MediaCapabilitiesExtension * SOAP_FMAC4 soap_in_tt__MediaCapabilitiesExtension(struct soap *soap, const char *tag, struct tt__MediaCapabilitiesExtension *a, const char *type)
{
	size_t soap_flag_ProfileCapabilities = 1;
	struct soap_blist *soap_blist___any = NULL;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct tt__MediaCapabilitiesExtension*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__MediaCapabilitiesExtension, sizeof(struct tt__MediaCapabilitiesExtension), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__MediaCapabilitiesExtension(soap, a);
	if (soap_s2char(soap, soap_attr_value(soap, "-anyAttribute", 0, 0), &a->__anyAttribute, 0, 0, -1, NULL))
		return NULL;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ProfileCapabilities && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__ProfileCapabilities(soap, "tt:ProfileCapabilities", &a->ProfileCapabilities, "tt:ProfileCapabilities"))
				{	soap_flag_ProfileCapabilities--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	if (a->__any == NULL)
				{	if (soap_blist___any == NULL)
						soap_blist___any = soap_alloc_block(soap);
					a->__any = (char **)soap_push_block_max(soap, soap_blist___any, sizeof(char *));
					if (a->__any == NULL)
						return NULL;
					*a->__any = NULL;
				}
				if (soap_inliteral(soap, "-any", (char**)a->__any))
				{	a->__size++;
					a->__any = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->__any)
			soap_pop_block(soap, soap_blist___any);
		if (a->__size)
		{	a->__any = (char **)soap_save_block(soap, soap_blist___any, NULL, 1);
		}
		else
		{	a->__any = NULL;
			if (soap_blist___any)
				soap_end_block(soap, soap_blist___any);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (!a->ProfileCapabilities))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct tt__MediaCapabilitiesExtension *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__MediaCapabilitiesExtension, SOAP_TYPE_tt__MediaCapabilitiesExtension, sizeof(struct tt__MediaCapabilitiesExtension), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct tt__MediaCapabilitiesExtension * SOAP_FMAC4 soap_new_tt__MediaCapabilitiesExtension(struct soap *soap, int n)
{
	struct tt__MediaCapabilitiesExtension *p;
	struct tt__MediaCapabilitiesExtension *a = (struct tt__MediaCapabilitiesExtension*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct tt__MediaCapabilitiesExtension));
	for (p = a; p && n--; p++)
		soap_default_tt__MediaCapabilitiesExtension(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__MediaCapabilitiesExtension(struct soap *soap, const struct tt__MediaCapabilitiesExtension *a, const char *tag, const char *type)
{
	if (soap_out_tt__MediaCapabilitiesExtension(soap, tag ? tag : "tt:MediaCapabilitiesExtension", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__MediaCapabilitiesExtension * SOAP_FMAC4 soap_get_tt__MediaCapabilitiesExtension(struct soap *soap, struct tt__MediaCapabilitiesExtension *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__MediaCapabilitiesExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__RealTimeStreamingCapabilities(struct soap *soap, struct tt__RealTimeStreamingCapabilities *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->RTPMulticast = NULL;
	a->RTP_USCORETCP = NULL;
	a->RTP_USCORERTSP_USCORETCP = NULL;
	a->__anyAttribute = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__RealTimeStreamingCapabilities(struct soap *soap, const struct tt__RealTimeStreamingCapabilities *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerToxsd__boolean(soap, &a->RTPMulticast);
	soap_serialize_PointerToxsd__boolean(soap, &a->RTP_USCORETCP);
	soap_serialize_PointerToxsd__boolean(soap, &a->RTP_USCORERTSP_USCORETCP);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__RealTimeStreamingCapabilities(struct soap *soap, const char *tag, int id, const struct tt__RealTimeStreamingCapabilities *a, const char *type)
{
	if (a->__anyAttribute)
		soap_set_attr(soap, "-anyAttribute", a->__anyAttribute, 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__RealTimeStreamingCapabilities), type))
		return soap->error;
	if (soap_out_PointerToxsd__boolean(soap, "tt:RTPMulticast", -1, &a->RTPMulticast, ""))
		return soap->error;
	if (soap_out_PointerToxsd__boolean(soap, "tt:RTP_TCP", -1, &a->RTP_USCORETCP, ""))
		return soap->error;
	if (soap_out_PointerToxsd__boolean(soap, "tt:RTP_RTSP_TCP", -1, &a->RTP_USCORERTSP_USCORETCP, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__RealTimeStreamingCapabilities * SOAP_FMAC4 soap_in_tt__RealTimeStreamingCapabilities(struct soap *soap, const char *tag, struct tt__RealTimeStreamingCapabilities *a, const char *type)
{
	size_t soap_flag_RTPMulticast = 1;
	size_t soap_flag_RTP_USCORETCP = 1;
	size_t soap_flag_RTP_USCORERTSP_USCORETCP = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct tt__RealTimeStreamingCapabilities*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__RealTimeStreamingCapabilities, sizeof(struct tt__RealTimeStreamingCapabilities), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__RealTimeStreamingCapabilities(soap, a);
	if (soap_s2char(soap, soap_attr_value(soap, "-anyAttribute", 0, 0), &a->__anyAttribute, 0, 0, -1, NULL))
		return NULL;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_RTPMulticast && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerToxsd__boolean(soap, "tt:RTPMulticast", &a->RTPMulticast, "xsd:boolean"))
				{	soap_flag_RTPMulticast--;
					continue;
				}
			}
			if (soap_flag_RTP_USCORETCP && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerToxsd__boolean(soap, "tt:RTP_TCP", &a->RTP_USCORETCP, "xsd:boolean"))
				{	soap_flag_RTP_USCORETCP--;
					continue;
				}
			}
			if (soap_flag_RTP_USCORERTSP_USCORETCP && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerToxsd__boolean(soap, "tt:RTP_RTSP_TCP", &a->RTP_USCORERTSP_USCORETCP, "xsd:boolean"))
				{	soap_flag_RTP_USCORERTSP_USCORETCP--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct tt__RealTimeStreamingCapabilities *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__RealTimeStreamingCapabilities, SOAP_TYPE_tt__RealTimeStreamingCapabilities, sizeof(struct tt__RealTimeStreamingCapabilities), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct tt__RealTimeStreamingCapabilities * SOAP_FMAC4 soap_new_tt__RealTimeStreamingCapabilities(struct soap *soap, int n)
{
	struct tt__RealTimeStreamingCapabilities *p;
	struct tt__RealTimeStreamingCapabilities *a = (struct tt__RealTimeStreamingCapabilities*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct tt__RealTimeStreamingCapabilities));
	for (p = a; p && n--; p++)
		soap_default_tt__RealTimeStreamingCapabilities(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__RealTimeStreamingCapabilities(struct soap *soap, const struct tt__RealTimeStreamingCapabilities *a, const char *tag, const char *type)
{
	if (soap_out_tt__RealTimeStreamingCapabilities(soap, tag ? tag : "tt:RealTimeStreamingCapabilities", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__RealTimeStreamingCapabilities * SOAP_FMAC4 soap_get_tt__RealTimeStreamingCapabilities(struct soap *soap, struct tt__RealTimeStreamingCapabilities *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__RealTimeStreamingCapabilities(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__SystemCapabilities(struct soap *soap, struct tt__SystemCapabilities *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_xsd__boolean(soap, &a->DiscoveryResolve);
	soap_default_xsd__boolean(soap, &a->DiscoveryBye);
	a->__sizeSupportedVersions = 0;
	a->SupportedVersions = NULL;
	a->__anyAttribute = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__SystemCapabilities(struct soap *soap, const struct tt__SystemCapabilities *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &a->DiscoveryResolve, SOAP_TYPE_xsd__boolean);
	soap_embedded(soap, &a->DiscoveryBye, SOAP_TYPE_xsd__boolean);
	if (a->SupportedVersions)
	{	int i;
		for (i = 0; i < (int)a->__sizeSupportedVersions; i++)
		{
			soap_embedded(soap, a->SupportedVersions + i, SOAP_TYPE_tt__OnvifVersion);
			soap_serialize_tt__OnvifVersion(soap, a->SupportedVersions + i);
		}
	}
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__SystemCapabilities(struct soap *soap, const char *tag, int id, const struct tt__SystemCapabilities *a, const char *type)
{
	if (a->__anyAttribute)
		soap_set_attr(soap, "-anyAttribute", a->__anyAttribute, 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__SystemCapabilities), type))
		return soap->error;
	if (soap_out_xsd__boolean(soap, "tt:DiscoveryResolve", -1, &a->DiscoveryResolve, ""))
		return soap->error;
	if (soap_out_xsd__boolean(soap, "tt:DiscoveryBye", -1, &a->DiscoveryBye, ""))
		return soap->error;
	if (a->SupportedVersions)
	{	int i;
		for (i = 0; i < (int)a->__sizeSupportedVersions; i++)
			if (soap_out_tt__OnvifVersion(soap, "tt:SupportedVersions", -1, a->SupportedVersions + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__SystemCapabilities * SOAP_FMAC4 soap_in_tt__SystemCapabilities(struct soap *soap, const char *tag, struct tt__SystemCapabilities *a, const char *type)
{
	size_t soap_flag_DiscoveryResolve = 1;
	size_t soap_flag_DiscoveryBye = 1;
	struct soap_blist *soap_blist_SupportedVersions = NULL;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct tt__SystemCapabilities*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__SystemCapabilities, sizeof(struct tt__SystemCapabilities), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__SystemCapabilities(soap, a);
	if (soap_s2char(soap, soap_attr_value(soap, "-anyAttribute", 0, 0), &a->__anyAttribute, 0, 0, -1, NULL))
		return NULL;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_DiscoveryResolve && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_xsd__boolean(soap, "tt:DiscoveryResolve", &a->DiscoveryResolve, "xsd:boolean"))
				{	soap_flag_DiscoveryResolve--;
					continue;
				}
			}
			if (soap_flag_DiscoveryBye && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_xsd__boolean(soap, "tt:DiscoveryBye", &a->DiscoveryBye, "xsd:boolean"))
				{	soap_flag_DiscoveryBye--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "tt:SupportedVersions", 1, NULL))
			{	if (a->SupportedVersions == NULL)
				{	if (soap_blist_SupportedVersions == NULL)
						soap_blist_SupportedVersions = soap_alloc_block(soap);
					a->SupportedVersions = (struct tt__OnvifVersion *)soap_push_block_max(soap, soap_blist_SupportedVersions, sizeof(struct tt__OnvifVersion));
					if (a->SupportedVersions == NULL)
						return NULL;
					soap_default_tt__OnvifVersion(soap, a->SupportedVersions);
				}
				soap_revert(soap);
				if (soap_in_tt__OnvifVersion(soap, "tt:SupportedVersions", a->SupportedVersions, "tt:OnvifVersion"))
				{	a->__sizeSupportedVersions++;
					a->SupportedVersions = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->SupportedVersions)
			soap_pop_block(soap, soap_blist_SupportedVersions);
		if (a->__sizeSupportedVersions)
		{	a->SupportedVersions = (struct tt__OnvifVersion *)soap_save_block(soap, soap_blist_SupportedVersions, NULL, 1);
		}
		else
		{	a->SupportedVersions = NULL;
			if (soap_blist_SupportedVersions)
				soap_end_block(soap, soap_blist_SupportedVersions);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_DiscoveryResolve > 0 || soap_flag_DiscoveryBye > 0 || a->__sizeSupportedVersions < 1))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct tt__SystemCapabilities *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__SystemCapabilities, SOAP_TYPE_tt__SystemCapabilities, sizeof(struct tt__SystemCapabilities), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct tt__SystemCapabilities * SOAP_FMAC4 soap_new_tt__SystemCapabilities(struct soap *soap, int n)
{
	struct tt__SystemCapabilities *p;
	struct tt__SystemCapabilities *a = (struct tt__SystemCapabilities*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct tt__SystemCapabilities));
	for (p = a; p && n--; p++)
		soap_default_tt__SystemCapabilities(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__SystemCapabilities(struct soap *soap, const struct tt__SystemCapabilities *a, const char *tag, const char *type)
{
	if (soap_out_tt__SystemCapabilities(soap, tag ? tag : "tt:SystemCapabilities", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__SystemCapabilities * SOAP_FMAC4 soap_get_tt__SystemCapabilities(struct soap *soap, struct tt__SystemCapabilities *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__SystemCapabilities(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__PTZCapabilities(struct soap *soap, struct tt__PTZCapabilities *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_xsd__anyURI(soap, &a->XAddr);
	a->__size = 0;
	a->__any = NULL;
	a->__anyAttribute = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__PTZCapabilities(struct soap *soap, const struct tt__PTZCapabilities *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_xsd__anyURI(soap, (char*const*)&a->XAddr);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__PTZCapabilities(struct soap *soap, const char *tag, int id, const struct tt__PTZCapabilities *a, const char *type)
{
	if (a->__anyAttribute)
		soap_set_attr(soap, "-anyAttribute", a->__anyAttribute, 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__PTZCapabilities), type))
		return soap->error;
	if (!a->XAddr)
	{	if (soap_element_empty(soap, "tt:XAddr", 0, NULL))
			return soap->error;
	}
	else if (soap_out_xsd__anyURI(soap, "tt:XAddr", -1, (char*const*)&a->XAddr, ""))
		return soap->error;
	if (a->__any)
	{	int i;
		for (i = 0; i < (int)a->__size; i++)
			if (soap_outliteral(soap, "-any", (char*const*)(a->__any + i), NULL))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__PTZCapabilities * SOAP_FMAC4 soap_in_tt__PTZCapabilities(struct soap *soap, const char *tag, struct tt__PTZCapabilities *a, const char *type)
{
	size_t soap_flag_XAddr = 1;
	struct soap_blist *soap_blist___any = NULL;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct tt__PTZCapabilities*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__PTZCapabilities, sizeof(struct tt__PTZCapabilities), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__PTZCapabilities(soap, a);
	if (soap_s2char(soap, soap_attr_value(soap, "-anyAttribute", 0, 0), &a->__anyAttribute, 0, 0, -1, NULL))
		return NULL;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_XAddr && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_xsd__anyURI(soap, "tt:XAddr", (char**)&a->XAddr, "xsd:anyURI"))
				{	soap_flag_XAddr--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	if (a->__any == NULL)
				{	if (soap_blist___any == NULL)
						soap_blist___any = soap_alloc_block(soap);
					a->__any = (char **)soap_push_block_max(soap, soap_blist___any, sizeof(char *));
					if (a->__any == NULL)
						return NULL;
					*a->__any = NULL;
				}
				if (soap_inliteral(soap, "-any", (char**)a->__any))
				{	a->__size++;
					a->__any = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->__any)
			soap_pop_block(soap, soap_blist___any);
		if (a->__size)
		{	a->__any = (char **)soap_save_block(soap, soap_blist___any, NULL, 1);
		}
		else
		{	a->__any = NULL;
			if (soap_blist___any)
				soap_end_block(soap, soap_blist___any);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (!a->XAddr))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct tt__PTZCapabilities *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__PTZCapabilities, SOAP_TYPE_tt__PTZCapabilities, sizeof(struct tt__PTZCapabilities), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct tt__PTZCapabilities * SOAP_FMAC4 soap_new_tt__PTZCapabilities(struct soap *soap, int n)
{
	struct tt__PTZCapabilities *p;
	struct tt__PTZCapabilities *a = (struct tt__PTZCapabilities*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct tt__PTZCapabilities));
	for (p = a; p && n--; p++)
		soap_default_tt__PTZCapabilities(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__PTZCapabilities(struct soap *soap, const struct tt__PTZCapabilities *a, const char *tag, const char *type)
{
	if (soap_out_tt__PTZCapabilities(soap, tag ? tag : "tt:PTZCapabilities", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__PTZCapabilities * SOAP_FMAC4 soap_get_tt__PTZCapabilities(struct soap *soap, struct tt__PTZCapabilities *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__PTZCapabilities(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__MediaCapabilities(struct soap *soap, struct tt__MediaCapabilities *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_xsd__anyURI(soap, &a->XAddr);
	a->StreamingCapabilities = NULL;
	a->__size = 0;
	a->__any = NULL;
	a->Extension = NULL;
	a->__anyAttribute = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__MediaCapabilities(struct soap *soap, const struct tt__MediaCapabilities *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_xsd__anyURI(soap, (char*const*)&a->XAddr);
	soap_serialize_PointerTott__RealTimeStreamingCapabilities(soap, &a->StreamingCapabilities);
	soap_serialize_PointerTott__MediaCapabilitiesExtension(soap, &a->Extension);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__MediaCapabilities(struct soap *soap, const char *tag, int id, const struct tt__MediaCapabilities *a, const char *type)
{
	if (a->__anyAttribute)
		soap_set_attr(soap, "-anyAttribute", a->__anyAttribute, 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__MediaCapabilities), type))
		return soap->error;
	if (!a->XAddr)
	{	if (soap_element_empty(soap, "tt:XAddr", 0, NULL))
			return soap->error;
	}
	else if (soap_out_xsd__anyURI(soap, "tt:XAddr", -1, (char*const*)&a->XAddr, ""))
		return soap->error;
	if (!a->StreamingCapabilities)
	{	if (soap_element_empty(soap, "tt:StreamingCapabilities", 0, NULL))
			return soap->error;
	}
	else if (soap_out_PointerTott__RealTimeStreamingCapabilities(soap, "tt:StreamingCapabilities", -1, &a->StreamingCapabilities, ""))
		return soap->error;
	if (a->__any)
	{	int i;
		for (i = 0; i < (int)a->__size; i++)
			if (soap_outliteral(soap, "-any", (char*const*)(a->__any + i), NULL))
				return soap->error;
	}
	if (soap_out_PointerTott__MediaCapabilitiesExtension(soap, "tt:Extension", -1, &a->Extension, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__MediaCapabilities * SOAP_FMAC4 soap_in_tt__MediaCapabilities(struct soap *soap, const char *tag, struct tt__MediaCapabilities *a, const char *type)
{
	size_t soap_flag_XAddr = 1;
	size_t soap_flag_StreamingCapabilities = 1;
	struct soap_blist *soap_blist___any = NULL;
	size_t soap_flag_Extension = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct tt__MediaCapabilities*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__MediaCapabilities, sizeof(struct tt__MediaCapabilities), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__MediaCapabilities(soap, a);
	if (soap_s2char(soap, soap_attr_value(soap, "-anyAttribute", 0, 0), &a->__anyAttribute, 0, 0, -1, NULL))
		return NULL;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_XAddr && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_xsd__anyURI(soap, "tt:XAddr", (char**)&a->XAddr, "xsd:anyURI"))
				{	soap_flag_XAddr--;
					continue;
				}
			}
			if (soap_flag_StreamingCapabilities && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__RealTimeStreamingCapabilities(soap, "tt:StreamingCapabilities", &a->StreamingCapabilities, "tt:RealTimeStreamingCapabilities"))
				{	soap_flag_StreamingCapabilities--;
					continue;
				}
			}
			if (soap_flag_Extension && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__MediaCapabilitiesExtension(soap, "tt:Extension", &a->Extension, "tt:MediaCapabilitiesExtension"))
				{	soap_flag_Extension--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	if (a->__any == NULL)
				{	if (soap_blist___any == NULL)
						soap_blist___any = soap_alloc_block(soap);
					a->__any = (char **)soap_push_block_max(soap, soap_blist___any, sizeof(char *));
					if (a->__any == NULL)
						return NULL;
					*a->__any = NULL;
				}
				if (soap_inliteral(soap, "-any", (char**)a->__any))
				{	a->__size++;
					a->__any = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->__any)
			soap_pop_block(soap, soap_blist___any);
		if (a->__size)
		{	a->__any = (char **)soap_save_block(soap, soap_blist___any, NULL, 1);
		}
		else
		{	a->__any = NULL;
			if (soap_blist___any)
				soap_end_block(soap, soap_blist___any);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (!a->XAddr || !a->StreamingCapabilities))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct tt__MediaCapabilities *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__MediaCapabilities, SOAP_TYPE_tt__MediaCapabilities, sizeof(struct tt__MediaCapabilities), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct tt__MediaCapabilities * SOAP_FMAC4 soap_new_tt__MediaCapabilities(struct soap *soap, int n)
{
	struct tt__MediaCapabilities *p;
	struct tt__MediaCapabilities *a = (struct tt__MediaCapabilities*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct tt__MediaCapabilities));
	for (p = a; p && n--; p++)
		soap_default_tt__MediaCapabilities(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__MediaCapabilities(struct soap *soap, const struct tt__MediaCapabilities *a, const char *tag, const char *type)
{
	if (soap_out_tt__MediaCapabilities(soap, tag ? tag : "tt:MediaCapabilities", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__MediaCapabilities * SOAP_FMAC4 soap_get_tt__MediaCapabilities(struct soap *soap, struct tt__MediaCapabilities *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__MediaCapabilities(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__EventCapabilities(struct soap *soap, struct tt__EventCapabilities *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_xsd__anyURI(soap, &a->XAddr);
	soap_default_xsd__boolean(soap, &a->WSSubscriptionPolicySupport);
	soap_default_xsd__boolean(soap, &a->WSPullPointSupport);
	soap_default_xsd__boolean(soap, &a->WSPausableSubscriptionManagerInterfaceSupport);
	a->__size = 0;
	a->__any = NULL;
	a->__anyAttribute = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__EventCapabilities(struct soap *soap, const struct tt__EventCapabilities *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_xsd__anyURI(soap, (char*const*)&a->XAddr);
	soap_embedded(soap, &a->WSSubscriptionPolicySupport, SOAP_TYPE_xsd__boolean);
	soap_embedded(soap, &a->WSPullPointSupport, SOAP_TYPE_xsd__boolean);
	soap_embedded(soap, &a->WSPausableSubscriptionManagerInterfaceSupport, SOAP_TYPE_xsd__boolean);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__EventCapabilities(struct soap *soap, const char *tag, int id, const struct tt__EventCapabilities *a, const char *type)
{
	if (a->__anyAttribute)
		soap_set_attr(soap, "-anyAttribute", a->__anyAttribute, 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__EventCapabilities), type))
		return soap->error;
	if (!a->XAddr)
	{	if (soap_element_empty(soap, "tt:XAddr", 0, NULL))
			return soap->error;
	}
	else if (soap_out_xsd__anyURI(soap, "tt:XAddr", -1, (char*const*)&a->XAddr, ""))
		return soap->error;
	if (soap_out_xsd__boolean(soap, "tt:WSSubscriptionPolicySupport", -1, &a->WSSubscriptionPolicySupport, ""))
		return soap->error;
	if (soap_out_xsd__boolean(soap, "tt:WSPullPointSupport", -1, &a->WSPullPointSupport, ""))
		return soap->error;
	if (soap_out_xsd__boolean(soap, "tt:WSPausableSubscriptionManagerInterfaceSupport", -1, &a->WSPausableSubscriptionManagerInterfaceSupport, ""))
		return soap->error;
	if (a->__any)
	{	int i;
		for (i = 0; i < (int)a->__size; i++)
			if (soap_outliteral(soap, "-any", (char*const*)(a->__any + i), NULL))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__EventCapabilities * SOAP_FMAC4 soap_in_tt__EventCapabilities(struct soap *soap, const char *tag, struct tt__EventCapabilities *a, const char *type)
{
	size_t soap_flag_XAddr = 1;
	size_t soap_flag_WSSubscriptionPolicySupport = 1;
	size_t soap_flag_WSPullPointSupport = 1;
	size_t soap_flag_WSPausableSubscriptionManagerInterfaceSupport = 1;
	struct soap_blist *soap_blist___any = NULL;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct tt__EventCapabilities*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__EventCapabilities, sizeof(struct tt__EventCapabilities), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__EventCapabilities(soap, a);
	if (soap_s2char(soap, soap_attr_value(soap, "-anyAttribute", 0, 0), &a->__anyAttribute, 0, 0, -1, NULL))
		return NULL;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_XAddr && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_xsd__anyURI(soap, "tt:XAddr", (char**)&a->XAddr, "xsd:anyURI"))
				{	soap_flag_XAddr--;
					continue;
				}
			}
			if (soap_flag_WSSubscriptionPolicySupport && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_xsd__boolean(soap, "tt:WSSubscriptionPolicySupport", &a->WSSubscriptionPolicySupport, "xsd:boolean"))
				{	soap_flag_WSSubscriptionPolicySupport--;
					continue;
				}
			}
			if (soap_flag_WSPullPointSupport && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_xsd__boolean(soap, "tt:WSPullPointSupport", &a->WSPullPointSupport, "xsd:boolean"))
				{	soap_flag_WSPullPointSupport--;
					continue;
				}
			}
			if (soap_flag_WSPausableSubscriptionManagerInterfaceSupport && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_xsd__boolean(soap, "tt:WSPausableSubscriptionManagerInterfaceSupport", &a->WSPausableSubscriptionManagerInterfaceSupport, "xsd:boolean"))
				{	soap_flag_WSPausableSubscriptionManagerInterfaceSupport--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	if (a->__any == NULL)
				{	if (soap_blist___any == NULL)
						soap_blist___any = soap_alloc_block(soap);
					a->__any = (char **)soap_push_block_max(soap, soap_blist___any, sizeof(char *));
					if (a->__any == NULL)
						return NULL;
					*a->__any = NULL;
				}
				if (soap_inliteral(soap, "-any", (char**)a->__any))
				{	a->__size++;
					a->__any = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->__any)
			soap_pop_block(soap, soap_blist___any);
		if (a->__size)
		{	a->__any = (char **)soap_save_block(soap, soap_blist___any, NULL, 1);
		}
		else
		{	a->__any = NULL;
			if (soap_blist___any)
				soap_end_block(soap, soap_blist___any);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (!a->XAddr || soap_flag_WSSubscriptionPolicySupport > 0 || soap_flag_WSPullPointSupport > 0 || soap_flag_WSPausableSubscriptionManagerInterfaceSupport > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct tt__EventCapabilities *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__EventCapabilities, SOAP_TYPE_tt__EventCapabilities, sizeof(struct tt__EventCapabilities), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct tt__EventCapabilities * SOAP_FMAC4 soap_new_tt__EventCapabilities(struct soap *soap, int n)
{
	struct tt__EventCapabilities *p;
	struct tt__EventCapabilities *a = (struct tt__EventCapabilities*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct tt__EventCapabilities));
	for (p = a; p && n--; p++)
		soap_default_tt__EventCapabilities(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__EventCapabilities(struct soap *soap, const struct tt__EventCapabilities *a, const char *tag, const char *type)
{
	if (soap_out_tt__EventCapabilities(soap, tag ? tag : "tt:EventCapabilities", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__EventCapabilities * SOAP_FMAC4 soap_get_tt__EventCapabilities(struct soap *soap, struct tt__EventCapabilities *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__EventCapabilities(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__DeviceCapabilities(struct soap *soap, struct tt__DeviceCapabilities *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_xsd__anyURI(soap, &a->XAddr);
	a->System = NULL;
	a->__anyAttribute = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__DeviceCapabilities(struct soap *soap, const struct tt__DeviceCapabilities *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_xsd__anyURI(soap, (char*const*)&a->XAddr);
	soap_serialize_PointerTott__SystemCapabilities(soap, &a->System);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__DeviceCapabilities(struct soap *soap, const char *tag, int id, const struct tt__DeviceCapabilities *a, const char *type)
{
	if (a->__anyAttribute)
		soap_set_attr(soap, "-anyAttribute", a->__anyAttribute, 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__DeviceCapabilities), type))
		return soap->error;
	if (!a->XAddr)
	{	if (soap_element_empty(soap, "tt:XAddr", 0, NULL))
			return soap->error;
	}
	else if (soap_out_xsd__anyURI(soap, "tt:XAddr", -1, (char*const*)&a->XAddr, ""))
		return soap->error;
	if (soap_out_PointerTott__SystemCapabilities(soap, "tt:System", -1, &a->System, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__DeviceCapabilities * SOAP_FMAC4 soap_in_tt__DeviceCapabilities(struct soap *soap, const char *tag, struct tt__DeviceCapabilities *a, const char *type)
{
	size_t soap_flag_XAddr = 1;
	size_t soap_flag_System = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct tt__DeviceCapabilities*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__DeviceCapabilities, sizeof(struct tt__DeviceCapabilities), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__DeviceCapabilities(soap, a);
	if (soap_s2char(soap, soap_attr_value(soap, "-anyAttribute", 0, 0), &a->__anyAttribute, 0, 0, -1, NULL))
		return NULL;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_XAddr && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_xsd__anyURI(soap, "tt:XAddr", (char**)&a->XAddr, "xsd:anyURI"))
				{	soap_flag_XAddr--;
					continue;
				}
			}
			if (soap_flag_System && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__SystemCapabilities(soap, "tt:System", &a->System, "tt:SystemCapabilities"))
				{	soap_flag_System--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (!a->XAddr))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct tt__DeviceCapabilities *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__DeviceCapabilities, SOAP_TYPE_tt__DeviceCapabilities, sizeof(struct tt__DeviceCapabilities), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct tt__DeviceCapabilities * SOAP_FMAC4 soap_new_tt__DeviceCapabilities(struct soap *soap, int n)
{
	struct tt__DeviceCapabilities *p;
	struct tt__DeviceCapabilities *a = (struct tt__DeviceCapabilities*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct tt__DeviceCapabilities));
	for (p = a; p && n--; p++)
		soap_default_tt__DeviceCapabilities(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__DeviceCapabilities(struct soap *soap, const struct tt__DeviceCapabilities *a, const char *tag, const char *type)
{
	if (soap_out_tt__DeviceCapabilities(soap, tag ? tag : "tt:DeviceCapabilities", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__DeviceCapabilities * SOAP_FMAC4 soap_get_tt__DeviceCapabilities(struct soap *soap, struct tt__DeviceCapabilities *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__DeviceCapabilities(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__ConfigurationEntity(struct soap *soap, struct tt__ConfigurationEntity *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_tt__Name(soap, &a->Name);
	soap_default_int(soap, &a->UseCount);
	soap_default_tt__ReferenceToken(soap, &a->token);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__ConfigurationEntity(struct soap *soap, const struct tt__ConfigurationEntity *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_tt__Name(soap, (char*const*)&a->Name);
	soap_embedded(soap, &a->UseCount, SOAP_TYPE_int);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__ConfigurationEntity(struct soap *soap, const char *tag, int id, const struct tt__ConfigurationEntity *a, const char *type)
{
	soap_set_attr(soap, "token", a->token ? soap_tt__ReferenceToken2s(soap, a->token) : "", 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__ConfigurationEntity), type))
		return soap->error;
	if (!a->Name)
	{	if (soap_element_empty(soap, "tt:Name", 0, NULL))
			return soap->error;
	}
	else if (soap_out_tt__Name(soap, "tt:Name", -1, (char*const*)&a->Name, ""))
		return soap->error;
	if (soap_out_int(soap, "tt:UseCount", -1, &a->UseCount, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__ConfigurationEntity * SOAP_FMAC4 soap_in_tt__ConfigurationEntity(struct soap *soap, const char *tag, struct tt__ConfigurationEntity *a, const char *type)
{
	size_t soap_flag_Name = 1;
	size_t soap_flag_UseCount = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct tt__ConfigurationEntity*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__ConfigurationEntity, sizeof(struct tt__ConfigurationEntity), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__ConfigurationEntity(soap, a);
	if (soap_s2tt__ReferenceToken(soap, soap_attr_value(soap, "token", 1, 1), &a->token))
		return NULL;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Name && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_tt__Name(soap, "tt:Name", (char**)&a->Name, "tt:Name"))
				{	soap_flag_Name--;
					continue;
				}
			}
			if (soap_flag_UseCount && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_int(soap, "tt:UseCount", &a->UseCount, "xsd:int"))
				{	soap_flag_UseCount--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (!a->Name || soap_flag_UseCount > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct tt__ConfigurationEntity *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__ConfigurationEntity, SOAP_TYPE_tt__ConfigurationEntity, sizeof(struct tt__ConfigurationEntity), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct tt__ConfigurationEntity * SOAP_FMAC4 soap_new_tt__ConfigurationEntity(struct soap *soap, int n)
{
	struct tt__ConfigurationEntity *p;
	struct tt__ConfigurationEntity *a = (struct tt__ConfigurationEntity*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct tt__ConfigurationEntity));
	for (p = a; p && n--; p++)
		soap_default_tt__ConfigurationEntity(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__ConfigurationEntity(struct soap *soap, const struct tt__ConfigurationEntity *a, const char *tag, const char *type)
{
	if (soap_out_tt__ConfigurationEntity(soap, tag ? tag : "tt:ConfigurationEntity", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__ConfigurationEntity * SOAP_FMAC4 soap_get_tt__ConfigurationEntity(struct soap *soap, struct tt__ConfigurationEntity *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__ConfigurationEntity(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__VideoEncoderConfiguration(struct soap *soap, struct tt__VideoEncoderConfiguration *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_tt__Name(soap, &a->Name);
	soap_default_int(soap, &a->UseCount);
	soap_default_tt__ReferenceToken(soap, &a->token);
	soap_default_tt__VideoEncoding(soap, &a->Encoding);
	a->Resolution = NULL;
	soap_default_float(soap, &a->Quality);
	a->RateControl = NULL;
	a->MPEG4 = NULL;
	a->H264 = NULL;
	a->Multicast = NULL;
	soap_default_xsd__duration(soap, &a->SessionTimeout);
	a->__size = 0;
	a->__any = NULL;
	a->GuaranteedFrameRate = NULL;
	a->__anyAttribute = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__VideoEncoderConfiguration(struct soap *soap, const struct tt__VideoEncoderConfiguration *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_tt__Name(soap, (char*const*)&a->Name);
	soap_embedded(soap, &a->UseCount, SOAP_TYPE_int);
	soap_serialize_PointerTott__VideoResolution(soap, &a->Resolution);
	soap_embedded(soap, &a->Quality, SOAP_TYPE_float);
	soap_serialize_PointerTott__VideoRateControl(soap, &a->RateControl);
	soap_serialize_PointerTott__Mpeg4Configuration(soap, &a->MPEG4);
	soap_serialize_PointerTott__H264Configuration(soap, &a->H264);
	soap_serialize_PointerTott__MulticastConfiguration(soap, &a->Multicast);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__VideoEncoderConfiguration(struct soap *soap, const char *tag, int id, const struct tt__VideoEncoderConfiguration *a, const char *type)
{
	soap_set_attr(soap, "token", a->token ? soap_tt__ReferenceToken2s(soap, a->token) : "", 1);
	if (a->GuaranteedFrameRate)
	{	soap_set_attr(soap, "GuaranteedFrameRate", soap_xsd__boolean2s(soap, *a->GuaranteedFrameRate), 1);
	}
	if (a->__anyAttribute)
		soap_set_attr(soap, "-anyAttribute", a->__anyAttribute, 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__VideoEncoderConfiguration), type))
		return soap->error;
	if (!a->Name)
	{	if (soap_element_empty(soap, "tt:Name", 0, NULL))
			return soap->error;
	}
	else if (soap_out_tt__Name(soap, "tt:Name", -1, (char*const*)&a->Name, ""))
		return soap->error;
	if (soap_out_int(soap, "tt:UseCount", -1, &a->UseCount, ""))
		return soap->error;
	if (soap_out_tt__VideoEncoding(soap, "tt:Encoding", -1, &a->Encoding, ""))
		return soap->error;
	if (!a->Resolution)
	{	if (soap_element_empty(soap, "tt:Resolution", 0, NULL))
			return soap->error;
	}
	else if (soap_out_PointerTott__VideoResolution(soap, "tt:Resolution", -1, &a->Resolution, ""))
		return soap->error;
	if (soap_out_float(soap, "tt:Quality", -1, &a->Quality, ""))
		return soap->error;
	if (soap_out_PointerTott__VideoRateControl(soap, "tt:RateControl", -1, &a->RateControl, ""))
		return soap->error;
	if (soap_out_PointerTott__Mpeg4Configuration(soap, "tt:MPEG4", -1, &a->MPEG4, ""))
		return soap->error;
	if (soap_out_PointerTott__H264Configuration(soap, "tt:H264", -1, &a->H264, ""))
		return soap->error;
	if (!a->Multicast)
	{	if (soap_element_empty(soap, "tt:Multicast", 0, NULL))
			return soap->error;
	}
	else if (soap_out_PointerTott__MulticastConfiguration(soap, "tt:Multicast", -1, &a->Multicast, ""))
		return soap->error;
	if (soap_out_xsd__duration(soap, "tt:SessionTimeout", -1, &a->SessionTimeout, ""))
		return soap->error;
	if (a->__any)
	{	int i;
		for (i = 0; i < (int)a->__size; i++)
			if (soap_outliteral(soap, "-any", (char*const*)(a->__any + i), NULL))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__VideoEncoderConfiguration * SOAP_FMAC4 soap_in_tt__VideoEncoderConfiguration(struct soap *soap, const char *tag, struct tt__VideoEncoderConfiguration *a, const char *type)
{
	size_t soap_flag_Name = 1;
	size_t soap_flag_UseCount = 1;
	size_t soap_flag_Encoding = 1;
	size_t soap_flag_Resolution = 1;
	size_t soap_flag_Quality = 1;
	size_t soap_flag_RateControl = 1;
	size_t soap_flag_MPEG4 = 1;
	size_t soap_flag_H264 = 1;
	size_t soap_flag_Multicast = 1;
	size_t soap_flag_SessionTimeout = 1;
	struct soap_blist *soap_blist___any = NULL;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct tt__VideoEncoderConfiguration*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__VideoEncoderConfiguration, sizeof(struct tt__VideoEncoderConfiguration), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__VideoEncoderConfiguration(soap, a);
	if (soap_s2tt__ReferenceToken(soap, soap_attr_value(soap, "token", 1, 1), &a->token))
		return NULL;
	{
		const char *t = soap_attr_value(soap, "GuaranteedFrameRate", 5, 0);
		if (t)
		{
			if (!(a->GuaranteedFrameRate = (enum xsd__boolean *)soap_malloc(soap, sizeof(enum xsd__boolean))))
				return NULL;
			if (soap_s2xsd__boolean(soap, t, a->GuaranteedFrameRate))
				return NULL;
		}
		else if (soap->error)
			return NULL;
	}
	if (soap_s2char(soap, soap_attr_value(soap, "-anyAttribute", 0, 0), &a->__anyAttribute, 0, 0, -1, NULL))
		return NULL;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Name && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_tt__Name(soap, "tt:Name", (char**)&a->Name, "tt:Name"))
				{	soap_flag_Name--;
					continue;
				}
			}
			if (soap_flag_UseCount && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_int(soap, "tt:UseCount", &a->UseCount, "xsd:int"))
				{	soap_flag_UseCount--;
					continue;
				}
			}
			if (soap_flag_Encoding && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_tt__VideoEncoding(soap, "tt:Encoding", &a->Encoding, "tt:VideoEncoding"))
				{	soap_flag_Encoding--;
					continue;
				}
			}
			if (soap_flag_Resolution && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__VideoResolution(soap, "tt:Resolution", &a->Resolution, "tt:VideoResolution"))
				{	soap_flag_Resolution--;
					continue;
				}
			}
			if (soap_flag_Quality && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_float(soap, "tt:Quality", &a->Quality, "xsd:float"))
				{	soap_flag_Quality--;
					continue;
				}
			}
			if (soap_flag_RateControl && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__VideoRateControl(soap, "tt:RateControl", &a->RateControl, "tt:VideoRateControl"))
				{	soap_flag_RateControl--;
					continue;
				}
			}
			if (soap_flag_MPEG4 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__Mpeg4Configuration(soap, "tt:MPEG4", &a->MPEG4, "tt:Mpeg4Configuration"))
				{	soap_flag_MPEG4--;
					continue;
				}
			}
			if (soap_flag_H264 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__H264Configuration(soap, "tt:H264", &a->H264, "tt:H264Configuration"))
				{	soap_flag_H264--;
					continue;
				}
			}
			if (soap_flag_Multicast && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__MulticastConfiguration(soap, "tt:Multicast", &a->Multicast, "tt:MulticastConfiguration"))
				{	soap_flag_Multicast--;
					continue;
				}
			}
			if (soap_flag_SessionTimeout && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_xsd__duration(soap, "tt:SessionTimeout", &a->SessionTimeout, "xsd:duration"))
				{	soap_flag_SessionTimeout--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	if (a->__any == NULL)
				{	if (soap_blist___any == NULL)
						soap_blist___any = soap_alloc_block(soap);
					a->__any = (char **)soap_push_block_max(soap, soap_blist___any, sizeof(char *));
					if (a->__any == NULL)
						return NULL;
					*a->__any = NULL;
				}
				if (soap_inliteral(soap, "-any", (char**)a->__any))
				{	a->__size++;
					a->__any = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->__any)
			soap_pop_block(soap, soap_blist___any);
		if (a->__size)
		{	a->__any = (char **)soap_save_block(soap, soap_blist___any, NULL, 1);
		}
		else
		{	a->__any = NULL;
			if (soap_blist___any)
				soap_end_block(soap, soap_blist___any);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (!a->Name || soap_flag_UseCount > 0 || soap_flag_Encoding > 0 || !a->Resolution || soap_flag_Quality > 0 || !a->Multicast || soap_flag_SessionTimeout > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct tt__VideoEncoderConfiguration *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__VideoEncoderConfiguration, SOAP_TYPE_tt__VideoEncoderConfiguration, sizeof(struct tt__VideoEncoderConfiguration), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct tt__VideoEncoderConfiguration * SOAP_FMAC4 soap_new_tt__VideoEncoderConfiguration(struct soap *soap, int n)
{
	struct tt__VideoEncoderConfiguration *p;
	struct tt__VideoEncoderConfiguration *a = (struct tt__VideoEncoderConfiguration*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct tt__VideoEncoderConfiguration));
	for (p = a; p && n--; p++)
		soap_default_tt__VideoEncoderConfiguration(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__VideoEncoderConfiguration(struct soap *soap, const struct tt__VideoEncoderConfiguration *a, const char *tag, const char *type)
{
	if (soap_out_tt__VideoEncoderConfiguration(soap, tag ? tag : "tt:VideoEncoderConfiguration", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__VideoEncoderConfiguration * SOAP_FMAC4 soap_get_tt__VideoEncoderConfiguration(struct soap *soap, struct tt__VideoEncoderConfiguration *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__VideoEncoderConfiguration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__Profile(struct soap *soap, struct tt__Profile *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_tt__Name(soap, &a->Name);
	a->VideoEncoderConfiguration = NULL;
	soap_default_tt__ReferenceToken(soap, &a->token);
	a->fixed = NULL;
	a->__anyAttribute = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__Profile(struct soap *soap, const struct tt__Profile *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_tt__Name(soap, (char*const*)&a->Name);
	soap_serialize_PointerTott__VideoEncoderConfiguration(soap, &a->VideoEncoderConfiguration);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__Profile(struct soap *soap, const char *tag, int id, const struct tt__Profile *a, const char *type)
{
	soap_set_attr(soap, "token", a->token ? soap_tt__ReferenceToken2s(soap, a->token) : "", 1);
	if (a->fixed)
	{	soap_set_attr(soap, "fixed", soap_xsd__boolean2s(soap, *a->fixed), 1);
	}
	if (a->__anyAttribute)
		soap_set_attr(soap, "-anyAttribute", a->__anyAttribute, 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__Profile), type))
		return soap->error;
	if (!a->Name)
	{	if (soap_element_empty(soap, "tt:Name", 0, NULL))
			return soap->error;
	}
	else if (soap_out_tt__Name(soap, "tt:Name", -1, (char*const*)&a->Name, ""))
		return soap->error;
	if (soap_out_PointerTott__VideoEncoderConfiguration(soap, "tt:VideoEncoderConfiguration", -1, &a->VideoEncoderConfiguration, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__Profile * SOAP_FMAC4 soap_in_tt__Profile(struct soap *soap, const char *tag, struct tt__Profile *a, const char *type)
{
	size_t soap_flag_Name = 1;
	size_t soap_flag_VideoEncoderConfiguration = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct tt__Profile*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__Profile, sizeof(struct tt__Profile), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__Profile(soap, a);
	if (soap_s2tt__ReferenceToken(soap, soap_attr_value(soap, "token", 1, 1), &a->token))
		return NULL;
	{
		const char *t = soap_attr_value(soap, "fixed", 5, 0);
		if (t)
		{
			if (!(a->fixed = (enum xsd__boolean *)soap_malloc(soap, sizeof(enum xsd__boolean))))
				return NULL;
			if (soap_s2xsd__boolean(soap, t, a->fixed))
				return NULL;
		}
		else if (soap->error)
			return NULL;
	}
	if (soap_s2char(soap, soap_attr_value(soap, "-anyAttribute", 0, 0), &a->__anyAttribute, 0, 0, -1, NULL))
		return NULL;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Name && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_tt__Name(soap, "tt:Name", (char**)&a->Name, "tt:Name"))
				{	soap_flag_Name--;
					continue;
				}
			}
			if (soap_flag_VideoEncoderConfiguration && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__VideoEncoderConfiguration(soap, "tt:VideoEncoderConfiguration", &a->VideoEncoderConfiguration, "tt:VideoEncoderConfiguration"))
				{	soap_flag_VideoEncoderConfiguration--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (!a->Name))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct tt__Profile *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__Profile, SOAP_TYPE_tt__Profile, sizeof(struct tt__Profile), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct tt__Profile * SOAP_FMAC4 soap_new_tt__Profile(struct soap *soap, int n)
{
	struct tt__Profile *p;
	struct tt__Profile *a = (struct tt__Profile*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct tt__Profile));
	for (p = a; p && n--; p++)
		soap_default_tt__Profile(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__Profile(struct soap *soap, const struct tt__Profile *a, const char *tag, const char *type)
{
	if (soap_out_tt__Profile(soap, tag ? tag : "tt:Profile", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__Profile * SOAP_FMAC4 soap_get_tt__Profile(struct soap *soap, struct tt__Profile *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__Profile(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__AnyHolder(struct soap *soap, struct tt__AnyHolder *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__size = 0;
	a->__any = NULL;
	a->__anyAttribute = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__AnyHolder(struct soap *soap, const struct tt__AnyHolder *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__AnyHolder(struct soap *soap, const char *tag, int id, const struct tt__AnyHolder *a, const char *type)
{
	if (a->__anyAttribute)
		soap_set_attr(soap, "-anyAttribute", a->__anyAttribute, 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__AnyHolder), type))
		return soap->error;
	if (a->__any)
	{	int i;
		for (i = 0; i < (int)a->__size; i++)
			if (soap_outliteral(soap, "-any", (char*const*)(a->__any + i), NULL))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__AnyHolder * SOAP_FMAC4 soap_in_tt__AnyHolder(struct soap *soap, const char *tag, struct tt__AnyHolder *a, const char *type)
{
	struct soap_blist *soap_blist___any = NULL;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct tt__AnyHolder*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__AnyHolder, sizeof(struct tt__AnyHolder), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__AnyHolder(soap, a);
	if (soap_s2char(soap, soap_attr_value(soap, "-anyAttribute", 0, 0), &a->__anyAttribute, 0, 0, -1, NULL))
		return NULL;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	if (a->__any == NULL)
				{	if (soap_blist___any == NULL)
						soap_blist___any = soap_alloc_block(soap);
					a->__any = (char **)soap_push_block_max(soap, soap_blist___any, sizeof(char *));
					if (a->__any == NULL)
						return NULL;
					*a->__any = NULL;
				}
				if (soap_inliteral(soap, "-any", (char**)a->__any))
				{	a->__size++;
					a->__any = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->__any)
			soap_pop_block(soap, soap_blist___any);
		if (a->__size)
		{	a->__any = (char **)soap_save_block(soap, soap_blist___any, NULL, 1);
		}
		else
		{	a->__any = NULL;
			if (soap_blist___any)
				soap_end_block(soap, soap_blist___any);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct tt__AnyHolder *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__AnyHolder, SOAP_TYPE_tt__AnyHolder, sizeof(struct tt__AnyHolder), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct tt__AnyHolder * SOAP_FMAC4 soap_new_tt__AnyHolder(struct soap *soap, int n)
{
	struct tt__AnyHolder *p;
	struct tt__AnyHolder *a = (struct tt__AnyHolder*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct tt__AnyHolder));
	for (p = a; p && n--; p++)
		soap_default_tt__AnyHolder(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__AnyHolder(struct soap *soap, const struct tt__AnyHolder *a, const char *tag, const char *type)
{
	if (soap_out_tt__AnyHolder(soap, tag ? tag : "tt:AnyHolder", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__AnyHolder * SOAP_FMAC4 soap_get_tt__AnyHolder(struct soap *soap, struct tt__AnyHolder *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__AnyHolder(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__FloatList(struct soap *soap, struct tt__FloatList *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__sizeItems = 0;
	a->Items = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__FloatList(struct soap *soap, const struct tt__FloatList *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (a->Items)
	{	int i;
		for (i = 0; i < (int)a->__sizeItems; i++)
		{
			soap_embedded(soap, a->Items + i, SOAP_TYPE_float);
		}
	}
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__FloatList(struct soap *soap, const char *tag, int id, const struct tt__FloatList *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__FloatList), type))
		return soap->error;
	if (a->Items)
	{	int i;
		for (i = 0; i < (int)a->__sizeItems; i++)
			if (soap_out_float(soap, "tt:Items", -1, a->Items + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__FloatList * SOAP_FMAC4 soap_in_tt__FloatList(struct soap *soap, const char *tag, struct tt__FloatList *a, const char *type)
{
	struct soap_blist *soap_blist_Items = NULL;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct tt__FloatList*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__FloatList, sizeof(struct tt__FloatList), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__FloatList(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "tt:Items", 1, NULL))
			{	if (a->Items == NULL)
				{	if (soap_blist_Items == NULL)
						soap_blist_Items = soap_alloc_block(soap);
					a->Items = (float *)soap_push_block_max(soap, soap_blist_Items, sizeof(float));
					if (a->Items == NULL)
						return NULL;
					soap_default_float(soap, a->Items);
				}
				soap_revert(soap);
				if (soap_in_float(soap, "tt:Items", a->Items, "xsd:float"))
				{	a->__sizeItems++;
					a->Items = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->Items)
			soap_pop_block(soap, soap_blist_Items);
		if (a->__sizeItems)
		{	a->Items = (float *)soap_save_block(soap, soap_blist_Items, NULL, 1);
		}
		else
		{	a->Items = NULL;
			if (soap_blist_Items)
				soap_end_block(soap, soap_blist_Items);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct tt__FloatList *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__FloatList, SOAP_TYPE_tt__FloatList, sizeof(struct tt__FloatList), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct tt__FloatList * SOAP_FMAC4 soap_new_tt__FloatList(struct soap *soap, int n)
{
	struct tt__FloatList *p;
	struct tt__FloatList *a = (struct tt__FloatList*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct tt__FloatList));
	for (p = a; p && n--; p++)
		soap_default_tt__FloatList(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__FloatList(struct soap *soap, const struct tt__FloatList *a, const char *tag, const char *type)
{
	if (soap_out_tt__FloatList(soap, tag ? tag : "tt:FloatList", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__FloatList * SOAP_FMAC4 soap_get_tt__FloatList(struct soap *soap, struct tt__FloatList *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__FloatList(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__IntList(struct soap *soap, struct tt__IntList *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__sizeItems = 0;
	a->Items = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__IntList(struct soap *soap, const struct tt__IntList *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (a->Items)
	{	int i;
		for (i = 0; i < (int)a->__sizeItems; i++)
		{
			soap_embedded(soap, a->Items + i, SOAP_TYPE_int);
		}
	}
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__IntList(struct soap *soap, const char *tag, int id, const struct tt__IntList *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__IntList), type))
		return soap->error;
	if (a->Items)
	{	int i;
		for (i = 0; i < (int)a->__sizeItems; i++)
			if (soap_out_int(soap, "tt:Items", -1, a->Items + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__IntList * SOAP_FMAC4 soap_in_tt__IntList(struct soap *soap, const char *tag, struct tt__IntList *a, const char *type)
{
	struct soap_blist *soap_blist_Items = NULL;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct tt__IntList*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__IntList, sizeof(struct tt__IntList), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__IntList(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "tt:Items", 1, NULL))
			{	if (a->Items == NULL)
				{	if (soap_blist_Items == NULL)
						soap_blist_Items = soap_alloc_block(soap);
					a->Items = (int *)soap_push_block_max(soap, soap_blist_Items, sizeof(int));
					if (a->Items == NULL)
						return NULL;
					soap_default_int(soap, a->Items);
				}
				soap_revert(soap);
				if (soap_in_int(soap, "tt:Items", a->Items, "xsd:int"))
				{	a->__sizeItems++;
					a->Items = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->Items)
			soap_pop_block(soap, soap_blist_Items);
		if (a->__sizeItems)
		{	a->Items = (int *)soap_save_block(soap, soap_blist_Items, NULL, 1);
		}
		else
		{	a->Items = NULL;
			if (soap_blist_Items)
				soap_end_block(soap, soap_blist_Items);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct tt__IntList *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__IntList, SOAP_TYPE_tt__IntList, sizeof(struct tt__IntList), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct tt__IntList * SOAP_FMAC4 soap_new_tt__IntList(struct soap *soap, int n)
{
	struct tt__IntList *p;
	struct tt__IntList *a = (struct tt__IntList*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct tt__IntList));
	for (p = a; p && n--; p++)
		soap_default_tt__IntList(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__IntList(struct soap *soap, const struct tt__IntList *a, const char *tag, const char *type)
{
	if (soap_out_tt__IntList(soap, tag ? tag : "tt:IntList", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__IntList * SOAP_FMAC4 soap_get_tt__IntList(struct soap *soap, struct tt__IntList *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__IntList(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__DurationRange(struct soap *soap, struct tt__DurationRange *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_xsd__duration(soap, &a->Min);
	soap_default_xsd__duration(soap, &a->Max);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__DurationRange(struct soap *soap, const struct tt__DurationRange *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__DurationRange(struct soap *soap, const char *tag, int id, const struct tt__DurationRange *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__DurationRange), type))
		return soap->error;
	if (soap_out_xsd__duration(soap, "tt:Min", -1, &a->Min, ""))
		return soap->error;
	if (soap_out_xsd__duration(soap, "tt:Max", -1, &a->Max, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__DurationRange * SOAP_FMAC4 soap_in_tt__DurationRange(struct soap *soap, const char *tag, struct tt__DurationRange *a, const char *type)
{
	size_t soap_flag_Min = 1;
	size_t soap_flag_Max = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct tt__DurationRange*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__DurationRange, sizeof(struct tt__DurationRange), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__DurationRange(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Min && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_xsd__duration(soap, "tt:Min", &a->Min, "xsd:duration"))
				{	soap_flag_Min--;
					continue;
				}
			}
			if (soap_flag_Max && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_xsd__duration(soap, "tt:Max", &a->Max, "xsd:duration"))
				{	soap_flag_Max--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Min > 0 || soap_flag_Max > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct tt__DurationRange *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__DurationRange, SOAP_TYPE_tt__DurationRange, sizeof(struct tt__DurationRange), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct tt__DurationRange * SOAP_FMAC4 soap_new_tt__DurationRange(struct soap *soap, int n)
{
	struct tt__DurationRange *p;
	struct tt__DurationRange *a = (struct tt__DurationRange*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct tt__DurationRange));
	for (p = a; p && n--; p++)
		soap_default_tt__DurationRange(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__DurationRange(struct soap *soap, const struct tt__DurationRange *a, const char *tag, const char *type)
{
	if (soap_out_tt__DurationRange(soap, tag ? tag : "tt:DurationRange", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__DurationRange * SOAP_FMAC4 soap_get_tt__DurationRange(struct soap *soap, struct tt__DurationRange *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__DurationRange(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__FloatRange(struct soap *soap, struct tt__FloatRange *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_float(soap, &a->Min);
	soap_default_float(soap, &a->Max);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__FloatRange(struct soap *soap, const struct tt__FloatRange *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &a->Min, SOAP_TYPE_float);
	soap_embedded(soap, &a->Max, SOAP_TYPE_float);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__FloatRange(struct soap *soap, const char *tag, int id, const struct tt__FloatRange *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__FloatRange), type))
		return soap->error;
	if (soap_out_float(soap, "tt:Min", -1, &a->Min, ""))
		return soap->error;
	if (soap_out_float(soap, "tt:Max", -1, &a->Max, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__FloatRange * SOAP_FMAC4 soap_in_tt__FloatRange(struct soap *soap, const char *tag, struct tt__FloatRange *a, const char *type)
{
	size_t soap_flag_Min = 1;
	size_t soap_flag_Max = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct tt__FloatRange*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__FloatRange, sizeof(struct tt__FloatRange), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__FloatRange(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Min && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_float(soap, "tt:Min", &a->Min, "xsd:float"))
				{	soap_flag_Min--;
					continue;
				}
			}
			if (soap_flag_Max && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_float(soap, "tt:Max", &a->Max, "xsd:float"))
				{	soap_flag_Max--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Min > 0 || soap_flag_Max > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct tt__FloatRange *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__FloatRange, SOAP_TYPE_tt__FloatRange, sizeof(struct tt__FloatRange), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct tt__FloatRange * SOAP_FMAC4 soap_new_tt__FloatRange(struct soap *soap, int n)
{
	struct tt__FloatRange *p;
	struct tt__FloatRange *a = (struct tt__FloatRange*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct tt__FloatRange));
	for (p = a; p && n--; p++)
		soap_default_tt__FloatRange(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__FloatRange(struct soap *soap, const struct tt__FloatRange *a, const char *tag, const char *type)
{
	if (soap_out_tt__FloatRange(soap, tag ? tag : "tt:FloatRange", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__FloatRange * SOAP_FMAC4 soap_get_tt__FloatRange(struct soap *soap, struct tt__FloatRange *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__FloatRange(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__IntRange(struct soap *soap, struct tt__IntRange *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_int(soap, &a->Min);
	soap_default_int(soap, &a->Max);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__IntRange(struct soap *soap, const struct tt__IntRange *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &a->Min, SOAP_TYPE_int);
	soap_embedded(soap, &a->Max, SOAP_TYPE_int);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__IntRange(struct soap *soap, const char *tag, int id, const struct tt__IntRange *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__IntRange), type))
		return soap->error;
	if (soap_out_int(soap, "tt:Min", -1, &a->Min, ""))
		return soap->error;
	if (soap_out_int(soap, "tt:Max", -1, &a->Max, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__IntRange * SOAP_FMAC4 soap_in_tt__IntRange(struct soap *soap, const char *tag, struct tt__IntRange *a, const char *type)
{
	size_t soap_flag_Min = 1;
	size_t soap_flag_Max = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct tt__IntRange*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__IntRange, sizeof(struct tt__IntRange), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__IntRange(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Min && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_int(soap, "tt:Min", &a->Min, "xsd:int"))
				{	soap_flag_Min--;
					continue;
				}
			}
			if (soap_flag_Max && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_int(soap, "tt:Max", &a->Max, "xsd:int"))
				{	soap_flag_Max--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Min > 0 || soap_flag_Max > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct tt__IntRange *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__IntRange, SOAP_TYPE_tt__IntRange, sizeof(struct tt__IntRange), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct tt__IntRange * SOAP_FMAC4 soap_new_tt__IntRange(struct soap *soap, int n)
{
	struct tt__IntRange *p;
	struct tt__IntRange *a = (struct tt__IntRange*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct tt__IntRange));
	for (p = a; p && n--; p++)
		soap_default_tt__IntRange(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__IntRange(struct soap *soap, const struct tt__IntRange *a, const char *tag, const char *type)
{
	if (soap_out_tt__IntRange(soap, tag ? tag : "tt:IntRange", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__IntRange * SOAP_FMAC4 soap_get_tt__IntRange(struct soap *soap, struct tt__IntRange *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__IntRange(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__IntRectangleRange(struct soap *soap, struct tt__IntRectangleRange *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->XRange = NULL;
	a->YRange = NULL;
	a->WidthRange = NULL;
	a->HeightRange = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__IntRectangleRange(struct soap *soap, const struct tt__IntRectangleRange *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTott__IntRange(soap, &a->XRange);
	soap_serialize_PointerTott__IntRange(soap, &a->YRange);
	soap_serialize_PointerTott__IntRange(soap, &a->WidthRange);
	soap_serialize_PointerTott__IntRange(soap, &a->HeightRange);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__IntRectangleRange(struct soap *soap, const char *tag, int id, const struct tt__IntRectangleRange *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__IntRectangleRange), type))
		return soap->error;
	if (!a->XRange)
	{	if (soap_element_empty(soap, "tt:XRange", 0, NULL))
			return soap->error;
	}
	else if (soap_out_PointerTott__IntRange(soap, "tt:XRange", -1, &a->XRange, ""))
		return soap->error;
	if (!a->YRange)
	{	if (soap_element_empty(soap, "tt:YRange", 0, NULL))
			return soap->error;
	}
	else if (soap_out_PointerTott__IntRange(soap, "tt:YRange", -1, &a->YRange, ""))
		return soap->error;
	if (!a->WidthRange)
	{	if (soap_element_empty(soap, "tt:WidthRange", 0, NULL))
			return soap->error;
	}
	else if (soap_out_PointerTott__IntRange(soap, "tt:WidthRange", -1, &a->WidthRange, ""))
		return soap->error;
	if (!a->HeightRange)
	{	if (soap_element_empty(soap, "tt:HeightRange", 0, NULL))
			return soap->error;
	}
	else if (soap_out_PointerTott__IntRange(soap, "tt:HeightRange", -1, &a->HeightRange, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__IntRectangleRange * SOAP_FMAC4 soap_in_tt__IntRectangleRange(struct soap *soap, const char *tag, struct tt__IntRectangleRange *a, const char *type)
{
	size_t soap_flag_XRange = 1;
	size_t soap_flag_YRange = 1;
	size_t soap_flag_WidthRange = 1;
	size_t soap_flag_HeightRange = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct tt__IntRectangleRange*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__IntRectangleRange, sizeof(struct tt__IntRectangleRange), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__IntRectangleRange(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_XRange && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__IntRange(soap, "tt:XRange", &a->XRange, "tt:IntRange"))
				{	soap_flag_XRange--;
					continue;
				}
			}
			if (soap_flag_YRange && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__IntRange(soap, "tt:YRange", &a->YRange, "tt:IntRange"))
				{	soap_flag_YRange--;
					continue;
				}
			}
			if (soap_flag_WidthRange && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__IntRange(soap, "tt:WidthRange", &a->WidthRange, "tt:IntRange"))
				{	soap_flag_WidthRange--;
					continue;
				}
			}
			if (soap_flag_HeightRange && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__IntRange(soap, "tt:HeightRange", &a->HeightRange, "tt:IntRange"))
				{	soap_flag_HeightRange--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (!a->XRange || !a->YRange || !a->WidthRange || !a->HeightRange))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct tt__IntRectangleRange *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__IntRectangleRange, SOAP_TYPE_tt__IntRectangleRange, sizeof(struct tt__IntRectangleRange), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct tt__IntRectangleRange * SOAP_FMAC4 soap_new_tt__IntRectangleRange(struct soap *soap, int n)
{
	struct tt__IntRectangleRange *p;
	struct tt__IntRectangleRange *a = (struct tt__IntRectangleRange*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct tt__IntRectangleRange));
	for (p = a; p && n--; p++)
		soap_default_tt__IntRectangleRange(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__IntRectangleRange(struct soap *soap, const struct tt__IntRectangleRange *a, const char *tag, const char *type)
{
	if (soap_out_tt__IntRectangleRange(soap, tag ? tag : "tt:IntRectangleRange", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__IntRectangleRange * SOAP_FMAC4 soap_get_tt__IntRectangleRange(struct soap *soap, struct tt__IntRectangleRange *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__IntRectangleRange(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__IntRectangle(struct soap *soap, struct tt__IntRectangle *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_int(soap, &a->x);
	soap_default_int(soap, &a->y);
	soap_default_int(soap, &a->width);
	soap_default_int(soap, &a->height);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__IntRectangle(struct soap *soap, const struct tt__IntRectangle *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__IntRectangle(struct soap *soap, const char *tag, int id, const struct tt__IntRectangle *a, const char *type)
{
	soap_set_attr(soap, "x", soap_int2s(soap, a->x), 1);
	soap_set_attr(soap, "y", soap_int2s(soap, a->y), 1);
	soap_set_attr(soap, "width", soap_int2s(soap, a->width), 1);
	soap_set_attr(soap, "height", soap_int2s(soap, a->height), 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__IntRectangle), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__IntRectangle * SOAP_FMAC4 soap_in_tt__IntRectangle(struct soap *soap, const char *tag, struct tt__IntRectangle *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct tt__IntRectangle*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__IntRectangle, sizeof(struct tt__IntRectangle), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__IntRectangle(soap, a);
	if (soap_s2int(soap, soap_attr_value(soap, "x", 5, 1), &a->x))
		return NULL;
	if (soap_s2int(soap, soap_attr_value(soap, "y", 5, 1), &a->y))
		return NULL;
	if (soap_s2int(soap, soap_attr_value(soap, "width", 5, 1), &a->width))
		return NULL;
	if (soap_s2int(soap, soap_attr_value(soap, "height", 5, 1), &a->height))
		return NULL;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct tt__IntRectangle *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__IntRectangle, SOAP_TYPE_tt__IntRectangle, sizeof(struct tt__IntRectangle), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct tt__IntRectangle * SOAP_FMAC4 soap_new_tt__IntRectangle(struct soap *soap, int n)
{
	struct tt__IntRectangle *p;
	struct tt__IntRectangle *a = (struct tt__IntRectangle*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct tt__IntRectangle));
	for (p = a; p && n--; p++)
		soap_default_tt__IntRectangle(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__IntRectangle(struct soap *soap, const struct tt__IntRectangle *a, const char *tag, const char *type)
{
	if (soap_out_tt__IntRectangle(soap, tag ? tag : "tt:IntRectangle", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__IntRectangle * SOAP_FMAC4 soap_get_tt__IntRectangle(struct soap *soap, struct tt__IntRectangle *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__IntRectangle(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__DeviceEntity(struct soap *soap, struct tt__DeviceEntity *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_tt__ReferenceToken(soap, &a->token);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__DeviceEntity(struct soap *soap, const struct tt__DeviceEntity *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__DeviceEntity(struct soap *soap, const char *tag, int id, const struct tt__DeviceEntity *a, const char *type)
{
	soap_set_attr(soap, "token", a->token ? soap_tt__ReferenceToken2s(soap, a->token) : "", 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__DeviceEntity), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__DeviceEntity * SOAP_FMAC4 soap_in_tt__DeviceEntity(struct soap *soap, const char *tag, struct tt__DeviceEntity *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct tt__DeviceEntity*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__DeviceEntity, sizeof(struct tt__DeviceEntity), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__DeviceEntity(soap, a);
	if (soap_s2tt__ReferenceToken(soap, soap_attr_value(soap, "token", 1, 1), &a->token))
		return NULL;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct tt__DeviceEntity *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__DeviceEntity, SOAP_TYPE_tt__DeviceEntity, sizeof(struct tt__DeviceEntity), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct tt__DeviceEntity * SOAP_FMAC4 soap_new_tt__DeviceEntity(struct soap *soap, int n)
{
	struct tt__DeviceEntity *p;
	struct tt__DeviceEntity *a = (struct tt__DeviceEntity*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct tt__DeviceEntity));
	for (p = a; p && n--; p++)
		soap_default_tt__DeviceEntity(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__DeviceEntity(struct soap *soap, const struct tt__DeviceEntity *a, const char *tag, const char *type)
{
	if (soap_out_tt__DeviceEntity(soap, tag ? tag : "tt:DeviceEntity", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__DeviceEntity * SOAP_FMAC4 soap_get_tt__DeviceEntity(struct soap *soap, struct tt__DeviceEntity *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__DeviceEntity(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__Capabilities(struct soap *soap, struct tt__Capabilities *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->Device = NULL;
	a->Events = NULL;
	a->Media = NULL;
	a->PTZ = NULL;
	a->__anyAttribute = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__Capabilities(struct soap *soap, const struct tt__Capabilities *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTott__DeviceCapabilities(soap, &a->Device);
	soap_serialize_PointerTott__EventCapabilities(soap, &a->Events);
	soap_serialize_PointerTott__MediaCapabilities(soap, &a->Media);
	soap_serialize_PointerTott__PTZCapabilities(soap, &a->PTZ);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__Capabilities(struct soap *soap, const char *tag, int id, const struct tt__Capabilities *a, const char *type)
{
	if (a->__anyAttribute)
		soap_set_attr(soap, "-anyAttribute", a->__anyAttribute, 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__Capabilities), type))
		return soap->error;
	if (soap_out_PointerTott__DeviceCapabilities(soap, "tt:Device", -1, &a->Device, ""))
		return soap->error;
	if (soap_out_PointerTott__EventCapabilities(soap, "tt:Events", -1, &a->Events, ""))
		return soap->error;
	if (soap_out_PointerTott__MediaCapabilities(soap, "tt:Media", -1, &a->Media, ""))
		return soap->error;
	if (soap_out_PointerTott__PTZCapabilities(soap, "tt:PTZ", -1, &a->PTZ, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__Capabilities * SOAP_FMAC4 soap_in_tt__Capabilities(struct soap *soap, const char *tag, struct tt__Capabilities *a, const char *type)
{
	size_t soap_flag_Device = 1;
	size_t soap_flag_Events = 1;
	size_t soap_flag_Media = 1;
	size_t soap_flag_PTZ = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct tt__Capabilities*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__Capabilities, sizeof(struct tt__Capabilities), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__Capabilities(soap, a);
	if (soap_s2char(soap, soap_attr_value(soap, "-anyAttribute", 0, 0), &a->__anyAttribute, 0, 0, -1, NULL))
		return NULL;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Device && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__DeviceCapabilities(soap, "tt:Device", &a->Device, "tt:DeviceCapabilities"))
				{	soap_flag_Device--;
					continue;
				}
			}
			if (soap_flag_Events && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__EventCapabilities(soap, "tt:Events", &a->Events, "tt:EventCapabilities"))
				{	soap_flag_Events--;
					continue;
				}
			}
			if (soap_flag_Media && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__MediaCapabilities(soap, "tt:Media", &a->Media, "tt:MediaCapabilities"))
				{	soap_flag_Media--;
					continue;
				}
			}
			if (soap_flag_PTZ && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__PTZCapabilities(soap, "tt:PTZ", &a->PTZ, "tt:PTZCapabilities"))
				{	soap_flag_PTZ--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct tt__Capabilities *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__Capabilities, SOAP_TYPE_tt__Capabilities, sizeof(struct tt__Capabilities), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct tt__Capabilities * SOAP_FMAC4 soap_new_tt__Capabilities(struct soap *soap, int n)
{
	struct tt__Capabilities *p;
	struct tt__Capabilities *a = (struct tt__Capabilities*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct tt__Capabilities));
	for (p = a; p && n--; p++)
		soap_default_tt__Capabilities(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__Capabilities(struct soap *soap, const struct tt__Capabilities *a, const char *tag, const char *type)
{
	if (soap_out_tt__Capabilities(soap, tag ? tag : "tt:Capabilities", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__Capabilities * SOAP_FMAC4 soap_get_tt__Capabilities(struct soap *soap, struct tt__Capabilities *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__Capabilities(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tds__GetCapabilitiesResponse(struct soap *soap, struct _tds__GetCapabilitiesResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->Capabilities = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tds__GetCapabilitiesResponse(struct soap *soap, const struct _tds__GetCapabilitiesResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTott__Capabilities(soap, &a->Capabilities);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__GetCapabilitiesResponse(struct soap *soap, const char *tag, int id, const struct _tds__GetCapabilitiesResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__GetCapabilitiesResponse), type))
		return soap->error;
	if (a->Capabilities)
		soap_element_result(soap, "tds:Capabilities");
	if (!a->Capabilities)
	{	if (soap_element_empty(soap, "tds:Capabilities", 0, NULL))
			return soap->error;
	}
	else if (soap_out_PointerTott__Capabilities(soap, "tds:Capabilities", -1, &a->Capabilities, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tds__GetCapabilitiesResponse * SOAP_FMAC4 soap_in__tds__GetCapabilitiesResponse(struct soap *soap, const char *tag, struct _tds__GetCapabilitiesResponse *a, const char *type)
{
	size_t soap_flag_Capabilities = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct _tds__GetCapabilitiesResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__GetCapabilitiesResponse, sizeof(struct _tds__GetCapabilitiesResponse), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tds__GetCapabilitiesResponse(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Capabilities && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__Capabilities(soap, "tds:Capabilities", &a->Capabilities, "tt:Capabilities"))
				{	soap_flag_Capabilities--;
					continue;
				}
			}
			soap_check_result(soap, "tds:Capabilities");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (!a->Capabilities))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct _tds__GetCapabilitiesResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__GetCapabilitiesResponse, SOAP_TYPE__tds__GetCapabilitiesResponse, sizeof(struct _tds__GetCapabilitiesResponse), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _tds__GetCapabilitiesResponse * SOAP_FMAC4 soap_new__tds__GetCapabilitiesResponse(struct soap *soap, int n)
{
	struct _tds__GetCapabilitiesResponse *p;
	struct _tds__GetCapabilitiesResponse *a = (struct _tds__GetCapabilitiesResponse*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _tds__GetCapabilitiesResponse));
	for (p = a; p && n--; p++)
		soap_default__tds__GetCapabilitiesResponse(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tds__GetCapabilitiesResponse(struct soap *soap, const struct _tds__GetCapabilitiesResponse *a, const char *tag, const char *type)
{
	if (soap_out__tds__GetCapabilitiesResponse(soap, tag ? tag : "tds:GetCapabilitiesResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tds__GetCapabilitiesResponse * SOAP_FMAC4 soap_get__tds__GetCapabilitiesResponse(struct soap *soap, struct _tds__GetCapabilitiesResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__GetCapabilitiesResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tds__GetCapabilities(struct soap *soap, struct _tds__GetCapabilities *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__sizeCategory = 0;
	a->Category = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tds__GetCapabilities(struct soap *soap, const struct _tds__GetCapabilities *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (a->Category)
	{	int i;
		for (i = 0; i < (int)a->__sizeCategory; i++)
		{
			soap_embedded(soap, a->Category + i, SOAP_TYPE_tt__CapabilityCategory);
		}
	}
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__GetCapabilities(struct soap *soap, const char *tag, int id, const struct _tds__GetCapabilities *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__GetCapabilities), type))
		return soap->error;
	if (a->Category)
	{	int i;
		for (i = 0; i < (int)a->__sizeCategory; i++)
			if (soap_out_tt__CapabilityCategory(soap, "tds:Category", -1, a->Category + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tds__GetCapabilities * SOAP_FMAC4 soap_in__tds__GetCapabilities(struct soap *soap, const char *tag, struct _tds__GetCapabilities *a, const char *type)
{
	struct soap_blist *soap_blist_Category = NULL;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct _tds__GetCapabilities*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__GetCapabilities, sizeof(struct _tds__GetCapabilities), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tds__GetCapabilities(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "tds:Category", 1, NULL))
			{	if (a->Category == NULL)
				{	if (soap_blist_Category == NULL)
						soap_blist_Category = soap_alloc_block(soap);
					a->Category = (enum tt__CapabilityCategory *)soap_push_block_max(soap, soap_blist_Category, sizeof(enum tt__CapabilityCategory));
					if (a->Category == NULL)
						return NULL;
					soap_default_tt__CapabilityCategory(soap, a->Category);
				}
				soap_revert(soap);
				if (soap_in_tt__CapabilityCategory(soap, "tds:Category", a->Category, "tt:CapabilityCategory"))
				{	a->__sizeCategory++;
					a->Category = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->Category)
			soap_pop_block(soap, soap_blist_Category);
		if (a->__sizeCategory)
		{	a->Category = (enum tt__CapabilityCategory *)soap_save_block(soap, soap_blist_Category, NULL, 1);
		}
		else
		{	a->Category = NULL;
			if (soap_blist_Category)
				soap_end_block(soap, soap_blist_Category);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _tds__GetCapabilities *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__GetCapabilities, SOAP_TYPE__tds__GetCapabilities, sizeof(struct _tds__GetCapabilities), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _tds__GetCapabilities * SOAP_FMAC4 soap_new__tds__GetCapabilities(struct soap *soap, int n)
{
	struct _tds__GetCapabilities *p;
	struct _tds__GetCapabilities *a = (struct _tds__GetCapabilities*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _tds__GetCapabilities));
	for (p = a; p && n--; p++)
		soap_default__tds__GetCapabilities(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tds__GetCapabilities(struct soap *soap, const struct _tds__GetCapabilities *a, const char *tag, const char *type)
{
	if (soap_out__tds__GetCapabilities(soap, tag ? tag : "tds:GetCapabilities", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tds__GetCapabilities * SOAP_FMAC4 soap_get__tds__GetCapabilities(struct soap *soap, struct _tds__GetCapabilities *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__GetCapabilities(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tds__SystemRebootResponse(struct soap *soap, struct _tds__SystemRebootResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->Message);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tds__SystemRebootResponse(struct soap *soap, const struct _tds__SystemRebootResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_string(soap, (char*const*)&a->Message);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__SystemRebootResponse(struct soap *soap, const char *tag, int id, const struct _tds__SystemRebootResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__SystemRebootResponse), type))
		return soap->error;
	if (a->Message)
		soap_element_result(soap, "tds:Message");
	if (!a->Message)
	{	if (soap_element_empty(soap, "tds:Message", 0, NULL))
			return soap->error;
	}
	else if (soap_out_string(soap, "tds:Message", -1, (char*const*)&a->Message, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tds__SystemRebootResponse * SOAP_FMAC4 soap_in__tds__SystemRebootResponse(struct soap *soap, const char *tag, struct _tds__SystemRebootResponse *a, const char *type)
{
	size_t soap_flag_Message = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct _tds__SystemRebootResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__SystemRebootResponse, sizeof(struct _tds__SystemRebootResponse), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tds__SystemRebootResponse(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Message && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_string(soap, "tds:Message", (char**)&a->Message, "xsd:string"))
				{	soap_flag_Message--;
					continue;
				}
			}
			soap_check_result(soap, "tds:Message");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (!a->Message))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct _tds__SystemRebootResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__SystemRebootResponse, SOAP_TYPE__tds__SystemRebootResponse, sizeof(struct _tds__SystemRebootResponse), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _tds__SystemRebootResponse * SOAP_FMAC4 soap_new__tds__SystemRebootResponse(struct soap *soap, int n)
{
	struct _tds__SystemRebootResponse *p;
	struct _tds__SystemRebootResponse *a = (struct _tds__SystemRebootResponse*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _tds__SystemRebootResponse));
	for (p = a; p && n--; p++)
		soap_default__tds__SystemRebootResponse(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tds__SystemRebootResponse(struct soap *soap, const struct _tds__SystemRebootResponse *a, const char *tag, const char *type)
{
	if (soap_out__tds__SystemRebootResponse(soap, tag ? tag : "tds:SystemRebootResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tds__SystemRebootResponse * SOAP_FMAC4 soap_get__tds__SystemRebootResponse(struct soap *soap, struct _tds__SystemRebootResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__SystemRebootResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tds__SystemReboot(struct soap *soap, struct _tds__SystemReboot *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tds__SystemReboot(struct soap *soap, const struct _tds__SystemReboot *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__SystemReboot(struct soap *soap, const char *tag, int id, const struct _tds__SystemReboot *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__SystemReboot), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tds__SystemReboot * SOAP_FMAC4 soap_in__tds__SystemReboot(struct soap *soap, const char *tag, struct _tds__SystemReboot *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct _tds__SystemReboot*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__SystemReboot, sizeof(struct _tds__SystemReboot), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tds__SystemReboot(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _tds__SystemReboot *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__SystemReboot, SOAP_TYPE__tds__SystemReboot, sizeof(struct _tds__SystemReboot), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _tds__SystemReboot * SOAP_FMAC4 soap_new__tds__SystemReboot(struct soap *soap, int n)
{
	struct _tds__SystemReboot *p;
	struct _tds__SystemReboot *a = (struct _tds__SystemReboot*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _tds__SystemReboot));
	for (p = a; p && n--; p++)
		soap_default__tds__SystemReboot(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tds__SystemReboot(struct soap *soap, const struct _tds__SystemReboot *a, const char *tag, const char *type)
{
	if (soap_out__tds__SystemReboot(soap, tag ? tag : "tds:SystemReboot", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tds__SystemReboot * SOAP_FMAC4 soap_get__tds__SystemReboot(struct soap *soap, struct _tds__SystemReboot *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__SystemReboot(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tds__GetDeviceInformationResponse(struct soap *soap, struct _tds__GetDeviceInformationResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tds__GetDeviceInformationResponse(struct soap *soap, const struct _tds__GetDeviceInformationResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__GetDeviceInformationResponse(struct soap *soap, const char *tag, int id, const struct _tds__GetDeviceInformationResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__GetDeviceInformationResponse), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tds__GetDeviceInformationResponse * SOAP_FMAC4 soap_in__tds__GetDeviceInformationResponse(struct soap *soap, const char *tag, struct _tds__GetDeviceInformationResponse *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct _tds__GetDeviceInformationResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__GetDeviceInformationResponse, sizeof(struct _tds__GetDeviceInformationResponse), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tds__GetDeviceInformationResponse(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _tds__GetDeviceInformationResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__GetDeviceInformationResponse, SOAP_TYPE__tds__GetDeviceInformationResponse, sizeof(struct _tds__GetDeviceInformationResponse), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _tds__GetDeviceInformationResponse * SOAP_FMAC4 soap_new__tds__GetDeviceInformationResponse(struct soap *soap, int n)
{
	struct _tds__GetDeviceInformationResponse *p;
	struct _tds__GetDeviceInformationResponse *a = (struct _tds__GetDeviceInformationResponse*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _tds__GetDeviceInformationResponse));
	for (p = a; p && n--; p++)
		soap_default__tds__GetDeviceInformationResponse(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tds__GetDeviceInformationResponse(struct soap *soap, const struct _tds__GetDeviceInformationResponse *a, const char *tag, const char *type)
{
	if (soap_out__tds__GetDeviceInformationResponse(soap, tag ? tag : "tds:GetDeviceInformationResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tds__GetDeviceInformationResponse * SOAP_FMAC4 soap_get__tds__GetDeviceInformationResponse(struct soap *soap, struct _tds__GetDeviceInformationResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__GetDeviceInformationResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tds__GetDeviceInformation(struct soap *soap, struct _tds__GetDeviceInformation *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tds__GetDeviceInformation(struct soap *soap, const struct _tds__GetDeviceInformation *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__GetDeviceInformation(struct soap *soap, const char *tag, int id, const struct _tds__GetDeviceInformation *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__GetDeviceInformation), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tds__GetDeviceInformation * SOAP_FMAC4 soap_in__tds__GetDeviceInformation(struct soap *soap, const char *tag, struct _tds__GetDeviceInformation *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct _tds__GetDeviceInformation*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__GetDeviceInformation, sizeof(struct _tds__GetDeviceInformation), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tds__GetDeviceInformation(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _tds__GetDeviceInformation *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__GetDeviceInformation, SOAP_TYPE__tds__GetDeviceInformation, sizeof(struct _tds__GetDeviceInformation), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _tds__GetDeviceInformation * SOAP_FMAC4 soap_new__tds__GetDeviceInformation(struct soap *soap, int n)
{
	struct _tds__GetDeviceInformation *p;
	struct _tds__GetDeviceInformation *a = (struct _tds__GetDeviceInformation*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _tds__GetDeviceInformation));
	for (p = a; p && n--; p++)
		soap_default__tds__GetDeviceInformation(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tds__GetDeviceInformation(struct soap *soap, const struct _tds__GetDeviceInformation *a, const char *tag, const char *type)
{
	if (soap_out__tds__GetDeviceInformation(soap, tag ? tag : "tds:GetDeviceInformation", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tds__GetDeviceInformation * SOAP_FMAC4 soap_get__tds__GetDeviceInformation(struct soap *soap, struct _tds__GetDeviceInformation *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__GetDeviceInformation(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tds__GetServiceCapabilitiesResponse(struct soap *soap, struct _tds__GetServiceCapabilitiesResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->Capabilities = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tds__GetServiceCapabilitiesResponse(struct soap *soap, const struct _tds__GetServiceCapabilitiesResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTotds__DeviceServiceCapabilities(soap, &a->Capabilities);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__GetServiceCapabilitiesResponse(struct soap *soap, const char *tag, int id, const struct _tds__GetServiceCapabilitiesResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__GetServiceCapabilitiesResponse), type))
		return soap->error;
	if (a->Capabilities)
		soap_element_result(soap, "tds:Capabilities");
	if (!a->Capabilities)
	{	if (soap_element_empty(soap, "tds:Capabilities", 0, NULL))
			return soap->error;
	}
	else if (soap_out_PointerTotds__DeviceServiceCapabilities(soap, "tds:Capabilities", -1, &a->Capabilities, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tds__GetServiceCapabilitiesResponse * SOAP_FMAC4 soap_in__tds__GetServiceCapabilitiesResponse(struct soap *soap, const char *tag, struct _tds__GetServiceCapabilitiesResponse *a, const char *type)
{
	size_t soap_flag_Capabilities = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct _tds__GetServiceCapabilitiesResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__GetServiceCapabilitiesResponse, sizeof(struct _tds__GetServiceCapabilitiesResponse), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tds__GetServiceCapabilitiesResponse(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Capabilities && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTotds__DeviceServiceCapabilities(soap, "tds:Capabilities", &a->Capabilities, "tds:DeviceServiceCapabilities"))
				{	soap_flag_Capabilities--;
					continue;
				}
			}
			soap_check_result(soap, "tds:Capabilities");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (!a->Capabilities))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct _tds__GetServiceCapabilitiesResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__GetServiceCapabilitiesResponse, SOAP_TYPE__tds__GetServiceCapabilitiesResponse, sizeof(struct _tds__GetServiceCapabilitiesResponse), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _tds__GetServiceCapabilitiesResponse * SOAP_FMAC4 soap_new__tds__GetServiceCapabilitiesResponse(struct soap *soap, int n)
{
	struct _tds__GetServiceCapabilitiesResponse *p;
	struct _tds__GetServiceCapabilitiesResponse *a = (struct _tds__GetServiceCapabilitiesResponse*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _tds__GetServiceCapabilitiesResponse));
	for (p = a; p && n--; p++)
		soap_default__tds__GetServiceCapabilitiesResponse(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tds__GetServiceCapabilitiesResponse(struct soap *soap, const struct _tds__GetServiceCapabilitiesResponse *a, const char *tag, const char *type)
{
	if (soap_out__tds__GetServiceCapabilitiesResponse(soap, tag ? tag : "tds:GetServiceCapabilitiesResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tds__GetServiceCapabilitiesResponse * SOAP_FMAC4 soap_get__tds__GetServiceCapabilitiesResponse(struct soap *soap, struct _tds__GetServiceCapabilitiesResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__GetServiceCapabilitiesResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tds__GetServiceCapabilities(struct soap *soap, struct _tds__GetServiceCapabilities *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tds__GetServiceCapabilities(struct soap *soap, const struct _tds__GetServiceCapabilities *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__GetServiceCapabilities(struct soap *soap, const char *tag, int id, const struct _tds__GetServiceCapabilities *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__GetServiceCapabilities), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tds__GetServiceCapabilities * SOAP_FMAC4 soap_in__tds__GetServiceCapabilities(struct soap *soap, const char *tag, struct _tds__GetServiceCapabilities *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct _tds__GetServiceCapabilities*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__GetServiceCapabilities, sizeof(struct _tds__GetServiceCapabilities), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tds__GetServiceCapabilities(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _tds__GetServiceCapabilities *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__GetServiceCapabilities, SOAP_TYPE__tds__GetServiceCapabilities, sizeof(struct _tds__GetServiceCapabilities), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _tds__GetServiceCapabilities * SOAP_FMAC4 soap_new__tds__GetServiceCapabilities(struct soap *soap, int n)
{
	struct _tds__GetServiceCapabilities *p;
	struct _tds__GetServiceCapabilities *a = (struct _tds__GetServiceCapabilities*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _tds__GetServiceCapabilities));
	for (p = a; p && n--; p++)
		soap_default__tds__GetServiceCapabilities(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tds__GetServiceCapabilities(struct soap *soap, const struct _tds__GetServiceCapabilities *a, const char *tag, const char *type)
{
	if (soap_out__tds__GetServiceCapabilities(soap, tag ? tag : "tds:GetServiceCapabilities", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tds__GetServiceCapabilities * SOAP_FMAC4 soap_get__tds__GetServiceCapabilities(struct soap *soap, struct _tds__GetServiceCapabilities *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__GetServiceCapabilities(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tds__GetServicesResponse(struct soap *soap, struct _tds__GetServicesResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__sizeService = 0;
	a->Service = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tds__GetServicesResponse(struct soap *soap, const struct _tds__GetServicesResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (a->Service)
	{	int i;
		for (i = 0; i < (int)a->__sizeService; i++)
		{
			soap_embedded(soap, a->Service + i, SOAP_TYPE_tds__Service);
			soap_serialize_tds__Service(soap, a->Service + i);
		}
	}
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__GetServicesResponse(struct soap *soap, const char *tag, int id, const struct _tds__GetServicesResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__GetServicesResponse), type))
		return soap->error;
	soap_element_result(soap, "-sizeService");
	if (a->Service)
	{	int i;
		for (i = 0; i < (int)a->__sizeService; i++)
			if (soap_out_tds__Service(soap, "tds:Service", -1, a->Service + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tds__GetServicesResponse * SOAP_FMAC4 soap_in__tds__GetServicesResponse(struct soap *soap, const char *tag, struct _tds__GetServicesResponse *a, const char *type)
{
	struct soap_blist *soap_blist_Service = NULL;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct _tds__GetServicesResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__GetServicesResponse, sizeof(struct _tds__GetServicesResponse), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tds__GetServicesResponse(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "tds:Service", 1, NULL))
			{	if (a->Service == NULL)
				{	if (soap_blist_Service == NULL)
						soap_blist_Service = soap_alloc_block(soap);
					a->Service = (struct tds__Service *)soap_push_block_max(soap, soap_blist_Service, sizeof(struct tds__Service));
					if (a->Service == NULL)
						return NULL;
					soap_default_tds__Service(soap, a->Service);
				}
				soap_revert(soap);
				if (soap_in_tds__Service(soap, "tds:Service", a->Service, "tds:Service"))
				{	a->__sizeService++;
					a->Service = NULL;
					continue;
				}
			}
			soap_check_result(soap, "-sizeService");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->Service)
			soap_pop_block(soap, soap_blist_Service);
		if (a->__sizeService)
		{	a->Service = (struct tds__Service *)soap_save_block(soap, soap_blist_Service, NULL, 1);
		}
		else
		{	a->Service = NULL;
			if (soap_blist_Service)
				soap_end_block(soap, soap_blist_Service);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (a->__sizeService < 1))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct _tds__GetServicesResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__GetServicesResponse, SOAP_TYPE__tds__GetServicesResponse, sizeof(struct _tds__GetServicesResponse), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _tds__GetServicesResponse * SOAP_FMAC4 soap_new__tds__GetServicesResponse(struct soap *soap, int n)
{
	struct _tds__GetServicesResponse *p;
	struct _tds__GetServicesResponse *a = (struct _tds__GetServicesResponse*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _tds__GetServicesResponse));
	for (p = a; p && n--; p++)
		soap_default__tds__GetServicesResponse(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tds__GetServicesResponse(struct soap *soap, const struct _tds__GetServicesResponse *a, const char *tag, const char *type)
{
	if (soap_out__tds__GetServicesResponse(soap, tag ? tag : "tds:GetServicesResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tds__GetServicesResponse * SOAP_FMAC4 soap_get__tds__GetServicesResponse(struct soap *soap, struct _tds__GetServicesResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__GetServicesResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tds__GetServices(struct soap *soap, struct _tds__GetServices *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_xsd__boolean(soap, &a->IncludeCapability);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tds__GetServices(struct soap *soap, const struct _tds__GetServices *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &a->IncludeCapability, SOAP_TYPE_xsd__boolean);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__GetServices(struct soap *soap, const char *tag, int id, const struct _tds__GetServices *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__GetServices), type))
		return soap->error;
	if (soap_out_xsd__boolean(soap, "tds:IncludeCapability", -1, &a->IncludeCapability, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tds__GetServices * SOAP_FMAC4 soap_in__tds__GetServices(struct soap *soap, const char *tag, struct _tds__GetServices *a, const char *type)
{
	size_t soap_flag_IncludeCapability = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct _tds__GetServices*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__GetServices, sizeof(struct _tds__GetServices), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tds__GetServices(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_IncludeCapability && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_xsd__boolean(soap, "tds:IncludeCapability", &a->IncludeCapability, "xsd:boolean"))
				{	soap_flag_IncludeCapability--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_IncludeCapability > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct _tds__GetServices *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__GetServices, SOAP_TYPE__tds__GetServices, sizeof(struct _tds__GetServices), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _tds__GetServices * SOAP_FMAC4 soap_new__tds__GetServices(struct soap *soap, int n)
{
	struct _tds__GetServices *p;
	struct _tds__GetServices *a = (struct _tds__GetServices*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _tds__GetServices));
	for (p = a; p && n--; p++)
		soap_default__tds__GetServices(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tds__GetServices(struct soap *soap, const struct _tds__GetServices *a, const char *tag, const char *type)
{
	if (soap_out__tds__GetServices(soap, tag ? tag : "tds:GetServices", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tds__GetServices * SOAP_FMAC4 soap_get__tds__GetServices(struct soap *soap, struct _tds__GetServices *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__GetServices(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tds__DeviceServiceCapabilities(struct soap *soap, struct tds__DeviceServiceCapabilities *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tds__DeviceServiceCapabilities(struct soap *soap, const struct tds__DeviceServiceCapabilities *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tds__DeviceServiceCapabilities(struct soap *soap, const char *tag, int id, const struct tds__DeviceServiceCapabilities *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tds__DeviceServiceCapabilities), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tds__DeviceServiceCapabilities * SOAP_FMAC4 soap_in_tds__DeviceServiceCapabilities(struct soap *soap, const char *tag, struct tds__DeviceServiceCapabilities *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct tds__DeviceServiceCapabilities*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tds__DeviceServiceCapabilities, sizeof(struct tds__DeviceServiceCapabilities), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tds__DeviceServiceCapabilities(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct tds__DeviceServiceCapabilities *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tds__DeviceServiceCapabilities, SOAP_TYPE_tds__DeviceServiceCapabilities, sizeof(struct tds__DeviceServiceCapabilities), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct tds__DeviceServiceCapabilities * SOAP_FMAC4 soap_new_tds__DeviceServiceCapabilities(struct soap *soap, int n)
{
	struct tds__DeviceServiceCapabilities *p;
	struct tds__DeviceServiceCapabilities *a = (struct tds__DeviceServiceCapabilities*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct tds__DeviceServiceCapabilities));
	for (p = a; p && n--; p++)
		soap_default_tds__DeviceServiceCapabilities(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tds__DeviceServiceCapabilities(struct soap *soap, const struct tds__DeviceServiceCapabilities *a, const char *tag, const char *type)
{
	if (soap_out_tds__DeviceServiceCapabilities(soap, tag ? tag : "tds:DeviceServiceCapabilities", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tds__DeviceServiceCapabilities * SOAP_FMAC4 soap_get_tds__DeviceServiceCapabilities(struct soap *soap, struct tds__DeviceServiceCapabilities *p, const char *tag, const char *type)
{
	if ((p = soap_in_tds__DeviceServiceCapabilities(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__OnvifVersion(struct soap *soap, struct tt__OnvifVersion *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_int(soap, &a->Major);
	soap_default_int(soap, &a->Minor);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__OnvifVersion(struct soap *soap, const struct tt__OnvifVersion *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &a->Major, SOAP_TYPE_int);
	soap_embedded(soap, &a->Minor, SOAP_TYPE_int);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__OnvifVersion(struct soap *soap, const char *tag, int id, const struct tt__OnvifVersion *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__OnvifVersion), type))
		return soap->error;
	if (soap_out_int(soap, "tt:Major", -1, &a->Major, ""))
		return soap->error;
	if (soap_out_int(soap, "tt:Minor", -1, &a->Minor, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__OnvifVersion * SOAP_FMAC4 soap_in_tt__OnvifVersion(struct soap *soap, const char *tag, struct tt__OnvifVersion *a, const char *type)
{
	size_t soap_flag_Major = 1;
	size_t soap_flag_Minor = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct tt__OnvifVersion*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__OnvifVersion, sizeof(struct tt__OnvifVersion), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__OnvifVersion(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Major && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_int(soap, "tt:Major", &a->Major, "xsd:int"))
				{	soap_flag_Major--;
					continue;
				}
			}
			if (soap_flag_Minor && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_int(soap, "tt:Minor", &a->Minor, "xsd:int"))
				{	soap_flag_Minor--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Major > 0 || soap_flag_Minor > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct tt__OnvifVersion *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__OnvifVersion, SOAP_TYPE_tt__OnvifVersion, sizeof(struct tt__OnvifVersion), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct tt__OnvifVersion * SOAP_FMAC4 soap_new_tt__OnvifVersion(struct soap *soap, int n)
{
	struct tt__OnvifVersion *p;
	struct tt__OnvifVersion *a = (struct tt__OnvifVersion*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct tt__OnvifVersion));
	for (p = a; p && n--; p++)
		soap_default_tt__OnvifVersion(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__OnvifVersion(struct soap *soap, const struct tt__OnvifVersion *a, const char *tag, const char *type)
{
	if (soap_out_tt__OnvifVersion(soap, tag ? tag : "tt:OnvifVersion", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__OnvifVersion * SOAP_FMAC4 soap_get_tt__OnvifVersion(struct soap *soap, struct tt__OnvifVersion *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__OnvifVersion(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tds__Service_Capabilities(struct soap *soap, struct _tds__Service_Capabilities *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__any = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tds__Service_Capabilities(struct soap *soap, const struct _tds__Service_Capabilities *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__Service_Capabilities(struct soap *soap, const char *tag, int id, const struct _tds__Service_Capabilities *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__Service_Capabilities), type))
		return soap->error;
	if (soap_outliteral(soap, "-any", (char*const*)&a->__any, NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tds__Service_Capabilities * SOAP_FMAC4 soap_in__tds__Service_Capabilities(struct soap *soap, const char *tag, struct _tds__Service_Capabilities *a, const char *type)
{
	size_t soap_flag___any = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct _tds__Service_Capabilities*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__Service_Capabilities, sizeof(struct _tds__Service_Capabilities), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tds__Service_Capabilities(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag___any && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_inliteral(soap, "-any", (char**)&a->__any))
				{	soap_flag___any--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _tds__Service_Capabilities *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__Service_Capabilities, SOAP_TYPE__tds__Service_Capabilities, sizeof(struct _tds__Service_Capabilities), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _tds__Service_Capabilities * SOAP_FMAC4 soap_new__tds__Service_Capabilities(struct soap *soap, int n)
{
	struct _tds__Service_Capabilities *p;
	struct _tds__Service_Capabilities *a = (struct _tds__Service_Capabilities*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _tds__Service_Capabilities));
	for (p = a; p && n--; p++)
		soap_default__tds__Service_Capabilities(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tds__Service_Capabilities(struct soap *soap, const struct _tds__Service_Capabilities *a, const char *tag, const char *type)
{
	if (soap_out__tds__Service_Capabilities(soap, tag ? tag : "tds:Service-Capabilities", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tds__Service_Capabilities * SOAP_FMAC4 soap_get__tds__Service_Capabilities(struct soap *soap, struct _tds__Service_Capabilities *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__Service_Capabilities(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tds__Service(struct soap *soap, struct tds__Service *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_xsd__anyURI(soap, &a->Namespace);
	soap_default_xsd__anyURI(soap, &a->XAddr);
	a->Capabilities = NULL;
	a->Version = NULL;
	a->__size = 0;
	a->__any = NULL;
	a->__anyAttribute = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tds__Service(struct soap *soap, const struct tds__Service *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_xsd__anyURI(soap, (char*const*)&a->Namespace);
	soap_serialize_xsd__anyURI(soap, (char*const*)&a->XAddr);
	soap_serialize_PointerTo_tds__Service_Capabilities(soap, &a->Capabilities);
	soap_serialize_PointerTott__OnvifVersion(soap, &a->Version);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tds__Service(struct soap *soap, const char *tag, int id, const struct tds__Service *a, const char *type)
{
	if (a->__anyAttribute)
		soap_set_attr(soap, "-anyAttribute", a->__anyAttribute, 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tds__Service), type))
		return soap->error;
	if (!a->Namespace)
	{	if (soap_element_empty(soap, "tds:Namespace", 0, NULL))
			return soap->error;
	}
	else if (soap_out_xsd__anyURI(soap, "tds:Namespace", -1, (char*const*)&a->Namespace, ""))
		return soap->error;
	if (!a->XAddr)
	{	if (soap_element_empty(soap, "tds:XAddr", 0, NULL))
			return soap->error;
	}
	else if (soap_out_xsd__anyURI(soap, "tds:XAddr", -1, (char*const*)&a->XAddr, ""))
		return soap->error;
	if (soap_out_PointerTo_tds__Service_Capabilities(soap, "tds:Capabilities", -1, &a->Capabilities, ""))
		return soap->error;
	if (!a->Version)
	{	if (soap_element_empty(soap, "tds:Version", 0, NULL))
			return soap->error;
	}
	else if (soap_out_PointerTott__OnvifVersion(soap, "tds:Version", -1, &a->Version, ""))
		return soap->error;
	if (a->__any)
	{	int i;
		for (i = 0; i < (int)a->__size; i++)
			if (soap_outliteral(soap, "-any", (char*const*)(a->__any + i), NULL))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tds__Service * SOAP_FMAC4 soap_in_tds__Service(struct soap *soap, const char *tag, struct tds__Service *a, const char *type)
{
	size_t soap_flag_Namespace = 1;
	size_t soap_flag_XAddr = 1;
	size_t soap_flag_Capabilities = 1;
	size_t soap_flag_Version = 1;
	struct soap_blist *soap_blist___any = NULL;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct tds__Service*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tds__Service, sizeof(struct tds__Service), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tds__Service(soap, a);
	if (soap_s2char(soap, soap_attr_value(soap, "-anyAttribute", 0, 0), &a->__anyAttribute, 0, 0, -1, NULL))
		return NULL;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Namespace && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_xsd__anyURI(soap, "tds:Namespace", (char**)&a->Namespace, "xsd:anyURI"))
				{	soap_flag_Namespace--;
					continue;
				}
			}
			if (soap_flag_XAddr && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_xsd__anyURI(soap, "tds:XAddr", (char**)&a->XAddr, "xsd:anyURI"))
				{	soap_flag_XAddr--;
					continue;
				}
			}
			if (soap_flag_Capabilities && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_tds__Service_Capabilities(soap, "tds:Capabilities", &a->Capabilities, ""))
				{	soap_flag_Capabilities--;
					continue;
				}
			}
			if (soap_flag_Version && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__OnvifVersion(soap, "tds:Version", &a->Version, "tt:OnvifVersion"))
				{	soap_flag_Version--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	if (a->__any == NULL)
				{	if (soap_blist___any == NULL)
						soap_blist___any = soap_alloc_block(soap);
					a->__any = (char **)soap_push_block_max(soap, soap_blist___any, sizeof(char *));
					if (a->__any == NULL)
						return NULL;
					*a->__any = NULL;
				}
				if (soap_inliteral(soap, "-any", (char**)a->__any))
				{	a->__size++;
					a->__any = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->__any)
			soap_pop_block(soap, soap_blist___any);
		if (a->__size)
		{	a->__any = (char **)soap_save_block(soap, soap_blist___any, NULL, 1);
		}
		else
		{	a->__any = NULL;
			if (soap_blist___any)
				soap_end_block(soap, soap_blist___any);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (!a->Namespace || !a->XAddr || !a->Version))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct tds__Service *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tds__Service, SOAP_TYPE_tds__Service, sizeof(struct tds__Service), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct tds__Service * SOAP_FMAC4 soap_new_tds__Service(struct soap *soap, int n)
{
	struct tds__Service *p;
	struct tds__Service *a = (struct tds__Service*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct tds__Service));
	for (p = a; p && n--; p++)
		soap_default_tds__Service(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tds__Service(struct soap *soap, const struct tds__Service *a, const char *tag, const char *type)
{
	if (soap_out_tds__Service(soap, tag ? tag : "tds:Service", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tds__Service * SOAP_FMAC4 soap_get_tds__Service(struct soap *soap, struct tds__Service *p, const char *tag, const char *type)
{
	if ((p = soap_in_tds__Service(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__wsse__Security(struct soap *soap, struct _wsse__Security *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->wsu__Timestamp = NULL;
	a->UsernameToken = NULL;
	a->BinarySecurityToken = NULL;
	a->xenc__EncryptedKey = NULL;
	a->xenc__ReferenceList = NULL;
	a->wsc__SecurityContextToken = NULL;
	a->ds__Signature = NULL;
	a->saml1__Assertion = NULL;
	a->saml2__Assertion = NULL;
	soap_default_string(soap, &a->SOAP_ENV__actor);
	soap_default_string(soap, &a->SOAP_ENV__role);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__wsse__Security(struct soap *soap, const struct _wsse__Security *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_wsu__Timestamp(soap, &a->wsu__Timestamp);
	soap_serialize_PointerTo_wsse__UsernameToken(soap, &a->UsernameToken);
	soap_serialize_PointerTo_wsse__BinarySecurityToken(soap, &a->BinarySecurityToken);
	soap_serialize_PointerToxenc__EncryptedKeyType(soap, &a->xenc__EncryptedKey);
	soap_serialize_PointerTo_xenc__ReferenceList(soap, &a->xenc__ReferenceList);
	soap_serialize_PointerTowsc__SecurityContextTokenType(soap, &a->wsc__SecurityContextToken);
	soap_serialize_PointerTods__SignatureType(soap, &a->ds__Signature);
	soap_serialize_PointerTosaml1__AssertionType(soap, &a->saml1__Assertion);
	soap_serialize_PointerTosaml2__AssertionType(soap, &a->saml2__Assertion);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__wsse__Security(struct soap *soap, const char *tag, int id, const struct _wsse__Security *a, const char *type)
{
	if (a->SOAP_ENV__actor)
		soap_set_attr(soap, "SOAP-ENV:actor", soap_string2s(soap, a->SOAP_ENV__actor), 1);
	if (a->SOAP_ENV__role)
		soap_set_attr(soap, "SOAP-ENV:role", soap_string2s(soap, a->SOAP_ENV__role), 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__wsse__Security), type))
		return soap->error;
	if (soap_out_PointerTo_wsu__Timestamp(soap, "wsu:Timestamp", -1, &a->wsu__Timestamp, ""))
		return soap->error;
	if (soap_out_PointerTo_wsse__UsernameToken(soap, "wsse:UsernameToken", -1, &a->UsernameToken, ""))
		return soap->error;
	if (soap_out_PointerTo_wsse__BinarySecurityToken(soap, "wsse:BinarySecurityToken", -1, &a->BinarySecurityToken, ""))
		return soap->error;
	if (soap_out_PointerToxenc__EncryptedKeyType(soap, "xenc:EncryptedKey", -1, &a->xenc__EncryptedKey, ""))
		return soap->error;
	if (soap_out_PointerTo_xenc__ReferenceList(soap, "xenc:ReferenceList", -1, &a->xenc__ReferenceList, ""))
		return soap->error;
	if (soap_out_PointerTowsc__SecurityContextTokenType(soap, "wsc:SecurityContextToken", -1, &a->wsc__SecurityContextToken, ""))
		return soap->error;
	if (soap_out_PointerTods__SignatureType(soap, "ds:Signature", -1, &a->ds__Signature, ""))
		return soap->error;
	if (soap_out_PointerTosaml1__AssertionType(soap, "saml1:Assertion", -1, &a->saml1__Assertion, ""))
		return soap->error;
	if (soap_out_PointerTosaml2__AssertionType(soap, "saml2:Assertion", -1, &a->saml2__Assertion, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _wsse__Security * SOAP_FMAC4 soap_in__wsse__Security(struct soap *soap, const char *tag, struct _wsse__Security *a, const char *type)
{
	size_t soap_flag_wsu__Timestamp = 1;
	size_t soap_flag_UsernameToken = 1;
	size_t soap_flag_BinarySecurityToken = 1;
	size_t soap_flag_xenc__EncryptedKey = 1;
	size_t soap_flag_xenc__ReferenceList = 1;
	size_t soap_flag_wsc__SecurityContextToken = 1;
	size_t soap_flag_ds__Signature = 1;
	size_t soap_flag_saml1__Assertion = 1;
	size_t soap_flag_saml2__Assertion = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct _wsse__Security*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__wsse__Security, sizeof(struct _wsse__Security), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__wsse__Security(soap, a);
	if (soap_s2string(soap, soap_attr_value(soap, "SOAP-ENV:actor", 1, 0), &a->SOAP_ENV__actor))
		return NULL;
	if (soap_s2string(soap, soap_attr_value(soap, "SOAP-ENV:role", 1, 0), &a->SOAP_ENV__role))
		return NULL;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_wsu__Timestamp && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_wsu__Timestamp(soap, "wsu:Timestamp", &a->wsu__Timestamp, ""))
				{	soap_flag_wsu__Timestamp--;
					continue;
				}
			}
			if (soap_flag_UsernameToken && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_wsse__UsernameToken(soap, "wsse:UsernameToken", &a->UsernameToken, ""))
				{	soap_flag_UsernameToken--;
					continue;
				}
			}
			if (soap_flag_BinarySecurityToken && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_wsse__BinarySecurityToken(soap, "wsse:BinarySecurityToken", &a->BinarySecurityToken, ""))
				{	soap_flag_BinarySecurityToken--;
					continue;
				}
			}
			if (soap_flag_xenc__EncryptedKey && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerToxenc__EncryptedKeyType(soap, "xenc:EncryptedKey", &a->xenc__EncryptedKey, "xenc:EncryptedKeyType"))
				{	soap_flag_xenc__EncryptedKey--;
					continue;
				}
			}
			if (soap_flag_xenc__ReferenceList && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_xenc__ReferenceList(soap, "xenc:ReferenceList", &a->xenc__ReferenceList, ""))
				{	soap_flag_xenc__ReferenceList--;
					continue;
				}
			}
			if (soap_flag_wsc__SecurityContextToken && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTowsc__SecurityContextTokenType(soap, "wsc:SecurityContextToken", &a->wsc__SecurityContextToken, "wsc:SecurityContextTokenType"))
				{	soap_flag_wsc__SecurityContextToken--;
					continue;
				}
			}
			if (soap_flag_ds__Signature && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTods__SignatureType(soap, "ds:Signature", &a->ds__Signature, "ds:SignatureType"))
				{	soap_flag_ds__Signature--;
					continue;
				}
			}
			if (soap_flag_saml1__Assertion && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTosaml1__AssertionType(soap, "saml1:Assertion", &a->saml1__Assertion, "saml1:AssertionType"))
				{	soap_flag_saml1__Assertion--;
					continue;
				}
			}
			if (soap_flag_saml2__Assertion && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTosaml2__AssertionType(soap, "saml2:Assertion", &a->saml2__Assertion, "saml2:AssertionType"))
				{	soap_flag_saml2__Assertion--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _wsse__Security *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__wsse__Security, SOAP_TYPE__wsse__Security, sizeof(struct _wsse__Security), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _wsse__Security * SOAP_FMAC4 soap_new__wsse__Security(struct soap *soap, int n)
{
	struct _wsse__Security *p;
	struct _wsse__Security *a = (struct _wsse__Security*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _wsse__Security));
	for (p = a; p && n--; p++)
		soap_default__wsse__Security(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__wsse__Security(struct soap *soap, const struct _wsse__Security *a, const char *tag, const char *type)
{
	if (soap_out__wsse__Security(soap, tag ? tag : "wsse:Security", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _wsse__Security * SOAP_FMAC4 soap_get__wsse__Security(struct soap *soap, struct _wsse__Security *p, const char *tag, const char *type)
{
	if ((p = soap_in__wsse__Security(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__saml2__EncryptedAttribute(struct soap *soap, const struct saml2__EncryptedElementType *a, const char *tag, const char *type)
{
	if (soap_out__saml2__EncryptedAttribute(soap, tag ? tag : "saml2:EncryptedAttribute", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__saml2__Attribute(struct soap *soap, const struct saml2__AttributeType *a, const char *tag, const char *type)
{
	if (soap_out__saml2__Attribute(soap, tag ? tag : "saml2:Attribute", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__saml2__AttributeStatement(struct soap *soap, const struct saml2__AttributeStatementType *a, const char *tag, const char *type)
{
	if (soap_out__saml2__AttributeStatement(soap, tag ? tag : "saml2:AttributeStatement", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__saml2__Evidence(struct soap *soap, const struct saml2__EvidenceType *a, const char *tag, const char *type)
{
	if (soap_out__saml2__Evidence(soap, tag ? tag : "saml2:Evidence", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__saml2__Action(struct soap *soap, const struct saml2__ActionType *a, const char *tag, const char *type)
{
	if (soap_out__saml2__Action(soap, tag ? tag : "saml2:Action", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__saml2__AuthzDecisionStatement(struct soap *soap, const struct saml2__AuthzDecisionStatementType *a, const char *tag, const char *type)
{
	if (soap_out__saml2__AuthzDecisionStatement(soap, tag ? tag : "saml2:AuthzDecisionStatement", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__saml2__AuthnContext(struct soap *soap, const struct saml2__AuthnContextType *a, const char *tag, const char *type)
{
	if (soap_out__saml2__AuthnContext(soap, tag ? tag : "saml2:AuthnContext", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__saml2__SubjectLocality(struct soap *soap, const struct saml2__SubjectLocalityType *a, const char *tag, const char *type)
{
	if (soap_out__saml2__SubjectLocality(soap, tag ? tag : "saml2:SubjectLocality", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__saml2__AuthnStatement(struct soap *soap, const struct saml2__AuthnStatementType *a, const char *tag, const char *type)
{
	if (soap_out__saml2__AuthnStatement(soap, tag ? tag : "saml2:AuthnStatement", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__saml2__Statement(struct soap *soap, const struct saml2__StatementAbstractType *a, const char *tag, const char *type)
{
	if (soap_out__saml2__Statement(soap, tag ? tag : "saml2:Statement", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__saml2__EncryptedAssertion(struct soap *soap, const struct saml2__EncryptedElementType *a, const char *tag, const char *type)
{
	if (soap_out__saml2__EncryptedAssertion(soap, tag ? tag : "saml2:EncryptedAssertion", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__saml2__Advice(struct soap *soap, const struct saml2__AdviceType *a, const char *tag, const char *type)
{
	if (soap_out__saml2__Advice(soap, tag ? tag : "saml2:Advice", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__saml2__ProxyRestriction(struct soap *soap, const struct saml2__ProxyRestrictionType *a, const char *tag, const char *type)
{
	if (soap_out__saml2__ProxyRestriction(soap, tag ? tag : "saml2:ProxyRestriction", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__saml2__OneTimeUse(struct soap *soap, const struct saml2__OneTimeUseType *a, const char *tag, const char *type)
{
	if (soap_out__saml2__OneTimeUse(soap, tag ? tag : "saml2:OneTimeUse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__saml2__AudienceRestriction(struct soap *soap, const struct saml2__AudienceRestrictionType *a, const char *tag, const char *type)
{
	if (soap_out__saml2__AudienceRestriction(soap, tag ? tag : "saml2:AudienceRestriction", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__saml2__Condition(struct soap *soap, const struct saml2__ConditionAbstractType *a, const char *tag, const char *type)
{
	if (soap_out__saml2__Condition(soap, tag ? tag : "saml2:Condition", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__saml2__Conditions(struct soap *soap, const struct saml2__ConditionsType *a, const char *tag, const char *type)
{
	if (soap_out__saml2__Conditions(soap, tag ? tag : "saml2:Conditions", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__saml2__SubjectConfirmationData(struct soap *soap, const struct saml2__SubjectConfirmationDataType *a, const char *tag, const char *type)
{
	if (soap_out__saml2__SubjectConfirmationData(soap, tag ? tag : "saml2:SubjectConfirmationData", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__saml2__SubjectConfirmation(struct soap *soap, const struct saml2__SubjectConfirmationType *a, const char *tag, const char *type)
{
	if (soap_out__saml2__SubjectConfirmation(soap, tag ? tag : "saml2:SubjectConfirmation", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__saml2__Subject(struct soap *soap, const struct saml2__SubjectType *a, const char *tag, const char *type)
{
	if (soap_out__saml2__Subject(soap, tag ? tag : "saml2:Subject", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__saml2__Assertion(struct soap *soap, const struct saml2__AssertionType *a, const char *tag, const char *type)
{
	if (soap_out__saml2__Assertion(soap, tag ? tag : "saml2:Assertion", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__saml2__Issuer(struct soap *soap, const struct saml2__NameIDType *a, const char *tag, const char *type)
{
	if (soap_out__saml2__Issuer(soap, tag ? tag : "saml2:Issuer", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__saml2__EncryptedID(struct soap *soap, const struct saml2__EncryptedElementType *a, const char *tag, const char *type)
{
	if (soap_out__saml2__EncryptedID(soap, tag ? tag : "saml2:EncryptedID", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__saml2__NameID(struct soap *soap, const struct saml2__NameIDType *a, const char *tag, const char *type)
{
	if (soap_out__saml2__NameID(soap, tag ? tag : "saml2:NameID", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__saml2__BaseID(struct soap *soap, const struct saml2__BaseIDAbstractType *a, const char *tag, const char *type)
{
	if (soap_out__saml2__BaseID(soap, tag ? tag : "saml2:BaseID", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___saml2__union_AttributeStatementType(struct soap *soap, struct __saml2__union_AttributeStatementType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->saml2__Attribute = NULL;
	a->saml2__EncryptedAttribute = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___saml2__union_AttributeStatementType(struct soap *soap, const struct __saml2__union_AttributeStatementType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTosaml2__AttributeType(soap, &a->saml2__Attribute);
	soap_serialize_PointerTosaml2__EncryptedElementType(soap, &a->saml2__EncryptedAttribute);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___saml2__union_AttributeStatementType(struct soap *soap, const char *tag, int id, const struct __saml2__union_AttributeStatementType *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTosaml2__AttributeType(soap, "saml2:Attribute", -1, &a->saml2__Attribute, ""))
		return soap->error;
	if (soap_out_PointerTosaml2__EncryptedElementType(soap, "saml2:EncryptedAttribute", -1, &a->saml2__EncryptedAttribute, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __saml2__union_AttributeStatementType * SOAP_FMAC4 soap_in___saml2__union_AttributeStatementType(struct soap *soap, const char *tag, struct __saml2__union_AttributeStatementType *a, const char *type)
{
	size_t soap_flag_saml2__Attribute = 1;
	size_t soap_flag_saml2__EncryptedAttribute = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __saml2__union_AttributeStatementType*)soap_id_enter(soap, "", a, SOAP_TYPE___saml2__union_AttributeStatementType, sizeof(struct __saml2__union_AttributeStatementType), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___saml2__union_AttributeStatementType(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_saml2__Attribute && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTosaml2__AttributeType(soap, "saml2:Attribute", &a->saml2__Attribute, "saml2:AttributeType"))
				{	soap_flag_saml2__Attribute--;
					continue;
				}
			}
			if (soap_flag_saml2__EncryptedAttribute && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTosaml2__EncryptedElementType(soap, "saml2:EncryptedAttribute", &a->saml2__EncryptedAttribute, "saml2:EncryptedElementType"))
				{	soap_flag_saml2__EncryptedAttribute--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 struct __saml2__union_AttributeStatementType * SOAP_FMAC4 soap_new___saml2__union_AttributeStatementType(struct soap *soap, int n)
{
	struct __saml2__union_AttributeStatementType *p;
	struct __saml2__union_AttributeStatementType *a = (struct __saml2__union_AttributeStatementType*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct __saml2__union_AttributeStatementType));
	for (p = a; p && n--; p++)
		soap_default___saml2__union_AttributeStatementType(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___saml2__union_AttributeStatementType(struct soap *soap, const struct __saml2__union_AttributeStatementType *a, const char *tag, const char *type)
{
	if (soap_out___saml2__union_AttributeStatementType(soap, tag ? tag : "-saml2:union-AttributeStatementType", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __saml2__union_AttributeStatementType * SOAP_FMAC4 soap_get___saml2__union_AttributeStatementType(struct soap *soap, struct __saml2__union_AttributeStatementType *p, const char *tag, const char *type)
{
	if ((p = soap_in___saml2__union_AttributeStatementType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___saml2__union_EvidenceType(struct soap *soap, struct __saml2__union_EvidenceType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->saml2__AssertionIDRef);
	soap_default_string(soap, &a->saml2__AssertionURIRef);
	a->saml2__Assertion = NULL;
	a->saml2__EncryptedAssertion = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___saml2__union_EvidenceType(struct soap *soap, const struct __saml2__union_EvidenceType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_string(soap, (char*const*)&a->saml2__AssertionIDRef);
	soap_serialize_string(soap, (char*const*)&a->saml2__AssertionURIRef);
	soap_serialize_PointerTosaml2__AssertionType(soap, &a->saml2__Assertion);
	soap_serialize_PointerTosaml2__EncryptedElementType(soap, &a->saml2__EncryptedAssertion);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___saml2__union_EvidenceType(struct soap *soap, const char *tag, int id, const struct __saml2__union_EvidenceType *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_string(soap, "saml2:AssertionIDRef", -1, (char*const*)&a->saml2__AssertionIDRef, ""))
		return soap->error;
	if (soap_out_string(soap, "saml2:AssertionURIRef", -1, (char*const*)&a->saml2__AssertionURIRef, ""))
		return soap->error;
	if (soap_out_PointerTosaml2__AssertionType(soap, "saml2:Assertion", -1, &a->saml2__Assertion, ""))
		return soap->error;
	if (soap_out_PointerTosaml2__EncryptedElementType(soap, "saml2:EncryptedAssertion", -1, &a->saml2__EncryptedAssertion, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __saml2__union_EvidenceType * SOAP_FMAC4 soap_in___saml2__union_EvidenceType(struct soap *soap, const char *tag, struct __saml2__union_EvidenceType *a, const char *type)
{
	size_t soap_flag_saml2__AssertionIDRef = 1;
	size_t soap_flag_saml2__AssertionURIRef = 1;
	size_t soap_flag_saml2__Assertion = 1;
	size_t soap_flag_saml2__EncryptedAssertion = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __saml2__union_EvidenceType*)soap_id_enter(soap, "", a, SOAP_TYPE___saml2__union_EvidenceType, sizeof(struct __saml2__union_EvidenceType), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___saml2__union_EvidenceType(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_saml2__AssertionIDRef && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_string(soap, "saml2:AssertionIDRef", (char**)&a->saml2__AssertionIDRef, "xsd:string"))
				{	soap_flag_saml2__AssertionIDRef--;
					continue;
				}
			}
			if (soap_flag_saml2__AssertionURIRef && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_string(soap, "saml2:AssertionURIRef", (char**)&a->saml2__AssertionURIRef, "xsd:string"))
				{	soap_flag_saml2__AssertionURIRef--;
					continue;
				}
			}
			if (soap_flag_saml2__Assertion && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTosaml2__AssertionType(soap, "saml2:Assertion", &a->saml2__Assertion, "saml2:AssertionType"))
				{	soap_flag_saml2__Assertion--;
					continue;
				}
			}
			if (soap_flag_saml2__EncryptedAssertion && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTosaml2__EncryptedElementType(soap, "saml2:EncryptedAssertion", &a->saml2__EncryptedAssertion, "saml2:EncryptedElementType"))
				{	soap_flag_saml2__EncryptedAssertion--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 struct __saml2__union_EvidenceType * SOAP_FMAC4 soap_new___saml2__union_EvidenceType(struct soap *soap, int n)
{
	struct __saml2__union_EvidenceType *p;
	struct __saml2__union_EvidenceType *a = (struct __saml2__union_EvidenceType*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct __saml2__union_EvidenceType));
	for (p = a; p && n--; p++)
		soap_default___saml2__union_EvidenceType(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___saml2__union_EvidenceType(struct soap *soap, const struct __saml2__union_EvidenceType *a, const char *tag, const char *type)
{
	if (soap_out___saml2__union_EvidenceType(soap, tag ? tag : "-saml2:union-EvidenceType", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __saml2__union_EvidenceType * SOAP_FMAC4 soap_get___saml2__union_EvidenceType(struct soap *soap, struct __saml2__union_EvidenceType *p, const char *tag, const char *type)
{
	if ((p = soap_in___saml2__union_EvidenceType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___saml2__union_AdviceType(struct soap *soap, struct __saml2__union_AdviceType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->saml2__AssertionIDRef);
	soap_default_string(soap, &a->saml2__AssertionURIRef);
	a->saml2__Assertion = NULL;
	a->saml2__EncryptedAssertion = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___saml2__union_AdviceType(struct soap *soap, const struct __saml2__union_AdviceType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_string(soap, (char*const*)&a->saml2__AssertionIDRef);
	soap_serialize_string(soap, (char*const*)&a->saml2__AssertionURIRef);
	soap_serialize_PointerTosaml2__AssertionType(soap, &a->saml2__Assertion);
	soap_serialize_PointerTosaml2__EncryptedElementType(soap, &a->saml2__EncryptedAssertion);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___saml2__union_AdviceType(struct soap *soap, const char *tag, int id, const struct __saml2__union_AdviceType *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_string(soap, "saml2:AssertionIDRef", -1, (char*const*)&a->saml2__AssertionIDRef, ""))
		return soap->error;
	if (soap_out_string(soap, "saml2:AssertionURIRef", -1, (char*const*)&a->saml2__AssertionURIRef, ""))
		return soap->error;
	if (soap_out_PointerTosaml2__AssertionType(soap, "saml2:Assertion", -1, &a->saml2__Assertion, ""))
		return soap->error;
	if (soap_out_PointerTosaml2__EncryptedElementType(soap, "saml2:EncryptedAssertion", -1, &a->saml2__EncryptedAssertion, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __saml2__union_AdviceType * SOAP_FMAC4 soap_in___saml2__union_AdviceType(struct soap *soap, const char *tag, struct __saml2__union_AdviceType *a, const char *type)
{
	size_t soap_flag_saml2__AssertionIDRef = 1;
	size_t soap_flag_saml2__AssertionURIRef = 1;
	size_t soap_flag_saml2__Assertion = 1;
	size_t soap_flag_saml2__EncryptedAssertion = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __saml2__union_AdviceType*)soap_id_enter(soap, "", a, SOAP_TYPE___saml2__union_AdviceType, sizeof(struct __saml2__union_AdviceType), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___saml2__union_AdviceType(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_saml2__AssertionIDRef && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_string(soap, "saml2:AssertionIDRef", (char**)&a->saml2__AssertionIDRef, "xsd:string"))
				{	soap_flag_saml2__AssertionIDRef--;
					continue;
				}
			}
			if (soap_flag_saml2__AssertionURIRef && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_string(soap, "saml2:AssertionURIRef", (char**)&a->saml2__AssertionURIRef, "xsd:string"))
				{	soap_flag_saml2__AssertionURIRef--;
					continue;
				}
			}
			if (soap_flag_saml2__Assertion && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTosaml2__AssertionType(soap, "saml2:Assertion", &a->saml2__Assertion, "saml2:AssertionType"))
				{	soap_flag_saml2__Assertion--;
					continue;
				}
			}
			if (soap_flag_saml2__EncryptedAssertion && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTosaml2__EncryptedElementType(soap, "saml2:EncryptedAssertion", &a->saml2__EncryptedAssertion, "saml2:EncryptedElementType"))
				{	soap_flag_saml2__EncryptedAssertion--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 struct __saml2__union_AdviceType * SOAP_FMAC4 soap_new___saml2__union_AdviceType(struct soap *soap, int n)
{
	struct __saml2__union_AdviceType *p;
	struct __saml2__union_AdviceType *a = (struct __saml2__union_AdviceType*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct __saml2__union_AdviceType));
	for (p = a; p && n--; p++)
		soap_default___saml2__union_AdviceType(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___saml2__union_AdviceType(struct soap *soap, const struct __saml2__union_AdviceType *a, const char *tag, const char *type)
{
	if (soap_out___saml2__union_AdviceType(soap, tag ? tag : "-saml2:union-AdviceType", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __saml2__union_AdviceType * SOAP_FMAC4 soap_get___saml2__union_AdviceType(struct soap *soap, struct __saml2__union_AdviceType *p, const char *tag, const char *type)
{
	if ((p = soap_in___saml2__union_AdviceType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___saml2__union_ConditionsType(struct soap *soap, struct __saml2__union_ConditionsType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->saml2__Condition = NULL;
	a->saml2__AudienceRestriction = NULL;
	a->saml2__OneTimeUse = NULL;
	a->saml2__ProxyRestriction = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___saml2__union_ConditionsType(struct soap *soap, const struct __saml2__union_ConditionsType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTosaml2__ConditionAbstractType(soap, &a->saml2__Condition);
	soap_serialize_PointerTosaml2__AudienceRestrictionType(soap, &a->saml2__AudienceRestriction);
	soap_serialize_PointerTosaml2__OneTimeUseType(soap, &a->saml2__OneTimeUse);
	soap_serialize_PointerTosaml2__ProxyRestrictionType(soap, &a->saml2__ProxyRestriction);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___saml2__union_ConditionsType(struct soap *soap, const char *tag, int id, const struct __saml2__union_ConditionsType *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTosaml2__ConditionAbstractType(soap, "saml2:Condition", -1, &a->saml2__Condition, ""))
		return soap->error;
	if (soap_out_PointerTosaml2__AudienceRestrictionType(soap, "saml2:AudienceRestriction", -1, &a->saml2__AudienceRestriction, ""))
		return soap->error;
	if (soap_out_PointerTosaml2__OneTimeUseType(soap, "saml2:OneTimeUse", -1, &a->saml2__OneTimeUse, ""))
		return soap->error;
	if (soap_out_PointerTosaml2__ProxyRestrictionType(soap, "saml2:ProxyRestriction", -1, &a->saml2__ProxyRestriction, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __saml2__union_ConditionsType * SOAP_FMAC4 soap_in___saml2__union_ConditionsType(struct soap *soap, const char *tag, struct __saml2__union_ConditionsType *a, const char *type)
{
	size_t soap_flag_saml2__Condition = 1;
	size_t soap_flag_saml2__AudienceRestriction = 1;
	size_t soap_flag_saml2__OneTimeUse = 1;
	size_t soap_flag_saml2__ProxyRestriction = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __saml2__union_ConditionsType*)soap_id_enter(soap, "", a, SOAP_TYPE___saml2__union_ConditionsType, sizeof(struct __saml2__union_ConditionsType), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___saml2__union_ConditionsType(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_saml2__Condition && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTosaml2__ConditionAbstractType(soap, "saml2:Condition", &a->saml2__Condition, "saml2:ConditionAbstractType"))
				{	soap_flag_saml2__Condition--;
					continue;
				}
			}
			if (soap_flag_saml2__AudienceRestriction && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTosaml2__AudienceRestrictionType(soap, "saml2:AudienceRestriction", &a->saml2__AudienceRestriction, "saml2:AudienceRestrictionType"))
				{	soap_flag_saml2__AudienceRestriction--;
					continue;
				}
			}
			if (soap_flag_saml2__OneTimeUse && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTosaml2__OneTimeUseType(soap, "saml2:OneTimeUse", &a->saml2__OneTimeUse, "saml2:OneTimeUseType"))
				{	soap_flag_saml2__OneTimeUse--;
					continue;
				}
			}
			if (soap_flag_saml2__ProxyRestriction && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTosaml2__ProxyRestrictionType(soap, "saml2:ProxyRestriction", &a->saml2__ProxyRestriction, "saml2:ProxyRestrictionType"))
				{	soap_flag_saml2__ProxyRestriction--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 struct __saml2__union_ConditionsType * SOAP_FMAC4 soap_new___saml2__union_ConditionsType(struct soap *soap, int n)
{
	struct __saml2__union_ConditionsType *p;
	struct __saml2__union_ConditionsType *a = (struct __saml2__union_ConditionsType*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct __saml2__union_ConditionsType));
	for (p = a; p && n--; p++)
		soap_default___saml2__union_ConditionsType(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___saml2__union_ConditionsType(struct soap *soap, const struct __saml2__union_ConditionsType *a, const char *tag, const char *type)
{
	if (soap_out___saml2__union_ConditionsType(soap, tag ? tag : "-saml2:union-ConditionsType", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __saml2__union_ConditionsType * SOAP_FMAC4 soap_get___saml2__union_ConditionsType(struct soap *soap, struct __saml2__union_ConditionsType *p, const char *tag, const char *type)
{
	if ((p = soap_in___saml2__union_ConditionsType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___saml2__union_AssertionType(struct soap *soap, struct __saml2__union_AssertionType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->saml2__Statement = NULL;
	a->saml2__AuthnStatement = NULL;
	a->saml2__AuthzDecisionStatement = NULL;
	a->saml2__AttributeStatement = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___saml2__union_AssertionType(struct soap *soap, const struct __saml2__union_AssertionType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTosaml2__StatementAbstractType(soap, &a->saml2__Statement);
	soap_serialize_PointerTosaml2__AuthnStatementType(soap, &a->saml2__AuthnStatement);
	soap_serialize_PointerTosaml2__AuthzDecisionStatementType(soap, &a->saml2__AuthzDecisionStatement);
	soap_serialize_PointerTosaml2__AttributeStatementType(soap, &a->saml2__AttributeStatement);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___saml2__union_AssertionType(struct soap *soap, const char *tag, int id, const struct __saml2__union_AssertionType *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTosaml2__StatementAbstractType(soap, "saml2:Statement", -1, &a->saml2__Statement, ""))
		return soap->error;
	if (soap_out_PointerTosaml2__AuthnStatementType(soap, "saml2:AuthnStatement", -1, &a->saml2__AuthnStatement, ""))
		return soap->error;
	if (soap_out_PointerTosaml2__AuthzDecisionStatementType(soap, "saml2:AuthzDecisionStatement", -1, &a->saml2__AuthzDecisionStatement, ""))
		return soap->error;
	if (soap_out_PointerTosaml2__AttributeStatementType(soap, "saml2:AttributeStatement", -1, &a->saml2__AttributeStatement, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __saml2__union_AssertionType * SOAP_FMAC4 soap_in___saml2__union_AssertionType(struct soap *soap, const char *tag, struct __saml2__union_AssertionType *a, const char *type)
{
	size_t soap_flag_saml2__Statement = 1;
	size_t soap_flag_saml2__AuthnStatement = 1;
	size_t soap_flag_saml2__AuthzDecisionStatement = 1;
	size_t soap_flag_saml2__AttributeStatement = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __saml2__union_AssertionType*)soap_id_enter(soap, "", a, SOAP_TYPE___saml2__union_AssertionType, sizeof(struct __saml2__union_AssertionType), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___saml2__union_AssertionType(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_saml2__Statement && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTosaml2__StatementAbstractType(soap, "saml2:Statement", &a->saml2__Statement, "saml2:StatementAbstractType"))
				{	soap_flag_saml2__Statement--;
					continue;
				}
			}
			if (soap_flag_saml2__AuthnStatement && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTosaml2__AuthnStatementType(soap, "saml2:AuthnStatement", &a->saml2__AuthnStatement, "saml2:AuthnStatementType"))
				{	soap_flag_saml2__AuthnStatement--;
					continue;
				}
			}
			if (soap_flag_saml2__AuthzDecisionStatement && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTosaml2__AuthzDecisionStatementType(soap, "saml2:AuthzDecisionStatement", &a->saml2__AuthzDecisionStatement, "saml2:AuthzDecisionStatementType"))
				{	soap_flag_saml2__AuthzDecisionStatement--;
					continue;
				}
			}
			if (soap_flag_saml2__AttributeStatement && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTosaml2__AttributeStatementType(soap, "saml2:AttributeStatement", &a->saml2__AttributeStatement, "saml2:AttributeStatementType"))
				{	soap_flag_saml2__AttributeStatement--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 struct __saml2__union_AssertionType * SOAP_FMAC4 soap_new___saml2__union_AssertionType(struct soap *soap, int n)
{
	struct __saml2__union_AssertionType *p;
	struct __saml2__union_AssertionType *a = (struct __saml2__union_AssertionType*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct __saml2__union_AssertionType));
	for (p = a; p && n--; p++)
		soap_default___saml2__union_AssertionType(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___saml2__union_AssertionType(struct soap *soap, const struct __saml2__union_AssertionType *a, const char *tag, const char *type)
{
	if (soap_out___saml2__union_AssertionType(soap, tag ? tag : "-saml2:union-AssertionType", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __saml2__union_AssertionType * SOAP_FMAC4 soap_get___saml2__union_AssertionType(struct soap *soap, struct __saml2__union_AssertionType *p, const char *tag, const char *type)
{
	if ((p = soap_in___saml2__union_AssertionType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_saml2__AttributeType(struct soap *soap, struct saml2__AttributeType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__sizeAttributeValue = 0;
	a->saml2__AttributeValue = NULL;
	soap_default_string(soap, &a->Name);
	soap_default_string(soap, &a->NameFormat);
	soap_default_string(soap, &a->FriendlyName);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_saml2__AttributeType(struct soap *soap, const struct saml2__AttributeType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_saml2__AttributeType(struct soap *soap, const char *tag, int id, const struct saml2__AttributeType *a, const char *type)
{
	soap_set_attr(soap, "Name", a->Name ? soap_string2s(soap, a->Name) : "", 1);
	if (a->NameFormat)
		soap_set_attr(soap, "NameFormat", soap_string2s(soap, a->NameFormat), 1);
	if (a->FriendlyName)
		soap_set_attr(soap, "FriendlyName", soap_string2s(soap, a->FriendlyName), 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_saml2__AttributeType), type))
		return soap->error;
	if (a->saml2__AttributeValue)
	{	int i;
		for (i = 0; i < (int)a->__sizeAttributeValue; i++)
			if (soap_outliteral(soap, "saml2:AttributeValue", (char*const*)(a->saml2__AttributeValue + i), NULL))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct saml2__AttributeType * SOAP_FMAC4 soap_in_saml2__AttributeType(struct soap *soap, const char *tag, struct saml2__AttributeType *a, const char *type)
{
	struct soap_blist *soap_blist_saml2__AttributeValue = NULL;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct saml2__AttributeType*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_saml2__AttributeType, sizeof(struct saml2__AttributeType), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_saml2__AttributeType(soap, a);
	if (soap_s2string(soap, soap_attr_value(soap, "Name", 1, 1), &a->Name))
		return NULL;
	if (soap_s2string(soap, soap_attr_value(soap, "NameFormat", 1, 0), &a->NameFormat))
		return NULL;
	if (soap_s2string(soap, soap_attr_value(soap, "FriendlyName", 1, 0), &a->FriendlyName))
		return NULL;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "saml2:AttributeValue", 1, NULL))
			{	if (a->saml2__AttributeValue == NULL)
				{	if (soap_blist_saml2__AttributeValue == NULL)
						soap_blist_saml2__AttributeValue = soap_alloc_block(soap);
					a->saml2__AttributeValue = (char **)soap_push_block_max(soap, soap_blist_saml2__AttributeValue, sizeof(char *));
					if (a->saml2__AttributeValue == NULL)
						return NULL;
					*a->saml2__AttributeValue = NULL;
				}
				soap_revert(soap);
				if (soap_inliteral(soap, "saml2:AttributeValue", (char**)a->saml2__AttributeValue))
				{	a->__sizeAttributeValue++;
					a->saml2__AttributeValue = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->saml2__AttributeValue)
			soap_pop_block(soap, soap_blist_saml2__AttributeValue);
		if (a->__sizeAttributeValue)
		{	a->saml2__AttributeValue = (char **)soap_save_block(soap, soap_blist_saml2__AttributeValue, NULL, 1);
		}
		else
		{	a->saml2__AttributeValue = NULL;
			if (soap_blist_saml2__AttributeValue)
				soap_end_block(soap, soap_blist_saml2__AttributeValue);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct saml2__AttributeType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_saml2__AttributeType, SOAP_TYPE_saml2__AttributeType, sizeof(struct saml2__AttributeType), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct saml2__AttributeType * SOAP_FMAC4 soap_new_saml2__AttributeType(struct soap *soap, int n)
{
	struct saml2__AttributeType *p;
	struct saml2__AttributeType *a = (struct saml2__AttributeType*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct saml2__AttributeType));
	for (p = a; p && n--; p++)
		soap_default_saml2__AttributeType(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_saml2__AttributeType(struct soap *soap, const struct saml2__AttributeType *a, const char *tag, const char *type)
{
	if (soap_out_saml2__AttributeType(soap, tag ? tag : "saml2:AttributeType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct saml2__AttributeType * SOAP_FMAC4 soap_get_saml2__AttributeType(struct soap *soap, struct saml2__AttributeType *p, const char *tag, const char *type)
{
	if ((p = soap_in_saml2__AttributeType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_saml2__AttributeStatementType(struct soap *soap, struct saml2__AttributeStatementType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__size_AttributeStatementType = 0;
	a->__union_AttributeStatementType = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_saml2__AttributeStatementType(struct soap *soap, const struct saml2__AttributeStatementType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (a->__union_AttributeStatementType)
	{	int i;
		for (i = 0; i < (int)a->__size_AttributeStatementType; i++)
		{
			soap_serialize___saml2__union_AttributeStatementType(soap, a->__union_AttributeStatementType + i);
		}
	}
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_saml2__AttributeStatementType(struct soap *soap, const char *tag, int id, const struct saml2__AttributeStatementType *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_saml2__AttributeStatementType), type))
		return soap->error;
	if (a->__union_AttributeStatementType)
	{	int i;
		for (i = 0; i < (int)a->__size_AttributeStatementType; i++)
			if (soap_out___saml2__union_AttributeStatementType(soap, "-union-AttributeStatementType", -1, a->__union_AttributeStatementType + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct saml2__AttributeStatementType * SOAP_FMAC4 soap_in_saml2__AttributeStatementType(struct soap *soap, const char *tag, struct saml2__AttributeStatementType *a, const char *type)
{
	struct soap_blist *soap_blist___union_AttributeStatementType = NULL;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct saml2__AttributeStatementType*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_saml2__AttributeStatementType, sizeof(struct saml2__AttributeStatementType), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_saml2__AttributeStatementType(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	if (a->__union_AttributeStatementType == NULL)
				{	if (soap_blist___union_AttributeStatementType == NULL)
						soap_blist___union_AttributeStatementType = soap_alloc_block(soap);
					a->__union_AttributeStatementType = (struct __saml2__union_AttributeStatementType *)soap_push_block_max(soap, soap_blist___union_AttributeStatementType, sizeof(struct __saml2__union_AttributeStatementType));
					if (a->__union_AttributeStatementType == NULL)
						return NULL;
					soap_default___saml2__union_AttributeStatementType(soap, a->__union_AttributeStatementType);
				}
				if (soap_in___saml2__union_AttributeStatementType(soap, "-union-AttributeStatementType", a->__union_AttributeStatementType, "-saml2:union-AttributeStatementType"))
				{	a->__size_AttributeStatementType++;
					a->__union_AttributeStatementType = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->__union_AttributeStatementType)
			soap_pop_block(soap, soap_blist___union_AttributeStatementType);
		if (a->__size_AttributeStatementType)
		{	a->__union_AttributeStatementType = (struct __saml2__union_AttributeStatementType *)soap_save_block(soap, soap_blist___union_AttributeStatementType, NULL, 1);
		}
		else
		{	a->__union_AttributeStatementType = NULL;
			if (soap_blist___union_AttributeStatementType)
				soap_end_block(soap, soap_blist___union_AttributeStatementType);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct saml2__AttributeStatementType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_saml2__AttributeStatementType, SOAP_TYPE_saml2__AttributeStatementType, sizeof(struct saml2__AttributeStatementType), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct saml2__AttributeStatementType * SOAP_FMAC4 soap_new_saml2__AttributeStatementType(struct soap *soap, int n)
{
	struct saml2__AttributeStatementType *p;
	struct saml2__AttributeStatementType *a = (struct saml2__AttributeStatementType*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct saml2__AttributeStatementType));
	for (p = a; p && n--; p++)
		soap_default_saml2__AttributeStatementType(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_saml2__AttributeStatementType(struct soap *soap, const struct saml2__AttributeStatementType *a, const char *tag, const char *type)
{
	if (soap_out_saml2__AttributeStatementType(soap, tag ? tag : "saml2:AttributeStatementType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct saml2__AttributeStatementType * SOAP_FMAC4 soap_get_saml2__AttributeStatementType(struct soap *soap, struct saml2__AttributeStatementType *p, const char *tag, const char *type)
{
	if ((p = soap_in_saml2__AttributeStatementType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_saml2__EvidenceType(struct soap *soap, struct saml2__EvidenceType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__size_EvidenceType = 0;
	a->__union_EvidenceType = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_saml2__EvidenceType(struct soap *soap, const struct saml2__EvidenceType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (a->__union_EvidenceType)
	{	int i;
		for (i = 0; i < (int)a->__size_EvidenceType; i++)
		{
			soap_serialize___saml2__union_EvidenceType(soap, a->__union_EvidenceType + i);
		}
	}
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_saml2__EvidenceType(struct soap *soap, const char *tag, int id, const struct saml2__EvidenceType *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_saml2__EvidenceType), type))
		return soap->error;
	if (a->__union_EvidenceType)
	{	int i;
		for (i = 0; i < (int)a->__size_EvidenceType; i++)
			if (soap_out___saml2__union_EvidenceType(soap, "-union-EvidenceType", -1, a->__union_EvidenceType + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct saml2__EvidenceType * SOAP_FMAC4 soap_in_saml2__EvidenceType(struct soap *soap, const char *tag, struct saml2__EvidenceType *a, const char *type)
{
	struct soap_blist *soap_blist___union_EvidenceType = NULL;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct saml2__EvidenceType*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_saml2__EvidenceType, sizeof(struct saml2__EvidenceType), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_saml2__EvidenceType(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	if (a->__union_EvidenceType == NULL)
				{	if (soap_blist___union_EvidenceType == NULL)
						soap_blist___union_EvidenceType = soap_alloc_block(soap);
					a->__union_EvidenceType = (struct __saml2__union_EvidenceType *)soap_push_block_max(soap, soap_blist___union_EvidenceType, sizeof(struct __saml2__union_EvidenceType));
					if (a->__union_EvidenceType == NULL)
						return NULL;
					soap_default___saml2__union_EvidenceType(soap, a->__union_EvidenceType);
				}
				if (soap_in___saml2__union_EvidenceType(soap, "-union-EvidenceType", a->__union_EvidenceType, "-saml2:union-EvidenceType"))
				{	a->__size_EvidenceType++;
					a->__union_EvidenceType = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->__union_EvidenceType)
			soap_pop_block(soap, soap_blist___union_EvidenceType);
		if (a->__size_EvidenceType)
		{	a->__union_EvidenceType = (struct __saml2__union_EvidenceType *)soap_save_block(soap, soap_blist___union_EvidenceType, NULL, 1);
		}
		else
		{	a->__union_EvidenceType = NULL;
			if (soap_blist___union_EvidenceType)
				soap_end_block(soap, soap_blist___union_EvidenceType);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct saml2__EvidenceType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_saml2__EvidenceType, SOAP_TYPE_saml2__EvidenceType, sizeof(struct saml2__EvidenceType), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct saml2__EvidenceType * SOAP_FMAC4 soap_new_saml2__EvidenceType(struct soap *soap, int n)
{
	struct saml2__EvidenceType *p;
	struct saml2__EvidenceType *a = (struct saml2__EvidenceType*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct saml2__EvidenceType));
	for (p = a; p && n--; p++)
		soap_default_saml2__EvidenceType(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_saml2__EvidenceType(struct soap *soap, const struct saml2__EvidenceType *a, const char *tag, const char *type)
{
	if (soap_out_saml2__EvidenceType(soap, tag ? tag : "saml2:EvidenceType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct saml2__EvidenceType * SOAP_FMAC4 soap_get_saml2__EvidenceType(struct soap *soap, struct saml2__EvidenceType *p, const char *tag, const char *type)
{
	if ((p = soap_in_saml2__EvidenceType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_saml2__ActionType(struct soap *soap, struct saml2__ActionType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->__item);
	soap_default_string(soap, &a->Namespace);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_saml2__ActionType(struct soap *soap, const struct saml2__ActionType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_string(soap, (char*const*)&a->__item);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_saml2__ActionType(struct soap *soap, const char *tag, int id, const struct saml2__ActionType *a, const char *type)
{
	soap_set_attr(soap, "Namespace", a->Namespace ? soap_string2s(soap, a->Namespace) : "", 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	return soap_out_string(soap, tag, id, (char*const*)&a->__item, "");
}

SOAP_FMAC3 struct saml2__ActionType * SOAP_FMAC4 soap_in_saml2__ActionType(struct soap *soap, const char *tag, struct saml2__ActionType *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	if (!(a = (struct saml2__ActionType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_saml2__ActionType, sizeof(struct saml2__ActionType), NULL, NULL, NULL, NULL)))
		return NULL;
	soap_revert(soap);
	*soap->id = '\0';
	soap_default_saml2__ActionType(soap, a);
	if (soap_s2string(soap, soap_attr_value(soap, "Namespace", 1, 1), &a->Namespace))
		return NULL;
	if (!soap_in_string(soap, tag, (char**)&a->__item, "saml2:ActionType"))
		return NULL;
	return a;
}

SOAP_FMAC3 struct saml2__ActionType * SOAP_FMAC4 soap_new_saml2__ActionType(struct soap *soap, int n)
{
	struct saml2__ActionType *p;
	struct saml2__ActionType *a = (struct saml2__ActionType*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct saml2__ActionType));
	for (p = a; p && n--; p++)
		soap_default_saml2__ActionType(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_saml2__ActionType(struct soap *soap, const struct saml2__ActionType *a, const char *tag, const char *type)
{
	if (soap_out_saml2__ActionType(soap, tag ? tag : "saml2:ActionType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct saml2__ActionType * SOAP_FMAC4 soap_get_saml2__ActionType(struct soap *soap, struct saml2__ActionType *p, const char *tag, const char *type)
{
	if ((p = soap_in_saml2__ActionType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_saml2__AuthzDecisionStatementType(struct soap *soap, struct saml2__AuthzDecisionStatementType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__sizeAction = 0;
	a->saml2__Action = NULL;
	a->saml2__Evidence = NULL;
	soap_default_string(soap, &a->Resource);
	soap_default_saml2__DecisionType(soap, &a->Decision);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_saml2__AuthzDecisionStatementType(struct soap *soap, const struct saml2__AuthzDecisionStatementType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (a->saml2__Action)
	{	int i;
		for (i = 0; i < (int)a->__sizeAction; i++)
		{
			soap_embedded(soap, a->saml2__Action + i, SOAP_TYPE_saml2__ActionType);
			soap_serialize_saml2__ActionType(soap, a->saml2__Action + i);
		}
	}
	soap_serialize_PointerTosaml2__EvidenceType(soap, &a->saml2__Evidence);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_saml2__AuthzDecisionStatementType(struct soap *soap, const char *tag, int id, const struct saml2__AuthzDecisionStatementType *a, const char *type)
{
	soap_set_attr(soap, "Resource", a->Resource ? soap_string2s(soap, a->Resource) : "", 1);
	soap_set_attr(soap, "Decision", soap_saml2__DecisionType2s(soap, a->Decision), 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_saml2__AuthzDecisionStatementType), type))
		return soap->error;
	if (a->saml2__Action)
	{	int i;
		for (i = 0; i < (int)a->__sizeAction; i++)
			if (soap_out_saml2__ActionType(soap, "saml2:Action", -1, a->saml2__Action + i, ""))
				return soap->error;
	}
	if (soap_out_PointerTosaml2__EvidenceType(soap, "saml2:Evidence", -1, &a->saml2__Evidence, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct saml2__AuthzDecisionStatementType * SOAP_FMAC4 soap_in_saml2__AuthzDecisionStatementType(struct soap *soap, const char *tag, struct saml2__AuthzDecisionStatementType *a, const char *type)
{
	struct soap_blist *soap_blist_saml2__Action = NULL;
	size_t soap_flag_saml2__Evidence = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct saml2__AuthzDecisionStatementType*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_saml2__AuthzDecisionStatementType, sizeof(struct saml2__AuthzDecisionStatementType), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_saml2__AuthzDecisionStatementType(soap, a);
	if (soap_s2string(soap, soap_attr_value(soap, "Resource", 1, 1), &a->Resource))
		return NULL;
	if (soap_s2saml2__DecisionType(soap, soap_attr_value(soap, "Decision", 5, 1), &a->Decision))
		return NULL;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "saml2:Action", 1, NULL))
			{	if (a->saml2__Action == NULL)
				{	if (soap_blist_saml2__Action == NULL)
						soap_blist_saml2__Action = soap_alloc_block(soap);
					a->saml2__Action = (struct saml2__ActionType *)soap_push_block_max(soap, soap_blist_saml2__Action, sizeof(struct saml2__ActionType));
					if (a->saml2__Action == NULL)
						return NULL;
					soap_default_saml2__ActionType(soap, a->saml2__Action);
				}
				soap_revert(soap);
				if (soap_in_saml2__ActionType(soap, "saml2:Action", a->saml2__Action, "saml2:ActionType"))
				{	a->__sizeAction++;
					a->saml2__Action = NULL;
					continue;
				}
			}
			if (soap_flag_saml2__Evidence && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTosaml2__EvidenceType(soap, "saml2:Evidence", &a->saml2__Evidence, "saml2:EvidenceType"))
				{	soap_flag_saml2__Evidence--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->saml2__Action)
			soap_pop_block(soap, soap_blist_saml2__Action);
		if (a->__sizeAction)
		{	a->saml2__Action = (struct saml2__ActionType *)soap_save_block(soap, soap_blist_saml2__Action, NULL, 1);
		}
		else
		{	a->saml2__Action = NULL;
			if (soap_blist_saml2__Action)
				soap_end_block(soap, soap_blist_saml2__Action);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (a->__sizeAction < 1))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct saml2__AuthzDecisionStatementType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_saml2__AuthzDecisionStatementType, SOAP_TYPE_saml2__AuthzDecisionStatementType, sizeof(struct saml2__AuthzDecisionStatementType), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct saml2__AuthzDecisionStatementType * SOAP_FMAC4 soap_new_saml2__AuthzDecisionStatementType(struct soap *soap, int n)
{
	struct saml2__AuthzDecisionStatementType *p;
	struct saml2__AuthzDecisionStatementType *a = (struct saml2__AuthzDecisionStatementType*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct saml2__AuthzDecisionStatementType));
	for (p = a; p && n--; p++)
		soap_default_saml2__AuthzDecisionStatementType(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_saml2__AuthzDecisionStatementType(struct soap *soap, const struct saml2__AuthzDecisionStatementType *a, const char *tag, const char *type)
{
	if (soap_out_saml2__AuthzDecisionStatementType(soap, tag ? tag : "saml2:AuthzDecisionStatementType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct saml2__AuthzDecisionStatementType * SOAP_FMAC4 soap_get_saml2__AuthzDecisionStatementType(struct soap *soap, struct saml2__AuthzDecisionStatementType *p, const char *tag, const char *type)
{
	if ((p = soap_in_saml2__AuthzDecisionStatementType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_saml2__AuthnContextType(struct soap *soap, struct saml2__AuthnContextType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->saml2__AuthnContextClassRef);
	a->saml2__AuthnContextDecl = NULL;
	soap_default_string(soap, &a->saml2__AuthnContextDeclRef);
	a->saml2__AuthnContextDecl_ = NULL;
	soap_default_string(soap, &a->saml2__AuthnContextDeclRef_);
	a->__sizeAuthenticatingAuthority = 0;
	a->saml2__AuthenticatingAuthority = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_saml2__AuthnContextType(struct soap *soap, const struct saml2__AuthnContextType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_string(soap, (char*const*)&a->saml2__AuthnContextClassRef);
	soap_serialize_string(soap, (char*const*)&a->saml2__AuthnContextDeclRef);
	soap_serialize_string(soap, (char*const*)&a->saml2__AuthnContextDeclRef_);
	if (a->saml2__AuthenticatingAuthority)
	{	int i;
		for (i = 0; i < (int)a->__sizeAuthenticatingAuthority; i++)
		{
			soap_serialize_string(soap, (char*const*)(a->saml2__AuthenticatingAuthority + i));
		}
	}
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_saml2__AuthnContextType(struct soap *soap, const char *tag, int id, const struct saml2__AuthnContextType *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_saml2__AuthnContextType), type))
		return soap->error;
	if (soap_out_string(soap, "saml2:AuthnContextClassRef", -1, (char*const*)&a->saml2__AuthnContextClassRef, ""))
		return soap->error;
	if (soap_outliteral(soap, "saml2:AuthnContextDecl", (char*const*)&a->saml2__AuthnContextDecl, NULL))
		return soap->error;
	if (soap_out_string(soap, "saml2:AuthnContextDeclRef", -1, (char*const*)&a->saml2__AuthnContextDeclRef, ""))
		return soap->error;
	if (soap_outliteral(soap, "saml2:AuthnContextDecl", (char*const*)&a->saml2__AuthnContextDecl_, NULL))
		return soap->error;
	if (soap_out_string(soap, "saml2:AuthnContextDeclRef", -1, (char*const*)&a->saml2__AuthnContextDeclRef_, ""))
		return soap->error;
	if (a->saml2__AuthenticatingAuthority)
	{	int i;
		for (i = 0; i < (int)a->__sizeAuthenticatingAuthority; i++)
			if (soap_out_string(soap, "saml2:AuthenticatingAuthority", -1, (char*const*)(a->saml2__AuthenticatingAuthority + i), ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct saml2__AuthnContextType * SOAP_FMAC4 soap_in_saml2__AuthnContextType(struct soap *soap, const char *tag, struct saml2__AuthnContextType *a, const char *type)
{
	size_t soap_flag_saml2__AuthnContextClassRef = 1;
	size_t soap_flag_saml2__AuthnContextDecl = 1;
	size_t soap_flag_saml2__AuthnContextDeclRef = 1;
	size_t soap_flag_saml2__AuthnContextDecl_ = 1;
	size_t soap_flag_saml2__AuthnContextDeclRef_ = 1;
	struct soap_blist *soap_blist_saml2__AuthenticatingAuthority = NULL;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct saml2__AuthnContextType*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_saml2__AuthnContextType, sizeof(struct saml2__AuthnContextType), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_saml2__AuthnContextType(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_saml2__AuthnContextClassRef && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_string(soap, "saml2:AuthnContextClassRef", (char**)&a->saml2__AuthnContextClassRef, "xsd:string"))
				{	soap_flag_saml2__AuthnContextClassRef--;
					continue;
				}
			}
			if (soap_flag_saml2__AuthnContextDecl && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_inliteral(soap, "saml2:AuthnContextDecl", (char**)&a->saml2__AuthnContextDecl))
				{	soap_flag_saml2__AuthnContextDecl--;
					continue;
				}
			}
			if (soap_flag_saml2__AuthnContextDeclRef && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_string(soap, "saml2:AuthnContextDeclRef", (char**)&a->saml2__AuthnContextDeclRef, "xsd:string"))
				{	soap_flag_saml2__AuthnContextDeclRef--;
					continue;
				}
			}
			if (soap_flag_saml2__AuthnContextDecl_ && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_inliteral(soap, "saml2:AuthnContextDecl", (char**)&a->saml2__AuthnContextDecl_))
				{	soap_flag_saml2__AuthnContextDecl_--;
					continue;
				}
			}
			if (soap_flag_saml2__AuthnContextDeclRef_ && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_string(soap, "saml2:AuthnContextDeclRef", (char**)&a->saml2__AuthnContextDeclRef_, "xsd:string"))
				{	soap_flag_saml2__AuthnContextDeclRef_--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "saml2:AuthenticatingAuthority", 1, NULL))
			{	if (a->saml2__AuthenticatingAuthority == NULL)
				{	if (soap_blist_saml2__AuthenticatingAuthority == NULL)
						soap_blist_saml2__AuthenticatingAuthority = soap_alloc_block(soap);
					a->saml2__AuthenticatingAuthority = (char **)soap_push_block_max(soap, soap_blist_saml2__AuthenticatingAuthority, sizeof(char *));
					if (a->saml2__AuthenticatingAuthority == NULL)
						return NULL;
					*a->saml2__AuthenticatingAuthority = NULL;
				}
				soap_revert(soap);
				if (soap_in_string(soap, "saml2:AuthenticatingAuthority", (char**)a->saml2__AuthenticatingAuthority, "xsd:string"))
				{	a->__sizeAuthenticatingAuthority++;
					a->saml2__AuthenticatingAuthority = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->saml2__AuthenticatingAuthority)
			soap_pop_block(soap, soap_blist_saml2__AuthenticatingAuthority);
		if (a->__sizeAuthenticatingAuthority)
		{	a->saml2__AuthenticatingAuthority = (char **)soap_save_block(soap, soap_blist_saml2__AuthenticatingAuthority, NULL, 1);
		}
		else
		{	a->saml2__AuthenticatingAuthority = NULL;
			if (soap_blist_saml2__AuthenticatingAuthority)
				soap_end_block(soap, soap_blist_saml2__AuthenticatingAuthority);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct saml2__AuthnContextType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_saml2__AuthnContextType, SOAP_TYPE_saml2__AuthnContextType, sizeof(struct saml2__AuthnContextType), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct saml2__AuthnContextType * SOAP_FMAC4 soap_new_saml2__AuthnContextType(struct soap *soap, int n)
{
	struct saml2__AuthnContextType *p;
	struct saml2__AuthnContextType *a = (struct saml2__AuthnContextType*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct saml2__AuthnContextType));
	for (p = a; p && n--; p++)
		soap_default_saml2__AuthnContextType(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_saml2__AuthnContextType(struct soap *soap, const struct saml2__AuthnContextType *a, const char *tag, const char *type)
{
	if (soap_out_saml2__AuthnContextType(soap, tag ? tag : "saml2:AuthnContextType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct saml2__AuthnContextType * SOAP_FMAC4 soap_get_saml2__AuthnContextType(struct soap *soap, struct saml2__AuthnContextType *p, const char *tag, const char *type)
{
	if ((p = soap_in_saml2__AuthnContextType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_saml2__SubjectLocalityType(struct soap *soap, struct saml2__SubjectLocalityType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->Address);
	soap_default_string(soap, &a->DNSName);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_saml2__SubjectLocalityType(struct soap *soap, const struct saml2__SubjectLocalityType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_saml2__SubjectLocalityType(struct soap *soap, const char *tag, int id, const struct saml2__SubjectLocalityType *a, const char *type)
{
	if (a->Address)
		soap_set_attr(soap, "Address", soap_string2s(soap, a->Address), 1);
	if (a->DNSName)
		soap_set_attr(soap, "DNSName", soap_string2s(soap, a->DNSName), 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_saml2__SubjectLocalityType), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct saml2__SubjectLocalityType * SOAP_FMAC4 soap_in_saml2__SubjectLocalityType(struct soap *soap, const char *tag, struct saml2__SubjectLocalityType *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct saml2__SubjectLocalityType*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_saml2__SubjectLocalityType, sizeof(struct saml2__SubjectLocalityType), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_saml2__SubjectLocalityType(soap, a);
	if (soap_s2string(soap, soap_attr_value(soap, "Address", 1, 0), &a->Address))
		return NULL;
	if (soap_s2string(soap, soap_attr_value(soap, "DNSName", 1, 0), &a->DNSName))
		return NULL;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct saml2__SubjectLocalityType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_saml2__SubjectLocalityType, SOAP_TYPE_saml2__SubjectLocalityType, sizeof(struct saml2__SubjectLocalityType), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct saml2__SubjectLocalityType * SOAP_FMAC4 soap_new_saml2__SubjectLocalityType(struct soap *soap, int n)
{
	struct saml2__SubjectLocalityType *p;
	struct saml2__SubjectLocalityType *a = (struct saml2__SubjectLocalityType*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct saml2__SubjectLocalityType));
	for (p = a; p && n--; p++)
		soap_default_saml2__SubjectLocalityType(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_saml2__SubjectLocalityType(struct soap *soap, const struct saml2__SubjectLocalityType *a, const char *tag, const char *type)
{
	if (soap_out_saml2__SubjectLocalityType(soap, tag ? tag : "saml2:SubjectLocalityType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct saml2__SubjectLocalityType * SOAP_FMAC4 soap_get_saml2__SubjectLocalityType(struct soap *soap, struct saml2__SubjectLocalityType *p, const char *tag, const char *type)
{
	if ((p = soap_in_saml2__SubjectLocalityType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_saml2__AuthnStatementType(struct soap *soap, struct saml2__AuthnStatementType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->saml2__SubjectLocality = NULL;
	a->saml2__AuthnContext = NULL;
	soap_default_xsd__dateTime(soap, &a->AuthnInstant);
	soap_default_string(soap, &a->SessionIndex);
	a->SessionNotOnOrAfter = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_saml2__AuthnStatementType(struct soap *soap, const struct saml2__AuthnStatementType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTosaml2__SubjectLocalityType(soap, &a->saml2__SubjectLocality);
	soap_serialize_PointerTosaml2__AuthnContextType(soap, &a->saml2__AuthnContext);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_saml2__AuthnStatementType(struct soap *soap, const char *tag, int id, const struct saml2__AuthnStatementType *a, const char *type)
{
	soap_set_attr(soap, "AuthnInstant", soap_xsd__dateTime2s(soap, a->AuthnInstant), 1);
	if (a->SessionIndex)
		soap_set_attr(soap, "SessionIndex", soap_string2s(soap, a->SessionIndex), 1);
	if (a->SessionNotOnOrAfter)
	{	soap_set_attr(soap, "SessionNotOnOrAfter", soap_xsd__dateTime2s(soap, *a->SessionNotOnOrAfter), 1);
	}
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_saml2__AuthnStatementType), type))
		return soap->error;
	if (soap_out_PointerTosaml2__SubjectLocalityType(soap, "saml2:SubjectLocality", -1, &a->saml2__SubjectLocality, ""))
		return soap->error;
	if (!a->saml2__AuthnContext)
	{	if (soap_element_empty(soap, "saml2:AuthnContext", 0, NULL))
			return soap->error;
	}
	else if (soap_out_PointerTosaml2__AuthnContextType(soap, "saml2:AuthnContext", -1, &a->saml2__AuthnContext, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct saml2__AuthnStatementType * SOAP_FMAC4 soap_in_saml2__AuthnStatementType(struct soap *soap, const char *tag, struct saml2__AuthnStatementType *a, const char *type)
{
	size_t soap_flag_saml2__SubjectLocality = 1;
	size_t soap_flag_saml2__AuthnContext = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct saml2__AuthnStatementType*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_saml2__AuthnStatementType, sizeof(struct saml2__AuthnStatementType), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_saml2__AuthnStatementType(soap, a);
	if (soap_s2xsd__dateTime(soap, soap_attr_value(soap, "AuthnInstant", 5, 1), &a->AuthnInstant))
		return NULL;
	if (soap_s2string(soap, soap_attr_value(soap, "SessionIndex", 1, 0), &a->SessionIndex))
		return NULL;
	{
		const char *t = soap_attr_value(soap, "SessionNotOnOrAfter", 5, 0);
		if (t)
		{
			if (!(a->SessionNotOnOrAfter = (struct timeval *)soap_malloc(soap, sizeof(struct timeval))))
				return NULL;
			if (soap_s2xsd__dateTime(soap, t, a->SessionNotOnOrAfter))
				return NULL;
		}
		else if (soap->error)
			return NULL;
	}
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_saml2__SubjectLocality && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTosaml2__SubjectLocalityType(soap, "saml2:SubjectLocality", &a->saml2__SubjectLocality, "saml2:SubjectLocalityType"))
				{	soap_flag_saml2__SubjectLocality--;
					continue;
				}
			}
			if (soap_flag_saml2__AuthnContext && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTosaml2__AuthnContextType(soap, "saml2:AuthnContext", &a->saml2__AuthnContext, "saml2:AuthnContextType"))
				{	soap_flag_saml2__AuthnContext--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (!a->saml2__AuthnContext))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct saml2__AuthnStatementType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_saml2__AuthnStatementType, SOAP_TYPE_saml2__AuthnStatementType, sizeof(struct saml2__AuthnStatementType), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct saml2__AuthnStatementType * SOAP_FMAC4 soap_new_saml2__AuthnStatementType(struct soap *soap, int n)
{
	struct saml2__AuthnStatementType *p;
	struct saml2__AuthnStatementType *a = (struct saml2__AuthnStatementType*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct saml2__AuthnStatementType));
	for (p = a; p && n--; p++)
		soap_default_saml2__AuthnStatementType(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_saml2__AuthnStatementType(struct soap *soap, const struct saml2__AuthnStatementType *a, const char *tag, const char *type)
{
	if (soap_out_saml2__AuthnStatementType(soap, tag ? tag : "saml2:AuthnStatementType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct saml2__AuthnStatementType * SOAP_FMAC4 soap_get_saml2__AuthnStatementType(struct soap *soap, struct saml2__AuthnStatementType *p, const char *tag, const char *type)
{
	if ((p = soap_in_saml2__AuthnStatementType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_saml2__StatementAbstractType(struct soap *soap, struct saml2__StatementAbstractType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_saml2__StatementAbstractType(struct soap *soap, const struct saml2__StatementAbstractType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_saml2__StatementAbstractType(struct soap *soap, const char *tag, int id, const struct saml2__StatementAbstractType *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_saml2__StatementAbstractType), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct saml2__StatementAbstractType * SOAP_FMAC4 soap_in_saml2__StatementAbstractType(struct soap *soap, const char *tag, struct saml2__StatementAbstractType *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct saml2__StatementAbstractType*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_saml2__StatementAbstractType, sizeof(struct saml2__StatementAbstractType), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_saml2__StatementAbstractType(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct saml2__StatementAbstractType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_saml2__StatementAbstractType, SOAP_TYPE_saml2__StatementAbstractType, sizeof(struct saml2__StatementAbstractType), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct saml2__StatementAbstractType * SOAP_FMAC4 soap_new_saml2__StatementAbstractType(struct soap *soap, int n)
{
	struct saml2__StatementAbstractType *p;
	struct saml2__StatementAbstractType *a = (struct saml2__StatementAbstractType*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct saml2__StatementAbstractType));
	for (p = a; p && n--; p++)
		soap_default_saml2__StatementAbstractType(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_saml2__StatementAbstractType(struct soap *soap, const struct saml2__StatementAbstractType *a, const char *tag, const char *type)
{
	if (soap_out_saml2__StatementAbstractType(soap, tag ? tag : "saml2:StatementAbstractType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct saml2__StatementAbstractType * SOAP_FMAC4 soap_get_saml2__StatementAbstractType(struct soap *soap, struct saml2__StatementAbstractType *p, const char *tag, const char *type)
{
	if ((p = soap_in_saml2__StatementAbstractType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_saml2__AdviceType(struct soap *soap, struct saml2__AdviceType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__size_AdviceType = 0;
	a->__union_AdviceType = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_saml2__AdviceType(struct soap *soap, const struct saml2__AdviceType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (a->__union_AdviceType)
	{	int i;
		for (i = 0; i < (int)a->__size_AdviceType; i++)
		{
			soap_serialize___saml2__union_AdviceType(soap, a->__union_AdviceType + i);
		}
	}
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_saml2__AdviceType(struct soap *soap, const char *tag, int id, const struct saml2__AdviceType *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_saml2__AdviceType), type))
		return soap->error;
	if (a->__union_AdviceType)
	{	int i;
		for (i = 0; i < (int)a->__size_AdviceType; i++)
			if (soap_out___saml2__union_AdviceType(soap, "-union-AdviceType", -1, a->__union_AdviceType + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct saml2__AdviceType * SOAP_FMAC4 soap_in_saml2__AdviceType(struct soap *soap, const char *tag, struct saml2__AdviceType *a, const char *type)
{
	struct soap_blist *soap_blist___union_AdviceType = NULL;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct saml2__AdviceType*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_saml2__AdviceType, sizeof(struct saml2__AdviceType), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_saml2__AdviceType(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	if (a->__union_AdviceType == NULL)
				{	if (soap_blist___union_AdviceType == NULL)
						soap_blist___union_AdviceType = soap_alloc_block(soap);
					a->__union_AdviceType = (struct __saml2__union_AdviceType *)soap_push_block_max(soap, soap_blist___union_AdviceType, sizeof(struct __saml2__union_AdviceType));
					if (a->__union_AdviceType == NULL)
						return NULL;
					soap_default___saml2__union_AdviceType(soap, a->__union_AdviceType);
				}
				if (soap_in___saml2__union_AdviceType(soap, "-union-AdviceType", a->__union_AdviceType, "-saml2:union-AdviceType"))
				{	a->__size_AdviceType++;
					a->__union_AdviceType = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->__union_AdviceType)
			soap_pop_block(soap, soap_blist___union_AdviceType);
		if (a->__size_AdviceType)
		{	a->__union_AdviceType = (struct __saml2__union_AdviceType *)soap_save_block(soap, soap_blist___union_AdviceType, NULL, 1);
		}
		else
		{	a->__union_AdviceType = NULL;
			if (soap_blist___union_AdviceType)
				soap_end_block(soap, soap_blist___union_AdviceType);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct saml2__AdviceType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_saml2__AdviceType, SOAP_TYPE_saml2__AdviceType, sizeof(struct saml2__AdviceType), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct saml2__AdviceType * SOAP_FMAC4 soap_new_saml2__AdviceType(struct soap *soap, int n)
{
	struct saml2__AdviceType *p;
	struct saml2__AdviceType *a = (struct saml2__AdviceType*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct saml2__AdviceType));
	for (p = a; p && n--; p++)
		soap_default_saml2__AdviceType(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_saml2__AdviceType(struct soap *soap, const struct saml2__AdviceType *a, const char *tag, const char *type)
{
	if (soap_out_saml2__AdviceType(soap, tag ? tag : "saml2:AdviceType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct saml2__AdviceType * SOAP_FMAC4 soap_get_saml2__AdviceType(struct soap *soap, struct saml2__AdviceType *p, const char *tag, const char *type)
{
	if ((p = soap_in_saml2__AdviceType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_saml2__ProxyRestrictionType(struct soap *soap, struct saml2__ProxyRestrictionType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__sizeAudience = 0;
	a->saml2__Audience = NULL;
	soap_default_string(soap, &a->Count);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_saml2__ProxyRestrictionType(struct soap *soap, const struct saml2__ProxyRestrictionType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (a->saml2__Audience)
	{	int i;
		for (i = 0; i < (int)a->__sizeAudience; i++)
		{
			soap_serialize_string(soap, (char*const*)(a->saml2__Audience + i));
		}
	}
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_saml2__ProxyRestrictionType(struct soap *soap, const char *tag, int id, const struct saml2__ProxyRestrictionType *a, const char *type)
{
	if (a->Count)
		soap_set_attr(soap, "Count", soap_string2s(soap, a->Count), 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_saml2__ProxyRestrictionType), type))
		return soap->error;
	if (a->saml2__Audience)
	{	int i;
		for (i = 0; i < (int)a->__sizeAudience; i++)
			if (soap_out_string(soap, "saml2:Audience", -1, (char*const*)(a->saml2__Audience + i), ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct saml2__ProxyRestrictionType * SOAP_FMAC4 soap_in_saml2__ProxyRestrictionType(struct soap *soap, const char *tag, struct saml2__ProxyRestrictionType *a, const char *type)
{
	struct soap_blist *soap_blist_saml2__Audience = NULL;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct saml2__ProxyRestrictionType*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_saml2__ProxyRestrictionType, sizeof(struct saml2__ProxyRestrictionType), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_saml2__ProxyRestrictionType(soap, a);
	if (soap_s2string(soap, soap_attr_value(soap, "Count", 1, 0), &a->Count))
		return NULL;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "saml2:Audience", 1, NULL))
			{	if (a->saml2__Audience == NULL)
				{	if (soap_blist_saml2__Audience == NULL)
						soap_blist_saml2__Audience = soap_alloc_block(soap);
					a->saml2__Audience = (char **)soap_push_block_max(soap, soap_blist_saml2__Audience, sizeof(char *));
					if (a->saml2__Audience == NULL)
						return NULL;
					*a->saml2__Audience = NULL;
				}
				soap_revert(soap);
				if (soap_in_string(soap, "saml2:Audience", (char**)a->saml2__Audience, "xsd:string"))
				{	a->__sizeAudience++;
					a->saml2__Audience = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->saml2__Audience)
			soap_pop_block(soap, soap_blist_saml2__Audience);
		if (a->__sizeAudience)
		{	a->saml2__Audience = (char **)soap_save_block(soap, soap_blist_saml2__Audience, NULL, 1);
		}
		else
		{	a->saml2__Audience = NULL;
			if (soap_blist_saml2__Audience)
				soap_end_block(soap, soap_blist_saml2__Audience);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct saml2__ProxyRestrictionType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_saml2__ProxyRestrictionType, SOAP_TYPE_saml2__ProxyRestrictionType, sizeof(struct saml2__ProxyRestrictionType), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct saml2__ProxyRestrictionType * SOAP_FMAC4 soap_new_saml2__ProxyRestrictionType(struct soap *soap, int n)
{
	struct saml2__ProxyRestrictionType *p;
	struct saml2__ProxyRestrictionType *a = (struct saml2__ProxyRestrictionType*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct saml2__ProxyRestrictionType));
	for (p = a; p && n--; p++)
		soap_default_saml2__ProxyRestrictionType(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_saml2__ProxyRestrictionType(struct soap *soap, const struct saml2__ProxyRestrictionType *a, const char *tag, const char *type)
{
	if (soap_out_saml2__ProxyRestrictionType(soap, tag ? tag : "saml2:ProxyRestrictionType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct saml2__ProxyRestrictionType * SOAP_FMAC4 soap_get_saml2__ProxyRestrictionType(struct soap *soap, struct saml2__ProxyRestrictionType *p, const char *tag, const char *type)
{
	if ((p = soap_in_saml2__ProxyRestrictionType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_saml2__OneTimeUseType(struct soap *soap, struct saml2__OneTimeUseType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_saml2__OneTimeUseType(struct soap *soap, const struct saml2__OneTimeUseType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_saml2__OneTimeUseType(struct soap *soap, const char *tag, int id, const struct saml2__OneTimeUseType *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_saml2__OneTimeUseType), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct saml2__OneTimeUseType * SOAP_FMAC4 soap_in_saml2__OneTimeUseType(struct soap *soap, const char *tag, struct saml2__OneTimeUseType *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct saml2__OneTimeUseType*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_saml2__OneTimeUseType, sizeof(struct saml2__OneTimeUseType), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_saml2__OneTimeUseType(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct saml2__OneTimeUseType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_saml2__OneTimeUseType, SOAP_TYPE_saml2__OneTimeUseType, sizeof(struct saml2__OneTimeUseType), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct saml2__OneTimeUseType * SOAP_FMAC4 soap_new_saml2__OneTimeUseType(struct soap *soap, int n)
{
	struct saml2__OneTimeUseType *p;
	struct saml2__OneTimeUseType *a = (struct saml2__OneTimeUseType*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct saml2__OneTimeUseType));
	for (p = a; p && n--; p++)
		soap_default_saml2__OneTimeUseType(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_saml2__OneTimeUseType(struct soap *soap, const struct saml2__OneTimeUseType *a, const char *tag, const char *type)
{
	if (soap_out_saml2__OneTimeUseType(soap, tag ? tag : "saml2:OneTimeUseType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct saml2__OneTimeUseType * SOAP_FMAC4 soap_get_saml2__OneTimeUseType(struct soap *soap, struct saml2__OneTimeUseType *p, const char *tag, const char *type)
{
	if ((p = soap_in_saml2__OneTimeUseType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_saml2__AudienceRestrictionType(struct soap *soap, struct saml2__AudienceRestrictionType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__sizeAudience = 0;
	a->saml2__Audience = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_saml2__AudienceRestrictionType(struct soap *soap, const struct saml2__AudienceRestrictionType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (a->saml2__Audience)
	{	int i;
		for (i = 0; i < (int)a->__sizeAudience; i++)
		{
			soap_serialize_string(soap, (char*const*)(a->saml2__Audience + i));
		}
	}
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_saml2__AudienceRestrictionType(struct soap *soap, const char *tag, int id, const struct saml2__AudienceRestrictionType *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_saml2__AudienceRestrictionType), type))
		return soap->error;
	if (a->saml2__Audience)
	{	int i;
		for (i = 0; i < (int)a->__sizeAudience; i++)
			if (soap_out_string(soap, "saml2:Audience", -1, (char*const*)(a->saml2__Audience + i), ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct saml2__AudienceRestrictionType * SOAP_FMAC4 soap_in_saml2__AudienceRestrictionType(struct soap *soap, const char *tag, struct saml2__AudienceRestrictionType *a, const char *type)
{
	struct soap_blist *soap_blist_saml2__Audience = NULL;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct saml2__AudienceRestrictionType*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_saml2__AudienceRestrictionType, sizeof(struct saml2__AudienceRestrictionType), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_saml2__AudienceRestrictionType(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "saml2:Audience", 1, NULL))
			{	if (a->saml2__Audience == NULL)
				{	if (soap_blist_saml2__Audience == NULL)
						soap_blist_saml2__Audience = soap_alloc_block(soap);
					a->saml2__Audience = (char **)soap_push_block_max(soap, soap_blist_saml2__Audience, sizeof(char *));
					if (a->saml2__Audience == NULL)
						return NULL;
					*a->saml2__Audience = NULL;
				}
				soap_revert(soap);
				if (soap_in_string(soap, "saml2:Audience", (char**)a->saml2__Audience, "xsd:string"))
				{	a->__sizeAudience++;
					a->saml2__Audience = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->saml2__Audience)
			soap_pop_block(soap, soap_blist_saml2__Audience);
		if (a->__sizeAudience)
		{	a->saml2__Audience = (char **)soap_save_block(soap, soap_blist_saml2__Audience, NULL, 1);
		}
		else
		{	a->saml2__Audience = NULL;
			if (soap_blist_saml2__Audience)
				soap_end_block(soap, soap_blist_saml2__Audience);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (a->__sizeAudience < 1))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct saml2__AudienceRestrictionType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_saml2__AudienceRestrictionType, SOAP_TYPE_saml2__AudienceRestrictionType, sizeof(struct saml2__AudienceRestrictionType), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct saml2__AudienceRestrictionType * SOAP_FMAC4 soap_new_saml2__AudienceRestrictionType(struct soap *soap, int n)
{
	struct saml2__AudienceRestrictionType *p;
	struct saml2__AudienceRestrictionType *a = (struct saml2__AudienceRestrictionType*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct saml2__AudienceRestrictionType));
	for (p = a; p && n--; p++)
		soap_default_saml2__AudienceRestrictionType(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_saml2__AudienceRestrictionType(struct soap *soap, const struct saml2__AudienceRestrictionType *a, const char *tag, const char *type)
{
	if (soap_out_saml2__AudienceRestrictionType(soap, tag ? tag : "saml2:AudienceRestrictionType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct saml2__AudienceRestrictionType * SOAP_FMAC4 soap_get_saml2__AudienceRestrictionType(struct soap *soap, struct saml2__AudienceRestrictionType *p, const char *tag, const char *type)
{
	if ((p = soap_in_saml2__AudienceRestrictionType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_saml2__ConditionAbstractType(struct soap *soap, struct saml2__ConditionAbstractType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_saml2__ConditionAbstractType(struct soap *soap, const struct saml2__ConditionAbstractType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_saml2__ConditionAbstractType(struct soap *soap, const char *tag, int id, const struct saml2__ConditionAbstractType *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_saml2__ConditionAbstractType), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct saml2__ConditionAbstractType * SOAP_FMAC4 soap_in_saml2__ConditionAbstractType(struct soap *soap, const char *tag, struct saml2__ConditionAbstractType *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct saml2__ConditionAbstractType*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_saml2__ConditionAbstractType, sizeof(struct saml2__ConditionAbstractType), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_saml2__ConditionAbstractType(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct saml2__ConditionAbstractType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_saml2__ConditionAbstractType, SOAP_TYPE_saml2__ConditionAbstractType, sizeof(struct saml2__ConditionAbstractType), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct saml2__ConditionAbstractType * SOAP_FMAC4 soap_new_saml2__ConditionAbstractType(struct soap *soap, int n)
{
	struct saml2__ConditionAbstractType *p;
	struct saml2__ConditionAbstractType *a = (struct saml2__ConditionAbstractType*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct saml2__ConditionAbstractType));
	for (p = a; p && n--; p++)
		soap_default_saml2__ConditionAbstractType(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_saml2__ConditionAbstractType(struct soap *soap, const struct saml2__ConditionAbstractType *a, const char *tag, const char *type)
{
	if (soap_out_saml2__ConditionAbstractType(soap, tag ? tag : "saml2:ConditionAbstractType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct saml2__ConditionAbstractType * SOAP_FMAC4 soap_get_saml2__ConditionAbstractType(struct soap *soap, struct saml2__ConditionAbstractType *p, const char *tag, const char *type)
{
	if ((p = soap_in_saml2__ConditionAbstractType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_saml2__ConditionsType(struct soap *soap, struct saml2__ConditionsType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__size_ConditionsType = 0;
	a->__union_ConditionsType = NULL;
	a->NotBefore = NULL;
	a->NotOnOrAfter = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_saml2__ConditionsType(struct soap *soap, const struct saml2__ConditionsType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (a->__union_ConditionsType)
	{	int i;
		for (i = 0; i < (int)a->__size_ConditionsType; i++)
		{
			soap_serialize___saml2__union_ConditionsType(soap, a->__union_ConditionsType + i);
		}
	}
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_saml2__ConditionsType(struct soap *soap, const char *tag, int id, const struct saml2__ConditionsType *a, const char *type)
{
	if (a->NotBefore)
	{	soap_set_attr(soap, "NotBefore", soap_xsd__dateTime2s(soap, *a->NotBefore), 1);
	}
	if (a->NotOnOrAfter)
	{	soap_set_attr(soap, "NotOnOrAfter", soap_xsd__dateTime2s(soap, *a->NotOnOrAfter), 1);
	}
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_saml2__ConditionsType), type))
		return soap->error;
	if (a->__union_ConditionsType)
	{	int i;
		for (i = 0; i < (int)a->__size_ConditionsType; i++)
			if (soap_out___saml2__union_ConditionsType(soap, "-union-ConditionsType", -1, a->__union_ConditionsType + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct saml2__ConditionsType * SOAP_FMAC4 soap_in_saml2__ConditionsType(struct soap *soap, const char *tag, struct saml2__ConditionsType *a, const char *type)
{
	struct soap_blist *soap_blist___union_ConditionsType = NULL;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct saml2__ConditionsType*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_saml2__ConditionsType, sizeof(struct saml2__ConditionsType), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_saml2__ConditionsType(soap, a);
	{
		const char *t = soap_attr_value(soap, "NotBefore", 5, 0);
		if (t)
		{
			if (!(a->NotBefore = (struct timeval *)soap_malloc(soap, sizeof(struct timeval))))
				return NULL;
			if (soap_s2xsd__dateTime(soap, t, a->NotBefore))
				return NULL;
		}
		else if (soap->error)
			return NULL;
	}
	{
		const char *t = soap_attr_value(soap, "NotOnOrAfter", 5, 0);
		if (t)
		{
			if (!(a->NotOnOrAfter = (struct timeval *)soap_malloc(soap, sizeof(struct timeval))))
				return NULL;
			if (soap_s2xsd__dateTime(soap, t, a->NotOnOrAfter))
				return NULL;
		}
		else if (soap->error)
			return NULL;
	}
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	if (a->__union_ConditionsType == NULL)
				{	if (soap_blist___union_ConditionsType == NULL)
						soap_blist___union_ConditionsType = soap_alloc_block(soap);
					a->__union_ConditionsType = (struct __saml2__union_ConditionsType *)soap_push_block_max(soap, soap_blist___union_ConditionsType, sizeof(struct __saml2__union_ConditionsType));
					if (a->__union_ConditionsType == NULL)
						return NULL;
					soap_default___saml2__union_ConditionsType(soap, a->__union_ConditionsType);
				}
				if (soap_in___saml2__union_ConditionsType(soap, "-union-ConditionsType", a->__union_ConditionsType, "-saml2:union-ConditionsType"))
				{	a->__size_ConditionsType++;
					a->__union_ConditionsType = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->__union_ConditionsType)
			soap_pop_block(soap, soap_blist___union_ConditionsType);
		if (a->__size_ConditionsType)
		{	a->__union_ConditionsType = (struct __saml2__union_ConditionsType *)soap_save_block(soap, soap_blist___union_ConditionsType, NULL, 1);
		}
		else
		{	a->__union_ConditionsType = NULL;
			if (soap_blist___union_ConditionsType)
				soap_end_block(soap, soap_blist___union_ConditionsType);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct saml2__ConditionsType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_saml2__ConditionsType, SOAP_TYPE_saml2__ConditionsType, sizeof(struct saml2__ConditionsType), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct saml2__ConditionsType * SOAP_FMAC4 soap_new_saml2__ConditionsType(struct soap *soap, int n)
{
	struct saml2__ConditionsType *p;
	struct saml2__ConditionsType *a = (struct saml2__ConditionsType*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct saml2__ConditionsType));
	for (p = a; p && n--; p++)
		soap_default_saml2__ConditionsType(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_saml2__ConditionsType(struct soap *soap, const struct saml2__ConditionsType *a, const char *tag, const char *type)
{
	if (soap_out_saml2__ConditionsType(soap, tag ? tag : "saml2:ConditionsType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct saml2__ConditionsType * SOAP_FMAC4 soap_get_saml2__ConditionsType(struct soap *soap, struct saml2__ConditionsType *p, const char *tag, const char *type)
{
	if ((p = soap_in_saml2__ConditionsType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_saml2__KeyInfoConfirmationDataType(struct soap *soap, struct saml2__KeyInfoConfirmationDataType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__sizeds__KeyInfo = 0;
	a->ds__KeyInfo = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_saml2__KeyInfoConfirmationDataType(struct soap *soap, const struct saml2__KeyInfoConfirmationDataType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (a->ds__KeyInfo)
	{	int i;
		for (i = 0; i < (int)a->__sizeds__KeyInfo; i++)
		{
			soap_serialize_PointerTo_ds__KeyInfo(soap, a->ds__KeyInfo + i);
		}
	}
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_saml2__KeyInfoConfirmationDataType(struct soap *soap, const char *tag, int id, const struct saml2__KeyInfoConfirmationDataType *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_saml2__KeyInfoConfirmationDataType), type))
		return soap->error;
	if (a->ds__KeyInfo)
	{	int i;
		for (i = 0; i < (int)a->__sizeds__KeyInfo; i++)
			if (soap_out_PointerTo_ds__KeyInfo(soap, "ds:KeyInfo", -1, a->ds__KeyInfo + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct saml2__KeyInfoConfirmationDataType * SOAP_FMAC4 soap_in_saml2__KeyInfoConfirmationDataType(struct soap *soap, const char *tag, struct saml2__KeyInfoConfirmationDataType *a, const char *type)
{
	struct soap_blist *soap_blist_ds__KeyInfo = NULL;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct saml2__KeyInfoConfirmationDataType*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_saml2__KeyInfoConfirmationDataType, sizeof(struct saml2__KeyInfoConfirmationDataType), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_saml2__KeyInfoConfirmationDataType(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "ds:KeyInfo", 1, NULL))
			{	if (a->ds__KeyInfo == NULL)
				{	if (soap_blist_ds__KeyInfo == NULL)
						soap_blist_ds__KeyInfo = soap_alloc_block(soap);
					a->ds__KeyInfo = (struct ds__KeyInfoType **)soap_push_block_max(soap, soap_blist_ds__KeyInfo, sizeof(struct ds__KeyInfoType *));
					if (a->ds__KeyInfo == NULL)
						return NULL;
					*a->ds__KeyInfo = NULL;
				}
				soap_revert(soap);
				if (soap_in_PointerTo_ds__KeyInfo(soap, "ds:KeyInfo", a->ds__KeyInfo, ""))
				{	a->__sizeds__KeyInfo++;
					a->ds__KeyInfo = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->ds__KeyInfo)
			soap_pop_block(soap, soap_blist_ds__KeyInfo);
		if (a->__sizeds__KeyInfo)
		{	a->ds__KeyInfo = (struct ds__KeyInfoType **)soap_save_block(soap, soap_blist_ds__KeyInfo, NULL, 1);
		}
		else
		{	a->ds__KeyInfo = NULL;
			if (soap_blist_ds__KeyInfo)
				soap_end_block(soap, soap_blist_ds__KeyInfo);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (a->__sizeds__KeyInfo < 1))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct saml2__KeyInfoConfirmationDataType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_saml2__KeyInfoConfirmationDataType, SOAP_TYPE_saml2__KeyInfoConfirmationDataType, sizeof(struct saml2__KeyInfoConfirmationDataType), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct saml2__KeyInfoConfirmationDataType * SOAP_FMAC4 soap_new_saml2__KeyInfoConfirmationDataType(struct soap *soap, int n)
{
	struct saml2__KeyInfoConfirmationDataType *p;
	struct saml2__KeyInfoConfirmationDataType *a = (struct saml2__KeyInfoConfirmationDataType*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct saml2__KeyInfoConfirmationDataType));
	for (p = a; p && n--; p++)
		soap_default_saml2__KeyInfoConfirmationDataType(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_saml2__KeyInfoConfirmationDataType(struct soap *soap, const struct saml2__KeyInfoConfirmationDataType *a, const char *tag, const char *type)
{
	if (soap_out_saml2__KeyInfoConfirmationDataType(soap, tag ? tag : "saml2:KeyInfoConfirmationDataType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct saml2__KeyInfoConfirmationDataType * SOAP_FMAC4 soap_get_saml2__KeyInfoConfirmationDataType(struct soap *soap, struct saml2__KeyInfoConfirmationDataType *p, const char *tag, const char *type)
{
	if ((p = soap_in_saml2__KeyInfoConfirmationDataType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_saml2__SubjectConfirmationDataType(struct soap *soap, struct saml2__SubjectConfirmationDataType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->NotBefore = NULL;
	a->NotOnOrAfter = NULL;
	soap_default_string(soap, &a->Recipient);
	soap_default_string(soap, &a->InResponseTo);
	soap_default_string(soap, &a->Address);
	a->__mixed = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_saml2__SubjectConfirmationDataType(struct soap *soap, const struct saml2__SubjectConfirmationDataType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_saml2__SubjectConfirmationDataType(struct soap *soap, const char *tag, int id, const struct saml2__SubjectConfirmationDataType *a, const char *type)
{
	if (a->NotBefore)
	{	soap_set_attr(soap, "NotBefore", soap_xsd__dateTime2s(soap, *a->NotBefore), 1);
	}
	if (a->NotOnOrAfter)
	{	soap_set_attr(soap, "NotOnOrAfter", soap_xsd__dateTime2s(soap, *a->NotOnOrAfter), 1);
	}
	if (a->Recipient)
		soap_set_attr(soap, "Recipient", soap_string2s(soap, a->Recipient), 1);
	if (a->InResponseTo)
		soap_set_attr(soap, "InResponseTo", soap_string2s(soap, a->InResponseTo), 1);
	if (a->Address)
		soap_set_attr(soap, "Address", soap_string2s(soap, a->Address), 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_saml2__SubjectConfirmationDataType), type))
		return soap->error;
	if (soap_outliteral(soap, "-mixed", (char*const*)&a->__mixed, NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct saml2__SubjectConfirmationDataType * SOAP_FMAC4 soap_in_saml2__SubjectConfirmationDataType(struct soap *soap, const char *tag, struct saml2__SubjectConfirmationDataType *a, const char *type)
{
	size_t soap_flag___mixed = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct saml2__SubjectConfirmationDataType*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_saml2__SubjectConfirmationDataType, sizeof(struct saml2__SubjectConfirmationDataType), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_saml2__SubjectConfirmationDataType(soap, a);
	{
		const char *t = soap_attr_value(soap, "NotBefore", 5, 0);
		if (t)
		{
			if (!(a->NotBefore = (struct timeval *)soap_malloc(soap, sizeof(struct timeval))))
				return NULL;
			if (soap_s2xsd__dateTime(soap, t, a->NotBefore))
				return NULL;
		}
		else if (soap->error)
			return NULL;
	}
	{
		const char *t = soap_attr_value(soap, "NotOnOrAfter", 5, 0);
		if (t)
		{
			if (!(a->NotOnOrAfter = (struct timeval *)soap_malloc(soap, sizeof(struct timeval))))
				return NULL;
			if (soap_s2xsd__dateTime(soap, t, a->NotOnOrAfter))
				return NULL;
		}
		else if (soap->error)
			return NULL;
	}
	if (soap_s2string(soap, soap_attr_value(soap, "Recipient", 1, 0), &a->Recipient))
		return NULL;
	if (soap_s2string(soap, soap_attr_value(soap, "InResponseTo", 1, 0), &a->InResponseTo))
		return NULL;
	if (soap_s2string(soap, soap_attr_value(soap, "Address", 1, 0), &a->Address))
		return NULL;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag___mixed && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_inliteral(soap, "-mixed", (char**)&a->__mixed))
				{	soap_flag___mixed--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct saml2__SubjectConfirmationDataType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_saml2__SubjectConfirmationDataType, SOAP_TYPE_saml2__SubjectConfirmationDataType, sizeof(struct saml2__SubjectConfirmationDataType), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct saml2__SubjectConfirmationDataType * SOAP_FMAC4 soap_new_saml2__SubjectConfirmationDataType(struct soap *soap, int n)
{
	struct saml2__SubjectConfirmationDataType *p;
	struct saml2__SubjectConfirmationDataType *a = (struct saml2__SubjectConfirmationDataType*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct saml2__SubjectConfirmationDataType));
	for (p = a; p && n--; p++)
		soap_default_saml2__SubjectConfirmationDataType(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_saml2__SubjectConfirmationDataType(struct soap *soap, const struct saml2__SubjectConfirmationDataType *a, const char *tag, const char *type)
{
	if (soap_out_saml2__SubjectConfirmationDataType(soap, tag ? tag : "saml2:SubjectConfirmationDataType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct saml2__SubjectConfirmationDataType * SOAP_FMAC4 soap_get_saml2__SubjectConfirmationDataType(struct soap *soap, struct saml2__SubjectConfirmationDataType *p, const char *tag, const char *type)
{
	if ((p = soap_in_saml2__SubjectConfirmationDataType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_saml2__SubjectConfirmationType(struct soap *soap, struct saml2__SubjectConfirmationType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->saml2__BaseID = NULL;
	a->saml2__NameID = NULL;
	a->saml2__EncryptedID = NULL;
	a->saml2__SubjectConfirmationData = NULL;
	soap_default_string(soap, &a->Method);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_saml2__SubjectConfirmationType(struct soap *soap, const struct saml2__SubjectConfirmationType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTosaml2__BaseIDAbstractType(soap, &a->saml2__BaseID);
	soap_serialize_PointerTosaml2__NameIDType(soap, &a->saml2__NameID);
	soap_serialize_PointerTosaml2__EncryptedElementType(soap, &a->saml2__EncryptedID);
	soap_serialize_PointerTosaml2__SubjectConfirmationDataType(soap, &a->saml2__SubjectConfirmationData);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_saml2__SubjectConfirmationType(struct soap *soap, const char *tag, int id, const struct saml2__SubjectConfirmationType *a, const char *type)
{
	soap_set_attr(soap, "Method", a->Method ? soap_string2s(soap, a->Method) : "", 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_saml2__SubjectConfirmationType), type))
		return soap->error;
	if (soap_out_PointerTosaml2__BaseIDAbstractType(soap, "saml2:BaseID", -1, &a->saml2__BaseID, ""))
		return soap->error;
	if (soap_out_PointerTosaml2__NameIDType(soap, "saml2:NameID", -1, &a->saml2__NameID, ""))
		return soap->error;
	if (soap_out_PointerTosaml2__EncryptedElementType(soap, "saml2:EncryptedID", -1, &a->saml2__EncryptedID, ""))
		return soap->error;
	if (soap_out_PointerTosaml2__SubjectConfirmationDataType(soap, "saml2:SubjectConfirmationData", -1, &a->saml2__SubjectConfirmationData, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct saml2__SubjectConfirmationType * SOAP_FMAC4 soap_in_saml2__SubjectConfirmationType(struct soap *soap, const char *tag, struct saml2__SubjectConfirmationType *a, const char *type)
{
	size_t soap_flag_saml2__BaseID = 1;
	size_t soap_flag_saml2__NameID = 1;
	size_t soap_flag_saml2__EncryptedID = 1;
	size_t soap_flag_saml2__SubjectConfirmationData = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct saml2__SubjectConfirmationType*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_saml2__SubjectConfirmationType, sizeof(struct saml2__SubjectConfirmationType), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_saml2__SubjectConfirmationType(soap, a);
	if (soap_s2string(soap, soap_attr_value(soap, "Method", 1, 1), &a->Method))
		return NULL;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_saml2__BaseID && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTosaml2__BaseIDAbstractType(soap, "saml2:BaseID", &a->saml2__BaseID, "saml2:BaseIDAbstractType"))
				{	soap_flag_saml2__BaseID--;
					continue;
				}
			}
			if (soap_flag_saml2__NameID && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTosaml2__NameIDType(soap, "saml2:NameID", &a->saml2__NameID, "saml2:NameIDType"))
				{	soap_flag_saml2__NameID--;
					continue;
				}
			}
			if (soap_flag_saml2__EncryptedID && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTosaml2__EncryptedElementType(soap, "saml2:EncryptedID", &a->saml2__EncryptedID, "saml2:EncryptedElementType"))
				{	soap_flag_saml2__EncryptedID--;
					continue;
				}
			}
			if (soap_flag_saml2__SubjectConfirmationData && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTosaml2__SubjectConfirmationDataType(soap, "saml2:SubjectConfirmationData", &a->saml2__SubjectConfirmationData, "saml2:SubjectConfirmationDataType"))
				{	soap_flag_saml2__SubjectConfirmationData--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct saml2__SubjectConfirmationType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_saml2__SubjectConfirmationType, SOAP_TYPE_saml2__SubjectConfirmationType, sizeof(struct saml2__SubjectConfirmationType), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct saml2__SubjectConfirmationType * SOAP_FMAC4 soap_new_saml2__SubjectConfirmationType(struct soap *soap, int n)
{
	struct saml2__SubjectConfirmationType *p;
	struct saml2__SubjectConfirmationType *a = (struct saml2__SubjectConfirmationType*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct saml2__SubjectConfirmationType));
	for (p = a; p && n--; p++)
		soap_default_saml2__SubjectConfirmationType(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_saml2__SubjectConfirmationType(struct soap *soap, const struct saml2__SubjectConfirmationType *a, const char *tag, const char *type)
{
	if (soap_out_saml2__SubjectConfirmationType(soap, tag ? tag : "saml2:SubjectConfirmationType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct saml2__SubjectConfirmationType * SOAP_FMAC4 soap_get_saml2__SubjectConfirmationType(struct soap *soap, struct saml2__SubjectConfirmationType *p, const char *tag, const char *type)
{
	if ((p = soap_in_saml2__SubjectConfirmationType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_saml2__SubjectType(struct soap *soap, struct saml2__SubjectType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->saml2__BaseID = NULL;
	a->saml2__NameID = NULL;
	a->saml2__EncryptedID = NULL;
	a->__sizeSubjectConfirmation = 0;
	a->saml2__SubjectConfirmation = NULL;
	a->__sizeSubjectConfirmation_ = 0;
	a->saml2__SubjectConfirmation_ = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_saml2__SubjectType(struct soap *soap, const struct saml2__SubjectType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTosaml2__BaseIDAbstractType(soap, &a->saml2__BaseID);
	soap_serialize_PointerTosaml2__NameIDType(soap, &a->saml2__NameID);
	soap_serialize_PointerTosaml2__EncryptedElementType(soap, &a->saml2__EncryptedID);
	if (a->saml2__SubjectConfirmation)
	{	int i;
		for (i = 0; i < (int)a->__sizeSubjectConfirmation; i++)
		{
			soap_embedded(soap, a->saml2__SubjectConfirmation + i, SOAP_TYPE_saml2__SubjectConfirmationType);
			soap_serialize_saml2__SubjectConfirmationType(soap, a->saml2__SubjectConfirmation + i);
		}
	}
	if (a->saml2__SubjectConfirmation_)
	{	int i;
		for (i = 0; i < (int)a->__sizeSubjectConfirmation_; i++)
		{
			soap_embedded(soap, a->saml2__SubjectConfirmation_ + i, SOAP_TYPE_saml2__SubjectConfirmationType);
			soap_serialize_saml2__SubjectConfirmationType(soap, a->saml2__SubjectConfirmation_ + i);
		}
	}
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_saml2__SubjectType(struct soap *soap, const char *tag, int id, const struct saml2__SubjectType *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_saml2__SubjectType), type))
		return soap->error;
	if (soap_out_PointerTosaml2__BaseIDAbstractType(soap, "saml2:BaseID", -1, &a->saml2__BaseID, ""))
		return soap->error;
	if (soap_out_PointerTosaml2__NameIDType(soap, "saml2:NameID", -1, &a->saml2__NameID, ""))
		return soap->error;
	if (soap_out_PointerTosaml2__EncryptedElementType(soap, "saml2:EncryptedID", -1, &a->saml2__EncryptedID, ""))
		return soap->error;
	if (a->saml2__SubjectConfirmation)
	{	int i;
		for (i = 0; i < (int)a->__sizeSubjectConfirmation; i++)
			if (soap_out_saml2__SubjectConfirmationType(soap, "saml2:SubjectConfirmation", -1, a->saml2__SubjectConfirmation + i, ""))
				return soap->error;
	}
	if (a->saml2__SubjectConfirmation_)
	{	int i;
		for (i = 0; i < (int)a->__sizeSubjectConfirmation_; i++)
			if (soap_out_saml2__SubjectConfirmationType(soap, "saml2:SubjectConfirmation", -1, a->saml2__SubjectConfirmation_ + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct saml2__SubjectType * SOAP_FMAC4 soap_in_saml2__SubjectType(struct soap *soap, const char *tag, struct saml2__SubjectType *a, const char *type)
{
	size_t soap_flag_saml2__BaseID = 1;
	size_t soap_flag_saml2__NameID = 1;
	size_t soap_flag_saml2__EncryptedID = 1;
	struct soap_blist *soap_blist_saml2__SubjectConfirmation = NULL;
	struct soap_blist *soap_blist_saml2__SubjectConfirmation_ = NULL;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct saml2__SubjectType*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_saml2__SubjectType, sizeof(struct saml2__SubjectType), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_saml2__SubjectType(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_saml2__BaseID && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTosaml2__BaseIDAbstractType(soap, "saml2:BaseID", &a->saml2__BaseID, "saml2:BaseIDAbstractType"))
				{	soap_flag_saml2__BaseID--;
					continue;
				}
			}
			if (soap_flag_saml2__NameID && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTosaml2__NameIDType(soap, "saml2:NameID", &a->saml2__NameID, "saml2:NameIDType"))
				{	soap_flag_saml2__NameID--;
					continue;
				}
			}
			if (soap_flag_saml2__EncryptedID && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTosaml2__EncryptedElementType(soap, "saml2:EncryptedID", &a->saml2__EncryptedID, "saml2:EncryptedElementType"))
				{	soap_flag_saml2__EncryptedID--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "saml2:SubjectConfirmation", 1, NULL))
			{	if (a->saml2__SubjectConfirmation == NULL)
				{	if (soap_blist_saml2__SubjectConfirmation == NULL)
						soap_blist_saml2__SubjectConfirmation = soap_alloc_block(soap);
					a->saml2__SubjectConfirmation = (struct saml2__SubjectConfirmationType *)soap_push_block_max(soap, soap_blist_saml2__SubjectConfirmation, sizeof(struct saml2__SubjectConfirmationType));
					if (a->saml2__SubjectConfirmation == NULL)
						return NULL;
					soap_default_saml2__SubjectConfirmationType(soap, a->saml2__SubjectConfirmation);
				}
				soap_revert(soap);
				if (soap_in_saml2__SubjectConfirmationType(soap, "saml2:SubjectConfirmation", a->saml2__SubjectConfirmation, "saml2:SubjectConfirmationType"))
				{	a->__sizeSubjectConfirmation++;
					a->saml2__SubjectConfirmation = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "saml2:SubjectConfirmation", 1, NULL))
			{	if (a->saml2__SubjectConfirmation_ == NULL)
				{	if (soap_blist_saml2__SubjectConfirmation_ == NULL)
						soap_blist_saml2__SubjectConfirmation_ = soap_alloc_block(soap);
					a->saml2__SubjectConfirmation_ = (struct saml2__SubjectConfirmationType *)soap_push_block_max(soap, soap_blist_saml2__SubjectConfirmation_, sizeof(struct saml2__SubjectConfirmationType));
					if (a->saml2__SubjectConfirmation_ == NULL)
						return NULL;
					soap_default_saml2__SubjectConfirmationType(soap, a->saml2__SubjectConfirmation_);
				}
				soap_revert(soap);
				if (soap_in_saml2__SubjectConfirmationType(soap, "saml2:SubjectConfirmation", a->saml2__SubjectConfirmation_, "saml2:SubjectConfirmationType"))
				{	a->__sizeSubjectConfirmation_++;
					a->saml2__SubjectConfirmation_ = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->saml2__SubjectConfirmation)
			soap_pop_block(soap, soap_blist_saml2__SubjectConfirmation);
		if (a->__sizeSubjectConfirmation)
		{	a->saml2__SubjectConfirmation = (struct saml2__SubjectConfirmationType *)soap_save_block(soap, soap_blist_saml2__SubjectConfirmation, NULL, 1);
		}
		else
		{	a->saml2__SubjectConfirmation = NULL;
			if (soap_blist_saml2__SubjectConfirmation)
				soap_end_block(soap, soap_blist_saml2__SubjectConfirmation);
		}
		if (a->saml2__SubjectConfirmation_)
			soap_pop_block(soap, soap_blist_saml2__SubjectConfirmation_);
		if (a->__sizeSubjectConfirmation_)
		{	a->saml2__SubjectConfirmation_ = (struct saml2__SubjectConfirmationType *)soap_save_block(soap, soap_blist_saml2__SubjectConfirmation_, NULL, 1);
		}
		else
		{	a->saml2__SubjectConfirmation_ = NULL;
			if (soap_blist_saml2__SubjectConfirmation_)
				soap_end_block(soap, soap_blist_saml2__SubjectConfirmation_);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct saml2__SubjectType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_saml2__SubjectType, SOAP_TYPE_saml2__SubjectType, sizeof(struct saml2__SubjectType), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct saml2__SubjectType * SOAP_FMAC4 soap_new_saml2__SubjectType(struct soap *soap, int n)
{
	struct saml2__SubjectType *p;
	struct saml2__SubjectType *a = (struct saml2__SubjectType*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct saml2__SubjectType));
	for (p = a; p && n--; p++)
		soap_default_saml2__SubjectType(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_saml2__SubjectType(struct soap *soap, const struct saml2__SubjectType *a, const char *tag, const char *type)
{
	if (soap_out_saml2__SubjectType(soap, tag ? tag : "saml2:SubjectType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct saml2__SubjectType * SOAP_FMAC4 soap_get_saml2__SubjectType(struct soap *soap, struct saml2__SubjectType *p, const char *tag, const char *type)
{
	if ((p = soap_in_saml2__SubjectType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_saml2__AssertionType(struct soap *soap, struct saml2__AssertionType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->saml2__Issuer = NULL;
	a->ds__Signature = NULL;
	a->saml2__Subject = NULL;
	a->saml2__Conditions = NULL;
	a->saml2__Advice = NULL;
	a->__size_AssertionType = 0;
	a->__union_AssertionType = NULL;
	soap_default_string(soap, &a->Version);
	soap_default_string(soap, &a->ID);
	soap_default_xsd__dateTime(soap, &a->IssueInstant);
	soap_default_string(soap, &a->wsu__Id);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_saml2__AssertionType(struct soap *soap, const struct saml2__AssertionType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTosaml2__NameIDType(soap, &a->saml2__Issuer);
	soap_serialize_PointerTo_ds__Signature(soap, &a->ds__Signature);
	soap_serialize_PointerTosaml2__SubjectType(soap, &a->saml2__Subject);
	soap_serialize_PointerTosaml2__ConditionsType(soap, &a->saml2__Conditions);
	soap_serialize_PointerTosaml2__AdviceType(soap, &a->saml2__Advice);
	if (a->__union_AssertionType)
	{	int i;
		for (i = 0; i < (int)a->__size_AssertionType; i++)
		{
			soap_serialize___saml2__union_AssertionType(soap, a->__union_AssertionType + i);
		}
	}
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_saml2__AssertionType(struct soap *soap, const char *tag, int id, const struct saml2__AssertionType *a, const char *type)
{
	soap_set_attr(soap, "Version", a->Version ? soap_string2s(soap, a->Version) : "", 1);
	soap_set_attr(soap, "ID", a->ID ? soap_string2s(soap, a->ID) : "", 1);
	soap_set_attr(soap, "IssueInstant", soap_xsd__dateTime2s(soap, a->IssueInstant), 1);
	if (a->wsu__Id)
		soap_set_attr(soap, "wsu:Id", soap_string2s(soap, a->wsu__Id), 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_saml2__AssertionType), type))
		return soap->error;
	if (!a->saml2__Issuer)
	{	if (soap_element_empty(soap, "saml2:Issuer", 0, NULL))
			return soap->error;
	}
	else if (soap_out_PointerTosaml2__NameIDType(soap, "saml2:Issuer", -1, &a->saml2__Issuer, ""))
		return soap->error;
	if (soap_out_PointerTo_ds__Signature(soap, "ds:Signature", -1, &a->ds__Signature, ""))
		return soap->error;
	if (soap_out_PointerTosaml2__SubjectType(soap, "saml2:Subject", -1, &a->saml2__Subject, ""))
		return soap->error;
	if (soap_out_PointerTosaml2__ConditionsType(soap, "saml2:Conditions", -1, &a->saml2__Conditions, ""))
		return soap->error;
	if (soap_out_PointerTosaml2__AdviceType(soap, "saml2:Advice", -1, &a->saml2__Advice, ""))
		return soap->error;
	if (a->__union_AssertionType)
	{	int i;
		for (i = 0; i < (int)a->__size_AssertionType; i++)
			if (soap_out___saml2__union_AssertionType(soap, "-union-AssertionType", -1, a->__union_AssertionType + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct saml2__AssertionType * SOAP_FMAC4 soap_in_saml2__AssertionType(struct soap *soap, const char *tag, struct saml2__AssertionType *a, const char *type)
{
	size_t soap_flag_saml2__Issuer = 1;
	size_t soap_flag_ds__Signature = 1;
	size_t soap_flag_saml2__Subject = 1;
	size_t soap_flag_saml2__Conditions = 1;
	size_t soap_flag_saml2__Advice = 1;
	struct soap_blist *soap_blist___union_AssertionType = NULL;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct saml2__AssertionType*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_saml2__AssertionType, sizeof(struct saml2__AssertionType), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_saml2__AssertionType(soap, a);
	if (soap_s2string(soap, soap_attr_value(soap, "Version", 1, 1), &a->Version))
		return NULL;
	if (soap_s2string(soap, soap_attr_value(soap, "ID", 1, 1), &a->ID))
		return NULL;
	if (soap_s2xsd__dateTime(soap, soap_attr_value(soap, "IssueInstant", 5, 1), &a->IssueInstant))
		return NULL;
	if (soap_s2string(soap, soap_attr_value(soap, "wsu:Id", 1, 0), &a->wsu__Id))
		return NULL;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_saml2__Issuer && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTosaml2__NameIDType(soap, "saml2:Issuer", &a->saml2__Issuer, "saml2:NameIDType"))
				{	soap_flag_saml2__Issuer--;
					continue;
				}
			}
			if (soap_flag_ds__Signature && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_ds__Signature(soap, "ds:Signature", &a->ds__Signature, ""))
				{	soap_flag_ds__Signature--;
					continue;
				}
			}
			if (soap_flag_saml2__Subject && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTosaml2__SubjectType(soap, "saml2:Subject", &a->saml2__Subject, "saml2:SubjectType"))
				{	soap_flag_saml2__Subject--;
					continue;
				}
			}
			if (soap_flag_saml2__Conditions && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTosaml2__ConditionsType(soap, "saml2:Conditions", &a->saml2__Conditions, "saml2:ConditionsType"))
				{	soap_flag_saml2__Conditions--;
					continue;
				}
			}
			if (soap_flag_saml2__Advice && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTosaml2__AdviceType(soap, "saml2:Advice", &a->saml2__Advice, "saml2:AdviceType"))
				{	soap_flag_saml2__Advice--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	if (a->__union_AssertionType == NULL)
				{	if (soap_blist___union_AssertionType == NULL)
						soap_blist___union_AssertionType = soap_alloc_block(soap);
					a->__union_AssertionType = (struct __saml2__union_AssertionType *)soap_push_block_max(soap, soap_blist___union_AssertionType, sizeof(struct __saml2__union_AssertionType));
					if (a->__union_AssertionType == NULL)
						return NULL;
					soap_default___saml2__union_AssertionType(soap, a->__union_AssertionType);
				}
				if (soap_in___saml2__union_AssertionType(soap, "-union-AssertionType", a->__union_AssertionType, "-saml2:union-AssertionType"))
				{	a->__size_AssertionType++;
					a->__union_AssertionType = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->__union_AssertionType)
			soap_pop_block(soap, soap_blist___union_AssertionType);
		if (a->__size_AssertionType)
		{	a->__union_AssertionType = (struct __saml2__union_AssertionType *)soap_save_block(soap, soap_blist___union_AssertionType, NULL, 1);
		}
		else
		{	a->__union_AssertionType = NULL;
			if (soap_blist___union_AssertionType)
				soap_end_block(soap, soap_blist___union_AssertionType);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (!a->saml2__Issuer))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct saml2__AssertionType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_saml2__AssertionType, SOAP_TYPE_saml2__AssertionType, sizeof(struct saml2__AssertionType), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct saml2__AssertionType * SOAP_FMAC4 soap_new_saml2__AssertionType(struct soap *soap, int n)
{
	struct saml2__AssertionType *p;
	struct saml2__AssertionType *a = (struct saml2__AssertionType*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct saml2__AssertionType));
	for (p = a; p && n--; p++)
		soap_default_saml2__AssertionType(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_saml2__AssertionType(struct soap *soap, const struct saml2__AssertionType *a, const char *tag, const char *type)
{
	if (soap_out_saml2__AssertionType(soap, tag ? tag : "saml2:AssertionType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct saml2__AssertionType * SOAP_FMAC4 soap_get_saml2__AssertionType(struct soap *soap, struct saml2__AssertionType *p, const char *tag, const char *type)
{
	if ((p = soap_in_saml2__AssertionType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_saml2__EncryptedElementType(struct soap *soap, struct saml2__EncryptedElementType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_xenc__EncryptedDataType(soap, &a->xenc__EncryptedData);
	a->__sizexenc__EncryptedKey = 0;
	a->xenc__EncryptedKey = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_saml2__EncryptedElementType(struct soap *soap, const struct saml2__EncryptedElementType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_xenc__EncryptedDataType(soap, &a->xenc__EncryptedData);
	if (a->xenc__EncryptedKey)
	{	int i;
		for (i = 0; i < (int)a->__sizexenc__EncryptedKey; i++)
		{
			soap_serialize_PointerToxenc__EncryptedKeyType(soap, a->xenc__EncryptedKey + i);
		}
	}
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_saml2__EncryptedElementType(struct soap *soap, const char *tag, int id, const struct saml2__EncryptedElementType *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_saml2__EncryptedElementType), type))
		return soap->error;
	if (soap_out_xenc__EncryptedDataType(soap, "xenc:EncryptedData", -1, &a->xenc__EncryptedData, ""))
		return soap->error;
	if (a->xenc__EncryptedKey)
	{	int i;
		for (i = 0; i < (int)a->__sizexenc__EncryptedKey; i++)
			if (soap_out_PointerToxenc__EncryptedKeyType(soap, "xenc:EncryptedKey", -1, a->xenc__EncryptedKey + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct saml2__EncryptedElementType * SOAP_FMAC4 soap_in_saml2__EncryptedElementType(struct soap *soap, const char *tag, struct saml2__EncryptedElementType *a, const char *type)
{
	size_t soap_flag_xenc__EncryptedData = 1;
	struct soap_blist *soap_blist_xenc__EncryptedKey = NULL;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct saml2__EncryptedElementType*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_saml2__EncryptedElementType, sizeof(struct saml2__EncryptedElementType), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_saml2__EncryptedElementType(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_xenc__EncryptedData && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_xenc__EncryptedDataType(soap, "xenc:EncryptedData", &a->xenc__EncryptedData, "xenc:EncryptedDataType"))
				{	soap_flag_xenc__EncryptedData--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "xenc:EncryptedKey", 1, NULL))
			{	if (a->xenc__EncryptedKey == NULL)
				{	if (soap_blist_xenc__EncryptedKey == NULL)
						soap_blist_xenc__EncryptedKey = soap_alloc_block(soap);
					a->xenc__EncryptedKey = (struct xenc__EncryptedKeyType **)soap_push_block_max(soap, soap_blist_xenc__EncryptedKey, sizeof(struct xenc__EncryptedKeyType *));
					if (a->xenc__EncryptedKey == NULL)
						return NULL;
					*a->xenc__EncryptedKey = NULL;
				}
				soap_revert(soap);
				if (soap_in_PointerToxenc__EncryptedKeyType(soap, "xenc:EncryptedKey", a->xenc__EncryptedKey, "xenc:EncryptedKeyType"))
				{	a->__sizexenc__EncryptedKey++;
					a->xenc__EncryptedKey = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->xenc__EncryptedKey)
			soap_pop_block(soap, soap_blist_xenc__EncryptedKey);
		if (a->__sizexenc__EncryptedKey)
		{	a->xenc__EncryptedKey = (struct xenc__EncryptedKeyType **)soap_save_block(soap, soap_blist_xenc__EncryptedKey, NULL, 1);
		}
		else
		{	a->xenc__EncryptedKey = NULL;
			if (soap_blist_xenc__EncryptedKey)
				soap_end_block(soap, soap_blist_xenc__EncryptedKey);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_xenc__EncryptedData > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct saml2__EncryptedElementType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_saml2__EncryptedElementType, SOAP_TYPE_saml2__EncryptedElementType, sizeof(struct saml2__EncryptedElementType), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct saml2__EncryptedElementType * SOAP_FMAC4 soap_new_saml2__EncryptedElementType(struct soap *soap, int n)
{
	struct saml2__EncryptedElementType *p;
	struct saml2__EncryptedElementType *a = (struct saml2__EncryptedElementType*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct saml2__EncryptedElementType));
	for (p = a; p && n--; p++)
		soap_default_saml2__EncryptedElementType(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_saml2__EncryptedElementType(struct soap *soap, const struct saml2__EncryptedElementType *a, const char *tag, const char *type)
{
	if (soap_out_saml2__EncryptedElementType(soap, tag ? tag : "saml2:EncryptedElementType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct saml2__EncryptedElementType * SOAP_FMAC4 soap_get_saml2__EncryptedElementType(struct soap *soap, struct saml2__EncryptedElementType *p, const char *tag, const char *type)
{
	if ((p = soap_in_saml2__EncryptedElementType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_saml2__NameIDType(struct soap *soap, struct saml2__NameIDType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->__item);
	soap_default_string(soap, &a->Format);
	soap_default_string(soap, &a->SPProvidedID);
	soap_default_string(soap, &a->NameQualifier);
	soap_default_string(soap, &a->SPNameQualifier);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_saml2__NameIDType(struct soap *soap, const struct saml2__NameIDType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_string(soap, (char*const*)&a->__item);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_saml2__NameIDType(struct soap *soap, const char *tag, int id, const struct saml2__NameIDType *a, const char *type)
{
	if (a->Format)
		soap_set_attr(soap, "Format", soap_string2s(soap, a->Format), 1);
	if (a->SPProvidedID)
		soap_set_attr(soap, "SPProvidedID", soap_string2s(soap, a->SPProvidedID), 1);
	if (a->NameQualifier)
		soap_set_attr(soap, "NameQualifier", soap_string2s(soap, a->NameQualifier), 1);
	if (a->SPNameQualifier)
		soap_set_attr(soap, "SPNameQualifier", soap_string2s(soap, a->SPNameQualifier), 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	return soap_out_string(soap, tag, id, (char*const*)&a->__item, "");
}

SOAP_FMAC3 struct saml2__NameIDType * SOAP_FMAC4 soap_in_saml2__NameIDType(struct soap *soap, const char *tag, struct saml2__NameIDType *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	if (!(a = (struct saml2__NameIDType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_saml2__NameIDType, sizeof(struct saml2__NameIDType), NULL, NULL, NULL, NULL)))
		return NULL;
	soap_revert(soap);
	*soap->id = '\0';
	soap_default_saml2__NameIDType(soap, a);
	if (soap_s2string(soap, soap_attr_value(soap, "Format", 1, 0), &a->Format))
		return NULL;
	if (soap_s2string(soap, soap_attr_value(soap, "SPProvidedID", 1, 0), &a->SPProvidedID))
		return NULL;
	if (soap_s2string(soap, soap_attr_value(soap, "NameQualifier", 1, 0), &a->NameQualifier))
		return NULL;
	if (soap_s2string(soap, soap_attr_value(soap, "SPNameQualifier", 1, 0), &a->SPNameQualifier))
		return NULL;
	if (!soap_in_string(soap, tag, (char**)&a->__item, "saml2:NameIDType"))
		return NULL;
	return a;
}

SOAP_FMAC3 struct saml2__NameIDType * SOAP_FMAC4 soap_new_saml2__NameIDType(struct soap *soap, int n)
{
	struct saml2__NameIDType *p;
	struct saml2__NameIDType *a = (struct saml2__NameIDType*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct saml2__NameIDType));
	for (p = a; p && n--; p++)
		soap_default_saml2__NameIDType(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_saml2__NameIDType(struct soap *soap, const struct saml2__NameIDType *a, const char *tag, const char *type)
{
	if (soap_out_saml2__NameIDType(soap, tag ? tag : "saml2:NameIDType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct saml2__NameIDType * SOAP_FMAC4 soap_get_saml2__NameIDType(struct soap *soap, struct saml2__NameIDType *p, const char *tag, const char *type)
{
	if ((p = soap_in_saml2__NameIDType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_saml2__BaseIDAbstractType(struct soap *soap, struct saml2__BaseIDAbstractType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->NameQualifier);
	soap_default_string(soap, &a->SPNameQualifier);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_saml2__BaseIDAbstractType(struct soap *soap, const struct saml2__BaseIDAbstractType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_saml2__BaseIDAbstractType(struct soap *soap, const char *tag, int id, const struct saml2__BaseIDAbstractType *a, const char *type)
{
	if (a->NameQualifier)
		soap_set_attr(soap, "NameQualifier", soap_string2s(soap, a->NameQualifier), 1);
	if (a->SPNameQualifier)
		soap_set_attr(soap, "SPNameQualifier", soap_string2s(soap, a->SPNameQualifier), 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_saml2__BaseIDAbstractType), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct saml2__BaseIDAbstractType * SOAP_FMAC4 soap_in_saml2__BaseIDAbstractType(struct soap *soap, const char *tag, struct saml2__BaseIDAbstractType *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct saml2__BaseIDAbstractType*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_saml2__BaseIDAbstractType, sizeof(struct saml2__BaseIDAbstractType), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_saml2__BaseIDAbstractType(soap, a);
	if (soap_s2string(soap, soap_attr_value(soap, "NameQualifier", 1, 0), &a->NameQualifier))
		return NULL;
	if (soap_s2string(soap, soap_attr_value(soap, "SPNameQualifier", 1, 0), &a->SPNameQualifier))
		return NULL;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct saml2__BaseIDAbstractType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_saml2__BaseIDAbstractType, SOAP_TYPE_saml2__BaseIDAbstractType, sizeof(struct saml2__BaseIDAbstractType), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct saml2__BaseIDAbstractType * SOAP_FMAC4 soap_new_saml2__BaseIDAbstractType(struct soap *soap, int n)
{
	struct saml2__BaseIDAbstractType *p;
	struct saml2__BaseIDAbstractType *a = (struct saml2__BaseIDAbstractType*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct saml2__BaseIDAbstractType));
	for (p = a; p && n--; p++)
		soap_default_saml2__BaseIDAbstractType(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_saml2__BaseIDAbstractType(struct soap *soap, const struct saml2__BaseIDAbstractType *a, const char *tag, const char *type)
{
	if (soap_out_saml2__BaseIDAbstractType(soap, tag ? tag : "saml2:BaseIDAbstractType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct saml2__BaseIDAbstractType * SOAP_FMAC4 soap_get_saml2__BaseIDAbstractType(struct soap *soap, struct saml2__BaseIDAbstractType *p, const char *tag, const char *type)
{
	if ((p = soap_in_saml2__BaseIDAbstractType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__saml1__Attribute(struct soap *soap, const struct saml1__AttributeType *a, const char *tag, const char *type)
{
	if (soap_out__saml1__Attribute(soap, tag ? tag : "saml1:Attribute", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__saml1__AttributeDesignator(struct soap *soap, const struct saml1__AttributeDesignatorType *a, const char *tag, const char *type)
{
	if (soap_out__saml1__AttributeDesignator(soap, tag ? tag : "saml1:AttributeDesignator", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__saml1__AttributeStatement(struct soap *soap, const struct saml1__AttributeStatementType *a, const char *tag, const char *type)
{
	if (soap_out__saml1__AttributeStatement(soap, tag ? tag : "saml1:AttributeStatement", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__saml1__Evidence(struct soap *soap, const struct saml1__EvidenceType *a, const char *tag, const char *type)
{
	if (soap_out__saml1__Evidence(soap, tag ? tag : "saml1:Evidence", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__saml1__Action(struct soap *soap, const struct saml1__ActionType *a, const char *tag, const char *type)
{
	if (soap_out__saml1__Action(soap, tag ? tag : "saml1:Action", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__saml1__AuthorizationDecisionStatement(struct soap *soap, const struct saml1__AuthorizationDecisionStatementType *a, const char *tag, const char *type)
{
	if (soap_out__saml1__AuthorizationDecisionStatement(soap, tag ? tag : "saml1:AuthorizationDecisionStatement", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__saml1__AuthorityBinding(struct soap *soap, const struct saml1__AuthorityBindingType *a, const char *tag, const char *type)
{
	if (soap_out__saml1__AuthorityBinding(soap, tag ? tag : "saml1:AuthorityBinding", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__saml1__SubjectLocality(struct soap *soap, const struct saml1__SubjectLocalityType *a, const char *tag, const char *type)
{
	if (soap_out__saml1__SubjectLocality(soap, tag ? tag : "saml1:SubjectLocality", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__saml1__AuthenticationStatement(struct soap *soap, const struct saml1__AuthenticationStatementType *a, const char *tag, const char *type)
{
	if (soap_out__saml1__AuthenticationStatement(soap, tag ? tag : "saml1:AuthenticationStatement", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__saml1__SubjectConfirmation(struct soap *soap, const struct saml1__SubjectConfirmationType *a, const char *tag, const char *type)
{
	if (soap_out__saml1__SubjectConfirmation(soap, tag ? tag : "saml1:SubjectConfirmation", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__saml1__NameIdentifier(struct soap *soap, const struct saml1__NameIdentifierType *a, const char *tag, const char *type)
{
	if (soap_out__saml1__NameIdentifier(soap, tag ? tag : "saml1:NameIdentifier", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__saml1__Subject(struct soap *soap, const struct saml1__SubjectType *a, const char *tag, const char *type)
{
	if (soap_out__saml1__Subject(soap, tag ? tag : "saml1:Subject", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__saml1__SubjectStatement(struct soap *soap, const struct saml1__SubjectStatementAbstractType *a, const char *tag, const char *type)
{
	if (soap_out__saml1__SubjectStatement(soap, tag ? tag : "saml1:SubjectStatement", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__saml1__Statement(struct soap *soap, const struct saml1__StatementAbstractType *a, const char *tag, const char *type)
{
	if (soap_out__saml1__Statement(soap, tag ? tag : "saml1:Statement", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__saml1__Advice(struct soap *soap, const struct saml1__AdviceType *a, const char *tag, const char *type)
{
	if (soap_out__saml1__Advice(soap, tag ? tag : "saml1:Advice", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__saml1__DoNotCacheCondition(struct soap *soap, const struct saml1__DoNotCacheConditionType *a, const char *tag, const char *type)
{
	if (soap_out__saml1__DoNotCacheCondition(soap, tag ? tag : "saml1:DoNotCacheCondition", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__saml1__AudienceRestrictionCondition(struct soap *soap, const struct saml1__AudienceRestrictionConditionType *a, const char *tag, const char *type)
{
	if (soap_out__saml1__AudienceRestrictionCondition(soap, tag ? tag : "saml1:AudienceRestrictionCondition", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__saml1__Condition(struct soap *soap, const struct saml1__ConditionAbstractType *a, const char *tag, const char *type)
{
	if (soap_out__saml1__Condition(soap, tag ? tag : "saml1:Condition", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__saml1__Conditions(struct soap *soap, const struct saml1__ConditionsType *a, const char *tag, const char *type)
{
	if (soap_out__saml1__Conditions(soap, tag ? tag : "saml1:Conditions", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__saml1__Assertion(struct soap *soap, const struct saml1__AssertionType *a, const char *tag, const char *type)
{
	if (soap_out__saml1__Assertion(soap, tag ? tag : "saml1:Assertion", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___saml1__union_EvidenceType(struct soap *soap, struct __saml1__union_EvidenceType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->saml1__AssertionIDReference);
	a->saml1__Assertion = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___saml1__union_EvidenceType(struct soap *soap, const struct __saml1__union_EvidenceType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_string(soap, (char*const*)&a->saml1__AssertionIDReference);
	soap_serialize_PointerTosaml1__AssertionType(soap, &a->saml1__Assertion);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___saml1__union_EvidenceType(struct soap *soap, const char *tag, int id, const struct __saml1__union_EvidenceType *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_string(soap, "saml1:AssertionIDReference", -1, (char*const*)&a->saml1__AssertionIDReference, ""))
		return soap->error;
	if (soap_out_PointerTosaml1__AssertionType(soap, "saml1:Assertion", -1, &a->saml1__Assertion, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __saml1__union_EvidenceType * SOAP_FMAC4 soap_in___saml1__union_EvidenceType(struct soap *soap, const char *tag, struct __saml1__union_EvidenceType *a, const char *type)
{
	size_t soap_flag_saml1__AssertionIDReference = 1;
	size_t soap_flag_saml1__Assertion = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __saml1__union_EvidenceType*)soap_id_enter(soap, "", a, SOAP_TYPE___saml1__union_EvidenceType, sizeof(struct __saml1__union_EvidenceType), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___saml1__union_EvidenceType(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_saml1__AssertionIDReference && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_string(soap, "saml1:AssertionIDReference", (char**)&a->saml1__AssertionIDReference, "xsd:string"))
				{	soap_flag_saml1__AssertionIDReference--;
					continue;
				}
			}
			if (soap_flag_saml1__Assertion && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTosaml1__AssertionType(soap, "saml1:Assertion", &a->saml1__Assertion, "saml1:AssertionType"))
				{	soap_flag_saml1__Assertion--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 struct __saml1__union_EvidenceType * SOAP_FMAC4 soap_new___saml1__union_EvidenceType(struct soap *soap, int n)
{
	struct __saml1__union_EvidenceType *p;
	struct __saml1__union_EvidenceType *a = (struct __saml1__union_EvidenceType*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct __saml1__union_EvidenceType));
	for (p = a; p && n--; p++)
		soap_default___saml1__union_EvidenceType(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___saml1__union_EvidenceType(struct soap *soap, const struct __saml1__union_EvidenceType *a, const char *tag, const char *type)
{
	if (soap_out___saml1__union_EvidenceType(soap, tag ? tag : "-saml1:union-EvidenceType", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __saml1__union_EvidenceType * SOAP_FMAC4 soap_get___saml1__union_EvidenceType(struct soap *soap, struct __saml1__union_EvidenceType *p, const char *tag, const char *type)
{
	if ((p = soap_in___saml1__union_EvidenceType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___saml1__union_AdviceType(struct soap *soap, struct __saml1__union_AdviceType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->saml1__AssertionIDReference);
	a->saml1__Assertion = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___saml1__union_AdviceType(struct soap *soap, const struct __saml1__union_AdviceType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_string(soap, (char*const*)&a->saml1__AssertionIDReference);
	soap_serialize_PointerTosaml1__AssertionType(soap, &a->saml1__Assertion);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___saml1__union_AdviceType(struct soap *soap, const char *tag, int id, const struct __saml1__union_AdviceType *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_string(soap, "saml1:AssertionIDReference", -1, (char*const*)&a->saml1__AssertionIDReference, ""))
		return soap->error;
	if (soap_out_PointerTosaml1__AssertionType(soap, "saml1:Assertion", -1, &a->saml1__Assertion, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __saml1__union_AdviceType * SOAP_FMAC4 soap_in___saml1__union_AdviceType(struct soap *soap, const char *tag, struct __saml1__union_AdviceType *a, const char *type)
{
	size_t soap_flag_saml1__AssertionIDReference = 1;
	size_t soap_flag_saml1__Assertion = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __saml1__union_AdviceType*)soap_id_enter(soap, "", a, SOAP_TYPE___saml1__union_AdviceType, sizeof(struct __saml1__union_AdviceType), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___saml1__union_AdviceType(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_saml1__AssertionIDReference && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_string(soap, "saml1:AssertionIDReference", (char**)&a->saml1__AssertionIDReference, "xsd:string"))
				{	soap_flag_saml1__AssertionIDReference--;
					continue;
				}
			}
			if (soap_flag_saml1__Assertion && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTosaml1__AssertionType(soap, "saml1:Assertion", &a->saml1__Assertion, "saml1:AssertionType"))
				{	soap_flag_saml1__Assertion--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 struct __saml1__union_AdviceType * SOAP_FMAC4 soap_new___saml1__union_AdviceType(struct soap *soap, int n)
{
	struct __saml1__union_AdviceType *p;
	struct __saml1__union_AdviceType *a = (struct __saml1__union_AdviceType*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct __saml1__union_AdviceType));
	for (p = a; p && n--; p++)
		soap_default___saml1__union_AdviceType(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___saml1__union_AdviceType(struct soap *soap, const struct __saml1__union_AdviceType *a, const char *tag, const char *type)
{
	if (soap_out___saml1__union_AdviceType(soap, tag ? tag : "-saml1:union-AdviceType", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __saml1__union_AdviceType * SOAP_FMAC4 soap_get___saml1__union_AdviceType(struct soap *soap, struct __saml1__union_AdviceType *p, const char *tag, const char *type)
{
	if ((p = soap_in___saml1__union_AdviceType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___saml1__union_ConditionsType(struct soap *soap, struct __saml1__union_ConditionsType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->saml1__AudienceRestrictionCondition = NULL;
	a->saml1__DoNotCacheCondition = NULL;
	a->saml1__Condition = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___saml1__union_ConditionsType(struct soap *soap, const struct __saml1__union_ConditionsType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTosaml1__AudienceRestrictionConditionType(soap, &a->saml1__AudienceRestrictionCondition);
	soap_serialize_PointerTosaml1__DoNotCacheConditionType(soap, &a->saml1__DoNotCacheCondition);
	soap_serialize_PointerTosaml1__ConditionAbstractType(soap, &a->saml1__Condition);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___saml1__union_ConditionsType(struct soap *soap, const char *tag, int id, const struct __saml1__union_ConditionsType *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTosaml1__AudienceRestrictionConditionType(soap, "saml1:AudienceRestrictionCondition", -1, &a->saml1__AudienceRestrictionCondition, ""))
		return soap->error;
	if (soap_out_PointerTosaml1__DoNotCacheConditionType(soap, "saml1:DoNotCacheCondition", -1, &a->saml1__DoNotCacheCondition, ""))
		return soap->error;
	if (soap_out_PointerTosaml1__ConditionAbstractType(soap, "saml1:Condition", -1, &a->saml1__Condition, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __saml1__union_ConditionsType * SOAP_FMAC4 soap_in___saml1__union_ConditionsType(struct soap *soap, const char *tag, struct __saml1__union_ConditionsType *a, const char *type)
{
	size_t soap_flag_saml1__AudienceRestrictionCondition = 1;
	size_t soap_flag_saml1__DoNotCacheCondition = 1;
	size_t soap_flag_saml1__Condition = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __saml1__union_ConditionsType*)soap_id_enter(soap, "", a, SOAP_TYPE___saml1__union_ConditionsType, sizeof(struct __saml1__union_ConditionsType), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___saml1__union_ConditionsType(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_saml1__AudienceRestrictionCondition && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTosaml1__AudienceRestrictionConditionType(soap, "saml1:AudienceRestrictionCondition", &a->saml1__AudienceRestrictionCondition, "saml1:AudienceRestrictionConditionType"))
				{	soap_flag_saml1__AudienceRestrictionCondition--;
					continue;
				}
			}
			if (soap_flag_saml1__DoNotCacheCondition && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTosaml1__DoNotCacheConditionType(soap, "saml1:DoNotCacheCondition", &a->saml1__DoNotCacheCondition, "saml1:DoNotCacheConditionType"))
				{	soap_flag_saml1__DoNotCacheCondition--;
					continue;
				}
			}
			if (soap_flag_saml1__Condition && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTosaml1__ConditionAbstractType(soap, "saml1:Condition", &a->saml1__Condition, "saml1:ConditionAbstractType"))
				{	soap_flag_saml1__Condition--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 struct __saml1__union_ConditionsType * SOAP_FMAC4 soap_new___saml1__union_ConditionsType(struct soap *soap, int n)
{
	struct __saml1__union_ConditionsType *p;
	struct __saml1__union_ConditionsType *a = (struct __saml1__union_ConditionsType*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct __saml1__union_ConditionsType));
	for (p = a; p && n--; p++)
		soap_default___saml1__union_ConditionsType(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___saml1__union_ConditionsType(struct soap *soap, const struct __saml1__union_ConditionsType *a, const char *tag, const char *type)
{
	if (soap_out___saml1__union_ConditionsType(soap, tag ? tag : "-saml1:union-ConditionsType", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __saml1__union_ConditionsType * SOAP_FMAC4 soap_get___saml1__union_ConditionsType(struct soap *soap, struct __saml1__union_ConditionsType *p, const char *tag, const char *type)
{
	if ((p = soap_in___saml1__union_ConditionsType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___saml1__union_AssertionType(struct soap *soap, struct __saml1__union_AssertionType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->saml1__Statement = NULL;
	a->saml1__SubjectStatement = NULL;
	a->saml1__AuthenticationStatement = NULL;
	a->saml1__AuthorizationDecisionStatement = NULL;
	a->saml1__AttributeStatement = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___saml1__union_AssertionType(struct soap *soap, const struct __saml1__union_AssertionType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTosaml1__StatementAbstractType(soap, &a->saml1__Statement);
	soap_serialize_PointerTosaml1__SubjectStatementAbstractType(soap, &a->saml1__SubjectStatement);
	soap_serialize_PointerTosaml1__AuthenticationStatementType(soap, &a->saml1__AuthenticationStatement);
	soap_serialize_PointerTosaml1__AuthorizationDecisionStatementType(soap, &a->saml1__AuthorizationDecisionStatement);
	soap_serialize_PointerTosaml1__AttributeStatementType(soap, &a->saml1__AttributeStatement);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___saml1__union_AssertionType(struct soap *soap, const char *tag, int id, const struct __saml1__union_AssertionType *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTosaml1__StatementAbstractType(soap, "saml1:Statement", -1, &a->saml1__Statement, ""))
		return soap->error;
	if (soap_out_PointerTosaml1__SubjectStatementAbstractType(soap, "saml1:SubjectStatement", -1, &a->saml1__SubjectStatement, ""))
		return soap->error;
	if (soap_out_PointerTosaml1__AuthenticationStatementType(soap, "saml1:AuthenticationStatement", -1, &a->saml1__AuthenticationStatement, ""))
		return soap->error;
	if (soap_out_PointerTosaml1__AuthorizationDecisionStatementType(soap, "saml1:AuthorizationDecisionStatement", -1, &a->saml1__AuthorizationDecisionStatement, ""))
		return soap->error;
	if (soap_out_PointerTosaml1__AttributeStatementType(soap, "saml1:AttributeStatement", -1, &a->saml1__AttributeStatement, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __saml1__union_AssertionType * SOAP_FMAC4 soap_in___saml1__union_AssertionType(struct soap *soap, const char *tag, struct __saml1__union_AssertionType *a, const char *type)
{
	size_t soap_flag_saml1__Statement = 1;
	size_t soap_flag_saml1__SubjectStatement = 1;
	size_t soap_flag_saml1__AuthenticationStatement = 1;
	size_t soap_flag_saml1__AuthorizationDecisionStatement = 1;
	size_t soap_flag_saml1__AttributeStatement = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __saml1__union_AssertionType*)soap_id_enter(soap, "", a, SOAP_TYPE___saml1__union_AssertionType, sizeof(struct __saml1__union_AssertionType), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___saml1__union_AssertionType(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_saml1__Statement && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTosaml1__StatementAbstractType(soap, "saml1:Statement", &a->saml1__Statement, "saml1:StatementAbstractType"))
				{	soap_flag_saml1__Statement--;
					continue;
				}
			}
			if (soap_flag_saml1__SubjectStatement && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTosaml1__SubjectStatementAbstractType(soap, "saml1:SubjectStatement", &a->saml1__SubjectStatement, "saml1:SubjectStatementAbstractType"))
				{	soap_flag_saml1__SubjectStatement--;
					continue;
				}
			}
			if (soap_flag_saml1__AuthenticationStatement && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTosaml1__AuthenticationStatementType(soap, "saml1:AuthenticationStatement", &a->saml1__AuthenticationStatement, "saml1:AuthenticationStatementType"))
				{	soap_flag_saml1__AuthenticationStatement--;
					continue;
				}
			}
			if (soap_flag_saml1__AuthorizationDecisionStatement && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTosaml1__AuthorizationDecisionStatementType(soap, "saml1:AuthorizationDecisionStatement", &a->saml1__AuthorizationDecisionStatement, "saml1:AuthorizationDecisionStatementType"))
				{	soap_flag_saml1__AuthorizationDecisionStatement--;
					continue;
				}
			}
			if (soap_flag_saml1__AttributeStatement && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTosaml1__AttributeStatementType(soap, "saml1:AttributeStatement", &a->saml1__AttributeStatement, "saml1:AttributeStatementType"))
				{	soap_flag_saml1__AttributeStatement--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 struct __saml1__union_AssertionType * SOAP_FMAC4 soap_new___saml1__union_AssertionType(struct soap *soap, int n)
{
	struct __saml1__union_AssertionType *p;
	struct __saml1__union_AssertionType *a = (struct __saml1__union_AssertionType*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct __saml1__union_AssertionType));
	for (p = a; p && n--; p++)
		soap_default___saml1__union_AssertionType(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___saml1__union_AssertionType(struct soap *soap, const struct __saml1__union_AssertionType *a, const char *tag, const char *type)
{
	if (soap_out___saml1__union_AssertionType(soap, tag ? tag : "-saml1:union-AssertionType", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __saml1__union_AssertionType * SOAP_FMAC4 soap_get___saml1__union_AssertionType(struct soap *soap, struct __saml1__union_AssertionType *p, const char *tag, const char *type)
{
	if ((p = soap_in___saml1__union_AssertionType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_saml1__AttributeType(struct soap *soap, struct saml1__AttributeType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->AttributeName);
	soap_default_string(soap, &a->AttributeNamespace);
	a->__sizeAttributeValue = 0;
	a->saml1__AttributeValue = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_saml1__AttributeType(struct soap *soap, const struct saml1__AttributeType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_saml1__AttributeType(struct soap *soap, const char *tag, int id, const struct saml1__AttributeType *a, const char *type)
{
	soap_set_attr(soap, "AttributeName", a->AttributeName ? soap_string2s(soap, a->AttributeName) : "", 1);
	soap_set_attr(soap, "AttributeNamespace", a->AttributeNamespace ? soap_string2s(soap, a->AttributeNamespace) : "", 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_saml1__AttributeType), type))
		return soap->error;
	if (a->saml1__AttributeValue)
	{	int i;
		for (i = 0; i < (int)a->__sizeAttributeValue; i++)
			if (soap_outliteral(soap, "saml1:AttributeValue", (char*const*)(a->saml1__AttributeValue + i), NULL))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct saml1__AttributeType * SOAP_FMAC4 soap_in_saml1__AttributeType(struct soap *soap, const char *tag, struct saml1__AttributeType *a, const char *type)
{
	struct soap_blist *soap_blist_saml1__AttributeValue = NULL;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct saml1__AttributeType*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_saml1__AttributeType, sizeof(struct saml1__AttributeType), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_saml1__AttributeType(soap, a);
	if (soap_s2string(soap, soap_attr_value(soap, "AttributeName", 1, 1), &a->AttributeName))
		return NULL;
	if (soap_s2string(soap, soap_attr_value(soap, "AttributeNamespace", 1, 1), &a->AttributeNamespace))
		return NULL;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "saml1:AttributeValue", 1, NULL))
			{	if (a->saml1__AttributeValue == NULL)
				{	if (soap_blist_saml1__AttributeValue == NULL)
						soap_blist_saml1__AttributeValue = soap_alloc_block(soap);
					a->saml1__AttributeValue = (char **)soap_push_block_max(soap, soap_blist_saml1__AttributeValue, sizeof(char *));
					if (a->saml1__AttributeValue == NULL)
						return NULL;
					*a->saml1__AttributeValue = NULL;
				}
				soap_revert(soap);
				if (soap_inliteral(soap, "saml1:AttributeValue", (char**)a->saml1__AttributeValue))
				{	a->__sizeAttributeValue++;
					a->saml1__AttributeValue = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->saml1__AttributeValue)
			soap_pop_block(soap, soap_blist_saml1__AttributeValue);
		if (a->__sizeAttributeValue)
		{	a->saml1__AttributeValue = (char **)soap_save_block(soap, soap_blist_saml1__AttributeValue, NULL, 1);
		}
		else
		{	a->saml1__AttributeValue = NULL;
			if (soap_blist_saml1__AttributeValue)
				soap_end_block(soap, soap_blist_saml1__AttributeValue);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (a->__sizeAttributeValue < 1))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct saml1__AttributeType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_saml1__AttributeType, SOAP_TYPE_saml1__AttributeType, sizeof(struct saml1__AttributeType), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct saml1__AttributeType * SOAP_FMAC4 soap_new_saml1__AttributeType(struct soap *soap, int n)
{
	struct saml1__AttributeType *p;
	struct saml1__AttributeType *a = (struct saml1__AttributeType*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct saml1__AttributeType));
	for (p = a; p && n--; p++)
		soap_default_saml1__AttributeType(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_saml1__AttributeType(struct soap *soap, const struct saml1__AttributeType *a, const char *tag, const char *type)
{
	if (soap_out_saml1__AttributeType(soap, tag ? tag : "saml1:AttributeType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct saml1__AttributeType * SOAP_FMAC4 soap_get_saml1__AttributeType(struct soap *soap, struct saml1__AttributeType *p, const char *tag, const char *type)
{
	if ((p = soap_in_saml1__AttributeType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_saml1__AttributeDesignatorType(struct soap *soap, struct saml1__AttributeDesignatorType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->AttributeName);
	soap_default_string(soap, &a->AttributeNamespace);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_saml1__AttributeDesignatorType(struct soap *soap, const struct saml1__AttributeDesignatorType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_saml1__AttributeDesignatorType(struct soap *soap, const char *tag, int id, const struct saml1__AttributeDesignatorType *a, const char *type)
{
	soap_set_attr(soap, "AttributeName", a->AttributeName ? soap_string2s(soap, a->AttributeName) : "", 1);
	soap_set_attr(soap, "AttributeNamespace", a->AttributeNamespace ? soap_string2s(soap, a->AttributeNamespace) : "", 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_saml1__AttributeDesignatorType), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct saml1__AttributeDesignatorType * SOAP_FMAC4 soap_in_saml1__AttributeDesignatorType(struct soap *soap, const char *tag, struct saml1__AttributeDesignatorType *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct saml1__AttributeDesignatorType*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_saml1__AttributeDesignatorType, sizeof(struct saml1__AttributeDesignatorType), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_saml1__AttributeDesignatorType(soap, a);
	if (soap_s2string(soap, soap_attr_value(soap, "AttributeName", 1, 1), &a->AttributeName))
		return NULL;
	if (soap_s2string(soap, soap_attr_value(soap, "AttributeNamespace", 1, 1), &a->AttributeNamespace))
		return NULL;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct saml1__AttributeDesignatorType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_saml1__AttributeDesignatorType, SOAP_TYPE_saml1__AttributeDesignatorType, sizeof(struct saml1__AttributeDesignatorType), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct saml1__AttributeDesignatorType * SOAP_FMAC4 soap_new_saml1__AttributeDesignatorType(struct soap *soap, int n)
{
	struct saml1__AttributeDesignatorType *p;
	struct saml1__AttributeDesignatorType *a = (struct saml1__AttributeDesignatorType*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct saml1__AttributeDesignatorType));
	for (p = a; p && n--; p++)
		soap_default_saml1__AttributeDesignatorType(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_saml1__AttributeDesignatorType(struct soap *soap, const struct saml1__AttributeDesignatorType *a, const char *tag, const char *type)
{
	if (soap_out_saml1__AttributeDesignatorType(soap, tag ? tag : "saml1:AttributeDesignatorType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct saml1__AttributeDesignatorType * SOAP_FMAC4 soap_get_saml1__AttributeDesignatorType(struct soap *soap, struct saml1__AttributeDesignatorType *p, const char *tag, const char *type)
{
	if ((p = soap_in_saml1__AttributeDesignatorType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_saml1__AttributeStatementType(struct soap *soap, struct saml1__AttributeStatementType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->saml1__Subject = NULL;
	a->__sizeAttribute = 0;
	a->saml1__Attribute = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_saml1__AttributeStatementType(struct soap *soap, const struct saml1__AttributeStatementType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTosaml1__SubjectType(soap, &a->saml1__Subject);
	if (a->saml1__Attribute)
	{	int i;
		for (i = 0; i < (int)a->__sizeAttribute; i++)
		{
			soap_embedded(soap, a->saml1__Attribute + i, SOAP_TYPE_saml1__AttributeType);
			soap_serialize_saml1__AttributeType(soap, a->saml1__Attribute + i);
		}
	}
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_saml1__AttributeStatementType(struct soap *soap, const char *tag, int id, const struct saml1__AttributeStatementType *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_saml1__AttributeStatementType), type))
		return soap->error;
	if (!a->saml1__Subject)
	{	if (soap_element_empty(soap, "saml1:Subject", 0, NULL))
			return soap->error;
	}
	else if (soap_out_PointerTosaml1__SubjectType(soap, "saml1:Subject", -1, &a->saml1__Subject, ""))
		return soap->error;
	if (a->saml1__Attribute)
	{	int i;
		for (i = 0; i < (int)a->__sizeAttribute; i++)
			if (soap_out_saml1__AttributeType(soap, "saml1:Attribute", -1, a->saml1__Attribute + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct saml1__AttributeStatementType * SOAP_FMAC4 soap_in_saml1__AttributeStatementType(struct soap *soap, const char *tag, struct saml1__AttributeStatementType *a, const char *type)
{
	size_t soap_flag_saml1__Subject = 1;
	struct soap_blist *soap_blist_saml1__Attribute = NULL;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct saml1__AttributeStatementType*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_saml1__AttributeStatementType, sizeof(struct saml1__AttributeStatementType), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_saml1__AttributeStatementType(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_saml1__Subject && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTosaml1__SubjectType(soap, "saml1:Subject", &a->saml1__Subject, "saml1:SubjectType"))
				{	soap_flag_saml1__Subject--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "saml1:Attribute", 1, NULL))
			{	if (a->saml1__Attribute == NULL)
				{	if (soap_blist_saml1__Attribute == NULL)
						soap_blist_saml1__Attribute = soap_alloc_block(soap);
					a->saml1__Attribute = (struct saml1__AttributeType *)soap_push_block_max(soap, soap_blist_saml1__Attribute, sizeof(struct saml1__AttributeType));
					if (a->saml1__Attribute == NULL)
						return NULL;
					soap_default_saml1__AttributeType(soap, a->saml1__Attribute);
				}
				soap_revert(soap);
				if (soap_in_saml1__AttributeType(soap, "saml1:Attribute", a->saml1__Attribute, "saml1:AttributeType"))
				{	a->__sizeAttribute++;
					a->saml1__Attribute = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->saml1__Attribute)
			soap_pop_block(soap, soap_blist_saml1__Attribute);
		if (a->__sizeAttribute)
		{	a->saml1__Attribute = (struct saml1__AttributeType *)soap_save_block(soap, soap_blist_saml1__Attribute, NULL, 1);
		}
		else
		{	a->saml1__Attribute = NULL;
			if (soap_blist_saml1__Attribute)
				soap_end_block(soap, soap_blist_saml1__Attribute);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (!a->saml1__Subject || a->__sizeAttribute < 1))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct saml1__AttributeStatementType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_saml1__AttributeStatementType, SOAP_TYPE_saml1__AttributeStatementType, sizeof(struct saml1__AttributeStatementType), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct saml1__AttributeStatementType * SOAP_FMAC4 soap_new_saml1__AttributeStatementType(struct soap *soap, int n)
{
	struct saml1__AttributeStatementType *p;
	struct saml1__AttributeStatementType *a = (struct saml1__AttributeStatementType*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct saml1__AttributeStatementType));
	for (p = a; p && n--; p++)
		soap_default_saml1__AttributeStatementType(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_saml1__AttributeStatementType(struct soap *soap, const struct saml1__AttributeStatementType *a, const char *tag, const char *type)
{
	if (soap_out_saml1__AttributeStatementType(soap, tag ? tag : "saml1:AttributeStatementType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct saml1__AttributeStatementType * SOAP_FMAC4 soap_get_saml1__AttributeStatementType(struct soap *soap, struct saml1__AttributeStatementType *p, const char *tag, const char *type)
{
	if ((p = soap_in_saml1__AttributeStatementType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_saml1__EvidenceType(struct soap *soap, struct saml1__EvidenceType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__size_EvidenceType = 0;
	a->__union_EvidenceType = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_saml1__EvidenceType(struct soap *soap, const struct saml1__EvidenceType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (a->__union_EvidenceType)
	{	int i;
		for (i = 0; i < (int)a->__size_EvidenceType; i++)
		{
			soap_serialize___saml1__union_EvidenceType(soap, a->__union_EvidenceType + i);
		}
	}
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_saml1__EvidenceType(struct soap *soap, const char *tag, int id, const struct saml1__EvidenceType *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_saml1__EvidenceType), type))
		return soap->error;
	if (a->__union_EvidenceType)
	{	int i;
		for (i = 0; i < (int)a->__size_EvidenceType; i++)
			if (soap_out___saml1__union_EvidenceType(soap, "-union-EvidenceType", -1, a->__union_EvidenceType + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct saml1__EvidenceType * SOAP_FMAC4 soap_in_saml1__EvidenceType(struct soap *soap, const char *tag, struct saml1__EvidenceType *a, const char *type)
{
	struct soap_blist *soap_blist___union_EvidenceType = NULL;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct saml1__EvidenceType*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_saml1__EvidenceType, sizeof(struct saml1__EvidenceType), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_saml1__EvidenceType(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	if (a->__union_EvidenceType == NULL)
				{	if (soap_blist___union_EvidenceType == NULL)
						soap_blist___union_EvidenceType = soap_alloc_block(soap);
					a->__union_EvidenceType = (struct __saml1__union_EvidenceType *)soap_push_block_max(soap, soap_blist___union_EvidenceType, sizeof(struct __saml1__union_EvidenceType));
					if (a->__union_EvidenceType == NULL)
						return NULL;
					soap_default___saml1__union_EvidenceType(soap, a->__union_EvidenceType);
				}
				if (soap_in___saml1__union_EvidenceType(soap, "-union-EvidenceType", a->__union_EvidenceType, "-saml1:union-EvidenceType"))
				{	a->__size_EvidenceType++;
					a->__union_EvidenceType = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->__union_EvidenceType)
			soap_pop_block(soap, soap_blist___union_EvidenceType);
		if (a->__size_EvidenceType)
		{	a->__union_EvidenceType = (struct __saml1__union_EvidenceType *)soap_save_block(soap, soap_blist___union_EvidenceType, NULL, 1);
		}
		else
		{	a->__union_EvidenceType = NULL;
			if (soap_blist___union_EvidenceType)
				soap_end_block(soap, soap_blist___union_EvidenceType);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct saml1__EvidenceType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_saml1__EvidenceType, SOAP_TYPE_saml1__EvidenceType, sizeof(struct saml1__EvidenceType), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct saml1__EvidenceType * SOAP_FMAC4 soap_new_saml1__EvidenceType(struct soap *soap, int n)
{
	struct saml1__EvidenceType *p;
	struct saml1__EvidenceType *a = (struct saml1__EvidenceType*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct saml1__EvidenceType));
	for (p = a; p && n--; p++)
		soap_default_saml1__EvidenceType(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_saml1__EvidenceType(struct soap *soap, const struct saml1__EvidenceType *a, const char *tag, const char *type)
{
	if (soap_out_saml1__EvidenceType(soap, tag ? tag : "saml1:EvidenceType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct saml1__EvidenceType * SOAP_FMAC4 soap_get_saml1__EvidenceType(struct soap *soap, struct saml1__EvidenceType *p, const char *tag, const char *type)
{
	if ((p = soap_in_saml1__EvidenceType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_saml1__ActionType(struct soap *soap, struct saml1__ActionType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->__item);
	soap_default_string(soap, &a->Namespace);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_saml1__ActionType(struct soap *soap, const struct saml1__ActionType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_string(soap, (char*const*)&a->__item);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_saml1__ActionType(struct soap *soap, const char *tag, int id, const struct saml1__ActionType *a, const char *type)
{
	if (a->Namespace)
		soap_set_attr(soap, "Namespace", soap_string2s(soap, a->Namespace), 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	return soap_out_string(soap, tag, id, (char*const*)&a->__item, "");
}

SOAP_FMAC3 struct saml1__ActionType * SOAP_FMAC4 soap_in_saml1__ActionType(struct soap *soap, const char *tag, struct saml1__ActionType *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	if (!(a = (struct saml1__ActionType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_saml1__ActionType, sizeof(struct saml1__ActionType), NULL, NULL, NULL, NULL)))
		return NULL;
	soap_revert(soap);
	*soap->id = '\0';
	soap_default_saml1__ActionType(soap, a);
	if (soap_s2string(soap, soap_attr_value(soap, "Namespace", 1, 0), &a->Namespace))
		return NULL;
	if (!soap_in_string(soap, tag, (char**)&a->__item, "saml1:ActionType"))
		return NULL;
	return a;
}

SOAP_FMAC3 struct saml1__ActionType * SOAP_FMAC4 soap_new_saml1__ActionType(struct soap *soap, int n)
{
	struct saml1__ActionType *p;
	struct saml1__ActionType *a = (struct saml1__ActionType*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct saml1__ActionType));
	for (p = a; p && n--; p++)
		soap_default_saml1__ActionType(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_saml1__ActionType(struct soap *soap, const struct saml1__ActionType *a, const char *tag, const char *type)
{
	if (soap_out_saml1__ActionType(soap, tag ? tag : "saml1:ActionType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct saml1__ActionType * SOAP_FMAC4 soap_get_saml1__ActionType(struct soap *soap, struct saml1__ActionType *p, const char *tag, const char *type)
{
	if ((p = soap_in_saml1__ActionType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_saml1__AuthorizationDecisionStatementType(struct soap *soap, struct saml1__AuthorizationDecisionStatementType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->saml1__Subject = NULL;
	a->__sizeAction = 0;
	a->saml1__Action = NULL;
	a->saml1__Evidence = NULL;
	soap_default_string(soap, &a->Resource);
	soap_default_saml1__DecisionType(soap, &a->Decision);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_saml1__AuthorizationDecisionStatementType(struct soap *soap, const struct saml1__AuthorizationDecisionStatementType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTosaml1__SubjectType(soap, &a->saml1__Subject);
	if (a->saml1__Action)
	{	int i;
		for (i = 0; i < (int)a->__sizeAction; i++)
		{
			soap_embedded(soap, a->saml1__Action + i, SOAP_TYPE_saml1__ActionType);
			soap_serialize_saml1__ActionType(soap, a->saml1__Action + i);
		}
	}
	soap_serialize_PointerTosaml1__EvidenceType(soap, &a->saml1__Evidence);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_saml1__AuthorizationDecisionStatementType(struct soap *soap, const char *tag, int id, const struct saml1__AuthorizationDecisionStatementType *a, const char *type)
{
	soap_set_attr(soap, "Resource", a->Resource ? soap_string2s(soap, a->Resource) : "", 1);
	soap_set_attr(soap, "Decision", soap_saml1__DecisionType2s(soap, a->Decision), 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_saml1__AuthorizationDecisionStatementType), type))
		return soap->error;
	if (!a->saml1__Subject)
	{	if (soap_element_empty(soap, "saml1:Subject", 0, NULL))
			return soap->error;
	}
	else if (soap_out_PointerTosaml1__SubjectType(soap, "saml1:Subject", -1, &a->saml1__Subject, ""))
		return soap->error;
	if (a->saml1__Action)
	{	int i;
		for (i = 0; i < (int)a->__sizeAction; i++)
			if (soap_out_saml1__ActionType(soap, "saml1:Action", -1, a->saml1__Action + i, ""))
				return soap->error;
	}
	if (soap_out_PointerTosaml1__EvidenceType(soap, "saml1:Evidence", -1, &a->saml1__Evidence, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct saml1__AuthorizationDecisionStatementType * SOAP_FMAC4 soap_in_saml1__AuthorizationDecisionStatementType(struct soap *soap, const char *tag, struct saml1__AuthorizationDecisionStatementType *a, const char *type)
{
	size_t soap_flag_saml1__Subject = 1;
	struct soap_blist *soap_blist_saml1__Action = NULL;
	size_t soap_flag_saml1__Evidence = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct saml1__AuthorizationDecisionStatementType*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_saml1__AuthorizationDecisionStatementType, sizeof(struct saml1__AuthorizationDecisionStatementType), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_saml1__AuthorizationDecisionStatementType(soap, a);
	if (soap_s2string(soap, soap_attr_value(soap, "Resource", 1, 1), &a->Resource))
		return NULL;
	if (soap_s2saml1__DecisionType(soap, soap_attr_value(soap, "Decision", 5, 1), &a->Decision))
		return NULL;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_saml1__Subject && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTosaml1__SubjectType(soap, "saml1:Subject", &a->saml1__Subject, "saml1:SubjectType"))
				{	soap_flag_saml1__Subject--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "saml1:Action", 1, NULL))
			{	if (a->saml1__Action == NULL)
				{	if (soap_blist_saml1__Action == NULL)
						soap_blist_saml1__Action = soap_alloc_block(soap);
					a->saml1__Action = (struct saml1__ActionType *)soap_push_block_max(soap, soap_blist_saml1__Action, sizeof(struct saml1__ActionType));
					if (a->saml1__Action == NULL)
						return NULL;
					soap_default_saml1__ActionType(soap, a->saml1__Action);
				}
				soap_revert(soap);
				if (soap_in_saml1__ActionType(soap, "saml1:Action", a->saml1__Action, "saml1:ActionType"))
				{	a->__sizeAction++;
					a->saml1__Action = NULL;
					continue;
				}
			}
			if (soap_flag_saml1__Evidence && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTosaml1__EvidenceType(soap, "saml1:Evidence", &a->saml1__Evidence, "saml1:EvidenceType"))
				{	soap_flag_saml1__Evidence--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->saml1__Action)
			soap_pop_block(soap, soap_blist_saml1__Action);
		if (a->__sizeAction)
		{	a->saml1__Action = (struct saml1__ActionType *)soap_save_block(soap, soap_blist_saml1__Action, NULL, 1);
		}
		else
		{	a->saml1__Action = NULL;
			if (soap_blist_saml1__Action)
				soap_end_block(soap, soap_blist_saml1__Action);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (!a->saml1__Subject || a->__sizeAction < 1))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct saml1__AuthorizationDecisionStatementType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_saml1__AuthorizationDecisionStatementType, SOAP_TYPE_saml1__AuthorizationDecisionStatementType, sizeof(struct saml1__AuthorizationDecisionStatementType), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct saml1__AuthorizationDecisionStatementType * SOAP_FMAC4 soap_new_saml1__AuthorizationDecisionStatementType(struct soap *soap, int n)
{
	struct saml1__AuthorizationDecisionStatementType *p;
	struct saml1__AuthorizationDecisionStatementType *a = (struct saml1__AuthorizationDecisionStatementType*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct saml1__AuthorizationDecisionStatementType));
	for (p = a; p && n--; p++)
		soap_default_saml1__AuthorizationDecisionStatementType(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_saml1__AuthorizationDecisionStatementType(struct soap *soap, const struct saml1__AuthorizationDecisionStatementType *a, const char *tag, const char *type)
{
	if (soap_out_saml1__AuthorizationDecisionStatementType(soap, tag ? tag : "saml1:AuthorizationDecisionStatementType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct saml1__AuthorizationDecisionStatementType * SOAP_FMAC4 soap_get_saml1__AuthorizationDecisionStatementType(struct soap *soap, struct saml1__AuthorizationDecisionStatementType *p, const char *tag, const char *type)
{
	if ((p = soap_in_saml1__AuthorizationDecisionStatementType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_saml1__AuthorityBindingType(struct soap *soap, struct saml1__AuthorityBindingType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default__QName(soap, &a->AuthorityKind);
	soap_default_string(soap, &a->Location);
	soap_default_string(soap, &a->Binding);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_saml1__AuthorityBindingType(struct soap *soap, const struct saml1__AuthorityBindingType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_saml1__AuthorityBindingType(struct soap *soap, const char *tag, int id, const struct saml1__AuthorityBindingType *a, const char *type)
{
	soap_set_attr(soap, "AuthorityKind", a->AuthorityKind ? soap__QName2s(soap, a->AuthorityKind) : "", 1);
	soap_set_attr(soap, "Location", a->Location ? soap_string2s(soap, a->Location) : "", 1);
	soap_set_attr(soap, "Binding", a->Binding ? soap_string2s(soap, a->Binding) : "", 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_saml1__AuthorityBindingType), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct saml1__AuthorityBindingType * SOAP_FMAC4 soap_in_saml1__AuthorityBindingType(struct soap *soap, const char *tag, struct saml1__AuthorityBindingType *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct saml1__AuthorityBindingType*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_saml1__AuthorityBindingType, sizeof(struct saml1__AuthorityBindingType), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_saml1__AuthorityBindingType(soap, a);
	if (soap_s2_QName(soap, soap_attr_value(soap, "AuthorityKind", 2, 1), &a->AuthorityKind))
		return NULL;
	if (soap_s2string(soap, soap_attr_value(soap, "Location", 1, 1), &a->Location))
		return NULL;
	if (soap_s2string(soap, soap_attr_value(soap, "Binding", 1, 1), &a->Binding))
		return NULL;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct saml1__AuthorityBindingType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_saml1__AuthorityBindingType, SOAP_TYPE_saml1__AuthorityBindingType, sizeof(struct saml1__AuthorityBindingType), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct saml1__AuthorityBindingType * SOAP_FMAC4 soap_new_saml1__AuthorityBindingType(struct soap *soap, int n)
{
	struct saml1__AuthorityBindingType *p;
	struct saml1__AuthorityBindingType *a = (struct saml1__AuthorityBindingType*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct saml1__AuthorityBindingType));
	for (p = a; p && n--; p++)
		soap_default_saml1__AuthorityBindingType(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_saml1__AuthorityBindingType(struct soap *soap, const struct saml1__AuthorityBindingType *a, const char *tag, const char *type)
{
	if (soap_out_saml1__AuthorityBindingType(soap, tag ? tag : "saml1:AuthorityBindingType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct saml1__AuthorityBindingType * SOAP_FMAC4 soap_get_saml1__AuthorityBindingType(struct soap *soap, struct saml1__AuthorityBindingType *p, const char *tag, const char *type)
{
	if ((p = soap_in_saml1__AuthorityBindingType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_saml1__SubjectLocalityType(struct soap *soap, struct saml1__SubjectLocalityType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->IPAddress);
	soap_default_string(soap, &a->DNSAddress);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_saml1__SubjectLocalityType(struct soap *soap, const struct saml1__SubjectLocalityType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_saml1__SubjectLocalityType(struct soap *soap, const char *tag, int id, const struct saml1__SubjectLocalityType *a, const char *type)
{
	if (a->IPAddress)
		soap_set_attr(soap, "IPAddress", soap_string2s(soap, a->IPAddress), 1);
	if (a->DNSAddress)
		soap_set_attr(soap, "DNSAddress", soap_string2s(soap, a->DNSAddress), 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_saml1__SubjectLocalityType), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct saml1__SubjectLocalityType * SOAP_FMAC4 soap_in_saml1__SubjectLocalityType(struct soap *soap, const char *tag, struct saml1__SubjectLocalityType *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct saml1__SubjectLocalityType*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_saml1__SubjectLocalityType, sizeof(struct saml1__SubjectLocalityType), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_saml1__SubjectLocalityType(soap, a);
	if (soap_s2string(soap, soap_attr_value(soap, "IPAddress", 1, 0), &a->IPAddress))
		return NULL;
	if (soap_s2string(soap, soap_attr_value(soap, "DNSAddress", 1, 0), &a->DNSAddress))
		return NULL;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct saml1__SubjectLocalityType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_saml1__SubjectLocalityType, SOAP_TYPE_saml1__SubjectLocalityType, sizeof(struct saml1__SubjectLocalityType), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct saml1__SubjectLocalityType * SOAP_FMAC4 soap_new_saml1__SubjectLocalityType(struct soap *soap, int n)
{
	struct saml1__SubjectLocalityType *p;
	struct saml1__SubjectLocalityType *a = (struct saml1__SubjectLocalityType*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct saml1__SubjectLocalityType));
	for (p = a; p && n--; p++)
		soap_default_saml1__SubjectLocalityType(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_saml1__SubjectLocalityType(struct soap *soap, const struct saml1__SubjectLocalityType *a, const char *tag, const char *type)
{
	if (soap_out_saml1__SubjectLocalityType(soap, tag ? tag : "saml1:SubjectLocalityType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct saml1__SubjectLocalityType * SOAP_FMAC4 soap_get_saml1__SubjectLocalityType(struct soap *soap, struct saml1__SubjectLocalityType *p, const char *tag, const char *type)
{
	if ((p = soap_in_saml1__SubjectLocalityType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_saml1__AuthenticationStatementType(struct soap *soap, struct saml1__AuthenticationStatementType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->saml1__Subject = NULL;
	a->saml1__SubjectLocality = NULL;
	a->__sizeAuthorityBinding = 0;
	a->saml1__AuthorityBinding = NULL;
	soap_default_string(soap, &a->AuthenticationMethod);
	soap_default_xsd__dateTime(soap, &a->AuthenticationInstant);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_saml1__AuthenticationStatementType(struct soap *soap, const struct saml1__AuthenticationStatementType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTosaml1__SubjectType(soap, &a->saml1__Subject);
	soap_serialize_PointerTosaml1__SubjectLocalityType(soap, &a->saml1__SubjectLocality);
	if (a->saml1__AuthorityBinding)
	{	int i;
		for (i = 0; i < (int)a->__sizeAuthorityBinding; i++)
		{
			soap_embedded(soap, a->saml1__AuthorityBinding + i, SOAP_TYPE_saml1__AuthorityBindingType);
			soap_serialize_saml1__AuthorityBindingType(soap, a->saml1__AuthorityBinding + i);
		}
	}
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_saml1__AuthenticationStatementType(struct soap *soap, const char *tag, int id, const struct saml1__AuthenticationStatementType *a, const char *type)
{
	soap_set_attr(soap, "AuthenticationMethod", a->AuthenticationMethod ? soap_string2s(soap, a->AuthenticationMethod) : "", 1);
	soap_set_attr(soap, "AuthenticationInstant", soap_xsd__dateTime2s(soap, a->AuthenticationInstant), 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_saml1__AuthenticationStatementType), type))
		return soap->error;
	if (!a->saml1__Subject)
	{	if (soap_element_empty(soap, "saml1:Subject", 0, NULL))
			return soap->error;
	}
	else if (soap_out_PointerTosaml1__SubjectType(soap, "saml1:Subject", -1, &a->saml1__Subject, ""))
		return soap->error;
	if (soap_out_PointerTosaml1__SubjectLocalityType(soap, "saml1:SubjectLocality", -1, &a->saml1__SubjectLocality, ""))
		return soap->error;
	if (a->saml1__AuthorityBinding)
	{	int i;
		for (i = 0; i < (int)a->__sizeAuthorityBinding; i++)
			if (soap_out_saml1__AuthorityBindingType(soap, "saml1:AuthorityBinding", -1, a->saml1__AuthorityBinding + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct saml1__AuthenticationStatementType * SOAP_FMAC4 soap_in_saml1__AuthenticationStatementType(struct soap *soap, const char *tag, struct saml1__AuthenticationStatementType *a, const char *type)
{
	size_t soap_flag_saml1__Subject = 1;
	size_t soap_flag_saml1__SubjectLocality = 1;
	struct soap_blist *soap_blist_saml1__AuthorityBinding = NULL;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct saml1__AuthenticationStatementType*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_saml1__AuthenticationStatementType, sizeof(struct saml1__AuthenticationStatementType), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_saml1__AuthenticationStatementType(soap, a);
	if (soap_s2string(soap, soap_attr_value(soap, "AuthenticationMethod", 1, 1), &a->AuthenticationMethod))
		return NULL;
	if (soap_s2xsd__dateTime(soap, soap_attr_value(soap, "AuthenticationInstant", 5, 1), &a->AuthenticationInstant))
		return NULL;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_saml1__Subject && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTosaml1__SubjectType(soap, "saml1:Subject", &a->saml1__Subject, "saml1:SubjectType"))
				{	soap_flag_saml1__Subject--;
					continue;
				}
			}
			if (soap_flag_saml1__SubjectLocality && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTosaml1__SubjectLocalityType(soap, "saml1:SubjectLocality", &a->saml1__SubjectLocality, "saml1:SubjectLocalityType"))
				{	soap_flag_saml1__SubjectLocality--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "saml1:AuthorityBinding", 1, NULL))
			{	if (a->saml1__AuthorityBinding == NULL)
				{	if (soap_blist_saml1__AuthorityBinding == NULL)
						soap_blist_saml1__AuthorityBinding = soap_alloc_block(soap);
					a->saml1__AuthorityBinding = (struct saml1__AuthorityBindingType *)soap_push_block_max(soap, soap_blist_saml1__AuthorityBinding, sizeof(struct saml1__AuthorityBindingType));
					if (a->saml1__AuthorityBinding == NULL)
						return NULL;
					soap_default_saml1__AuthorityBindingType(soap, a->saml1__AuthorityBinding);
				}
				soap_revert(soap);
				if (soap_in_saml1__AuthorityBindingType(soap, "saml1:AuthorityBinding", a->saml1__AuthorityBinding, "saml1:AuthorityBindingType"))
				{	a->__sizeAuthorityBinding++;
					a->saml1__AuthorityBinding = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->saml1__AuthorityBinding)
			soap_pop_block(soap, soap_blist_saml1__AuthorityBinding);
		if (a->__sizeAuthorityBinding)
		{	a->saml1__AuthorityBinding = (struct saml1__AuthorityBindingType *)soap_save_block(soap, soap_blist_saml1__AuthorityBinding, NULL, 1);
		}
		else
		{	a->saml1__AuthorityBinding = NULL;
			if (soap_blist_saml1__AuthorityBinding)
				soap_end_block(soap, soap_blist_saml1__AuthorityBinding);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (!a->saml1__Subject))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct saml1__AuthenticationStatementType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_saml1__AuthenticationStatementType, SOAP_TYPE_saml1__AuthenticationStatementType, sizeof(struct saml1__AuthenticationStatementType), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct saml1__AuthenticationStatementType * SOAP_FMAC4 soap_new_saml1__AuthenticationStatementType(struct soap *soap, int n)
{
	struct saml1__AuthenticationStatementType *p;
	struct saml1__AuthenticationStatementType *a = (struct saml1__AuthenticationStatementType*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct saml1__AuthenticationStatementType));
	for (p = a; p && n--; p++)
		soap_default_saml1__AuthenticationStatementType(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_saml1__AuthenticationStatementType(struct soap *soap, const struct saml1__AuthenticationStatementType *a, const char *tag, const char *type)
{
	if (soap_out_saml1__AuthenticationStatementType(soap, tag ? tag : "saml1:AuthenticationStatementType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct saml1__AuthenticationStatementType * SOAP_FMAC4 soap_get_saml1__AuthenticationStatementType(struct soap *soap, struct saml1__AuthenticationStatementType *p, const char *tag, const char *type)
{
	if ((p = soap_in_saml1__AuthenticationStatementType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_saml1__SubjectConfirmationType(struct soap *soap, struct saml1__SubjectConfirmationType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__sizeConfirmationMethod = 0;
	a->saml1__ConfirmationMethod = NULL;
	a->saml1__SubjectConfirmationData = NULL;
	a->ds__KeyInfo = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_saml1__SubjectConfirmationType(struct soap *soap, const struct saml1__SubjectConfirmationType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (a->saml1__ConfirmationMethod)
	{	int i;
		for (i = 0; i < (int)a->__sizeConfirmationMethod; i++)
		{
			soap_serialize_string(soap, (char*const*)(a->saml1__ConfirmationMethod + i));
		}
	}
	soap_serialize_PointerTo_ds__KeyInfo(soap, &a->ds__KeyInfo);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_saml1__SubjectConfirmationType(struct soap *soap, const char *tag, int id, const struct saml1__SubjectConfirmationType *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_saml1__SubjectConfirmationType), type))
		return soap->error;
	if (a->saml1__ConfirmationMethod)
	{	int i;
		for (i = 0; i < (int)a->__sizeConfirmationMethod; i++)
			if (soap_out_string(soap, "saml1:ConfirmationMethod", -1, (char*const*)(a->saml1__ConfirmationMethod + i), ""))
				return soap->error;
	}
	if (soap_outliteral(soap, "saml1:SubjectConfirmationData", (char*const*)&a->saml1__SubjectConfirmationData, NULL))
		return soap->error;
	if (soap_out_PointerTo_ds__KeyInfo(soap, "ds:KeyInfo", -1, &a->ds__KeyInfo, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct saml1__SubjectConfirmationType * SOAP_FMAC4 soap_in_saml1__SubjectConfirmationType(struct soap *soap, const char *tag, struct saml1__SubjectConfirmationType *a, const char *type)
{
	struct soap_blist *soap_blist_saml1__ConfirmationMethod = NULL;
	size_t soap_flag_saml1__SubjectConfirmationData = 1;
	size_t soap_flag_ds__KeyInfo = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct saml1__SubjectConfirmationType*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_saml1__SubjectConfirmationType, sizeof(struct saml1__SubjectConfirmationType), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_saml1__SubjectConfirmationType(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "saml1:ConfirmationMethod", 1, NULL))
			{	if (a->saml1__ConfirmationMethod == NULL)
				{	if (soap_blist_saml1__ConfirmationMethod == NULL)
						soap_blist_saml1__ConfirmationMethod = soap_alloc_block(soap);
					a->saml1__ConfirmationMethod = (char **)soap_push_block_max(soap, soap_blist_saml1__ConfirmationMethod, sizeof(char *));
					if (a->saml1__ConfirmationMethod == NULL)
						return NULL;
					*a->saml1__ConfirmationMethod = NULL;
				}
				soap_revert(soap);
				if (soap_in_string(soap, "saml1:ConfirmationMethod", (char**)a->saml1__ConfirmationMethod, "xsd:string"))
				{	a->__sizeConfirmationMethod++;
					a->saml1__ConfirmationMethod = NULL;
					continue;
				}
			}
			if (soap_flag_saml1__SubjectConfirmationData && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_inliteral(soap, "saml1:SubjectConfirmationData", (char**)&a->saml1__SubjectConfirmationData))
				{	soap_flag_saml1__SubjectConfirmationData--;
					continue;
				}
			}
			if (soap_flag_ds__KeyInfo && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_ds__KeyInfo(soap, "ds:KeyInfo", &a->ds__KeyInfo, ""))
				{	soap_flag_ds__KeyInfo--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->saml1__ConfirmationMethod)
			soap_pop_block(soap, soap_blist_saml1__ConfirmationMethod);
		if (a->__sizeConfirmationMethod)
		{	a->saml1__ConfirmationMethod = (char **)soap_save_block(soap, soap_blist_saml1__ConfirmationMethod, NULL, 1);
		}
		else
		{	a->saml1__ConfirmationMethod = NULL;
			if (soap_blist_saml1__ConfirmationMethod)
				soap_end_block(soap, soap_blist_saml1__ConfirmationMethod);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (a->__sizeConfirmationMethod < 1))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct saml1__SubjectConfirmationType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_saml1__SubjectConfirmationType, SOAP_TYPE_saml1__SubjectConfirmationType, sizeof(struct saml1__SubjectConfirmationType), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct saml1__SubjectConfirmationType * SOAP_FMAC4 soap_new_saml1__SubjectConfirmationType(struct soap *soap, int n)
{
	struct saml1__SubjectConfirmationType *p;
	struct saml1__SubjectConfirmationType *a = (struct saml1__SubjectConfirmationType*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct saml1__SubjectConfirmationType));
	for (p = a; p && n--; p++)
		soap_default_saml1__SubjectConfirmationType(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_saml1__SubjectConfirmationType(struct soap *soap, const struct saml1__SubjectConfirmationType *a, const char *tag, const char *type)
{
	if (soap_out_saml1__SubjectConfirmationType(soap, tag ? tag : "saml1:SubjectConfirmationType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct saml1__SubjectConfirmationType * SOAP_FMAC4 soap_get_saml1__SubjectConfirmationType(struct soap *soap, struct saml1__SubjectConfirmationType *p, const char *tag, const char *type)
{
	if ((p = soap_in_saml1__SubjectConfirmationType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_saml1__NameIdentifierType(struct soap *soap, struct saml1__NameIdentifierType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->__item);
	soap_default_string(soap, &a->NameQualifier);
	soap_default_string(soap, &a->Format);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_saml1__NameIdentifierType(struct soap *soap, const struct saml1__NameIdentifierType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_string(soap, (char*const*)&a->__item);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_saml1__NameIdentifierType(struct soap *soap, const char *tag, int id, const struct saml1__NameIdentifierType *a, const char *type)
{
	if (a->NameQualifier)
		soap_set_attr(soap, "NameQualifier", soap_string2s(soap, a->NameQualifier), 1);
	if (a->Format)
		soap_set_attr(soap, "Format", soap_string2s(soap, a->Format), 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	return soap_out_string(soap, tag, id, (char*const*)&a->__item, "");
}

SOAP_FMAC3 struct saml1__NameIdentifierType * SOAP_FMAC4 soap_in_saml1__NameIdentifierType(struct soap *soap, const char *tag, struct saml1__NameIdentifierType *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	if (!(a = (struct saml1__NameIdentifierType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_saml1__NameIdentifierType, sizeof(struct saml1__NameIdentifierType), NULL, NULL, NULL, NULL)))
		return NULL;
	soap_revert(soap);
	*soap->id = '\0';
	soap_default_saml1__NameIdentifierType(soap, a);
	if (soap_s2string(soap, soap_attr_value(soap, "NameQualifier", 1, 0), &a->NameQualifier))
		return NULL;
	if (soap_s2string(soap, soap_attr_value(soap, "Format", 1, 0), &a->Format))
		return NULL;
	if (!soap_in_string(soap, tag, (char**)&a->__item, "saml1:NameIdentifierType"))
		return NULL;
	return a;
}

SOAP_FMAC3 struct saml1__NameIdentifierType * SOAP_FMAC4 soap_new_saml1__NameIdentifierType(struct soap *soap, int n)
{
	struct saml1__NameIdentifierType *p;
	struct saml1__NameIdentifierType *a = (struct saml1__NameIdentifierType*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct saml1__NameIdentifierType));
	for (p = a; p && n--; p++)
		soap_default_saml1__NameIdentifierType(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_saml1__NameIdentifierType(struct soap *soap, const struct saml1__NameIdentifierType *a, const char *tag, const char *type)
{
	if (soap_out_saml1__NameIdentifierType(soap, tag ? tag : "saml1:NameIdentifierType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct saml1__NameIdentifierType * SOAP_FMAC4 soap_get_saml1__NameIdentifierType(struct soap *soap, struct saml1__NameIdentifierType *p, const char *tag, const char *type)
{
	if ((p = soap_in_saml1__NameIdentifierType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_saml1__SubjectType(struct soap *soap, struct saml1__SubjectType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->saml1__NameIdentifier = NULL;
	a->saml1__SubjectConfirmation = NULL;
	a->saml1__SubjectConfirmation_ = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_saml1__SubjectType(struct soap *soap, const struct saml1__SubjectType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTosaml1__NameIdentifierType(soap, &a->saml1__NameIdentifier);
	soap_serialize_PointerTosaml1__SubjectConfirmationType(soap, &a->saml1__SubjectConfirmation);
	soap_serialize_PointerTosaml1__SubjectConfirmationType(soap, &a->saml1__SubjectConfirmation_);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_saml1__SubjectType(struct soap *soap, const char *tag, int id, const struct saml1__SubjectType *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_saml1__SubjectType), type))
		return soap->error;
	if (soap_out_PointerTosaml1__NameIdentifierType(soap, "saml1:NameIdentifier", -1, &a->saml1__NameIdentifier, ""))
		return soap->error;
	if (soap_out_PointerTosaml1__SubjectConfirmationType(soap, "saml1:SubjectConfirmation", -1, &a->saml1__SubjectConfirmation, ""))
		return soap->error;
	if (soap_out_PointerTosaml1__SubjectConfirmationType(soap, "saml1:SubjectConfirmation", -1, &a->saml1__SubjectConfirmation_, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct saml1__SubjectType * SOAP_FMAC4 soap_in_saml1__SubjectType(struct soap *soap, const char *tag, struct saml1__SubjectType *a, const char *type)
{
	size_t soap_flag_saml1__NameIdentifier = 1;
	size_t soap_flag_saml1__SubjectConfirmation = 1;
	size_t soap_flag_saml1__SubjectConfirmation_ = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct saml1__SubjectType*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_saml1__SubjectType, sizeof(struct saml1__SubjectType), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_saml1__SubjectType(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_saml1__NameIdentifier && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTosaml1__NameIdentifierType(soap, "saml1:NameIdentifier", &a->saml1__NameIdentifier, "saml1:NameIdentifierType"))
				{	soap_flag_saml1__NameIdentifier--;
					continue;
				}
			}
			if (soap_flag_saml1__SubjectConfirmation && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTosaml1__SubjectConfirmationType(soap, "saml1:SubjectConfirmation", &a->saml1__SubjectConfirmation, "saml1:SubjectConfirmationType"))
				{	soap_flag_saml1__SubjectConfirmation--;
					continue;
				}
			}
			if (soap_flag_saml1__SubjectConfirmation_ && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTosaml1__SubjectConfirmationType(soap, "saml1:SubjectConfirmation", &a->saml1__SubjectConfirmation_, "saml1:SubjectConfirmationType"))
				{	soap_flag_saml1__SubjectConfirmation_--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct saml1__SubjectType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_saml1__SubjectType, SOAP_TYPE_saml1__SubjectType, sizeof(struct saml1__SubjectType), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct saml1__SubjectType * SOAP_FMAC4 soap_new_saml1__SubjectType(struct soap *soap, int n)
{
	struct saml1__SubjectType *p;
	struct saml1__SubjectType *a = (struct saml1__SubjectType*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct saml1__SubjectType));
	for (p = a; p && n--; p++)
		soap_default_saml1__SubjectType(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_saml1__SubjectType(struct soap *soap, const struct saml1__SubjectType *a, const char *tag, const char *type)
{
	if (soap_out_saml1__SubjectType(soap, tag ? tag : "saml1:SubjectType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct saml1__SubjectType * SOAP_FMAC4 soap_get_saml1__SubjectType(struct soap *soap, struct saml1__SubjectType *p, const char *tag, const char *type)
{
	if ((p = soap_in_saml1__SubjectType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_saml1__SubjectStatementAbstractType(struct soap *soap, struct saml1__SubjectStatementAbstractType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->saml1__Subject = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_saml1__SubjectStatementAbstractType(struct soap *soap, const struct saml1__SubjectStatementAbstractType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTosaml1__SubjectType(soap, &a->saml1__Subject);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_saml1__SubjectStatementAbstractType(struct soap *soap, const char *tag, int id, const struct saml1__SubjectStatementAbstractType *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_saml1__SubjectStatementAbstractType), type))
		return soap->error;
	if (!a->saml1__Subject)
	{	if (soap_element_empty(soap, "saml1:Subject", 0, NULL))
			return soap->error;
	}
	else if (soap_out_PointerTosaml1__SubjectType(soap, "saml1:Subject", -1, &a->saml1__Subject, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct saml1__SubjectStatementAbstractType * SOAP_FMAC4 soap_in_saml1__SubjectStatementAbstractType(struct soap *soap, const char *tag, struct saml1__SubjectStatementAbstractType *a, const char *type)
{
	size_t soap_flag_saml1__Subject = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct saml1__SubjectStatementAbstractType*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_saml1__SubjectStatementAbstractType, sizeof(struct saml1__SubjectStatementAbstractType), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_saml1__SubjectStatementAbstractType(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_saml1__Subject && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTosaml1__SubjectType(soap, "saml1:Subject", &a->saml1__Subject, "saml1:SubjectType"))
				{	soap_flag_saml1__Subject--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (!a->saml1__Subject))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct saml1__SubjectStatementAbstractType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_saml1__SubjectStatementAbstractType, SOAP_TYPE_saml1__SubjectStatementAbstractType, sizeof(struct saml1__SubjectStatementAbstractType), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct saml1__SubjectStatementAbstractType * SOAP_FMAC4 soap_new_saml1__SubjectStatementAbstractType(struct soap *soap, int n)
{
	struct saml1__SubjectStatementAbstractType *p;
	struct saml1__SubjectStatementAbstractType *a = (struct saml1__SubjectStatementAbstractType*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct saml1__SubjectStatementAbstractType));
	for (p = a; p && n--; p++)
		soap_default_saml1__SubjectStatementAbstractType(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_saml1__SubjectStatementAbstractType(struct soap *soap, const struct saml1__SubjectStatementAbstractType *a, const char *tag, const char *type)
{
	if (soap_out_saml1__SubjectStatementAbstractType(soap, tag ? tag : "saml1:SubjectStatementAbstractType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct saml1__SubjectStatementAbstractType * SOAP_FMAC4 soap_get_saml1__SubjectStatementAbstractType(struct soap *soap, struct saml1__SubjectStatementAbstractType *p, const char *tag, const char *type)
{
	if ((p = soap_in_saml1__SubjectStatementAbstractType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_saml1__StatementAbstractType(struct soap *soap, struct saml1__StatementAbstractType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_saml1__StatementAbstractType(struct soap *soap, const struct saml1__StatementAbstractType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_saml1__StatementAbstractType(struct soap *soap, const char *tag, int id, const struct saml1__StatementAbstractType *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_saml1__StatementAbstractType), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct saml1__StatementAbstractType * SOAP_FMAC4 soap_in_saml1__StatementAbstractType(struct soap *soap, const char *tag, struct saml1__StatementAbstractType *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct saml1__StatementAbstractType*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_saml1__StatementAbstractType, sizeof(struct saml1__StatementAbstractType), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_saml1__StatementAbstractType(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct saml1__StatementAbstractType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_saml1__StatementAbstractType, SOAP_TYPE_saml1__StatementAbstractType, sizeof(struct saml1__StatementAbstractType), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct saml1__StatementAbstractType * SOAP_FMAC4 soap_new_saml1__StatementAbstractType(struct soap *soap, int n)
{
	struct saml1__StatementAbstractType *p;
	struct saml1__StatementAbstractType *a = (struct saml1__StatementAbstractType*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct saml1__StatementAbstractType));
	for (p = a; p && n--; p++)
		soap_default_saml1__StatementAbstractType(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_saml1__StatementAbstractType(struct soap *soap, const struct saml1__StatementAbstractType *a, const char *tag, const char *type)
{
	if (soap_out_saml1__StatementAbstractType(soap, tag ? tag : "saml1:StatementAbstractType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct saml1__StatementAbstractType * SOAP_FMAC4 soap_get_saml1__StatementAbstractType(struct soap *soap, struct saml1__StatementAbstractType *p, const char *tag, const char *type)
{
	if ((p = soap_in_saml1__StatementAbstractType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_saml1__AdviceType(struct soap *soap, struct saml1__AdviceType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__size_AdviceType = 0;
	a->__union_AdviceType = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_saml1__AdviceType(struct soap *soap, const struct saml1__AdviceType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (a->__union_AdviceType)
	{	int i;
		for (i = 0; i < (int)a->__size_AdviceType; i++)
		{
			soap_serialize___saml1__union_AdviceType(soap, a->__union_AdviceType + i);
		}
	}
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_saml1__AdviceType(struct soap *soap, const char *tag, int id, const struct saml1__AdviceType *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_saml1__AdviceType), type))
		return soap->error;
	if (a->__union_AdviceType)
	{	int i;
		for (i = 0; i < (int)a->__size_AdviceType; i++)
			if (soap_out___saml1__union_AdviceType(soap, "-union-AdviceType", -1, a->__union_AdviceType + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct saml1__AdviceType * SOAP_FMAC4 soap_in_saml1__AdviceType(struct soap *soap, const char *tag, struct saml1__AdviceType *a, const char *type)
{
	struct soap_blist *soap_blist___union_AdviceType = NULL;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct saml1__AdviceType*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_saml1__AdviceType, sizeof(struct saml1__AdviceType), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_saml1__AdviceType(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	if (a->__union_AdviceType == NULL)
				{	if (soap_blist___union_AdviceType == NULL)
						soap_blist___union_AdviceType = soap_alloc_block(soap);
					a->__union_AdviceType = (struct __saml1__union_AdviceType *)soap_push_block_max(soap, soap_blist___union_AdviceType, sizeof(struct __saml1__union_AdviceType));
					if (a->__union_AdviceType == NULL)
						return NULL;
					soap_default___saml1__union_AdviceType(soap, a->__union_AdviceType);
				}
				if (soap_in___saml1__union_AdviceType(soap, "-union-AdviceType", a->__union_AdviceType, "-saml1:union-AdviceType"))
				{	a->__size_AdviceType++;
					a->__union_AdviceType = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->__union_AdviceType)
			soap_pop_block(soap, soap_blist___union_AdviceType);
		if (a->__size_AdviceType)
		{	a->__union_AdviceType = (struct __saml1__union_AdviceType *)soap_save_block(soap, soap_blist___union_AdviceType, NULL, 1);
		}
		else
		{	a->__union_AdviceType = NULL;
			if (soap_blist___union_AdviceType)
				soap_end_block(soap, soap_blist___union_AdviceType);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct saml1__AdviceType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_saml1__AdviceType, SOAP_TYPE_saml1__AdviceType, sizeof(struct saml1__AdviceType), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct saml1__AdviceType * SOAP_FMAC4 soap_new_saml1__AdviceType(struct soap *soap, int n)
{
	struct saml1__AdviceType *p;
	struct saml1__AdviceType *a = (struct saml1__AdviceType*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct saml1__AdviceType));
	for (p = a; p && n--; p++)
		soap_default_saml1__AdviceType(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_saml1__AdviceType(struct soap *soap, const struct saml1__AdviceType *a, const char *tag, const char *type)
{
	if (soap_out_saml1__AdviceType(soap, tag ? tag : "saml1:AdviceType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct saml1__AdviceType * SOAP_FMAC4 soap_get_saml1__AdviceType(struct soap *soap, struct saml1__AdviceType *p, const char *tag, const char *type)
{
	if ((p = soap_in_saml1__AdviceType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_saml1__DoNotCacheConditionType(struct soap *soap, struct saml1__DoNotCacheConditionType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_saml1__DoNotCacheConditionType(struct soap *soap, const struct saml1__DoNotCacheConditionType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_saml1__DoNotCacheConditionType(struct soap *soap, const char *tag, int id, const struct saml1__DoNotCacheConditionType *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_saml1__DoNotCacheConditionType), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct saml1__DoNotCacheConditionType * SOAP_FMAC4 soap_in_saml1__DoNotCacheConditionType(struct soap *soap, const char *tag, struct saml1__DoNotCacheConditionType *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct saml1__DoNotCacheConditionType*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_saml1__DoNotCacheConditionType, sizeof(struct saml1__DoNotCacheConditionType), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_saml1__DoNotCacheConditionType(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct saml1__DoNotCacheConditionType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_saml1__DoNotCacheConditionType, SOAP_TYPE_saml1__DoNotCacheConditionType, sizeof(struct saml1__DoNotCacheConditionType), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct saml1__DoNotCacheConditionType * SOAP_FMAC4 soap_new_saml1__DoNotCacheConditionType(struct soap *soap, int n)
{
	struct saml1__DoNotCacheConditionType *p;
	struct saml1__DoNotCacheConditionType *a = (struct saml1__DoNotCacheConditionType*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct saml1__DoNotCacheConditionType));
	for (p = a; p && n--; p++)
		soap_default_saml1__DoNotCacheConditionType(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_saml1__DoNotCacheConditionType(struct soap *soap, const struct saml1__DoNotCacheConditionType *a, const char *tag, const char *type)
{
	if (soap_out_saml1__DoNotCacheConditionType(soap, tag ? tag : "saml1:DoNotCacheConditionType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct saml1__DoNotCacheConditionType * SOAP_FMAC4 soap_get_saml1__DoNotCacheConditionType(struct soap *soap, struct saml1__DoNotCacheConditionType *p, const char *tag, const char *type)
{
	if ((p = soap_in_saml1__DoNotCacheConditionType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_saml1__AudienceRestrictionConditionType(struct soap *soap, struct saml1__AudienceRestrictionConditionType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__sizeAudience = 0;
	a->saml1__Audience = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_saml1__AudienceRestrictionConditionType(struct soap *soap, const struct saml1__AudienceRestrictionConditionType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (a->saml1__Audience)
	{	int i;
		for (i = 0; i < (int)a->__sizeAudience; i++)
		{
			soap_serialize_string(soap, (char*const*)(a->saml1__Audience + i));
		}
	}
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_saml1__AudienceRestrictionConditionType(struct soap *soap, const char *tag, int id, const struct saml1__AudienceRestrictionConditionType *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_saml1__AudienceRestrictionConditionType), type))
		return soap->error;
	if (a->saml1__Audience)
	{	int i;
		for (i = 0; i < (int)a->__sizeAudience; i++)
			if (soap_out_string(soap, "saml1:Audience", -1, (char*const*)(a->saml1__Audience + i), ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct saml1__AudienceRestrictionConditionType * SOAP_FMAC4 soap_in_saml1__AudienceRestrictionConditionType(struct soap *soap, const char *tag, struct saml1__AudienceRestrictionConditionType *a, const char *type)
{
	struct soap_blist *soap_blist_saml1__Audience = NULL;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct saml1__AudienceRestrictionConditionType*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_saml1__AudienceRestrictionConditionType, sizeof(struct saml1__AudienceRestrictionConditionType), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_saml1__AudienceRestrictionConditionType(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "saml1:Audience", 1, NULL))
			{	if (a->saml1__Audience == NULL)
				{	if (soap_blist_saml1__Audience == NULL)
						soap_blist_saml1__Audience = soap_alloc_block(soap);
					a->saml1__Audience = (char **)soap_push_block_max(soap, soap_blist_saml1__Audience, sizeof(char *));
					if (a->saml1__Audience == NULL)
						return NULL;
					*a->saml1__Audience = NULL;
				}
				soap_revert(soap);
				if (soap_in_string(soap, "saml1:Audience", (char**)a->saml1__Audience, "xsd:string"))
				{	a->__sizeAudience++;
					a->saml1__Audience = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->saml1__Audience)
			soap_pop_block(soap, soap_blist_saml1__Audience);
		if (a->__sizeAudience)
		{	a->saml1__Audience = (char **)soap_save_block(soap, soap_blist_saml1__Audience, NULL, 1);
		}
		else
		{	a->saml1__Audience = NULL;
			if (soap_blist_saml1__Audience)
				soap_end_block(soap, soap_blist_saml1__Audience);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (a->__sizeAudience < 1))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct saml1__AudienceRestrictionConditionType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_saml1__AudienceRestrictionConditionType, SOAP_TYPE_saml1__AudienceRestrictionConditionType, sizeof(struct saml1__AudienceRestrictionConditionType), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct saml1__AudienceRestrictionConditionType * SOAP_FMAC4 soap_new_saml1__AudienceRestrictionConditionType(struct soap *soap, int n)
{
	struct saml1__AudienceRestrictionConditionType *p;
	struct saml1__AudienceRestrictionConditionType *a = (struct saml1__AudienceRestrictionConditionType*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct saml1__AudienceRestrictionConditionType));
	for (p = a; p && n--; p++)
		soap_default_saml1__AudienceRestrictionConditionType(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_saml1__AudienceRestrictionConditionType(struct soap *soap, const struct saml1__AudienceRestrictionConditionType *a, const char *tag, const char *type)
{
	if (soap_out_saml1__AudienceRestrictionConditionType(soap, tag ? tag : "saml1:AudienceRestrictionConditionType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct saml1__AudienceRestrictionConditionType * SOAP_FMAC4 soap_get_saml1__AudienceRestrictionConditionType(struct soap *soap, struct saml1__AudienceRestrictionConditionType *p, const char *tag, const char *type)
{
	if ((p = soap_in_saml1__AudienceRestrictionConditionType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_saml1__ConditionAbstractType(struct soap *soap, struct saml1__ConditionAbstractType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_saml1__ConditionAbstractType(struct soap *soap, const struct saml1__ConditionAbstractType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_saml1__ConditionAbstractType(struct soap *soap, const char *tag, int id, const struct saml1__ConditionAbstractType *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_saml1__ConditionAbstractType), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct saml1__ConditionAbstractType * SOAP_FMAC4 soap_in_saml1__ConditionAbstractType(struct soap *soap, const char *tag, struct saml1__ConditionAbstractType *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct saml1__ConditionAbstractType*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_saml1__ConditionAbstractType, sizeof(struct saml1__ConditionAbstractType), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_saml1__ConditionAbstractType(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct saml1__ConditionAbstractType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_saml1__ConditionAbstractType, SOAP_TYPE_saml1__ConditionAbstractType, sizeof(struct saml1__ConditionAbstractType), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct saml1__ConditionAbstractType * SOAP_FMAC4 soap_new_saml1__ConditionAbstractType(struct soap *soap, int n)
{
	struct saml1__ConditionAbstractType *p;
	struct saml1__ConditionAbstractType *a = (struct saml1__ConditionAbstractType*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct saml1__ConditionAbstractType));
	for (p = a; p && n--; p++)
		soap_default_saml1__ConditionAbstractType(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_saml1__ConditionAbstractType(struct soap *soap, const struct saml1__ConditionAbstractType *a, const char *tag, const char *type)
{
	if (soap_out_saml1__ConditionAbstractType(soap, tag ? tag : "saml1:ConditionAbstractType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct saml1__ConditionAbstractType * SOAP_FMAC4 soap_get_saml1__ConditionAbstractType(struct soap *soap, struct saml1__ConditionAbstractType *p, const char *tag, const char *type)
{
	if ((p = soap_in_saml1__ConditionAbstractType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_saml1__ConditionsType(struct soap *soap, struct saml1__ConditionsType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__size_ConditionsType = 0;
	a->__union_ConditionsType = NULL;
	a->NotBefore = NULL;
	a->NotOnOrAfter = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_saml1__ConditionsType(struct soap *soap, const struct saml1__ConditionsType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (a->__union_ConditionsType)
	{	int i;
		for (i = 0; i < (int)a->__size_ConditionsType; i++)
		{
			soap_serialize___saml1__union_ConditionsType(soap, a->__union_ConditionsType + i);
		}
	}
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_saml1__ConditionsType(struct soap *soap, const char *tag, int id, const struct saml1__ConditionsType *a, const char *type)
{
	if (a->NotBefore)
	{	soap_set_attr(soap, "NotBefore", soap_xsd__dateTime2s(soap, *a->NotBefore), 1);
	}
	if (a->NotOnOrAfter)
	{	soap_set_attr(soap, "NotOnOrAfter", soap_xsd__dateTime2s(soap, *a->NotOnOrAfter), 1);
	}
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_saml1__ConditionsType), type))
		return soap->error;
	if (a->__union_ConditionsType)
	{	int i;
		for (i = 0; i < (int)a->__size_ConditionsType; i++)
			if (soap_out___saml1__union_ConditionsType(soap, "-union-ConditionsType", -1, a->__union_ConditionsType + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct saml1__ConditionsType * SOAP_FMAC4 soap_in_saml1__ConditionsType(struct soap *soap, const char *tag, struct saml1__ConditionsType *a, const char *type)
{
	struct soap_blist *soap_blist___union_ConditionsType = NULL;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct saml1__ConditionsType*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_saml1__ConditionsType, sizeof(struct saml1__ConditionsType), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_saml1__ConditionsType(soap, a);
	{
		const char *t = soap_attr_value(soap, "NotBefore", 5, 0);
		if (t)
		{
			if (!(a->NotBefore = (struct timeval *)soap_malloc(soap, sizeof(struct timeval))))
				return NULL;
			if (soap_s2xsd__dateTime(soap, t, a->NotBefore))
				return NULL;
		}
		else if (soap->error)
			return NULL;
	}
	{
		const char *t = soap_attr_value(soap, "NotOnOrAfter", 5, 0);
		if (t)
		{
			if (!(a->NotOnOrAfter = (struct timeval *)soap_malloc(soap, sizeof(struct timeval))))
				return NULL;
			if (soap_s2xsd__dateTime(soap, t, a->NotOnOrAfter))
				return NULL;
		}
		else if (soap->error)
			return NULL;
	}
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	if (a->__union_ConditionsType == NULL)
				{	if (soap_blist___union_ConditionsType == NULL)
						soap_blist___union_ConditionsType = soap_alloc_block(soap);
					a->__union_ConditionsType = (struct __saml1__union_ConditionsType *)soap_push_block_max(soap, soap_blist___union_ConditionsType, sizeof(struct __saml1__union_ConditionsType));
					if (a->__union_ConditionsType == NULL)
						return NULL;
					soap_default___saml1__union_ConditionsType(soap, a->__union_ConditionsType);
				}
				if (soap_in___saml1__union_ConditionsType(soap, "-union-ConditionsType", a->__union_ConditionsType, "-saml1:union-ConditionsType"))
				{	a->__size_ConditionsType++;
					a->__union_ConditionsType = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->__union_ConditionsType)
			soap_pop_block(soap, soap_blist___union_ConditionsType);
		if (a->__size_ConditionsType)
		{	a->__union_ConditionsType = (struct __saml1__union_ConditionsType *)soap_save_block(soap, soap_blist___union_ConditionsType, NULL, 1);
		}
		else
		{	a->__union_ConditionsType = NULL;
			if (soap_blist___union_ConditionsType)
				soap_end_block(soap, soap_blist___union_ConditionsType);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct saml1__ConditionsType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_saml1__ConditionsType, SOAP_TYPE_saml1__ConditionsType, sizeof(struct saml1__ConditionsType), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct saml1__ConditionsType * SOAP_FMAC4 soap_new_saml1__ConditionsType(struct soap *soap, int n)
{
	struct saml1__ConditionsType *p;
	struct saml1__ConditionsType *a = (struct saml1__ConditionsType*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct saml1__ConditionsType));
	for (p = a; p && n--; p++)
		soap_default_saml1__ConditionsType(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_saml1__ConditionsType(struct soap *soap, const struct saml1__ConditionsType *a, const char *tag, const char *type)
{
	if (soap_out_saml1__ConditionsType(soap, tag ? tag : "saml1:ConditionsType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct saml1__ConditionsType * SOAP_FMAC4 soap_get_saml1__ConditionsType(struct soap *soap, struct saml1__ConditionsType *p, const char *tag, const char *type)
{
	if ((p = soap_in_saml1__ConditionsType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_saml1__AssertionType(struct soap *soap, struct saml1__AssertionType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->saml1__Conditions = NULL;
	a->saml1__Advice = NULL;
	a->__size_AssertionType = 0;
	a->__union_AssertionType = NULL;
	a->ds__Signature = NULL;
	soap_default_string(soap, &a->MajorVersion);
	soap_default_string(soap, &a->MinorVersion);
	soap_default_string(soap, &a->AssertionID);
	soap_default_string(soap, &a->Issuer);
	soap_default_xsd__dateTime(soap, &a->IssueInstant);
	soap_default_string(soap, &a->wsu__Id);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_saml1__AssertionType(struct soap *soap, const struct saml1__AssertionType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTosaml1__ConditionsType(soap, &a->saml1__Conditions);
	soap_serialize_PointerTosaml1__AdviceType(soap, &a->saml1__Advice);
	if (a->__union_AssertionType)
	{	int i;
		for (i = 0; i < (int)a->__size_AssertionType; i++)
		{
			soap_serialize___saml1__union_AssertionType(soap, a->__union_AssertionType + i);
		}
	}
	soap_serialize_PointerTo_ds__Signature(soap, &a->ds__Signature);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_saml1__AssertionType(struct soap *soap, const char *tag, int id, const struct saml1__AssertionType *a, const char *type)
{
	soap_set_attr(soap, "MajorVersion", a->MajorVersion ? soap_string2s(soap, a->MajorVersion) : "", 1);
	soap_set_attr(soap, "MinorVersion", a->MinorVersion ? soap_string2s(soap, a->MinorVersion) : "", 1);
	soap_set_attr(soap, "AssertionID", a->AssertionID ? soap_string2s(soap, a->AssertionID) : "", 1);
	soap_set_attr(soap, "Issuer", a->Issuer ? soap_string2s(soap, a->Issuer) : "", 1);
	soap_set_attr(soap, "IssueInstant", soap_xsd__dateTime2s(soap, a->IssueInstant), 1);
	if (a->wsu__Id)
		soap_set_attr(soap, "wsu:Id", soap_string2s(soap, a->wsu__Id), 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_saml1__AssertionType), type))
		return soap->error;
	if (soap_out_PointerTosaml1__ConditionsType(soap, "saml1:Conditions", -1, &a->saml1__Conditions, ""))
		return soap->error;
	if (soap_out_PointerTosaml1__AdviceType(soap, "saml1:Advice", -1, &a->saml1__Advice, ""))
		return soap->error;
	if (a->__union_AssertionType)
	{	int i;
		for (i = 0; i < (int)a->__size_AssertionType; i++)
			if (soap_out___saml1__union_AssertionType(soap, "-union-AssertionType", -1, a->__union_AssertionType + i, ""))
				return soap->error;
	}
	if (soap_out_PointerTo_ds__Signature(soap, "ds:Signature", -1, &a->ds__Signature, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct saml1__AssertionType * SOAP_FMAC4 soap_in_saml1__AssertionType(struct soap *soap, const char *tag, struct saml1__AssertionType *a, const char *type)
{
	size_t soap_flag_saml1__Conditions = 1;
	size_t soap_flag_saml1__Advice = 1;
	struct soap_blist *soap_blist___union_AssertionType = NULL;
	size_t soap_flag_ds__Signature = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct saml1__AssertionType*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_saml1__AssertionType, sizeof(struct saml1__AssertionType), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_saml1__AssertionType(soap, a);
	if (soap_s2string(soap, soap_attr_value(soap, "MajorVersion", 1, 1), &a->MajorVersion))
		return NULL;
	if (soap_s2string(soap, soap_attr_value(soap, "MinorVersion", 1, 1), &a->MinorVersion))
		return NULL;
	if (soap_s2string(soap, soap_attr_value(soap, "AssertionID", 1, 1), &a->AssertionID))
		return NULL;
	if (soap_s2string(soap, soap_attr_value(soap, "Issuer", 1, 1), &a->Issuer))
		return NULL;
	if (soap_s2xsd__dateTime(soap, soap_attr_value(soap, "IssueInstant", 5, 1), &a->IssueInstant))
		return NULL;
	if (soap_s2string(soap, soap_attr_value(soap, "wsu:Id", 1, 0), &a->wsu__Id))
		return NULL;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_saml1__Conditions && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTosaml1__ConditionsType(soap, "saml1:Conditions", &a->saml1__Conditions, "saml1:ConditionsType"))
				{	soap_flag_saml1__Conditions--;
					continue;
				}
			}
			if (soap_flag_saml1__Advice && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTosaml1__AdviceType(soap, "saml1:Advice", &a->saml1__Advice, "saml1:AdviceType"))
				{	soap_flag_saml1__Advice--;
					continue;
				}
			}
			if (soap_flag_ds__Signature && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_ds__Signature(soap, "ds:Signature", &a->ds__Signature, ""))
				{	soap_flag_ds__Signature--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	if (a->__union_AssertionType == NULL)
				{	if (soap_blist___union_AssertionType == NULL)
						soap_blist___union_AssertionType = soap_alloc_block(soap);
					a->__union_AssertionType = (struct __saml1__union_AssertionType *)soap_push_block_max(soap, soap_blist___union_AssertionType, sizeof(struct __saml1__union_AssertionType));
					if (a->__union_AssertionType == NULL)
						return NULL;
					soap_default___saml1__union_AssertionType(soap, a->__union_AssertionType);
				}
				if (soap_in___saml1__union_AssertionType(soap, "-union-AssertionType", a->__union_AssertionType, "-saml1:union-AssertionType"))
				{	a->__size_AssertionType++;
					a->__union_AssertionType = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->__union_AssertionType)
			soap_pop_block(soap, soap_blist___union_AssertionType);
		if (a->__size_AssertionType)
		{	a->__union_AssertionType = (struct __saml1__union_AssertionType *)soap_save_block(soap, soap_blist___union_AssertionType, NULL, 1);
		}
		else
		{	a->__union_AssertionType = NULL;
			if (soap_blist___union_AssertionType)
				soap_end_block(soap, soap_blist___union_AssertionType);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct saml1__AssertionType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_saml1__AssertionType, SOAP_TYPE_saml1__AssertionType, sizeof(struct saml1__AssertionType), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct saml1__AssertionType * SOAP_FMAC4 soap_new_saml1__AssertionType(struct soap *soap, int n)
{
	struct saml1__AssertionType *p;
	struct saml1__AssertionType *a = (struct saml1__AssertionType*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct saml1__AssertionType));
	for (p = a; p && n--; p++)
		soap_default_saml1__AssertionType(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_saml1__AssertionType(struct soap *soap, const struct saml1__AssertionType *a, const char *tag, const char *type)
{
	if (soap_out_saml1__AssertionType(soap, tag ? tag : "saml1:AssertionType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct saml1__AssertionType * SOAP_FMAC4 soap_get_saml1__AssertionType(struct soap *soap, struct saml1__AssertionType *p, const char *tag, const char *type)
{
	if ((p = soap_in_saml1__AssertionType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct timeval * SOAP_FMAC4 soap_new_xsd__dateTime(struct soap *soap, int n)
{
	struct timeval *p;
	struct timeval *a = (struct timeval*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct timeval));
	for (p = a; p && n--; p++)
		soap_default_xsd__dateTime(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_xsd__dateTime(struct soap *soap, const struct timeval *a, const char *tag, const char *type)
{
	if (soap_out_xsd__dateTime(soap, tag ? tag : "xsd:dateTime", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct timeval * SOAP_FMAC4 soap_get_xsd__dateTime(struct soap *soap, struct timeval *p, const char *tag, const char *type)
{
	if ((p = soap_in_xsd__dateTime(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___wsc__DerivedKeyTokenType_sequence(struct soap *soap, struct __wsc__DerivedKeyTokenType_sequence *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__union_DerivedKeyTokenType = -1;
	a->Length = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___wsc__DerivedKeyTokenType_sequence(struct soap *soap, const struct __wsc__DerivedKeyTokenType_sequence *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize__wsc__union_DerivedKeyTokenType(soap, a->__union_DerivedKeyTokenType, &a->union_DerivedKeyTokenType);
	soap_serialize_PointerToULONG64(soap, &a->Length);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___wsc__DerivedKeyTokenType_sequence(struct soap *soap, const char *tag, int id, const struct __wsc__DerivedKeyTokenType_sequence *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out__wsc__union_DerivedKeyTokenType(soap, a->__union_DerivedKeyTokenType, &a->union_DerivedKeyTokenType))
		return soap->error;
	if (soap_out_PointerToULONG64(soap, "wsc:Length", -1, &a->Length, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __wsc__DerivedKeyTokenType_sequence * SOAP_FMAC4 soap_in___wsc__DerivedKeyTokenType_sequence(struct soap *soap, const char *tag, struct __wsc__DerivedKeyTokenType_sequence *a, const char *type)
{
	size_t soap_flag_union_DerivedKeyTokenType = 1;
	size_t soap_flag_Length = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __wsc__DerivedKeyTokenType_sequence*)soap_id_enter(soap, "", a, SOAP_TYPE___wsc__DerivedKeyTokenType_sequence, sizeof(struct __wsc__DerivedKeyTokenType_sequence), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___wsc__DerivedKeyTokenType_sequence(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_union_DerivedKeyTokenType && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in__wsc__union_DerivedKeyTokenType(soap, &a->__union_DerivedKeyTokenType, &a->union_DerivedKeyTokenType))
				{	soap_flag_union_DerivedKeyTokenType = 0;
					continue;
				}
			}
			if (soap_flag_Length && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerToULONG64(soap, "wsc:Length", &a->Length, "xsd:unsignedLong"))
				{	soap_flag_Length--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 struct __wsc__DerivedKeyTokenType_sequence * SOAP_FMAC4 soap_new___wsc__DerivedKeyTokenType_sequence(struct soap *soap, int n)
{
	struct __wsc__DerivedKeyTokenType_sequence *p;
	struct __wsc__DerivedKeyTokenType_sequence *a = (struct __wsc__DerivedKeyTokenType_sequence*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct __wsc__DerivedKeyTokenType_sequence));
	for (p = a; p && n--; p++)
		soap_default___wsc__DerivedKeyTokenType_sequence(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___wsc__DerivedKeyTokenType_sequence(struct soap *soap, const struct __wsc__DerivedKeyTokenType_sequence *a, const char *tag, const char *type)
{
	if (soap_out___wsc__DerivedKeyTokenType_sequence(soap, tag ? tag : "-wsc:DerivedKeyTokenType-sequence", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __wsc__DerivedKeyTokenType_sequence * SOAP_FMAC4 soap_get___wsc__DerivedKeyTokenType_sequence(struct soap *soap, struct __wsc__DerivedKeyTokenType_sequence *p, const char *tag, const char *type)
{
	if ((p = soap_in___wsc__DerivedKeyTokenType_sequence(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_wsc__PropertiesType(struct soap *soap, struct wsc__PropertiesType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_wsc__PropertiesType(struct soap *soap, const struct wsc__PropertiesType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_wsc__PropertiesType(struct soap *soap, const char *tag, int id, const struct wsc__PropertiesType *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_wsc__PropertiesType), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct wsc__PropertiesType * SOAP_FMAC4 soap_in_wsc__PropertiesType(struct soap *soap, const char *tag, struct wsc__PropertiesType *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct wsc__PropertiesType*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_wsc__PropertiesType, sizeof(struct wsc__PropertiesType), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_wsc__PropertiesType(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct wsc__PropertiesType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_wsc__PropertiesType, SOAP_TYPE_wsc__PropertiesType, sizeof(struct wsc__PropertiesType), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct wsc__PropertiesType * SOAP_FMAC4 soap_new_wsc__PropertiesType(struct soap *soap, int n)
{
	struct wsc__PropertiesType *p;
	struct wsc__PropertiesType *a = (struct wsc__PropertiesType*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct wsc__PropertiesType));
	for (p = a; p && n--; p++)
		soap_default_wsc__PropertiesType(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_wsc__PropertiesType(struct soap *soap, const struct wsc__PropertiesType *a, const char *tag, const char *type)
{
	if (soap_out_wsc__PropertiesType(soap, tag ? tag : "wsc:PropertiesType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct wsc__PropertiesType * SOAP_FMAC4 soap_get_wsc__PropertiesType(struct soap *soap, struct wsc__PropertiesType *p, const char *tag, const char *type)
{
	if ((p = soap_in_wsc__PropertiesType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_wsc__DerivedKeyTokenType(struct soap *soap, struct wsc__DerivedKeyTokenType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->wsse__SecurityTokenReference = NULL;
	a->Properties = NULL;
	a->__DerivedKeyTokenType_sequence = NULL;
	soap_default_string(soap, &a->Label);
	soap_default_string(soap, &a->Nonce);
	soap_default_string(soap, &a->wsu__Id);
	soap_default_string(soap, &a->Algorithm);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_wsc__DerivedKeyTokenType(struct soap *soap, const struct wsc__DerivedKeyTokenType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_wsse__SecurityTokenReference(soap, &a->wsse__SecurityTokenReference);
	soap_serialize_PointerTowsc__PropertiesType(soap, &a->Properties);
	soap_serialize_PointerTo__wsc__DerivedKeyTokenType_sequence(soap, &a->__DerivedKeyTokenType_sequence);
	soap_serialize_string(soap, (char*const*)&a->Label);
	soap_serialize_string(soap, (char*const*)&a->Nonce);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_wsc__DerivedKeyTokenType(struct soap *soap, const char *tag, int id, const struct wsc__DerivedKeyTokenType *a, const char *type)
{
	if (a->wsu__Id)
		soap_set_attr(soap, "wsu:Id", soap_string2s(soap, a->wsu__Id), 1);
	if (a->Algorithm)
		soap_set_attr(soap, "Algorithm", soap_string2s(soap, a->Algorithm), 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_wsc__DerivedKeyTokenType), type))
		return soap->error;
	if (soap_out_PointerTo_wsse__SecurityTokenReference(soap, "wsse:SecurityTokenReference", -1, &a->wsse__SecurityTokenReference, ""))
		return soap->error;
	if (soap_out_PointerTowsc__PropertiesType(soap, "wsc:Properties", -1, &a->Properties, ""))
		return soap->error;
	if (soap_out_PointerTo__wsc__DerivedKeyTokenType_sequence(soap, "-DerivedKeyTokenType-sequence", -1, &a->__DerivedKeyTokenType_sequence, ""))
		return soap->error;
	if (soap_out_string(soap, "wsc:Label", -1, (char*const*)&a->Label, ""))
		return soap->error;
	if (soap_out_string(soap, "wsc:Nonce", -1, (char*const*)&a->Nonce, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct wsc__DerivedKeyTokenType * SOAP_FMAC4 soap_in_wsc__DerivedKeyTokenType(struct soap *soap, const char *tag, struct wsc__DerivedKeyTokenType *a, const char *type)
{
	size_t soap_flag_wsse__SecurityTokenReference = 1;
	size_t soap_flag_Properties = 1;
	size_t soap_flag___DerivedKeyTokenType_sequence = 1;
	size_t soap_flag_Label = 1;
	size_t soap_flag_Nonce = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct wsc__DerivedKeyTokenType*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_wsc__DerivedKeyTokenType, sizeof(struct wsc__DerivedKeyTokenType), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_wsc__DerivedKeyTokenType(soap, a);
	if (soap_s2string(soap, soap_attr_value(soap, "wsu:Id", 1, 0), &a->wsu__Id))
		return NULL;
	if (soap_s2string(soap, soap_attr_value(soap, "Algorithm", 1, 0), &a->Algorithm))
		return NULL;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_wsse__SecurityTokenReference && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_wsse__SecurityTokenReference(soap, "wsse:SecurityTokenReference", &a->wsse__SecurityTokenReference, ""))
				{	soap_flag_wsse__SecurityTokenReference--;
					continue;
				}
			}
			if (soap_flag_Properties && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTowsc__PropertiesType(soap, "wsc:Properties", &a->Properties, "wsc:PropertiesType"))
				{	soap_flag_Properties--;
					continue;
				}
			}
			if (soap_flag_Label && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_string(soap, "wsc:Label", (char**)&a->Label, "xsd:string"))
				{	soap_flag_Label--;
					continue;
				}
			}
			if (soap_flag_Nonce && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_string(soap, "wsc:Nonce", (char**)&a->Nonce, "xsd:string"))
				{	soap_flag_Nonce--;
					continue;
				}
			}
			if (soap_flag___DerivedKeyTokenType_sequence && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo__wsc__DerivedKeyTokenType_sequence(soap, "-DerivedKeyTokenType-sequence", &a->__DerivedKeyTokenType_sequence, "-wsc:DerivedKeyTokenType-sequence"))
				{	soap_flag___DerivedKeyTokenType_sequence--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct wsc__DerivedKeyTokenType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_wsc__DerivedKeyTokenType, SOAP_TYPE_wsc__DerivedKeyTokenType, sizeof(struct wsc__DerivedKeyTokenType), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct wsc__DerivedKeyTokenType * SOAP_FMAC4 soap_new_wsc__DerivedKeyTokenType(struct soap *soap, int n)
{
	struct wsc__DerivedKeyTokenType *p;
	struct wsc__DerivedKeyTokenType *a = (struct wsc__DerivedKeyTokenType*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct wsc__DerivedKeyTokenType));
	for (p = a; p && n--; p++)
		soap_default_wsc__DerivedKeyTokenType(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_wsc__DerivedKeyTokenType(struct soap *soap, const struct wsc__DerivedKeyTokenType *a, const char *tag, const char *type)
{
	if (soap_out_wsc__DerivedKeyTokenType(soap, tag ? tag : "wsc:DerivedKeyTokenType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct wsc__DerivedKeyTokenType * SOAP_FMAC4 soap_get_wsc__DerivedKeyTokenType(struct soap *soap, struct wsc__DerivedKeyTokenType *p, const char *tag, const char *type)
{
	if ((p = soap_in_wsc__DerivedKeyTokenType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_wsc__SecurityContextTokenType(struct soap *soap, struct wsc__SecurityContextTokenType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->wsu__Id);
	soap_default_string(soap, &a->Identifier);
	soap_default_string(soap, &a->Instance);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_wsc__SecurityContextTokenType(struct soap *soap, const struct wsc__SecurityContextTokenType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_string(soap, (char*const*)&a->Identifier);
	soap_serialize_string(soap, (char*const*)&a->Instance);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_wsc__SecurityContextTokenType(struct soap *soap, const char *tag, int id, const struct wsc__SecurityContextTokenType *a, const char *type)
{
	if (a->wsu__Id)
		soap_set_attr(soap, "wsu:Id", soap_string2s(soap, a->wsu__Id), 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_wsc__SecurityContextTokenType), type))
		return soap->error;
	if (soap_out_string(soap, "wsc:Identifier", -1, (char*const*)&a->Identifier, ""))
		return soap->error;
	if (soap_out_string(soap, "wsc:Instance", -1, (char*const*)&a->Instance, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct wsc__SecurityContextTokenType * SOAP_FMAC4 soap_in_wsc__SecurityContextTokenType(struct soap *soap, const char *tag, struct wsc__SecurityContextTokenType *a, const char *type)
{
	size_t soap_flag_Identifier = 1;
	size_t soap_flag_Instance = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct wsc__SecurityContextTokenType*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_wsc__SecurityContextTokenType, sizeof(struct wsc__SecurityContextTokenType), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_wsc__SecurityContextTokenType(soap, a);
	if (soap_s2string(soap, soap_attr_value(soap, "wsu:Id", 1, 0), &a->wsu__Id))
		return NULL;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Identifier && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_string(soap, "wsc:Identifier", (char**)&a->Identifier, "xsd:string"))
				{	soap_flag_Identifier--;
					continue;
				}
			}
			if (soap_flag_Instance && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_string(soap, "wsc:Instance", (char**)&a->Instance, "xsd:string"))
				{	soap_flag_Instance--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct wsc__SecurityContextTokenType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_wsc__SecurityContextTokenType, SOAP_TYPE_wsc__SecurityContextTokenType, sizeof(struct wsc__SecurityContextTokenType), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct wsc__SecurityContextTokenType * SOAP_FMAC4 soap_new_wsc__SecurityContextTokenType(struct soap *soap, int n)
{
	struct wsc__SecurityContextTokenType *p;
	struct wsc__SecurityContextTokenType *a = (struct wsc__SecurityContextTokenType*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct wsc__SecurityContextTokenType));
	for (p = a; p && n--; p++)
		soap_default_wsc__SecurityContextTokenType(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_wsc__SecurityContextTokenType(struct soap *soap, const struct wsc__SecurityContextTokenType *a, const char *tag, const char *type)
{
	if (soap_out_wsc__SecurityContextTokenType(soap, tag ? tag : "wsc:SecurityContextTokenType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct wsc__SecurityContextTokenType * SOAP_FMAC4 soap_get_wsc__SecurityContextTokenType(struct soap *soap, struct wsc__SecurityContextTokenType *p, const char *tag, const char *type)
{
	if ((p = soap_in_wsc__SecurityContextTokenType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___xenc__union_ReferenceList(struct soap *soap, struct __xenc__union_ReferenceList *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->DataReference = NULL;
	a->KeyReference = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___xenc__union_ReferenceList(struct soap *soap, const struct __xenc__union_ReferenceList *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerToxenc__ReferenceType(soap, &a->DataReference);
	soap_serialize_PointerToxenc__ReferenceType(soap, &a->KeyReference);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___xenc__union_ReferenceList(struct soap *soap, const char *tag, int id, const struct __xenc__union_ReferenceList *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerToxenc__ReferenceType(soap, "xenc:DataReference", -1, &a->DataReference, ""))
		return soap->error;
	if (soap_out_PointerToxenc__ReferenceType(soap, "xenc:KeyReference", -1, &a->KeyReference, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __xenc__union_ReferenceList * SOAP_FMAC4 soap_in___xenc__union_ReferenceList(struct soap *soap, const char *tag, struct __xenc__union_ReferenceList *a, const char *type)
{
	size_t soap_flag_DataReference = 1;
	size_t soap_flag_KeyReference = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __xenc__union_ReferenceList*)soap_id_enter(soap, "", a, SOAP_TYPE___xenc__union_ReferenceList, sizeof(struct __xenc__union_ReferenceList), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___xenc__union_ReferenceList(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_DataReference && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerToxenc__ReferenceType(soap, "xenc:DataReference", &a->DataReference, "xenc:ReferenceType"))
				{	soap_flag_DataReference--;
					continue;
				}
			}
			if (soap_flag_KeyReference && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerToxenc__ReferenceType(soap, "xenc:KeyReference", &a->KeyReference, "xenc:ReferenceType"))
				{	soap_flag_KeyReference--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 struct __xenc__union_ReferenceList * SOAP_FMAC4 soap_new___xenc__union_ReferenceList(struct soap *soap, int n)
{
	struct __xenc__union_ReferenceList *p;
	struct __xenc__union_ReferenceList *a = (struct __xenc__union_ReferenceList*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct __xenc__union_ReferenceList));
	for (p = a; p && n--; p++)
		soap_default___xenc__union_ReferenceList(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___xenc__union_ReferenceList(struct soap *soap, const struct __xenc__union_ReferenceList *a, const char *tag, const char *type)
{
	if (soap_out___xenc__union_ReferenceList(soap, tag ? tag : "-xenc:union-ReferenceList", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __xenc__union_ReferenceList * SOAP_FMAC4 soap_get___xenc__union_ReferenceList(struct soap *soap, struct __xenc__union_ReferenceList *p, const char *tag, const char *type)
{
	if ((p = soap_in___xenc__union_ReferenceList(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__xenc__ReferenceList(struct soap *soap, struct _xenc__ReferenceList *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__size_ReferenceList = 0;
	a->__union_ReferenceList = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__xenc__ReferenceList(struct soap *soap, const struct _xenc__ReferenceList *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (a->__union_ReferenceList)
	{	int i;
		for (i = 0; i < (int)a->__size_ReferenceList; i++)
		{
			soap_serialize___xenc__union_ReferenceList(soap, a->__union_ReferenceList + i);
		}
	}
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__xenc__ReferenceList(struct soap *soap, const char *tag, int id, const struct _xenc__ReferenceList *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__xenc__ReferenceList), type))
		return soap->error;
	if (a->__union_ReferenceList)
	{	int i;
		for (i = 0; i < (int)a->__size_ReferenceList; i++)
			if (soap_out___xenc__union_ReferenceList(soap, "-union-ReferenceList", -1, a->__union_ReferenceList + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _xenc__ReferenceList * SOAP_FMAC4 soap_in__xenc__ReferenceList(struct soap *soap, const char *tag, struct _xenc__ReferenceList *a, const char *type)
{
	struct soap_blist *soap_blist___union_ReferenceList = NULL;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct _xenc__ReferenceList*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__xenc__ReferenceList, sizeof(struct _xenc__ReferenceList), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__xenc__ReferenceList(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	if (a->__union_ReferenceList == NULL)
				{	if (soap_blist___union_ReferenceList == NULL)
						soap_blist___union_ReferenceList = soap_alloc_block(soap);
					a->__union_ReferenceList = (struct __xenc__union_ReferenceList *)soap_push_block_max(soap, soap_blist___union_ReferenceList, sizeof(struct __xenc__union_ReferenceList));
					if (a->__union_ReferenceList == NULL)
						return NULL;
					soap_default___xenc__union_ReferenceList(soap, a->__union_ReferenceList);
				}
				if (soap_in___xenc__union_ReferenceList(soap, "-union-ReferenceList", a->__union_ReferenceList, "-xenc:union-ReferenceList"))
				{	a->__size_ReferenceList++;
					a->__union_ReferenceList = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->__union_ReferenceList)
			soap_pop_block(soap, soap_blist___union_ReferenceList);
		if (a->__size_ReferenceList)
		{	a->__union_ReferenceList = (struct __xenc__union_ReferenceList *)soap_save_block(soap, soap_blist___union_ReferenceList, NULL, 1);
		}
		else
		{	a->__union_ReferenceList = NULL;
			if (soap_blist___union_ReferenceList)
				soap_end_block(soap, soap_blist___union_ReferenceList);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (a->__size_ReferenceList < 1))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct _xenc__ReferenceList *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__xenc__ReferenceList, SOAP_TYPE__xenc__ReferenceList, sizeof(struct _xenc__ReferenceList), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _xenc__ReferenceList * SOAP_FMAC4 soap_new__xenc__ReferenceList(struct soap *soap, int n)
{
	struct _xenc__ReferenceList *p;
	struct _xenc__ReferenceList *a = (struct _xenc__ReferenceList*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _xenc__ReferenceList));
	for (p = a; p && n--; p++)
		soap_default__xenc__ReferenceList(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__xenc__ReferenceList(struct soap *soap, const struct _xenc__ReferenceList *a, const char *tag, const char *type)
{
	if (soap_out__xenc__ReferenceList(soap, tag ? tag : "xenc:ReferenceList", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _xenc__ReferenceList * SOAP_FMAC4 soap_get__xenc__ReferenceList(struct soap *soap, struct _xenc__ReferenceList *p, const char *tag, const char *type)
{
	if ((p = soap_in__xenc__ReferenceList(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_xenc__EncryptionPropertyType(struct soap *soap, struct xenc__EncryptionPropertyType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->Target);
	soap_default_string(soap, &a->Id);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_xenc__EncryptionPropertyType(struct soap *soap, const struct xenc__EncryptionPropertyType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_xenc__EncryptionPropertyType(struct soap *soap, const char *tag, int id, const struct xenc__EncryptionPropertyType *a, const char *type)
{
	if (a->Target)
		soap_set_attr(soap, "Target", soap_string2s(soap, a->Target), 1);
	if (a->Id)
		soap_set_attr(soap, "Id", soap_string2s(soap, a->Id), 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_xenc__EncryptionPropertyType), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct xenc__EncryptionPropertyType * SOAP_FMAC4 soap_in_xenc__EncryptionPropertyType(struct soap *soap, const char *tag, struct xenc__EncryptionPropertyType *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct xenc__EncryptionPropertyType*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_xenc__EncryptionPropertyType, sizeof(struct xenc__EncryptionPropertyType), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_xenc__EncryptionPropertyType(soap, a);
	if (soap_s2string(soap, soap_attr_value(soap, "Target", 1, 0), &a->Target))
		return NULL;
	if (soap_s2string(soap, soap_attr_value(soap, "Id", 1, 0), &a->Id))
		return NULL;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct xenc__EncryptionPropertyType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_xenc__EncryptionPropertyType, SOAP_TYPE_xenc__EncryptionPropertyType, sizeof(struct xenc__EncryptionPropertyType), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct xenc__EncryptionPropertyType * SOAP_FMAC4 soap_new_xenc__EncryptionPropertyType(struct soap *soap, int n)
{
	struct xenc__EncryptionPropertyType *p;
	struct xenc__EncryptionPropertyType *a = (struct xenc__EncryptionPropertyType*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct xenc__EncryptionPropertyType));
	for (p = a; p && n--; p++)
		soap_default_xenc__EncryptionPropertyType(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_xenc__EncryptionPropertyType(struct soap *soap, const struct xenc__EncryptionPropertyType *a, const char *tag, const char *type)
{
	if (soap_out_xenc__EncryptionPropertyType(soap, tag ? tag : "xenc:EncryptionPropertyType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct xenc__EncryptionPropertyType * SOAP_FMAC4 soap_get_xenc__EncryptionPropertyType(struct soap *soap, struct xenc__EncryptionPropertyType *p, const char *tag, const char *type)
{
	if ((p = soap_in_xenc__EncryptionPropertyType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_xenc__EncryptionPropertiesType(struct soap *soap, struct xenc__EncryptionPropertiesType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__sizeEncryptionProperty = 0;
	a->EncryptionProperty = NULL;
	soap_default_string(soap, &a->Id);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_xenc__EncryptionPropertiesType(struct soap *soap, const struct xenc__EncryptionPropertiesType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (a->EncryptionProperty)
	{	int i;
		for (i = 0; i < (int)a->__sizeEncryptionProperty; i++)
		{
			soap_embedded(soap, a->EncryptionProperty + i, SOAP_TYPE_xenc__EncryptionPropertyType);
			soap_serialize_xenc__EncryptionPropertyType(soap, a->EncryptionProperty + i);
		}
	}
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_xenc__EncryptionPropertiesType(struct soap *soap, const char *tag, int id, const struct xenc__EncryptionPropertiesType *a, const char *type)
{
	if (a->Id)
		soap_set_attr(soap, "Id", soap_string2s(soap, a->Id), 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_xenc__EncryptionPropertiesType), type))
		return soap->error;
	if (a->EncryptionProperty)
	{	int i;
		for (i = 0; i < (int)a->__sizeEncryptionProperty; i++)
			if (soap_out_xenc__EncryptionPropertyType(soap, "xenc:EncryptionProperty", -1, a->EncryptionProperty + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct xenc__EncryptionPropertiesType * SOAP_FMAC4 soap_in_xenc__EncryptionPropertiesType(struct soap *soap, const char *tag, struct xenc__EncryptionPropertiesType *a, const char *type)
{
	struct soap_blist *soap_blist_EncryptionProperty = NULL;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct xenc__EncryptionPropertiesType*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_xenc__EncryptionPropertiesType, sizeof(struct xenc__EncryptionPropertiesType), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_xenc__EncryptionPropertiesType(soap, a);
	if (soap_s2string(soap, soap_attr_value(soap, "Id", 1, 0), &a->Id))
		return NULL;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "xenc:EncryptionProperty", 1, NULL))
			{	if (a->EncryptionProperty == NULL)
				{	if (soap_blist_EncryptionProperty == NULL)
						soap_blist_EncryptionProperty = soap_alloc_block(soap);
					a->EncryptionProperty = (struct xenc__EncryptionPropertyType *)soap_push_block_max(soap, soap_blist_EncryptionProperty, sizeof(struct xenc__EncryptionPropertyType));
					if (a->EncryptionProperty == NULL)
						return NULL;
					soap_default_xenc__EncryptionPropertyType(soap, a->EncryptionProperty);
				}
				soap_revert(soap);
				if (soap_in_xenc__EncryptionPropertyType(soap, "xenc:EncryptionProperty", a->EncryptionProperty, "xenc:EncryptionPropertyType"))
				{	a->__sizeEncryptionProperty++;
					a->EncryptionProperty = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->EncryptionProperty)
			soap_pop_block(soap, soap_blist_EncryptionProperty);
		if (a->__sizeEncryptionProperty)
		{	a->EncryptionProperty = (struct xenc__EncryptionPropertyType *)soap_save_block(soap, soap_blist_EncryptionProperty, NULL, 1);
		}
		else
		{	a->EncryptionProperty = NULL;
			if (soap_blist_EncryptionProperty)
				soap_end_block(soap, soap_blist_EncryptionProperty);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (a->__sizeEncryptionProperty < 1))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct xenc__EncryptionPropertiesType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_xenc__EncryptionPropertiesType, SOAP_TYPE_xenc__EncryptionPropertiesType, sizeof(struct xenc__EncryptionPropertiesType), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct xenc__EncryptionPropertiesType * SOAP_FMAC4 soap_new_xenc__EncryptionPropertiesType(struct soap *soap, int n)
{
	struct xenc__EncryptionPropertiesType *p;
	struct xenc__EncryptionPropertiesType *a = (struct xenc__EncryptionPropertiesType*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct xenc__EncryptionPropertiesType));
	for (p = a; p && n--; p++)
		soap_default_xenc__EncryptionPropertiesType(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_xenc__EncryptionPropertiesType(struct soap *soap, const struct xenc__EncryptionPropertiesType *a, const char *tag, const char *type)
{
	if (soap_out_xenc__EncryptionPropertiesType(soap, tag ? tag : "xenc:EncryptionPropertiesType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct xenc__EncryptionPropertiesType * SOAP_FMAC4 soap_get_xenc__EncryptionPropertiesType(struct soap *soap, struct xenc__EncryptionPropertiesType *p, const char *tag, const char *type)
{
	if ((p = soap_in_xenc__EncryptionPropertiesType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_xenc__ReferenceType(struct soap *soap, struct xenc__ReferenceType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->URI);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_xenc__ReferenceType(struct soap *soap, const struct xenc__ReferenceType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_xenc__ReferenceType(struct soap *soap, const char *tag, int id, const struct xenc__ReferenceType *a, const char *type)
{
	soap_set_attr(soap, "URI", a->URI ? soap_string2s(soap, a->URI) : "", 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_xenc__ReferenceType), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct xenc__ReferenceType * SOAP_FMAC4 soap_in_xenc__ReferenceType(struct soap *soap, const char *tag, struct xenc__ReferenceType *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct xenc__ReferenceType*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_xenc__ReferenceType, sizeof(struct xenc__ReferenceType), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_xenc__ReferenceType(soap, a);
	if (soap_s2string(soap, soap_attr_value(soap, "URI", 1, 1), &a->URI))
		return NULL;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct xenc__ReferenceType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_xenc__ReferenceType, SOAP_TYPE_xenc__ReferenceType, sizeof(struct xenc__ReferenceType), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct xenc__ReferenceType * SOAP_FMAC4 soap_new_xenc__ReferenceType(struct soap *soap, int n)
{
	struct xenc__ReferenceType *p;
	struct xenc__ReferenceType *a = (struct xenc__ReferenceType*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct xenc__ReferenceType));
	for (p = a; p && n--; p++)
		soap_default_xenc__ReferenceType(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_xenc__ReferenceType(struct soap *soap, const struct xenc__ReferenceType *a, const char *tag, const char *type)
{
	if (soap_out_xenc__ReferenceType(soap, tag ? tag : "xenc:ReferenceType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct xenc__ReferenceType * SOAP_FMAC4 soap_get_xenc__ReferenceType(struct soap *soap, struct xenc__ReferenceType *p, const char *tag, const char *type)
{
	if ((p = soap_in_xenc__ReferenceType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_xenc__AgreementMethodType(struct soap *soap, struct xenc__AgreementMethodType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->KA_Nonce);
	a->OriginatorKeyInfo = NULL;
	a->RecipientKeyInfo = NULL;
	soap_default_string(soap, &a->Algorithm);
	a->__mixed = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_xenc__AgreementMethodType(struct soap *soap, const struct xenc__AgreementMethodType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_string(soap, (char*const*)&a->KA_Nonce);
	soap_serialize_PointerTods__KeyInfoType(soap, &a->OriginatorKeyInfo);
	soap_serialize_PointerTods__KeyInfoType(soap, &a->RecipientKeyInfo);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_xenc__AgreementMethodType(struct soap *soap, const char *tag, int id, const struct xenc__AgreementMethodType *a, const char *type)
{
	soap_set_attr(soap, "Algorithm", a->Algorithm ? soap_string2s(soap, a->Algorithm) : "", 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_xenc__AgreementMethodType), type))
		return soap->error;
	if (soap_out_string(soap, "xenc:KA-Nonce", -1, (char*const*)&a->KA_Nonce, ""))
		return soap->error;
	if (soap_out_PointerTods__KeyInfoType(soap, "xenc:OriginatorKeyInfo", -1, &a->OriginatorKeyInfo, ""))
		return soap->error;
	if (soap_out_PointerTods__KeyInfoType(soap, "xenc:RecipientKeyInfo", -1, &a->RecipientKeyInfo, ""))
		return soap->error;
	if (soap_outliteral(soap, "-mixed", (char*const*)&a->__mixed, NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct xenc__AgreementMethodType * SOAP_FMAC4 soap_in_xenc__AgreementMethodType(struct soap *soap, const char *tag, struct xenc__AgreementMethodType *a, const char *type)
{
	size_t soap_flag_KA_Nonce = 1;
	size_t soap_flag_OriginatorKeyInfo = 1;
	size_t soap_flag_RecipientKeyInfo = 1;
	size_t soap_flag___mixed = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct xenc__AgreementMethodType*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_xenc__AgreementMethodType, sizeof(struct xenc__AgreementMethodType), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_xenc__AgreementMethodType(soap, a);
	if (soap_s2string(soap, soap_attr_value(soap, "Algorithm", 1, 1), &a->Algorithm))
		return NULL;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_KA_Nonce && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_string(soap, "xenc:KA-Nonce", (char**)&a->KA_Nonce, "xsd:string"))
				{	soap_flag_KA_Nonce--;
					continue;
				}
			}
			if (soap_flag_OriginatorKeyInfo && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTods__KeyInfoType(soap, "xenc:OriginatorKeyInfo", &a->OriginatorKeyInfo, "ds:KeyInfoType"))
				{	soap_flag_OriginatorKeyInfo--;
					continue;
				}
			}
			if (soap_flag_RecipientKeyInfo && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTods__KeyInfoType(soap, "xenc:RecipientKeyInfo", &a->RecipientKeyInfo, "ds:KeyInfoType"))
				{	soap_flag_RecipientKeyInfo--;
					continue;
				}
			}
			if (soap_flag___mixed && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_inliteral(soap, "-mixed", (char**)&a->__mixed))
				{	soap_flag___mixed--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct xenc__AgreementMethodType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_xenc__AgreementMethodType, SOAP_TYPE_xenc__AgreementMethodType, sizeof(struct xenc__AgreementMethodType), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct xenc__AgreementMethodType * SOAP_FMAC4 soap_new_xenc__AgreementMethodType(struct soap *soap, int n)
{
	struct xenc__AgreementMethodType *p;
	struct xenc__AgreementMethodType *a = (struct xenc__AgreementMethodType*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct xenc__AgreementMethodType));
	for (p = a; p && n--; p++)
		soap_default_xenc__AgreementMethodType(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_xenc__AgreementMethodType(struct soap *soap, const struct xenc__AgreementMethodType *a, const char *tag, const char *type)
{
	if (soap_out_xenc__AgreementMethodType(soap, tag ? tag : "xenc:AgreementMethodType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct xenc__AgreementMethodType * SOAP_FMAC4 soap_get_xenc__AgreementMethodType(struct soap *soap, struct xenc__AgreementMethodType *p, const char *tag, const char *type)
{
	if ((p = soap_in_xenc__AgreementMethodType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_xenc__EncryptedDataType(struct soap *soap, struct xenc__EncryptedDataType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->EncryptionMethod = NULL;
	a->ds__KeyInfo = NULL;
	a->CipherData = NULL;
	a->EncryptionProperties = NULL;
	soap_default_string(soap, &a->Id);
	soap_default_string(soap, &a->Type);
	soap_default_string(soap, &a->MimeType);
	soap_default_string(soap, &a->Encoding);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_xenc__EncryptedDataType(struct soap *soap, const struct xenc__EncryptedDataType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerToxenc__EncryptionMethodType(soap, &a->EncryptionMethod);
	soap_serialize_PointerTo_ds__KeyInfo(soap, &a->ds__KeyInfo);
	soap_serialize_PointerToxenc__CipherDataType(soap, &a->CipherData);
	soap_serialize_PointerToxenc__EncryptionPropertiesType(soap, &a->EncryptionProperties);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_xenc__EncryptedDataType(struct soap *soap, const char *tag, int id, const struct xenc__EncryptedDataType *a, const char *type)
{
	if (a->Id)
		soap_set_attr(soap, "Id", soap_string2s(soap, a->Id), 1);
	if (a->Type)
		soap_set_attr(soap, "Type", soap_string2s(soap, a->Type), 1);
	if (a->MimeType)
		soap_set_attr(soap, "MimeType", soap_string2s(soap, a->MimeType), 1);
	if (a->Encoding)
		soap_set_attr(soap, "Encoding", soap_string2s(soap, a->Encoding), 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_xenc__EncryptedDataType), type))
		return soap->error;
	if (soap_out_PointerToxenc__EncryptionMethodType(soap, "xenc:EncryptionMethod", -1, &a->EncryptionMethod, ""))
		return soap->error;
	if (soap_out_PointerTo_ds__KeyInfo(soap, "ds:KeyInfo", -1, &a->ds__KeyInfo, ""))
		return soap->error;
	if (!a->CipherData)
	{	if (soap_element_empty(soap, "xenc:CipherData", 0, NULL))
			return soap->error;
	}
	else if (soap_out_PointerToxenc__CipherDataType(soap, "xenc:CipherData", -1, &a->CipherData, ""))
		return soap->error;
	if (soap_out_PointerToxenc__EncryptionPropertiesType(soap, "xenc:EncryptionProperties", -1, &a->EncryptionProperties, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct xenc__EncryptedDataType * SOAP_FMAC4 soap_in_xenc__EncryptedDataType(struct soap *soap, const char *tag, struct xenc__EncryptedDataType *a, const char *type)
{
	size_t soap_flag_EncryptionMethod = 1;
	size_t soap_flag_ds__KeyInfo = 1;
	size_t soap_flag_CipherData = 1;
	size_t soap_flag_EncryptionProperties = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct xenc__EncryptedDataType*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_xenc__EncryptedDataType, sizeof(struct xenc__EncryptedDataType), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_xenc__EncryptedDataType(soap, a);
	if (soap_s2string(soap, soap_attr_value(soap, "Id", 1, 0), &a->Id))
		return NULL;
	if (soap_s2string(soap, soap_attr_value(soap, "Type", 1, 0), &a->Type))
		return NULL;
	if (soap_s2string(soap, soap_attr_value(soap, "MimeType", 1, 0), &a->MimeType))
		return NULL;
	if (soap_s2string(soap, soap_attr_value(soap, "Encoding", 1, 0), &a->Encoding))
		return NULL;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_EncryptionMethod && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerToxenc__EncryptionMethodType(soap, "xenc:EncryptionMethod", &a->EncryptionMethod, "xenc:EncryptionMethodType"))
				{	soap_flag_EncryptionMethod--;
					continue;
				}
			}
			if (soap_flag_ds__KeyInfo && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_ds__KeyInfo(soap, "ds:KeyInfo", &a->ds__KeyInfo, ""))
				{	soap_flag_ds__KeyInfo--;
					continue;
				}
			}
			if (soap_flag_CipherData && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerToxenc__CipherDataType(soap, "xenc:CipherData", &a->CipherData, "xenc:CipherDataType"))
				{	soap_flag_CipherData--;
					continue;
				}
			}
			if (soap_flag_EncryptionProperties && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerToxenc__EncryptionPropertiesType(soap, "xenc:EncryptionProperties", &a->EncryptionProperties, "xenc:EncryptionPropertiesType"))
				{	soap_flag_EncryptionProperties--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (!a->CipherData))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct xenc__EncryptedDataType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_xenc__EncryptedDataType, SOAP_TYPE_xenc__EncryptedDataType, sizeof(struct xenc__EncryptedDataType), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct xenc__EncryptedDataType * SOAP_FMAC4 soap_new_xenc__EncryptedDataType(struct soap *soap, int n)
{
	struct xenc__EncryptedDataType *p;
	struct xenc__EncryptedDataType *a = (struct xenc__EncryptedDataType*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct xenc__EncryptedDataType));
	for (p = a; p && n--; p++)
		soap_default_xenc__EncryptedDataType(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_xenc__EncryptedDataType(struct soap *soap, const struct xenc__EncryptedDataType *a, const char *tag, const char *type)
{
	if (soap_out_xenc__EncryptedDataType(soap, tag ? tag : "xenc:EncryptedDataType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct xenc__EncryptedDataType * SOAP_FMAC4 soap_get_xenc__EncryptedDataType(struct soap *soap, struct xenc__EncryptedDataType *p, const char *tag, const char *type)
{
	if ((p = soap_in_xenc__EncryptedDataType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_xenc__TransformsType(struct soap *soap, struct xenc__TransformsType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default__ds__Transform(soap, &a->ds__Transform);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_xenc__TransformsType(struct soap *soap, const struct xenc__TransformsType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize__ds__Transform(soap, &a->ds__Transform);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_xenc__TransformsType(struct soap *soap, const char *tag, int id, const struct xenc__TransformsType *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_xenc__TransformsType), type))
		return soap->error;
	if (soap_out__ds__Transform(soap, "ds:Transform", -1, &a->ds__Transform, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct xenc__TransformsType * SOAP_FMAC4 soap_in_xenc__TransformsType(struct soap *soap, const char *tag, struct xenc__TransformsType *a, const char *type)
{
	size_t soap_flag_ds__Transform = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct xenc__TransformsType*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_xenc__TransformsType, sizeof(struct xenc__TransformsType), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_xenc__TransformsType(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ds__Transform && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in__ds__Transform(soap, "ds:Transform", &a->ds__Transform, ""))
				{	soap_flag_ds__Transform--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_ds__Transform > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct xenc__TransformsType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_xenc__TransformsType, SOAP_TYPE_xenc__TransformsType, sizeof(struct xenc__TransformsType), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct xenc__TransformsType * SOAP_FMAC4 soap_new_xenc__TransformsType(struct soap *soap, int n)
{
	struct xenc__TransformsType *p;
	struct xenc__TransformsType *a = (struct xenc__TransformsType*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct xenc__TransformsType));
	for (p = a; p && n--; p++)
		soap_default_xenc__TransformsType(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_xenc__TransformsType(struct soap *soap, const struct xenc__TransformsType *a, const char *tag, const char *type)
{
	if (soap_out_xenc__TransformsType(soap, tag ? tag : "xenc:TransformsType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct xenc__TransformsType * SOAP_FMAC4 soap_get_xenc__TransformsType(struct soap *soap, struct xenc__TransformsType *p, const char *tag, const char *type)
{
	if ((p = soap_in_xenc__TransformsType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_xenc__CipherReferenceType(struct soap *soap, struct xenc__CipherReferenceType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->Transforms = NULL;
	soap_default_string(soap, &a->URI);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_xenc__CipherReferenceType(struct soap *soap, const struct xenc__CipherReferenceType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerToxenc__TransformsType(soap, &a->Transforms);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_xenc__CipherReferenceType(struct soap *soap, const char *tag, int id, const struct xenc__CipherReferenceType *a, const char *type)
{
	soap_set_attr(soap, "URI", a->URI ? soap_string2s(soap, a->URI) : "", 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_xenc__CipherReferenceType), type))
		return soap->error;
	if (soap_out_PointerToxenc__TransformsType(soap, "xenc:Transforms", -1, &a->Transforms, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct xenc__CipherReferenceType * SOAP_FMAC4 soap_in_xenc__CipherReferenceType(struct soap *soap, const char *tag, struct xenc__CipherReferenceType *a, const char *type)
{
	size_t soap_flag_Transforms = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct xenc__CipherReferenceType*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_xenc__CipherReferenceType, sizeof(struct xenc__CipherReferenceType), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_xenc__CipherReferenceType(soap, a);
	if (soap_s2string(soap, soap_attr_value(soap, "URI", 1, 1), &a->URI))
		return NULL;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Transforms && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerToxenc__TransformsType(soap, "xenc:Transforms", &a->Transforms, "xenc:TransformsType"))
				{	soap_flag_Transforms--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct xenc__CipherReferenceType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_xenc__CipherReferenceType, SOAP_TYPE_xenc__CipherReferenceType, sizeof(struct xenc__CipherReferenceType), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct xenc__CipherReferenceType * SOAP_FMAC4 soap_new_xenc__CipherReferenceType(struct soap *soap, int n)
{
	struct xenc__CipherReferenceType *p;
	struct xenc__CipherReferenceType *a = (struct xenc__CipherReferenceType*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct xenc__CipherReferenceType));
	for (p = a; p && n--; p++)
		soap_default_xenc__CipherReferenceType(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_xenc__CipherReferenceType(struct soap *soap, const struct xenc__CipherReferenceType *a, const char *tag, const char *type)
{
	if (soap_out_xenc__CipherReferenceType(soap, tag ? tag : "xenc:CipherReferenceType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct xenc__CipherReferenceType * SOAP_FMAC4 soap_get_xenc__CipherReferenceType(struct soap *soap, struct xenc__CipherReferenceType *p, const char *tag, const char *type)
{
	if ((p = soap_in_xenc__CipherReferenceType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_xenc__CipherDataType(struct soap *soap, struct xenc__CipherDataType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->CipherValue);
	a->CipherReference = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_xenc__CipherDataType(struct soap *soap, const struct xenc__CipherDataType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_string(soap, (char*const*)&a->CipherValue);
	soap_serialize_PointerToxenc__CipherReferenceType(soap, &a->CipherReference);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_xenc__CipherDataType(struct soap *soap, const char *tag, int id, const struct xenc__CipherDataType *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_xenc__CipherDataType), type))
		return soap->error;
	if (soap_out_string(soap, "xenc:CipherValue", -1, (char*const*)&a->CipherValue, ""))
		return soap->error;
	if (soap_out_PointerToxenc__CipherReferenceType(soap, "xenc:CipherReference", -1, &a->CipherReference, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct xenc__CipherDataType * SOAP_FMAC4 soap_in_xenc__CipherDataType(struct soap *soap, const char *tag, struct xenc__CipherDataType *a, const char *type)
{
	size_t soap_flag_CipherValue = 1;
	size_t soap_flag_CipherReference = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct xenc__CipherDataType*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_xenc__CipherDataType, sizeof(struct xenc__CipherDataType), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_xenc__CipherDataType(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_CipherValue && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_string(soap, "xenc:CipherValue", (char**)&a->CipherValue, "xsd:string"))
				{	soap_flag_CipherValue--;
					continue;
				}
			}
			if (soap_flag_CipherReference && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerToxenc__CipherReferenceType(soap, "xenc:CipherReference", &a->CipherReference, "xenc:CipherReferenceType"))
				{	soap_flag_CipherReference--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct xenc__CipherDataType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_xenc__CipherDataType, SOAP_TYPE_xenc__CipherDataType, sizeof(struct xenc__CipherDataType), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct xenc__CipherDataType * SOAP_FMAC4 soap_new_xenc__CipherDataType(struct soap *soap, int n)
{
	struct xenc__CipherDataType *p;
	struct xenc__CipherDataType *a = (struct xenc__CipherDataType*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct xenc__CipherDataType));
	for (p = a; p && n--; p++)
		soap_default_xenc__CipherDataType(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_xenc__CipherDataType(struct soap *soap, const struct xenc__CipherDataType *a, const char *tag, const char *type)
{
	if (soap_out_xenc__CipherDataType(soap, tag ? tag : "xenc:CipherDataType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct xenc__CipherDataType * SOAP_FMAC4 soap_get_xenc__CipherDataType(struct soap *soap, struct xenc__CipherDataType *p, const char *tag, const char *type)
{
	if ((p = soap_in_xenc__CipherDataType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_xenc__EncryptionMethodType(struct soap *soap, struct xenc__EncryptionMethodType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->KeySize = NULL;
	soap_default_string(soap, &a->OAEPparams);
	soap_default_string(soap, &a->Algorithm);
	a->ds__DigestMethod = NULL;
	a->__mixed = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_xenc__EncryptionMethodType(struct soap *soap, const struct xenc__EncryptionMethodType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerToint(soap, &a->KeySize);
	soap_serialize_string(soap, (char*const*)&a->OAEPparams);
	soap_serialize_PointerTods__DigestMethodType(soap, &a->ds__DigestMethod);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_xenc__EncryptionMethodType(struct soap *soap, const char *tag, int id, const struct xenc__EncryptionMethodType *a, const char *type)
{
	soap_set_attr(soap, "Algorithm", a->Algorithm ? soap_string2s(soap, a->Algorithm) : "", 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_xenc__EncryptionMethodType), type))
		return soap->error;
	if (soap_out_PointerToint(soap, "xenc:KeySize", -1, &a->KeySize, ""))
		return soap->error;
	if (soap_out_string(soap, "xenc:OAEPparams", -1, (char*const*)&a->OAEPparams, ""))
		return soap->error;
	if (soap_out_PointerTods__DigestMethodType(soap, "ds:DigestMethod", -1, &a->ds__DigestMethod, ""))
		return soap->error;
	if (soap_outliteral(soap, "-mixed", (char*const*)&a->__mixed, NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct xenc__EncryptionMethodType * SOAP_FMAC4 soap_in_xenc__EncryptionMethodType(struct soap *soap, const char *tag, struct xenc__EncryptionMethodType *a, const char *type)
{
	size_t soap_flag_KeySize = 1;
	size_t soap_flag_OAEPparams = 1;
	size_t soap_flag_ds__DigestMethod = 1;
	size_t soap_flag___mixed = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct xenc__EncryptionMethodType*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_xenc__EncryptionMethodType, sizeof(struct xenc__EncryptionMethodType), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_xenc__EncryptionMethodType(soap, a);
	if (soap_s2string(soap, soap_attr_value(soap, "Algorithm", 1, 1), &a->Algorithm))
		return NULL;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_KeySize && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerToint(soap, "xenc:KeySize", &a->KeySize, "xsd:int"))
				{	soap_flag_KeySize--;
					continue;
				}
			}
			if (soap_flag_OAEPparams && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_string(soap, "xenc:OAEPparams", (char**)&a->OAEPparams, "xsd:string"))
				{	soap_flag_OAEPparams--;
					continue;
				}
			}
			if (soap_flag_ds__DigestMethod && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTods__DigestMethodType(soap, "ds:DigestMethod", &a->ds__DigestMethod, "ds:DigestMethodType"))
				{	soap_flag_ds__DigestMethod--;
					continue;
				}
			}
			if (soap_flag___mixed && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_inliteral(soap, "-mixed", (char**)&a->__mixed))
				{	soap_flag___mixed--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct xenc__EncryptionMethodType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_xenc__EncryptionMethodType, SOAP_TYPE_xenc__EncryptionMethodType, sizeof(struct xenc__EncryptionMethodType), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct xenc__EncryptionMethodType * SOAP_FMAC4 soap_new_xenc__EncryptionMethodType(struct soap *soap, int n)
{
	struct xenc__EncryptionMethodType *p;
	struct xenc__EncryptionMethodType *a = (struct xenc__EncryptionMethodType*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct xenc__EncryptionMethodType));
	for (p = a; p && n--; p++)
		soap_default_xenc__EncryptionMethodType(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_xenc__EncryptionMethodType(struct soap *soap, const struct xenc__EncryptionMethodType *a, const char *tag, const char *type)
{
	if (soap_out_xenc__EncryptionMethodType(soap, tag ? tag : "xenc:EncryptionMethodType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct xenc__EncryptionMethodType * SOAP_FMAC4 soap_get_xenc__EncryptionMethodType(struct soap *soap, struct xenc__EncryptionMethodType *p, const char *tag, const char *type)
{
	if ((p = soap_in_xenc__EncryptionMethodType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_xenc__EncryptedType(struct soap *soap, struct xenc__EncryptedType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->EncryptionMethod = NULL;
	a->ds__KeyInfo = NULL;
	a->CipherData = NULL;
	a->EncryptionProperties = NULL;
	soap_default_string(soap, &a->Id);
	soap_default_string(soap, &a->Type);
	soap_default_string(soap, &a->MimeType);
	soap_default_string(soap, &a->Encoding);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_xenc__EncryptedType(struct soap *soap, const struct xenc__EncryptedType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerToxenc__EncryptionMethodType(soap, &a->EncryptionMethod);
	soap_serialize_PointerTo_ds__KeyInfo(soap, &a->ds__KeyInfo);
	soap_serialize_PointerToxenc__CipherDataType(soap, &a->CipherData);
	soap_serialize_PointerToxenc__EncryptionPropertiesType(soap, &a->EncryptionProperties);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_xenc__EncryptedType(struct soap *soap, const char *tag, int id, const struct xenc__EncryptedType *a, const char *type)
{
	if (a->Id)
		soap_set_attr(soap, "Id", soap_string2s(soap, a->Id), 1);
	if (a->Type)
		soap_set_attr(soap, "Type", soap_string2s(soap, a->Type), 1);
	if (a->MimeType)
		soap_set_attr(soap, "MimeType", soap_string2s(soap, a->MimeType), 1);
	if (a->Encoding)
		soap_set_attr(soap, "Encoding", soap_string2s(soap, a->Encoding), 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_xenc__EncryptedType), type))
		return soap->error;
	if (soap_out_PointerToxenc__EncryptionMethodType(soap, "xenc:EncryptionMethod", -1, &a->EncryptionMethod, ""))
		return soap->error;
	if (soap_out_PointerTo_ds__KeyInfo(soap, "ds:KeyInfo", -1, &a->ds__KeyInfo, ""))
		return soap->error;
	if (!a->CipherData)
	{	if (soap_element_empty(soap, "xenc:CipherData", 0, NULL))
			return soap->error;
	}
	else if (soap_out_PointerToxenc__CipherDataType(soap, "xenc:CipherData", -1, &a->CipherData, ""))
		return soap->error;
	if (soap_out_PointerToxenc__EncryptionPropertiesType(soap, "xenc:EncryptionProperties", -1, &a->EncryptionProperties, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct xenc__EncryptedType * SOAP_FMAC4 soap_in_xenc__EncryptedType(struct soap *soap, const char *tag, struct xenc__EncryptedType *a, const char *type)
{
	size_t soap_flag_EncryptionMethod = 1;
	size_t soap_flag_ds__KeyInfo = 1;
	size_t soap_flag_CipherData = 1;
	size_t soap_flag_EncryptionProperties = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct xenc__EncryptedType*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_xenc__EncryptedType, sizeof(struct xenc__EncryptedType), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_xenc__EncryptedType(soap, a);
	if (soap_s2string(soap, soap_attr_value(soap, "Id", 1, 0), &a->Id))
		return NULL;
	if (soap_s2string(soap, soap_attr_value(soap, "Type", 1, 0), &a->Type))
		return NULL;
	if (soap_s2string(soap, soap_attr_value(soap, "MimeType", 1, 0), &a->MimeType))
		return NULL;
	if (soap_s2string(soap, soap_attr_value(soap, "Encoding", 1, 0), &a->Encoding))
		return NULL;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_EncryptionMethod && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerToxenc__EncryptionMethodType(soap, "xenc:EncryptionMethod", &a->EncryptionMethod, "xenc:EncryptionMethodType"))
				{	soap_flag_EncryptionMethod--;
					continue;
				}
			}
			if (soap_flag_ds__KeyInfo && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_ds__KeyInfo(soap, "ds:KeyInfo", &a->ds__KeyInfo, ""))
				{	soap_flag_ds__KeyInfo--;
					continue;
				}
			}
			if (soap_flag_CipherData && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerToxenc__CipherDataType(soap, "xenc:CipherData", &a->CipherData, "xenc:CipherDataType"))
				{	soap_flag_CipherData--;
					continue;
				}
			}
			if (soap_flag_EncryptionProperties && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerToxenc__EncryptionPropertiesType(soap, "xenc:EncryptionProperties", &a->EncryptionProperties, "xenc:EncryptionPropertiesType"))
				{	soap_flag_EncryptionProperties--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (!a->CipherData))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct xenc__EncryptedType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_xenc__EncryptedType, SOAP_TYPE_xenc__EncryptedType, sizeof(struct xenc__EncryptedType), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct xenc__EncryptedType * SOAP_FMAC4 soap_new_xenc__EncryptedType(struct soap *soap, int n)
{
	struct xenc__EncryptedType *p;
	struct xenc__EncryptedType *a = (struct xenc__EncryptedType*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct xenc__EncryptedType));
	for (p = a; p && n--; p++)
		soap_default_xenc__EncryptedType(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_xenc__EncryptedType(struct soap *soap, const struct xenc__EncryptedType *a, const char *tag, const char *type)
{
	if (soap_out_xenc__EncryptedType(soap, tag ? tag : "xenc:EncryptedType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct xenc__EncryptedType * SOAP_FMAC4 soap_get_xenc__EncryptedType(struct soap *soap, struct xenc__EncryptedType *p, const char *tag, const char *type)
{
	if ((p = soap_in_xenc__EncryptedType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ds__RSAKeyValueType(struct soap *soap, struct ds__RSAKeyValueType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->Modulus);
	soap_default_string(soap, &a->Exponent);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ds__RSAKeyValueType(struct soap *soap, const struct ds__RSAKeyValueType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_string(soap, (char*const*)&a->Modulus);
	soap_serialize_string(soap, (char*const*)&a->Exponent);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ds__RSAKeyValueType(struct soap *soap, const char *tag, int id, const struct ds__RSAKeyValueType *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ds__RSAKeyValueType), type))
		return soap->error;
	if (!a->Modulus)
	{	if (soap_element_empty(soap, "ds:Modulus", 0, NULL))
			return soap->error;
	}
	else if (soap_out_string(soap, "ds:Modulus", -1, (char*const*)&a->Modulus, ""))
		return soap->error;
	if (!a->Exponent)
	{	if (soap_element_empty(soap, "ds:Exponent", 0, NULL))
			return soap->error;
	}
	else if (soap_out_string(soap, "ds:Exponent", -1, (char*const*)&a->Exponent, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ds__RSAKeyValueType * SOAP_FMAC4 soap_in_ds__RSAKeyValueType(struct soap *soap, const char *tag, struct ds__RSAKeyValueType *a, const char *type)
{
	size_t soap_flag_Modulus = 1;
	size_t soap_flag_Exponent = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct ds__RSAKeyValueType*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ds__RSAKeyValueType, sizeof(struct ds__RSAKeyValueType), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ds__RSAKeyValueType(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Modulus && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_string(soap, "ds:Modulus", (char**)&a->Modulus, "xsd:string"))
				{	soap_flag_Modulus--;
					continue;
				}
			}
			if (soap_flag_Exponent && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_string(soap, "ds:Exponent", (char**)&a->Exponent, "xsd:string"))
				{	soap_flag_Exponent--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (!a->Modulus || !a->Exponent))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct ds__RSAKeyValueType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ds__RSAKeyValueType, SOAP_TYPE_ds__RSAKeyValueType, sizeof(struct ds__RSAKeyValueType), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct ds__RSAKeyValueType * SOAP_FMAC4 soap_new_ds__RSAKeyValueType(struct soap *soap, int n)
{
	struct ds__RSAKeyValueType *p;
	struct ds__RSAKeyValueType *a = (struct ds__RSAKeyValueType*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct ds__RSAKeyValueType));
	for (p = a; p && n--; p++)
		soap_default_ds__RSAKeyValueType(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ds__RSAKeyValueType(struct soap *soap, const struct ds__RSAKeyValueType *a, const char *tag, const char *type)
{
	if (soap_out_ds__RSAKeyValueType(soap, tag ? tag : "ds:RSAKeyValueType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ds__RSAKeyValueType * SOAP_FMAC4 soap_get_ds__RSAKeyValueType(struct soap *soap, struct ds__RSAKeyValueType *p, const char *tag, const char *type)
{
	if ((p = soap_in_ds__RSAKeyValueType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ds__DSAKeyValueType(struct soap *soap, struct ds__DSAKeyValueType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->G);
	soap_default_string(soap, &a->Y);
	soap_default_string(soap, &a->J);
	soap_default_string(soap, &a->P);
	soap_default_string(soap, &a->Q);
	soap_default_string(soap, &a->Seed);
	soap_default_string(soap, &a->PgenCounter);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ds__DSAKeyValueType(struct soap *soap, const struct ds__DSAKeyValueType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_string(soap, (char*const*)&a->G);
	soap_serialize_string(soap, (char*const*)&a->Y);
	soap_serialize_string(soap, (char*const*)&a->J);
	soap_serialize_string(soap, (char*const*)&a->P);
	soap_serialize_string(soap, (char*const*)&a->Q);
	soap_serialize_string(soap, (char*const*)&a->Seed);
	soap_serialize_string(soap, (char*const*)&a->PgenCounter);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ds__DSAKeyValueType(struct soap *soap, const char *tag, int id, const struct ds__DSAKeyValueType *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ds__DSAKeyValueType), type))
		return soap->error;
	if (soap_out_string(soap, "ds:G", -1, (char*const*)&a->G, ""))
		return soap->error;
	if (!a->Y)
	{	if (soap_element_empty(soap, "ds:Y", 0, NULL))
			return soap->error;
	}
	else if (soap_out_string(soap, "ds:Y", -1, (char*const*)&a->Y, ""))
		return soap->error;
	if (soap_out_string(soap, "ds:J", -1, (char*const*)&a->J, ""))
		return soap->error;
	if (!a->P)
	{	if (soap_element_empty(soap, "ds:P", 0, NULL))
			return soap->error;
	}
	else if (soap_out_string(soap, "ds:P", -1, (char*const*)&a->P, ""))
		return soap->error;
	if (!a->Q)
	{	if (soap_element_empty(soap, "ds:Q", 0, NULL))
			return soap->error;
	}
	else if (soap_out_string(soap, "ds:Q", -1, (char*const*)&a->Q, ""))
		return soap->error;
	if (!a->Seed)
	{	if (soap_element_empty(soap, "ds:Seed", 0, NULL))
			return soap->error;
	}
	else if (soap_out_string(soap, "ds:Seed", -1, (char*const*)&a->Seed, ""))
		return soap->error;
	if (!a->PgenCounter)
	{	if (soap_element_empty(soap, "ds:PgenCounter", 0, NULL))
			return soap->error;
	}
	else if (soap_out_string(soap, "ds:PgenCounter", -1, (char*const*)&a->PgenCounter, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ds__DSAKeyValueType * SOAP_FMAC4 soap_in_ds__DSAKeyValueType(struct soap *soap, const char *tag, struct ds__DSAKeyValueType *a, const char *type)
{
	size_t soap_flag_G = 1;
	size_t soap_flag_Y = 1;
	size_t soap_flag_J = 1;
	size_t soap_flag_P = 1;
	size_t soap_flag_Q = 1;
	size_t soap_flag_Seed = 1;
	size_t soap_flag_PgenCounter = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct ds__DSAKeyValueType*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ds__DSAKeyValueType, sizeof(struct ds__DSAKeyValueType), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ds__DSAKeyValueType(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_G && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_string(soap, "ds:G", (char**)&a->G, "xsd:string"))
				{	soap_flag_G--;
					continue;
				}
			}
			if (soap_flag_Y && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_string(soap, "ds:Y", (char**)&a->Y, "xsd:string"))
				{	soap_flag_Y--;
					continue;
				}
			}
			if (soap_flag_J && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_string(soap, "ds:J", (char**)&a->J, "xsd:string"))
				{	soap_flag_J--;
					continue;
				}
			}
			if (soap_flag_P && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_string(soap, "ds:P", (char**)&a->P, "xsd:string"))
				{	soap_flag_P--;
					continue;
				}
			}
			if (soap_flag_Q && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_string(soap, "ds:Q", (char**)&a->Q, "xsd:string"))
				{	soap_flag_Q--;
					continue;
				}
			}
			if (soap_flag_Seed && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_string(soap, "ds:Seed", (char**)&a->Seed, "xsd:string"))
				{	soap_flag_Seed--;
					continue;
				}
			}
			if (soap_flag_PgenCounter && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_string(soap, "ds:PgenCounter", (char**)&a->PgenCounter, "xsd:string"))
				{	soap_flag_PgenCounter--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (!a->Y || !a->P || !a->Q || !a->Seed || !a->PgenCounter))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct ds__DSAKeyValueType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ds__DSAKeyValueType, SOAP_TYPE_ds__DSAKeyValueType, sizeof(struct ds__DSAKeyValueType), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct ds__DSAKeyValueType * SOAP_FMAC4 soap_new_ds__DSAKeyValueType(struct soap *soap, int n)
{
	struct ds__DSAKeyValueType *p;
	struct ds__DSAKeyValueType *a = (struct ds__DSAKeyValueType*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct ds__DSAKeyValueType));
	for (p = a; p && n--; p++)
		soap_default_ds__DSAKeyValueType(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ds__DSAKeyValueType(struct soap *soap, const struct ds__DSAKeyValueType *a, const char *tag, const char *type)
{
	if (soap_out_ds__DSAKeyValueType(soap, tag ? tag : "ds:DSAKeyValueType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ds__DSAKeyValueType * SOAP_FMAC4 soap_get_ds__DSAKeyValueType(struct soap *soap, struct ds__DSAKeyValueType *p, const char *tag, const char *type)
{
	if ((p = soap_in_ds__DSAKeyValueType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ds__X509IssuerSerialType(struct soap *soap, struct ds__X509IssuerSerialType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->X509IssuerName);
	soap_default_string(soap, &a->X509SerialNumber);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ds__X509IssuerSerialType(struct soap *soap, const struct ds__X509IssuerSerialType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_string(soap, (char*const*)&a->X509IssuerName);
	soap_serialize_string(soap, (char*const*)&a->X509SerialNumber);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ds__X509IssuerSerialType(struct soap *soap, const char *tag, int id, const struct ds__X509IssuerSerialType *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ds__X509IssuerSerialType), type))
		return soap->error;
	if (!a->X509IssuerName)
	{	if (soap_element_empty(soap, "ds:X509IssuerName", 0, NULL))
			return soap->error;
	}
	else if (soap_out_string(soap, "ds:X509IssuerName", -1, (char*const*)&a->X509IssuerName, ""))
		return soap->error;
	if (!a->X509SerialNumber)
	{	if (soap_element_empty(soap, "ds:X509SerialNumber", 0, NULL))
			return soap->error;
	}
	else if (soap_out_string(soap, "ds:X509SerialNumber", -1, (char*const*)&a->X509SerialNumber, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ds__X509IssuerSerialType * SOAP_FMAC4 soap_in_ds__X509IssuerSerialType(struct soap *soap, const char *tag, struct ds__X509IssuerSerialType *a, const char *type)
{
	size_t soap_flag_X509IssuerName = 1;
	size_t soap_flag_X509SerialNumber = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct ds__X509IssuerSerialType*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ds__X509IssuerSerialType, sizeof(struct ds__X509IssuerSerialType), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ds__X509IssuerSerialType(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_X509IssuerName && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_string(soap, "ds:X509IssuerName", (char**)&a->X509IssuerName, "xsd:string"))
				{	soap_flag_X509IssuerName--;
					continue;
				}
			}
			if (soap_flag_X509SerialNumber && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_string(soap, "ds:X509SerialNumber", (char**)&a->X509SerialNumber, "xsd:string"))
				{	soap_flag_X509SerialNumber--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (!a->X509IssuerName || !a->X509SerialNumber))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct ds__X509IssuerSerialType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ds__X509IssuerSerialType, SOAP_TYPE_ds__X509IssuerSerialType, sizeof(struct ds__X509IssuerSerialType), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct ds__X509IssuerSerialType * SOAP_FMAC4 soap_new_ds__X509IssuerSerialType(struct soap *soap, int n)
{
	struct ds__X509IssuerSerialType *p;
	struct ds__X509IssuerSerialType *a = (struct ds__X509IssuerSerialType*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct ds__X509IssuerSerialType));
	for (p = a; p && n--; p++)
		soap_default_ds__X509IssuerSerialType(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ds__X509IssuerSerialType(struct soap *soap, const struct ds__X509IssuerSerialType *a, const char *tag, const char *type)
{
	if (soap_out_ds__X509IssuerSerialType(soap, tag ? tag : "ds:X509IssuerSerialType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ds__X509IssuerSerialType * SOAP_FMAC4 soap_get_ds__X509IssuerSerialType(struct soap *soap, struct ds__X509IssuerSerialType *p, const char *tag, const char *type)
{
	if ((p = soap_in_ds__X509IssuerSerialType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__ds__KeyInfo(struct soap *soap, const struct ds__KeyInfoType *a, const char *tag, const char *type)
{
	if (soap_out__ds__KeyInfo(soap, tag ? tag : "ds:KeyInfo", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ds__RetrievalMethodType(struct soap *soap, struct ds__RetrievalMethodType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->Transforms = NULL;
	soap_default_string(soap, &a->URI);
	soap_default_string(soap, &a->Type);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ds__RetrievalMethodType(struct soap *soap, const struct ds__RetrievalMethodType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTods__TransformsType(soap, &a->Transforms);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ds__RetrievalMethodType(struct soap *soap, const char *tag, int id, const struct ds__RetrievalMethodType *a, const char *type)
{
	if (a->URI)
		soap_set_attr(soap, "URI", soap_string2s(soap, a->URI), 1);
	if (a->Type)
		soap_set_attr(soap, "Type", soap_string2s(soap, a->Type), 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ds__RetrievalMethodType), type))
		return soap->error;
	if (soap_out_PointerTods__TransformsType(soap, "ds:Transforms", -1, &a->Transforms, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ds__RetrievalMethodType * SOAP_FMAC4 soap_in_ds__RetrievalMethodType(struct soap *soap, const char *tag, struct ds__RetrievalMethodType *a, const char *type)
{
	size_t soap_flag_Transforms = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct ds__RetrievalMethodType*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ds__RetrievalMethodType, sizeof(struct ds__RetrievalMethodType), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ds__RetrievalMethodType(soap, a);
	if (soap_s2string(soap, soap_attr_value(soap, "URI", 1, 0), &a->URI))
		return NULL;
	if (soap_s2string(soap, soap_attr_value(soap, "Type", 1, 0), &a->Type))
		return NULL;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Transforms && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTods__TransformsType(soap, "ds:Transforms", &a->Transforms, "ds:TransformsType"))
				{	soap_flag_Transforms--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ds__RetrievalMethodType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ds__RetrievalMethodType, SOAP_TYPE_ds__RetrievalMethodType, sizeof(struct ds__RetrievalMethodType), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct ds__RetrievalMethodType * SOAP_FMAC4 soap_new_ds__RetrievalMethodType(struct soap *soap, int n)
{
	struct ds__RetrievalMethodType *p;
	struct ds__RetrievalMethodType *a = (struct ds__RetrievalMethodType*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct ds__RetrievalMethodType));
	for (p = a; p && n--; p++)
		soap_default_ds__RetrievalMethodType(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ds__RetrievalMethodType(struct soap *soap, const struct ds__RetrievalMethodType *a, const char *tag, const char *type)
{
	if (soap_out_ds__RetrievalMethodType(soap, tag ? tag : "ds:RetrievalMethodType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ds__RetrievalMethodType * SOAP_FMAC4 soap_get_ds__RetrievalMethodType(struct soap *soap, struct ds__RetrievalMethodType *p, const char *tag, const char *type)
{
	if ((p = soap_in_ds__RetrievalMethodType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ds__KeyValueType(struct soap *soap, struct ds__KeyValueType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->DSAKeyValue = NULL;
	a->RSAKeyValue = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ds__KeyValueType(struct soap *soap, const struct ds__KeyValueType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTods__DSAKeyValueType(soap, &a->DSAKeyValue);
	soap_serialize_PointerTods__RSAKeyValueType(soap, &a->RSAKeyValue);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ds__KeyValueType(struct soap *soap, const char *tag, int id, const struct ds__KeyValueType *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ds__KeyValueType), type))
		return soap->error;
	if (soap_out_PointerTods__DSAKeyValueType(soap, "ds:DSAKeyValue", -1, &a->DSAKeyValue, ""))
		return soap->error;
	if (soap_out_PointerTods__RSAKeyValueType(soap, "ds:RSAKeyValue", -1, &a->RSAKeyValue, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ds__KeyValueType * SOAP_FMAC4 soap_in_ds__KeyValueType(struct soap *soap, const char *tag, struct ds__KeyValueType *a, const char *type)
{
	size_t soap_flag_DSAKeyValue = 1;
	size_t soap_flag_RSAKeyValue = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct ds__KeyValueType*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ds__KeyValueType, sizeof(struct ds__KeyValueType), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ds__KeyValueType(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_DSAKeyValue && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTods__DSAKeyValueType(soap, "ds:DSAKeyValue", &a->DSAKeyValue, "ds:DSAKeyValueType"))
				{	soap_flag_DSAKeyValue--;
					continue;
				}
			}
			if (soap_flag_RSAKeyValue && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTods__RSAKeyValueType(soap, "ds:RSAKeyValue", &a->RSAKeyValue, "ds:RSAKeyValueType"))
				{	soap_flag_RSAKeyValue--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ds__KeyValueType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ds__KeyValueType, SOAP_TYPE_ds__KeyValueType, sizeof(struct ds__KeyValueType), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct ds__KeyValueType * SOAP_FMAC4 soap_new_ds__KeyValueType(struct soap *soap, int n)
{
	struct ds__KeyValueType *p;
	struct ds__KeyValueType *a = (struct ds__KeyValueType*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct ds__KeyValueType));
	for (p = a; p && n--; p++)
		soap_default_ds__KeyValueType(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ds__KeyValueType(struct soap *soap, const struct ds__KeyValueType *a, const char *tag, const char *type)
{
	if (soap_out_ds__KeyValueType(soap, tag ? tag : "ds:KeyValueType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ds__KeyValueType * SOAP_FMAC4 soap_get_ds__KeyValueType(struct soap *soap, struct ds__KeyValueType *p, const char *tag, const char *type)
{
	if ((p = soap_in_ds__KeyValueType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ds__DigestMethodType(struct soap *soap, struct ds__DigestMethodType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->Algorithm);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ds__DigestMethodType(struct soap *soap, const struct ds__DigestMethodType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ds__DigestMethodType(struct soap *soap, const char *tag, int id, const struct ds__DigestMethodType *a, const char *type)
{
	soap_set_attr(soap, "Algorithm", a->Algorithm ? soap_string2s(soap, a->Algorithm) : "", 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ds__DigestMethodType), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ds__DigestMethodType * SOAP_FMAC4 soap_in_ds__DigestMethodType(struct soap *soap, const char *tag, struct ds__DigestMethodType *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct ds__DigestMethodType*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ds__DigestMethodType, sizeof(struct ds__DigestMethodType), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ds__DigestMethodType(soap, a);
	if (soap_s2string(soap, soap_attr_value(soap, "Algorithm", 1, 1), &a->Algorithm))
		return NULL;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ds__DigestMethodType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ds__DigestMethodType, SOAP_TYPE_ds__DigestMethodType, sizeof(struct ds__DigestMethodType), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct ds__DigestMethodType * SOAP_FMAC4 soap_new_ds__DigestMethodType(struct soap *soap, int n)
{
	struct ds__DigestMethodType *p;
	struct ds__DigestMethodType *a = (struct ds__DigestMethodType*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct ds__DigestMethodType));
	for (p = a; p && n--; p++)
		soap_default_ds__DigestMethodType(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ds__DigestMethodType(struct soap *soap, const struct ds__DigestMethodType *a, const char *tag, const char *type)
{
	if (soap_out_ds__DigestMethodType(soap, tag ? tag : "ds:DigestMethodType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ds__DigestMethodType * SOAP_FMAC4 soap_get_ds__DigestMethodType(struct soap *soap, struct ds__DigestMethodType *p, const char *tag, const char *type)
{
	if ((p = soap_in_ds__DigestMethodType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__ds__Transform(struct soap *soap, const struct ds__TransformType *a, const char *tag, const char *type)
{
	if (soap_out__ds__Transform(soap, tag ? tag : "ds:Transform", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ds__TransformType(struct soap *soap, struct ds__TransformType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->c14n__InclusiveNamespaces = NULL;
	a->__any = NULL;
	soap_default_string(soap, &a->Algorithm);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ds__TransformType(struct soap *soap, const struct ds__TransformType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_c14n__InclusiveNamespaces(soap, &a->c14n__InclusiveNamespaces);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ds__TransformType(struct soap *soap, const char *tag, int id, const struct ds__TransformType *a, const char *type)
{
	if (a->Algorithm)
		soap_set_attr(soap, "Algorithm", soap_string2s(soap, a->Algorithm), 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ds__TransformType), type))
		return soap->error;
	if (soap_out_PointerTo_c14n__InclusiveNamespaces(soap, "c14n:InclusiveNamespaces", -1, &a->c14n__InclusiveNamespaces, ""))
		return soap->error;
	if (soap_outliteral(soap, "-any", (char*const*)&a->__any, NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ds__TransformType * SOAP_FMAC4 soap_in_ds__TransformType(struct soap *soap, const char *tag, struct ds__TransformType *a, const char *type)
{
	size_t soap_flag_c14n__InclusiveNamespaces = 1;
	size_t soap_flag___any = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct ds__TransformType*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ds__TransformType, sizeof(struct ds__TransformType), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ds__TransformType(soap, a);
	if (soap_s2string(soap, soap_attr_value(soap, "Algorithm", 1, 0), &a->Algorithm))
		return NULL;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_c14n__InclusiveNamespaces && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_c14n__InclusiveNamespaces(soap, "c14n:InclusiveNamespaces", &a->c14n__InclusiveNamespaces, ""))
				{	soap_flag_c14n__InclusiveNamespaces--;
					continue;
				}
			}
			if (soap_flag___any && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_inliteral(soap, "-any", (char**)&a->__any))
				{	soap_flag___any--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ds__TransformType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ds__TransformType, SOAP_TYPE_ds__TransformType, sizeof(struct ds__TransformType), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct ds__TransformType * SOAP_FMAC4 soap_new_ds__TransformType(struct soap *soap, int n)
{
	struct ds__TransformType *p;
	struct ds__TransformType *a = (struct ds__TransformType*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct ds__TransformType));
	for (p = a; p && n--; p++)
		soap_default_ds__TransformType(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ds__TransformType(struct soap *soap, const struct ds__TransformType *a, const char *tag, const char *type)
{
	if (soap_out_ds__TransformType(soap, tag ? tag : "ds:TransformType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ds__TransformType * SOAP_FMAC4 soap_get_ds__TransformType(struct soap *soap, struct ds__TransformType *p, const char *tag, const char *type)
{
	if ((p = soap_in_ds__TransformType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__c14n__InclusiveNamespaces(struct soap *soap, struct _c14n__InclusiveNamespaces *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->PrefixList);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__c14n__InclusiveNamespaces(struct soap *soap, const struct _c14n__InclusiveNamespaces *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__c14n__InclusiveNamespaces(struct soap *soap, const char *tag, int id, const struct _c14n__InclusiveNamespaces *a, const char *type)
{
	if (a->PrefixList)
		soap_set_attr(soap, "PrefixList", soap_string2s(soap, a->PrefixList), 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__c14n__InclusiveNamespaces), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _c14n__InclusiveNamespaces * SOAP_FMAC4 soap_in__c14n__InclusiveNamespaces(struct soap *soap, const char *tag, struct _c14n__InclusiveNamespaces *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct _c14n__InclusiveNamespaces*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__c14n__InclusiveNamespaces, sizeof(struct _c14n__InclusiveNamespaces), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__c14n__InclusiveNamespaces(soap, a);
	if (soap_s2string(soap, soap_attr_value(soap, "PrefixList", 1, 0), &a->PrefixList))
		return NULL;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _c14n__InclusiveNamespaces *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__c14n__InclusiveNamespaces, SOAP_TYPE__c14n__InclusiveNamespaces, sizeof(struct _c14n__InclusiveNamespaces), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _c14n__InclusiveNamespaces * SOAP_FMAC4 soap_new__c14n__InclusiveNamespaces(struct soap *soap, int n)
{
	struct _c14n__InclusiveNamespaces *p;
	struct _c14n__InclusiveNamespaces *a = (struct _c14n__InclusiveNamespaces*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _c14n__InclusiveNamespaces));
	for (p = a; p && n--; p++)
		soap_default__c14n__InclusiveNamespaces(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__c14n__InclusiveNamespaces(struct soap *soap, const struct _c14n__InclusiveNamespaces *a, const char *tag, const char *type)
{
	if (soap_out__c14n__InclusiveNamespaces(soap, tag ? tag : "c14n:InclusiveNamespaces", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _c14n__InclusiveNamespaces * SOAP_FMAC4 soap_get__c14n__InclusiveNamespaces(struct soap *soap, struct _c14n__InclusiveNamespaces *p, const char *tag, const char *type)
{
	if ((p = soap_in__c14n__InclusiveNamespaces(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ds__TransformsType(struct soap *soap, struct ds__TransformsType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__sizeTransform = 0;
	a->Transform = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ds__TransformsType(struct soap *soap, const struct ds__TransformsType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (a->Transform)
	{	int i;
		for (i = 0; i < (int)a->__sizeTransform; i++)
		{
			soap_embedded(soap, a->Transform + i, SOAP_TYPE_ds__TransformType);
			soap_serialize_ds__TransformType(soap, a->Transform + i);
		}
	}
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ds__TransformsType(struct soap *soap, const char *tag, int id, const struct ds__TransformsType *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ds__TransformsType), type))
		return soap->error;
	if (a->Transform)
	{	int i;
		for (i = 0; i < (int)a->__sizeTransform; i++)
			if (soap_out_ds__TransformType(soap, "ds:Transform", -1, a->Transform + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ds__TransformsType * SOAP_FMAC4 soap_in_ds__TransformsType(struct soap *soap, const char *tag, struct ds__TransformsType *a, const char *type)
{
	struct soap_blist *soap_blist_Transform = NULL;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct ds__TransformsType*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ds__TransformsType, sizeof(struct ds__TransformsType), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ds__TransformsType(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "ds:Transform", 1, NULL))
			{	if (a->Transform == NULL)
				{	if (soap_blist_Transform == NULL)
						soap_blist_Transform = soap_alloc_block(soap);
					a->Transform = (struct ds__TransformType *)soap_push_block_max(soap, soap_blist_Transform, sizeof(struct ds__TransformType));
					if (a->Transform == NULL)
						return NULL;
					soap_default_ds__TransformType(soap, a->Transform);
				}
				soap_revert(soap);
				if (soap_in_ds__TransformType(soap, "ds:Transform", a->Transform, "ds:TransformType"))
				{	a->__sizeTransform++;
					a->Transform = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->Transform)
			soap_pop_block(soap, soap_blist_Transform);
		if (a->__sizeTransform)
		{	a->Transform = (struct ds__TransformType *)soap_save_block(soap, soap_blist_Transform, NULL, 1);
		}
		else
		{	a->Transform = NULL;
			if (soap_blist_Transform)
				soap_end_block(soap, soap_blist_Transform);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ds__TransformsType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ds__TransformsType, SOAP_TYPE_ds__TransformsType, sizeof(struct ds__TransformsType), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct ds__TransformsType * SOAP_FMAC4 soap_new_ds__TransformsType(struct soap *soap, int n)
{
	struct ds__TransformsType *p;
	struct ds__TransformsType *a = (struct ds__TransformsType*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct ds__TransformsType));
	for (p = a; p && n--; p++)
		soap_default_ds__TransformsType(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ds__TransformsType(struct soap *soap, const struct ds__TransformsType *a, const char *tag, const char *type)
{
	if (soap_out_ds__TransformsType(soap, tag ? tag : "ds:TransformsType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ds__TransformsType * SOAP_FMAC4 soap_get_ds__TransformsType(struct soap *soap, struct ds__TransformsType *p, const char *tag, const char *type)
{
	if ((p = soap_in_ds__TransformsType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ds__ReferenceType(struct soap *soap, struct ds__ReferenceType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->Transforms = NULL;
	a->DigestMethod = NULL;
	soap_default_string(soap, &a->DigestValue);
	soap_default_string(soap, &a->Id);
	soap_default_string(soap, &a->URI);
	soap_default_string(soap, &a->Type);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ds__ReferenceType(struct soap *soap, const struct ds__ReferenceType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTods__TransformsType(soap, &a->Transforms);
	soap_serialize_PointerTods__DigestMethodType(soap, &a->DigestMethod);
	soap_serialize_string(soap, (char*const*)&a->DigestValue);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ds__ReferenceType(struct soap *soap, const char *tag, int id, const struct ds__ReferenceType *a, const char *type)
{
	if (a->Id)
		soap_set_attr(soap, "Id", soap_string2s(soap, a->Id), 1);
	if (a->URI)
		soap_set_attr(soap, "URI", soap_string2s(soap, a->URI), 1);
	if (a->Type)
		soap_set_attr(soap, "Type", soap_string2s(soap, a->Type), 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ds__ReferenceType), type))
		return soap->error;
	if (soap_out_PointerTods__TransformsType(soap, "ds:Transforms", -1, &a->Transforms, ""))
		return soap->error;
	if (!a->DigestMethod)
	{	if (soap_element_empty(soap, "ds:DigestMethod", 0, NULL))
			return soap->error;
	}
	else if (soap_out_PointerTods__DigestMethodType(soap, "ds:DigestMethod", -1, &a->DigestMethod, ""))
		return soap->error;
	if (!a->DigestValue)
	{	if (soap_element_empty(soap, "ds:DigestValue", 0, NULL))
			return soap->error;
	}
	else if (soap_out_string(soap, "ds:DigestValue", -1, (char*const*)&a->DigestValue, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ds__ReferenceType * SOAP_FMAC4 soap_in_ds__ReferenceType(struct soap *soap, const char *tag, struct ds__ReferenceType *a, const char *type)
{
	size_t soap_flag_Transforms = 1;
	size_t soap_flag_DigestMethod = 1;
	size_t soap_flag_DigestValue = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct ds__ReferenceType*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ds__ReferenceType, sizeof(struct ds__ReferenceType), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ds__ReferenceType(soap, a);
	if (soap_s2string(soap, soap_attr_value(soap, "Id", 1, 0), &a->Id))
		return NULL;
	if (soap_s2string(soap, soap_attr_value(soap, "URI", 1, 0), &a->URI))
		return NULL;
	if (soap_s2string(soap, soap_attr_value(soap, "Type", 1, 0), &a->Type))
		return NULL;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Transforms && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTods__TransformsType(soap, "ds:Transforms", &a->Transforms, "ds:TransformsType"))
				{	soap_flag_Transforms--;
					continue;
				}
			}
			if (soap_flag_DigestMethod && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTods__DigestMethodType(soap, "ds:DigestMethod", &a->DigestMethod, "ds:DigestMethodType"))
				{	soap_flag_DigestMethod--;
					continue;
				}
			}
			if (soap_flag_DigestValue && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_string(soap, "ds:DigestValue", (char**)&a->DigestValue, "xsd:string"))
				{	soap_flag_DigestValue--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (!a->DigestMethod || !a->DigestValue))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct ds__ReferenceType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ds__ReferenceType, SOAP_TYPE_ds__ReferenceType, sizeof(struct ds__ReferenceType), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct ds__ReferenceType * SOAP_FMAC4 soap_new_ds__ReferenceType(struct soap *soap, int n)
{
	struct ds__ReferenceType *p;
	struct ds__ReferenceType *a = (struct ds__ReferenceType*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct ds__ReferenceType));
	for (p = a; p && n--; p++)
		soap_default_ds__ReferenceType(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ds__ReferenceType(struct soap *soap, const struct ds__ReferenceType *a, const char *tag, const char *type)
{
	if (soap_out_ds__ReferenceType(soap, tag ? tag : "ds:ReferenceType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ds__ReferenceType * SOAP_FMAC4 soap_get_ds__ReferenceType(struct soap *soap, struct ds__ReferenceType *p, const char *tag, const char *type)
{
	if ((p = soap_in_ds__ReferenceType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ds__SignatureMethodType(struct soap *soap, struct ds__SignatureMethodType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->HMACOutputLength = NULL;
	soap_default_string(soap, &a->Algorithm);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ds__SignatureMethodType(struct soap *soap, const struct ds__SignatureMethodType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerToint(soap, &a->HMACOutputLength);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ds__SignatureMethodType(struct soap *soap, const char *tag, int id, const struct ds__SignatureMethodType *a, const char *type)
{
	soap_set_attr(soap, "Algorithm", a->Algorithm ? soap_string2s(soap, a->Algorithm) : "", 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ds__SignatureMethodType), type))
		return soap->error;
	if (soap_out_PointerToint(soap, "ds:HMACOutputLength", -1, &a->HMACOutputLength, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ds__SignatureMethodType * SOAP_FMAC4 soap_in_ds__SignatureMethodType(struct soap *soap, const char *tag, struct ds__SignatureMethodType *a, const char *type)
{
	size_t soap_flag_HMACOutputLength = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct ds__SignatureMethodType*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ds__SignatureMethodType, sizeof(struct ds__SignatureMethodType), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ds__SignatureMethodType(soap, a);
	if (soap_s2string(soap, soap_attr_value(soap, "Algorithm", 1, 1), &a->Algorithm))
		return NULL;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_HMACOutputLength && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerToint(soap, "ds:HMACOutputLength", &a->HMACOutputLength, "xsd:int"))
				{	soap_flag_HMACOutputLength--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ds__SignatureMethodType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ds__SignatureMethodType, SOAP_TYPE_ds__SignatureMethodType, sizeof(struct ds__SignatureMethodType), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct ds__SignatureMethodType * SOAP_FMAC4 soap_new_ds__SignatureMethodType(struct soap *soap, int n)
{
	struct ds__SignatureMethodType *p;
	struct ds__SignatureMethodType *a = (struct ds__SignatureMethodType*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct ds__SignatureMethodType));
	for (p = a; p && n--; p++)
		soap_default_ds__SignatureMethodType(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ds__SignatureMethodType(struct soap *soap, const struct ds__SignatureMethodType *a, const char *tag, const char *type)
{
	if (soap_out_ds__SignatureMethodType(soap, tag ? tag : "ds:SignatureMethodType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ds__SignatureMethodType * SOAP_FMAC4 soap_get_ds__SignatureMethodType(struct soap *soap, struct ds__SignatureMethodType *p, const char *tag, const char *type)
{
	if ((p = soap_in_ds__SignatureMethodType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ds__CanonicalizationMethodType(struct soap *soap, struct ds__CanonicalizationMethodType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->Algorithm);
	a->c14n__InclusiveNamespaces = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ds__CanonicalizationMethodType(struct soap *soap, const struct ds__CanonicalizationMethodType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_c14n__InclusiveNamespaces(soap, &a->c14n__InclusiveNamespaces);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ds__CanonicalizationMethodType(struct soap *soap, const char *tag, int id, const struct ds__CanonicalizationMethodType *a, const char *type)
{
	soap_set_attr(soap, "Algorithm", a->Algorithm ? soap_string2s(soap, a->Algorithm) : "", 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ds__CanonicalizationMethodType), type))
		return soap->error;
	if (soap_out_PointerTo_c14n__InclusiveNamespaces(soap, "c14n:InclusiveNamespaces", -1, &a->c14n__InclusiveNamespaces, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ds__CanonicalizationMethodType * SOAP_FMAC4 soap_in_ds__CanonicalizationMethodType(struct soap *soap, const char *tag, struct ds__CanonicalizationMethodType *a, const char *type)
{
	size_t soap_flag_c14n__InclusiveNamespaces = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct ds__CanonicalizationMethodType*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ds__CanonicalizationMethodType, sizeof(struct ds__CanonicalizationMethodType), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ds__CanonicalizationMethodType(soap, a);
	if (soap_s2string(soap, soap_attr_value(soap, "Algorithm", 1, 1), &a->Algorithm))
		return NULL;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_c14n__InclusiveNamespaces && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_c14n__InclusiveNamespaces(soap, "c14n:InclusiveNamespaces", &a->c14n__InclusiveNamespaces, ""))
				{	soap_flag_c14n__InclusiveNamespaces--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ds__CanonicalizationMethodType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ds__CanonicalizationMethodType, SOAP_TYPE_ds__CanonicalizationMethodType, sizeof(struct ds__CanonicalizationMethodType), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct ds__CanonicalizationMethodType * SOAP_FMAC4 soap_new_ds__CanonicalizationMethodType(struct soap *soap, int n)
{
	struct ds__CanonicalizationMethodType *p;
	struct ds__CanonicalizationMethodType *a = (struct ds__CanonicalizationMethodType*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct ds__CanonicalizationMethodType));
	for (p = a; p && n--; p++)
		soap_default_ds__CanonicalizationMethodType(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ds__CanonicalizationMethodType(struct soap *soap, const struct ds__CanonicalizationMethodType *a, const char *tag, const char *type)
{
	if (soap_out_ds__CanonicalizationMethodType(soap, tag ? tag : "ds:CanonicalizationMethodType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ds__CanonicalizationMethodType * SOAP_FMAC4 soap_get_ds__CanonicalizationMethodType(struct soap *soap, struct ds__CanonicalizationMethodType *p, const char *tag, const char *type)
{
	if ((p = soap_in_ds__CanonicalizationMethodType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__ds__Signature(struct soap *soap, const struct ds__SignatureType *a, const char *tag, const char *type)
{
	if (soap_out__ds__Signature(soap, tag ? tag : "ds:Signature", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ds__SignedInfoType(struct soap *soap, struct ds__SignedInfoType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->CanonicalizationMethod = NULL;
	a->SignatureMethod = NULL;
	a->__sizeReference = 0;
	a->Reference = NULL;
	soap_default_string(soap, &a->Id);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ds__SignedInfoType(struct soap *soap, const struct ds__SignedInfoType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTods__CanonicalizationMethodType(soap, &a->CanonicalizationMethod);
	soap_serialize_PointerTods__SignatureMethodType(soap, &a->SignatureMethod);
	if (a->Reference)
	{	int i;
		for (i = 0; i < (int)a->__sizeReference; i++)
		{
			soap_serialize_PointerTods__ReferenceType(soap, a->Reference + i);
		}
	}
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ds__SignedInfoType(struct soap *soap, const char *tag, int id, const struct ds__SignedInfoType *a, const char *type)
{
	if (a->Id)
		soap_set_attr(soap, "Id", soap_string2s(soap, a->Id), 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ds__SignedInfoType), type))
		return soap->error;
	if (!a->CanonicalizationMethod)
	{	if (soap_element_empty(soap, "ds:CanonicalizationMethod", 0, NULL))
			return soap->error;
	}
	else if (soap_out_PointerTods__CanonicalizationMethodType(soap, "ds:CanonicalizationMethod", -1, &a->CanonicalizationMethod, ""))
		return soap->error;
	if (!a->SignatureMethod)
	{	if (soap_element_empty(soap, "ds:SignatureMethod", 0, NULL))
			return soap->error;
	}
	else if (soap_out_PointerTods__SignatureMethodType(soap, "ds:SignatureMethod", -1, &a->SignatureMethod, ""))
		return soap->error;
	if (a->Reference)
	{	int i;
		for (i = 0; i < (int)a->__sizeReference; i++)
			if (soap_out_PointerTods__ReferenceType(soap, "ds:Reference", -1, a->Reference + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ds__SignedInfoType * SOAP_FMAC4 soap_in_ds__SignedInfoType(struct soap *soap, const char *tag, struct ds__SignedInfoType *a, const char *type)
{
	size_t soap_flag_CanonicalizationMethod = 1;
	size_t soap_flag_SignatureMethod = 1;
	struct soap_blist *soap_blist_Reference = NULL;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct ds__SignedInfoType*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ds__SignedInfoType, sizeof(struct ds__SignedInfoType), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ds__SignedInfoType(soap, a);
	if (soap_s2string(soap, soap_attr_value(soap, "Id", 1, 0), &a->Id))
		return NULL;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_CanonicalizationMethod && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTods__CanonicalizationMethodType(soap, "ds:CanonicalizationMethod", &a->CanonicalizationMethod, "ds:CanonicalizationMethodType"))
				{	soap_flag_CanonicalizationMethod--;
					continue;
				}
			}
			if (soap_flag_SignatureMethod && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTods__SignatureMethodType(soap, "ds:SignatureMethod", &a->SignatureMethod, "ds:SignatureMethodType"))
				{	soap_flag_SignatureMethod--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "ds:Reference", 1, NULL))
			{	if (a->Reference == NULL)
				{	if (soap_blist_Reference == NULL)
						soap_blist_Reference = soap_alloc_block(soap);
					a->Reference = (struct ds__ReferenceType **)soap_push_block_max(soap, soap_blist_Reference, sizeof(struct ds__ReferenceType *));
					if (a->Reference == NULL)
						return NULL;
					*a->Reference = NULL;
				}
				soap_revert(soap);
				if (soap_in_PointerTods__ReferenceType(soap, "ds:Reference", a->Reference, "ds:ReferenceType"))
				{	a->__sizeReference++;
					a->Reference = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->Reference)
			soap_pop_block(soap, soap_blist_Reference);
		if (a->__sizeReference)
		{	a->Reference = (struct ds__ReferenceType **)soap_save_block(soap, soap_blist_Reference, NULL, 1);
		}
		else
		{	a->Reference = NULL;
			if (soap_blist_Reference)
				soap_end_block(soap, soap_blist_Reference);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (!a->CanonicalizationMethod || !a->SignatureMethod))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct ds__SignedInfoType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ds__SignedInfoType, SOAP_TYPE_ds__SignedInfoType, sizeof(struct ds__SignedInfoType), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct ds__SignedInfoType * SOAP_FMAC4 soap_new_ds__SignedInfoType(struct soap *soap, int n)
{
	struct ds__SignedInfoType *p;
	struct ds__SignedInfoType *a = (struct ds__SignedInfoType*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct ds__SignedInfoType));
	for (p = a; p && n--; p++)
		soap_default_ds__SignedInfoType(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ds__SignedInfoType(struct soap *soap, const struct ds__SignedInfoType *a, const char *tag, const char *type)
{
	if (soap_out_ds__SignedInfoType(soap, tag ? tag : "ds:SignedInfoType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ds__SignedInfoType * SOAP_FMAC4 soap_get_ds__SignedInfoType(struct soap *soap, struct ds__SignedInfoType *p, const char *tag, const char *type)
{
	if ((p = soap_in_ds__SignedInfoType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ds__SignatureType(struct soap *soap, struct ds__SignatureType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->SignedInfo = NULL;
	soap_default__ds__SignatureValue(soap, &a->SignatureValue);
	a->KeyInfo = NULL;
	soap_default_string(soap, &a->Id);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ds__SignatureType(struct soap *soap, const struct ds__SignatureType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTods__SignedInfoType(soap, &a->SignedInfo);
	soap_serialize__ds__SignatureValue(soap, (char*const*)&a->SignatureValue);
	soap_serialize_PointerTods__KeyInfoType(soap, &a->KeyInfo);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ds__SignatureType(struct soap *soap, const char *tag, int id, const struct ds__SignatureType *a, const char *type)
{
	if (a->Id)
		soap_set_attr(soap, "Id", soap_string2s(soap, a->Id), 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ds__SignatureType), type))
		return soap->error;
	if (soap_out_PointerTods__SignedInfoType(soap, "ds:SignedInfo", -1, &a->SignedInfo, ""))
		return soap->error;
	if (soap_out__ds__SignatureValue(soap, "ds:SignatureValue", -1, (char*const*)&a->SignatureValue, ""))
		return soap->error;
	if (soap_out_PointerTods__KeyInfoType(soap, "ds:KeyInfo", -1, &a->KeyInfo, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ds__SignatureType * SOAP_FMAC4 soap_in_ds__SignatureType(struct soap *soap, const char *tag, struct ds__SignatureType *a, const char *type)
{
	size_t soap_flag_SignedInfo = 1;
	size_t soap_flag_SignatureValue = 1;
	size_t soap_flag_KeyInfo = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct ds__SignatureType*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ds__SignatureType, sizeof(struct ds__SignatureType), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ds__SignatureType(soap, a);
	if (soap_s2string(soap, soap_attr_value(soap, "Id", 1, 0), &a->Id))
		return NULL;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_SignedInfo && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTods__SignedInfoType(soap, "ds:SignedInfo", &a->SignedInfo, "ds:SignedInfoType"))
				{	soap_flag_SignedInfo--;
					continue;
				}
			}
			if (soap_flag_SignatureValue && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in__ds__SignatureValue(soap, "ds:SignatureValue", (char**)&a->SignatureValue, ""))
				{	soap_flag_SignatureValue--;
					continue;
				}
			}
			if (soap_flag_KeyInfo && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTods__KeyInfoType(soap, "ds:KeyInfo", &a->KeyInfo, "ds:KeyInfoType"))
				{	soap_flag_KeyInfo--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ds__SignatureType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ds__SignatureType, SOAP_TYPE_ds__SignatureType, sizeof(struct ds__SignatureType), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct ds__SignatureType * SOAP_FMAC4 soap_new_ds__SignatureType(struct soap *soap, int n)
{
	struct ds__SignatureType *p;
	struct ds__SignatureType *a = (struct ds__SignatureType*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct ds__SignatureType));
	for (p = a; p && n--; p++)
		soap_default_ds__SignatureType(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ds__SignatureType(struct soap *soap, const struct ds__SignatureType *a, const char *tag, const char *type)
{
	if (soap_out_ds__SignatureType(soap, tag ? tag : "ds:SignatureType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ds__SignatureType * SOAP_FMAC4 soap_get_ds__SignatureType(struct soap *soap, struct ds__SignatureType *p, const char *tag, const char *type)
{
	if ((p = soap_in_ds__SignatureType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_xenc__EncryptedKeyType(struct soap *soap, struct xenc__EncryptedKeyType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->EncryptionMethod = NULL;
	a->ds__KeyInfo = NULL;
	a->CipherData = NULL;
	a->EncryptionProperties = NULL;
	soap_default_string(soap, &a->Id);
	soap_default_string(soap, &a->Type);
	soap_default_string(soap, &a->MimeType);
	soap_default_string(soap, &a->Encoding);
	a->ReferenceList = NULL;
	soap_default_string(soap, &a->CarriedKeyName);
	soap_default_string(soap, &a->Recipient);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_xenc__EncryptedKeyType(struct soap *soap, const struct xenc__EncryptedKeyType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerToxenc__EncryptionMethodType(soap, &a->EncryptionMethod);
	soap_serialize_PointerTo_ds__KeyInfo(soap, &a->ds__KeyInfo);
	soap_serialize_PointerToxenc__CipherDataType(soap, &a->CipherData);
	soap_serialize_PointerToxenc__EncryptionPropertiesType(soap, &a->EncryptionProperties);
	soap_serialize_PointerTo_xenc__ReferenceList(soap, &a->ReferenceList);
	soap_serialize_string(soap, (char*const*)&a->CarriedKeyName);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_xenc__EncryptedKeyType(struct soap *soap, const char *tag, int id, const struct xenc__EncryptedKeyType *a, const char *type)
{
	if (a->Id)
		soap_set_attr(soap, "Id", soap_string2s(soap, a->Id), 1);
	if (a->Type)
		soap_set_attr(soap, "Type", soap_string2s(soap, a->Type), 1);
	if (a->MimeType)
		soap_set_attr(soap, "MimeType", soap_string2s(soap, a->MimeType), 1);
	if (a->Encoding)
		soap_set_attr(soap, "Encoding", soap_string2s(soap, a->Encoding), 1);
	if (a->Recipient)
		soap_set_attr(soap, "Recipient", soap_string2s(soap, a->Recipient), 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_xenc__EncryptedKeyType), type))
		return soap->error;
	if (soap_out_PointerToxenc__EncryptionMethodType(soap, "xenc:EncryptionMethod", -1, &a->EncryptionMethod, ""))
		return soap->error;
	if (soap_out_PointerTo_ds__KeyInfo(soap, "ds:KeyInfo", -1, &a->ds__KeyInfo, ""))
		return soap->error;
	if (!a->CipherData)
	{	if (soap_element_empty(soap, "xenc:CipherData", 0, NULL))
			return soap->error;
	}
	else if (soap_out_PointerToxenc__CipherDataType(soap, "xenc:CipherData", -1, &a->CipherData, ""))
		return soap->error;
	if (soap_out_PointerToxenc__EncryptionPropertiesType(soap, "xenc:EncryptionProperties", -1, &a->EncryptionProperties, ""))
		return soap->error;
	if (soap_out_PointerTo_xenc__ReferenceList(soap, "xenc:ReferenceList", -1, &a->ReferenceList, ""))
		return soap->error;
	if (soap_out_string(soap, "xenc:CarriedKeyName", -1, (char*const*)&a->CarriedKeyName, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct xenc__EncryptedKeyType * SOAP_FMAC4 soap_in_xenc__EncryptedKeyType(struct soap *soap, const char *tag, struct xenc__EncryptedKeyType *a, const char *type)
{
	size_t soap_flag_EncryptionMethod = 1;
	size_t soap_flag_ds__KeyInfo = 1;
	size_t soap_flag_CipherData = 1;
	size_t soap_flag_EncryptionProperties = 1;
	size_t soap_flag_ReferenceList = 1;
	size_t soap_flag_CarriedKeyName = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct xenc__EncryptedKeyType*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_xenc__EncryptedKeyType, sizeof(struct xenc__EncryptedKeyType), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_xenc__EncryptedKeyType(soap, a);
	if (soap_s2string(soap, soap_attr_value(soap, "Id", 1, 0), &a->Id))
		return NULL;
	if (soap_s2string(soap, soap_attr_value(soap, "Type", 1, 0), &a->Type))
		return NULL;
	if (soap_s2string(soap, soap_attr_value(soap, "MimeType", 1, 0), &a->MimeType))
		return NULL;
	if (soap_s2string(soap, soap_attr_value(soap, "Encoding", 1, 0), &a->Encoding))
		return NULL;
	if (soap_s2string(soap, soap_attr_value(soap, "Recipient", 1, 0), &a->Recipient))
		return NULL;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_EncryptionMethod && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerToxenc__EncryptionMethodType(soap, "xenc:EncryptionMethod", &a->EncryptionMethod, "xenc:EncryptionMethodType"))
				{	soap_flag_EncryptionMethod--;
					continue;
				}
			}
			if (soap_flag_ds__KeyInfo && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_ds__KeyInfo(soap, "ds:KeyInfo", &a->ds__KeyInfo, ""))
				{	soap_flag_ds__KeyInfo--;
					continue;
				}
			}
			if (soap_flag_CipherData && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerToxenc__CipherDataType(soap, "xenc:CipherData", &a->CipherData, "xenc:CipherDataType"))
				{	soap_flag_CipherData--;
					continue;
				}
			}
			if (soap_flag_EncryptionProperties && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerToxenc__EncryptionPropertiesType(soap, "xenc:EncryptionProperties", &a->EncryptionProperties, "xenc:EncryptionPropertiesType"))
				{	soap_flag_EncryptionProperties--;
					continue;
				}
			}
			if (soap_flag_ReferenceList && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_xenc__ReferenceList(soap, "xenc:ReferenceList", &a->ReferenceList, ""))
				{	soap_flag_ReferenceList--;
					continue;
				}
			}
			if (soap_flag_CarriedKeyName && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_string(soap, "xenc:CarriedKeyName", (char**)&a->CarriedKeyName, "xsd:string"))
				{	soap_flag_CarriedKeyName--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (!a->CipherData))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct xenc__EncryptedKeyType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_xenc__EncryptedKeyType, SOAP_TYPE_xenc__EncryptedKeyType, sizeof(struct xenc__EncryptedKeyType), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct xenc__EncryptedKeyType * SOAP_FMAC4 soap_new_xenc__EncryptedKeyType(struct soap *soap, int n)
{
	struct xenc__EncryptedKeyType *p;
	struct xenc__EncryptedKeyType *a = (struct xenc__EncryptedKeyType*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct xenc__EncryptedKeyType));
	for (p = a; p && n--; p++)
		soap_default_xenc__EncryptedKeyType(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_xenc__EncryptedKeyType(struct soap *soap, const struct xenc__EncryptedKeyType *a, const char *tag, const char *type)
{
	if (soap_out_xenc__EncryptedKeyType(soap, tag ? tag : "xenc:EncryptedKeyType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct xenc__EncryptedKeyType * SOAP_FMAC4 soap_get_xenc__EncryptedKeyType(struct soap *soap, struct xenc__EncryptedKeyType *p, const char *tag, const char *type)
{
	if ((p = soap_in_xenc__EncryptedKeyType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ds__KeyInfoType(struct soap *soap, struct ds__KeyInfoType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->xenc__EncryptedKey = NULL;
	soap_default_string(soap, &a->KeyName);
	a->KeyValue = NULL;
	a->RetrievalMethod = NULL;
	a->X509Data = NULL;
	a->wsse__SecurityTokenReference = NULL;
	soap_default_string(soap, &a->Id);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ds__KeyInfoType(struct soap *soap, const struct ds__KeyInfoType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerToxenc__EncryptedKeyType(soap, &a->xenc__EncryptedKey);
	soap_serialize_string(soap, (char*const*)&a->KeyName);
	soap_serialize_PointerTods__KeyValueType(soap, &a->KeyValue);
	soap_serialize_PointerTods__RetrievalMethodType(soap, &a->RetrievalMethod);
	soap_serialize_PointerTods__X509DataType(soap, &a->X509Data);
	soap_serialize_PointerTo_wsse__SecurityTokenReference(soap, &a->wsse__SecurityTokenReference);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ds__KeyInfoType(struct soap *soap, const char *tag, int id, const struct ds__KeyInfoType *a, const char *type)
{
	if (a->Id)
		soap_set_attr(soap, "Id", soap_string2s(soap, a->Id), 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ds__KeyInfoType), type))
		return soap->error;
	if (soap_out_PointerToxenc__EncryptedKeyType(soap, "xenc:EncryptedKey", -1, &a->xenc__EncryptedKey, ""))
		return soap->error;
	if (soap_out_string(soap, "ds:KeyName", -1, (char*const*)&a->KeyName, ""))
		return soap->error;
	if (soap_out_PointerTods__KeyValueType(soap, "ds:KeyValue", -1, &a->KeyValue, ""))
		return soap->error;
	if (soap_out_PointerTods__RetrievalMethodType(soap, "ds:RetrievalMethod", -1, &a->RetrievalMethod, ""))
		return soap->error;
	if (soap_out_PointerTods__X509DataType(soap, "ds:X509Data", -1, &a->X509Data, ""))
		return soap->error;
	if (soap_out_PointerTo_wsse__SecurityTokenReference(soap, "wsse:SecurityTokenReference", -1, &a->wsse__SecurityTokenReference, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ds__KeyInfoType * SOAP_FMAC4 soap_in_ds__KeyInfoType(struct soap *soap, const char *tag, struct ds__KeyInfoType *a, const char *type)
{
	size_t soap_flag_xenc__EncryptedKey = 1;
	size_t soap_flag_KeyName = 1;
	size_t soap_flag_KeyValue = 1;
	size_t soap_flag_RetrievalMethod = 1;
	size_t soap_flag_X509Data = 1;
	size_t soap_flag_wsse__SecurityTokenReference = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct ds__KeyInfoType*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ds__KeyInfoType, sizeof(struct ds__KeyInfoType), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ds__KeyInfoType(soap, a);
	if (soap_s2string(soap, soap_attr_value(soap, "Id", 1, 0), &a->Id))
		return NULL;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_xenc__EncryptedKey && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerToxenc__EncryptedKeyType(soap, "xenc:EncryptedKey", &a->xenc__EncryptedKey, "xenc:EncryptedKeyType"))
				{	soap_flag_xenc__EncryptedKey--;
					continue;
				}
			}
			if (soap_flag_KeyName && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_string(soap, "ds:KeyName", (char**)&a->KeyName, "xsd:string"))
				{	soap_flag_KeyName--;
					continue;
				}
			}
			if (soap_flag_KeyValue && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTods__KeyValueType(soap, "ds:KeyValue", &a->KeyValue, "ds:KeyValueType"))
				{	soap_flag_KeyValue--;
					continue;
				}
			}
			if (soap_flag_RetrievalMethod && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTods__RetrievalMethodType(soap, "ds:RetrievalMethod", &a->RetrievalMethod, "ds:RetrievalMethodType"))
				{	soap_flag_RetrievalMethod--;
					continue;
				}
			}
			if (soap_flag_X509Data && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTods__X509DataType(soap, "ds:X509Data", &a->X509Data, "ds:X509DataType"))
				{	soap_flag_X509Data--;
					continue;
				}
			}
			if (soap_flag_wsse__SecurityTokenReference && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_wsse__SecurityTokenReference(soap, "wsse:SecurityTokenReference", &a->wsse__SecurityTokenReference, ""))
				{	soap_flag_wsse__SecurityTokenReference--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ds__KeyInfoType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ds__KeyInfoType, SOAP_TYPE_ds__KeyInfoType, sizeof(struct ds__KeyInfoType), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct ds__KeyInfoType * SOAP_FMAC4 soap_new_ds__KeyInfoType(struct soap *soap, int n)
{
	struct ds__KeyInfoType *p;
	struct ds__KeyInfoType *a = (struct ds__KeyInfoType*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct ds__KeyInfoType));
	for (p = a; p && n--; p++)
		soap_default_ds__KeyInfoType(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ds__KeyInfoType(struct soap *soap, const struct ds__KeyInfoType *a, const char *tag, const char *type)
{
	if (soap_out_ds__KeyInfoType(soap, tag ? tag : "ds:KeyInfoType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ds__KeyInfoType * SOAP_FMAC4 soap_get_ds__KeyInfoType(struct soap *soap, struct ds__KeyInfoType *p, const char *tag, const char *type)
{
	if ((p = soap_in_ds__KeyInfoType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ds__X509DataType(struct soap *soap, struct ds__X509DataType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->X509IssuerSerial = NULL;
	soap_default_string(soap, &a->X509SKI);
	soap_default_string(soap, &a->X509SubjectName);
	soap_default_string(soap, &a->X509Certificate);
	soap_default_string(soap, &a->X509CRL);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ds__X509DataType(struct soap *soap, const struct ds__X509DataType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTods__X509IssuerSerialType(soap, &a->X509IssuerSerial);
	soap_serialize_string(soap, (char*const*)&a->X509SKI);
	soap_serialize_string(soap, (char*const*)&a->X509SubjectName);
	soap_serialize_string(soap, (char*const*)&a->X509Certificate);
	soap_serialize_string(soap, (char*const*)&a->X509CRL);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ds__X509DataType(struct soap *soap, const char *tag, int id, const struct ds__X509DataType *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ds__X509DataType), type))
		return soap->error;
	if (soap_out_PointerTods__X509IssuerSerialType(soap, "ds:X509IssuerSerial", -1, &a->X509IssuerSerial, ""))
		return soap->error;
	if (soap_out_string(soap, "ds:X509SKI", -1, (char*const*)&a->X509SKI, ""))
		return soap->error;
	if (soap_out_string(soap, "ds:X509SubjectName", -1, (char*const*)&a->X509SubjectName, ""))
		return soap->error;
	if (soap_out_string(soap, "ds:X509Certificate", -1, (char*const*)&a->X509Certificate, ""))
		return soap->error;
	if (soap_out_string(soap, "ds:X509CRL", -1, (char*const*)&a->X509CRL, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ds__X509DataType * SOAP_FMAC4 soap_in_ds__X509DataType(struct soap *soap, const char *tag, struct ds__X509DataType *a, const char *type)
{
	size_t soap_flag_X509IssuerSerial = 1;
	size_t soap_flag_X509SKI = 1;
	size_t soap_flag_X509SubjectName = 1;
	size_t soap_flag_X509Certificate = 1;
	size_t soap_flag_X509CRL = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct ds__X509DataType*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ds__X509DataType, sizeof(struct ds__X509DataType), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ds__X509DataType(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_X509IssuerSerial && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTods__X509IssuerSerialType(soap, "ds:X509IssuerSerial", &a->X509IssuerSerial, "ds:X509IssuerSerialType"))
				{	soap_flag_X509IssuerSerial--;
					continue;
				}
			}
			if (soap_flag_X509SKI && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_string(soap, "ds:X509SKI", (char**)&a->X509SKI, "xsd:string"))
				{	soap_flag_X509SKI--;
					continue;
				}
			}
			if (soap_flag_X509SubjectName && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_string(soap, "ds:X509SubjectName", (char**)&a->X509SubjectName, "xsd:string"))
				{	soap_flag_X509SubjectName--;
					continue;
				}
			}
			if (soap_flag_X509Certificate && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_string(soap, "ds:X509Certificate", (char**)&a->X509Certificate, "xsd:string"))
				{	soap_flag_X509Certificate--;
					continue;
				}
			}
			if (soap_flag_X509CRL && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_string(soap, "ds:X509CRL", (char**)&a->X509CRL, "xsd:string"))
				{	soap_flag_X509CRL--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ds__X509DataType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ds__X509DataType, SOAP_TYPE_ds__X509DataType, sizeof(struct ds__X509DataType), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct ds__X509DataType * SOAP_FMAC4 soap_new_ds__X509DataType(struct soap *soap, int n)
{
	struct ds__X509DataType *p;
	struct ds__X509DataType *a = (struct ds__X509DataType*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct ds__X509DataType));
	for (p = a; p && n--; p++)
		soap_default_ds__X509DataType(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ds__X509DataType(struct soap *soap, const struct ds__X509DataType *a, const char *tag, const char *type)
{
	if (soap_out_ds__X509DataType(soap, tag ? tag : "ds:X509DataType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ds__X509DataType * SOAP_FMAC4 soap_get_ds__X509DataType(struct soap *soap, struct ds__X509DataType *p, const char *tag, const char *type)
{
	if ((p = soap_in_ds__X509DataType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__wsse__SecurityTokenReference(struct soap *soap, struct _wsse__SecurityTokenReference *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->Reference = NULL;
	a->KeyIdentifier = NULL;
	a->Embedded = NULL;
	a->ds__X509Data = NULL;
	soap_default_string(soap, &a->wsu__Id);
	soap_default_string(soap, &a->wsc__Instance);
	soap_default_string(soap, &a->Usage);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__wsse__SecurityTokenReference(struct soap *soap, const struct _wsse__SecurityTokenReference *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_wsse__Reference(soap, &a->Reference);
	soap_serialize_PointerTo_wsse__KeyIdentifier(soap, &a->KeyIdentifier);
	soap_serialize_PointerTo_wsse__Embedded(soap, &a->Embedded);
	soap_serialize_PointerTods__X509DataType(soap, &a->ds__X509Data);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__wsse__SecurityTokenReference(struct soap *soap, const char *tag, int id, const struct _wsse__SecurityTokenReference *a, const char *type)
{
	if (a->wsu__Id)
		soap_set_attr(soap, "wsu:Id", soap_string2s(soap, a->wsu__Id), 1);
	if (a->wsc__Instance)
		soap_set_attr(soap, "wsc:Instance", soap_string2s(soap, a->wsc__Instance), 1);
	if (a->Usage)
		soap_set_attr(soap, "Usage", soap_string2s(soap, a->Usage), 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__wsse__SecurityTokenReference), type))
		return soap->error;
	if (soap_out_PointerTo_wsse__Reference(soap, "wsse:Reference", -1, &a->Reference, ""))
		return soap->error;
	if (soap_out_PointerTo_wsse__KeyIdentifier(soap, "wsse:KeyIdentifier", -1, &a->KeyIdentifier, ""))
		return soap->error;
	if (soap_out_PointerTo_wsse__Embedded(soap, "wsse:Embedded", -1, &a->Embedded, ""))
		return soap->error;
	if (soap_out_PointerTods__X509DataType(soap, "ds:X509Data", -1, &a->ds__X509Data, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _wsse__SecurityTokenReference * SOAP_FMAC4 soap_in__wsse__SecurityTokenReference(struct soap *soap, const char *tag, struct _wsse__SecurityTokenReference *a, const char *type)
{
	size_t soap_flag_Reference = 1;
	size_t soap_flag_KeyIdentifier = 1;
	size_t soap_flag_Embedded = 1;
	size_t soap_flag_ds__X509Data = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct _wsse__SecurityTokenReference*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__wsse__SecurityTokenReference, sizeof(struct _wsse__SecurityTokenReference), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__wsse__SecurityTokenReference(soap, a);
	if (soap_s2string(soap, soap_attr_value(soap, "wsu:Id", 1, 0), &a->wsu__Id))
		return NULL;
	if (soap_s2string(soap, soap_attr_value(soap, "wsc:Instance", 1, 0), &a->wsc__Instance))
		return NULL;
	if (soap_s2string(soap, soap_attr_value(soap, "Usage", 1, 0), &a->Usage))
		return NULL;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Reference && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_wsse__Reference(soap, "wsse:Reference", &a->Reference, ""))
				{	soap_flag_Reference--;
					continue;
				}
			}
			if (soap_flag_KeyIdentifier && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_wsse__KeyIdentifier(soap, "wsse:KeyIdentifier", &a->KeyIdentifier, ""))
				{	soap_flag_KeyIdentifier--;
					continue;
				}
			}
			if (soap_flag_Embedded && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_wsse__Embedded(soap, "wsse:Embedded", &a->Embedded, ""))
				{	soap_flag_Embedded--;
					continue;
				}
			}
			if (soap_flag_ds__X509Data && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTods__X509DataType(soap, "ds:X509Data", &a->ds__X509Data, "ds:X509DataType"))
				{	soap_flag_ds__X509Data--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _wsse__SecurityTokenReference *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__wsse__SecurityTokenReference, SOAP_TYPE__wsse__SecurityTokenReference, sizeof(struct _wsse__SecurityTokenReference), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _wsse__SecurityTokenReference * SOAP_FMAC4 soap_new__wsse__SecurityTokenReference(struct soap *soap, int n)
{
	struct _wsse__SecurityTokenReference *p;
	struct _wsse__SecurityTokenReference *a = (struct _wsse__SecurityTokenReference*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _wsse__SecurityTokenReference));
	for (p = a; p && n--; p++)
		soap_default__wsse__SecurityTokenReference(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__wsse__SecurityTokenReference(struct soap *soap, const struct _wsse__SecurityTokenReference *a, const char *tag, const char *type)
{
	if (soap_out__wsse__SecurityTokenReference(soap, tag ? tag : "wsse:SecurityTokenReference", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _wsse__SecurityTokenReference * SOAP_FMAC4 soap_get__wsse__SecurityTokenReference(struct soap *soap, struct _wsse__SecurityTokenReference *p, const char *tag, const char *type)
{
	if ((p = soap_in__wsse__SecurityTokenReference(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__wsse__KeyIdentifier(struct soap *soap, struct _wsse__KeyIdentifier *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->__item);
	soap_default_string(soap, &a->wsu__Id);
	soap_default_string(soap, &a->ValueType);
	soap_default_string(soap, &a->EncodingType);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__wsse__KeyIdentifier(struct soap *soap, const struct _wsse__KeyIdentifier *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_string(soap, (char*const*)&a->__item);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__wsse__KeyIdentifier(struct soap *soap, const char *tag, int id, const struct _wsse__KeyIdentifier *a, const char *type)
{
	if (a->wsu__Id)
		soap_set_attr(soap, "wsu:Id", soap_string2s(soap, a->wsu__Id), 1);
	if (a->ValueType)
		soap_set_attr(soap, "ValueType", soap_string2s(soap, a->ValueType), 1);
	if (a->EncodingType)
		soap_set_attr(soap, "EncodingType", soap_string2s(soap, a->EncodingType), 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	return soap_out_string(soap, tag, id, (char*const*)&a->__item, "");
}

SOAP_FMAC3 struct _wsse__KeyIdentifier * SOAP_FMAC4 soap_in__wsse__KeyIdentifier(struct soap *soap, const char *tag, struct _wsse__KeyIdentifier *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	if (!(a = (struct _wsse__KeyIdentifier *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__wsse__KeyIdentifier, sizeof(struct _wsse__KeyIdentifier), NULL, NULL, NULL, NULL)))
		return NULL;
	soap_revert(soap);
	*soap->id = '\0';
	soap_default__wsse__KeyIdentifier(soap, a);
	if (soap_s2string(soap, soap_attr_value(soap, "wsu:Id", 1, 0), &a->wsu__Id))
		return NULL;
	if (soap_s2string(soap, soap_attr_value(soap, "ValueType", 1, 0), &a->ValueType))
		return NULL;
	if (soap_s2string(soap, soap_attr_value(soap, "EncodingType", 1, 0), &a->EncodingType))
		return NULL;
	if (!soap_in_string(soap, tag, (char**)&a->__item, ""))
		return NULL;
	return a;
}

SOAP_FMAC3 struct _wsse__KeyIdentifier * SOAP_FMAC4 soap_new__wsse__KeyIdentifier(struct soap *soap, int n)
{
	struct _wsse__KeyIdentifier *p;
	struct _wsse__KeyIdentifier *a = (struct _wsse__KeyIdentifier*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _wsse__KeyIdentifier));
	for (p = a; p && n--; p++)
		soap_default__wsse__KeyIdentifier(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__wsse__KeyIdentifier(struct soap *soap, const struct _wsse__KeyIdentifier *a, const char *tag, const char *type)
{
	if (soap_out__wsse__KeyIdentifier(soap, tag ? tag : "wsse:KeyIdentifier", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _wsse__KeyIdentifier * SOAP_FMAC4 soap_get__wsse__KeyIdentifier(struct soap *soap, struct _wsse__KeyIdentifier *p, const char *tag, const char *type)
{
	if ((p = soap_in__wsse__KeyIdentifier(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__wsse__Embedded(struct soap *soap, struct _wsse__Embedded *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->wsu__Id);
	soap_default_string(soap, &a->ValueType);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__wsse__Embedded(struct soap *soap, const struct _wsse__Embedded *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__wsse__Embedded(struct soap *soap, const char *tag, int id, const struct _wsse__Embedded *a, const char *type)
{
	if (a->wsu__Id)
		soap_set_attr(soap, "wsu:Id", soap_string2s(soap, a->wsu__Id), 1);
	if (a->ValueType)
		soap_set_attr(soap, "ValueType", soap_string2s(soap, a->ValueType), 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__wsse__Embedded), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _wsse__Embedded * SOAP_FMAC4 soap_in__wsse__Embedded(struct soap *soap, const char *tag, struct _wsse__Embedded *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct _wsse__Embedded*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__wsse__Embedded, sizeof(struct _wsse__Embedded), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__wsse__Embedded(soap, a);
	if (soap_s2string(soap, soap_attr_value(soap, "wsu:Id", 1, 0), &a->wsu__Id))
		return NULL;
	if (soap_s2string(soap, soap_attr_value(soap, "ValueType", 1, 0), &a->ValueType))
		return NULL;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _wsse__Embedded *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__wsse__Embedded, SOAP_TYPE__wsse__Embedded, sizeof(struct _wsse__Embedded), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _wsse__Embedded * SOAP_FMAC4 soap_new__wsse__Embedded(struct soap *soap, int n)
{
	struct _wsse__Embedded *p;
	struct _wsse__Embedded *a = (struct _wsse__Embedded*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _wsse__Embedded));
	for (p = a; p && n--; p++)
		soap_default__wsse__Embedded(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__wsse__Embedded(struct soap *soap, const struct _wsse__Embedded *a, const char *tag, const char *type)
{
	if (soap_out__wsse__Embedded(soap, tag ? tag : "wsse:Embedded", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _wsse__Embedded * SOAP_FMAC4 soap_get__wsse__Embedded(struct soap *soap, struct _wsse__Embedded *p, const char *tag, const char *type)
{
	if ((p = soap_in__wsse__Embedded(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__wsse__Reference(struct soap *soap, struct _wsse__Reference *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->URI);
	soap_default_string(soap, &a->ValueType);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__wsse__Reference(struct soap *soap, const struct _wsse__Reference *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__wsse__Reference(struct soap *soap, const char *tag, int id, const struct _wsse__Reference *a, const char *type)
{
	if (a->URI)
		soap_set_attr(soap, "URI", soap_string2s(soap, a->URI), 1);
	if (a->ValueType)
		soap_set_attr(soap, "ValueType", soap_string2s(soap, a->ValueType), 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__wsse__Reference), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _wsse__Reference * SOAP_FMAC4 soap_in__wsse__Reference(struct soap *soap, const char *tag, struct _wsse__Reference *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct _wsse__Reference*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__wsse__Reference, sizeof(struct _wsse__Reference), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__wsse__Reference(soap, a);
	if (soap_s2string(soap, soap_attr_value(soap, "URI", 1, 0), &a->URI))
		return NULL;
	if (soap_s2string(soap, soap_attr_value(soap, "ValueType", 1, 0), &a->ValueType))
		return NULL;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _wsse__Reference *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__wsse__Reference, SOAP_TYPE__wsse__Reference, sizeof(struct _wsse__Reference), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _wsse__Reference * SOAP_FMAC4 soap_new__wsse__Reference(struct soap *soap, int n)
{
	struct _wsse__Reference *p;
	struct _wsse__Reference *a = (struct _wsse__Reference*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _wsse__Reference));
	for (p = a; p && n--; p++)
		soap_default__wsse__Reference(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__wsse__Reference(struct soap *soap, const struct _wsse__Reference *a, const char *tag, const char *type)
{
	if (soap_out__wsse__Reference(soap, tag ? tag : "wsse:Reference", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _wsse__Reference * SOAP_FMAC4 soap_get__wsse__Reference(struct soap *soap, struct _wsse__Reference *p, const char *tag, const char *type)
{
	if ((p = soap_in__wsse__Reference(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__wsse__BinarySecurityToken(struct soap *soap, struct _wsse__BinarySecurityToken *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->__item);
	soap_default_string(soap, &a->wsu__Id);
	soap_default_string(soap, &a->ValueType);
	soap_default_string(soap, &a->EncodingType);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__wsse__BinarySecurityToken(struct soap *soap, const struct _wsse__BinarySecurityToken *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_string(soap, (char*const*)&a->__item);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__wsse__BinarySecurityToken(struct soap *soap, const char *tag, int id, const struct _wsse__BinarySecurityToken *a, const char *type)
{
	if (a->wsu__Id)
		soap_set_attr(soap, "wsu:Id", soap_string2s(soap, a->wsu__Id), 1);
	if (a->ValueType)
		soap_set_attr(soap, "ValueType", soap_string2s(soap, a->ValueType), 1);
	if (a->EncodingType)
		soap_set_attr(soap, "EncodingType", soap_string2s(soap, a->EncodingType), 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	return soap_out_string(soap, tag, id, (char*const*)&a->__item, "");
}

SOAP_FMAC3 struct _wsse__BinarySecurityToken * SOAP_FMAC4 soap_in__wsse__BinarySecurityToken(struct soap *soap, const char *tag, struct _wsse__BinarySecurityToken *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	if (!(a = (struct _wsse__BinarySecurityToken *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__wsse__BinarySecurityToken, sizeof(struct _wsse__BinarySecurityToken), NULL, NULL, NULL, NULL)))
		return NULL;
	soap_revert(soap);
	*soap->id = '\0';
	soap_default__wsse__BinarySecurityToken(soap, a);
	if (soap_s2string(soap, soap_attr_value(soap, "wsu:Id", 1, 0), &a->wsu__Id))
		return NULL;
	if (soap_s2string(soap, soap_attr_value(soap, "ValueType", 1, 0), &a->ValueType))
		return NULL;
	if (soap_s2string(soap, soap_attr_value(soap, "EncodingType", 1, 0), &a->EncodingType))
		return NULL;
	if (!soap_in_string(soap, tag, (char**)&a->__item, ""))
		return NULL;
	return a;
}

SOAP_FMAC3 struct _wsse__BinarySecurityToken * SOAP_FMAC4 soap_new__wsse__BinarySecurityToken(struct soap *soap, int n)
{
	struct _wsse__BinarySecurityToken *p;
	struct _wsse__BinarySecurityToken *a = (struct _wsse__BinarySecurityToken*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _wsse__BinarySecurityToken));
	for (p = a; p && n--; p++)
		soap_default__wsse__BinarySecurityToken(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__wsse__BinarySecurityToken(struct soap *soap, const struct _wsse__BinarySecurityToken *a, const char *tag, const char *type)
{
	if (soap_out__wsse__BinarySecurityToken(soap, tag ? tag : "wsse:BinarySecurityToken", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _wsse__BinarySecurityToken * SOAP_FMAC4 soap_get__wsse__BinarySecurityToken(struct soap *soap, struct _wsse__BinarySecurityToken *p, const char *tag, const char *type)
{
	if ((p = soap_in__wsse__BinarySecurityToken(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__wsse__Password(struct soap *soap, struct _wsse__Password *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->__item);
	soap_default_string(soap, &a->Type);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__wsse__Password(struct soap *soap, const struct _wsse__Password *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_string(soap, (char*const*)&a->__item);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__wsse__Password(struct soap *soap, const char *tag, int id, const struct _wsse__Password *a, const char *type)
{
	if (a->Type)
		soap_set_attr(soap, "Type", soap_string2s(soap, a->Type), 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	return soap_out_string(soap, tag, id, (char*const*)&a->__item, "");
}

SOAP_FMAC3 struct _wsse__Password * SOAP_FMAC4 soap_in__wsse__Password(struct soap *soap, const char *tag, struct _wsse__Password *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	if (!(a = (struct _wsse__Password *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__wsse__Password, sizeof(struct _wsse__Password), NULL, NULL, NULL, NULL)))
		return NULL;
	soap_revert(soap);
	*soap->id = '\0';
	soap_default__wsse__Password(soap, a);
	if (soap_s2string(soap, soap_attr_value(soap, "Type", 1, 0), &a->Type))
		return NULL;
	if (!soap_in_string(soap, tag, (char**)&a->__item, ""))
		return NULL;
	return a;
}

SOAP_FMAC3 struct _wsse__Password * SOAP_FMAC4 soap_new__wsse__Password(struct soap *soap, int n)
{
	struct _wsse__Password *p;
	struct _wsse__Password *a = (struct _wsse__Password*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _wsse__Password));
	for (p = a; p && n--; p++)
		soap_default__wsse__Password(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__wsse__Password(struct soap *soap, const struct _wsse__Password *a, const char *tag, const char *type)
{
	if (soap_out__wsse__Password(soap, tag ? tag : "wsse:Password", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _wsse__Password * SOAP_FMAC4 soap_get__wsse__Password(struct soap *soap, struct _wsse__Password *p, const char *tag, const char *type)
{
	if ((p = soap_in__wsse__Password(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__wsse__UsernameToken(struct soap *soap, struct _wsse__UsernameToken *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->Username);
	a->Password = NULL;
	a->Nonce = NULL;
	soap_default_string(soap, &a->Salt);
	a->Iteration = NULL;
	soap_default_string(soap, &a->wsu__Created);
	soap_default_string(soap, &a->wsu__Id);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__wsse__UsernameToken(struct soap *soap, const struct _wsse__UsernameToken *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_string(soap, (char*const*)&a->Username);
	soap_serialize_PointerTo_wsse__Password(soap, &a->Password);
	soap_serialize_PointerTowsse__EncodedString(soap, &a->Nonce);
	soap_serialize_string(soap, (char*const*)&a->Salt);
	soap_serialize_PointerTounsignedInt(soap, &a->Iteration);
	soap_serialize_string(soap, (char*const*)&a->wsu__Created);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__wsse__UsernameToken(struct soap *soap, const char *tag, int id, const struct _wsse__UsernameToken *a, const char *type)
{
	if (a->wsu__Id)
		soap_set_attr(soap, "wsu:Id", soap_string2s(soap, a->wsu__Id), 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__wsse__UsernameToken), type))
		return soap->error;
	if (soap_out_string(soap, "wsse:Username", -1, (char*const*)&a->Username, ""))
		return soap->error;
	if (soap_out_PointerTo_wsse__Password(soap, "wsse:Password", -1, &a->Password, ""))
		return soap->error;
	if (soap_out_PointerTowsse__EncodedString(soap, "wsse:Nonce", -1, &a->Nonce, ""))
		return soap->error;
	if (soap_out_string(soap, "wsse:Salt", -1, (char*const*)&a->Salt, ""))
		return soap->error;
	if (soap_out_PointerTounsignedInt(soap, "wsse:Iteration", -1, &a->Iteration, ""))
		return soap->error;
	if (soap_out_string(soap, "wsu:Created", -1, (char*const*)&a->wsu__Created, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _wsse__UsernameToken * SOAP_FMAC4 soap_in__wsse__UsernameToken(struct soap *soap, const char *tag, struct _wsse__UsernameToken *a, const char *type)
{
	size_t soap_flag_Username = 1;
	size_t soap_flag_Password = 1;
	size_t soap_flag_Nonce = 1;
	size_t soap_flag_Salt = 1;
	size_t soap_flag_Iteration = 1;
	size_t soap_flag_wsu__Created = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct _wsse__UsernameToken*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__wsse__UsernameToken, sizeof(struct _wsse__UsernameToken), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__wsse__UsernameToken(soap, a);
	if (soap_s2string(soap, soap_attr_value(soap, "wsu:Id", 1, 0), &a->wsu__Id))
		return NULL;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Username && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_string(soap, "wsse:Username", (char**)&a->Username, "xsd:string"))
				{	soap_flag_Username--;
					continue;
				}
			}
			if (soap_flag_Password && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_wsse__Password(soap, "wsse:Password", &a->Password, ""))
				{	soap_flag_Password--;
					continue;
				}
			}
			if (soap_flag_Nonce && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTowsse__EncodedString(soap, "wsse:Nonce", &a->Nonce, "wsse:EncodedString"))
				{	soap_flag_Nonce--;
					continue;
				}
			}
			if (soap_flag_Salt && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_string(soap, "wsse:Salt", (char**)&a->Salt, "xsd:string"))
				{	soap_flag_Salt--;
					continue;
				}
			}
			if (soap_flag_Iteration && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTounsignedInt(soap, "wsse:Iteration", &a->Iteration, "xsd:unsignedInt"))
				{	soap_flag_Iteration--;
					continue;
				}
			}
			if (soap_flag_wsu__Created && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_string(soap, "wsu:Created", (char**)&a->wsu__Created, "xsd:string"))
				{	soap_flag_wsu__Created--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _wsse__UsernameToken *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__wsse__UsernameToken, SOAP_TYPE__wsse__UsernameToken, sizeof(struct _wsse__UsernameToken), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _wsse__UsernameToken * SOAP_FMAC4 soap_new__wsse__UsernameToken(struct soap *soap, int n)
{
	struct _wsse__UsernameToken *p;
	struct _wsse__UsernameToken *a = (struct _wsse__UsernameToken*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _wsse__UsernameToken));
	for (p = a; p && n--; p++)
		soap_default__wsse__UsernameToken(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__wsse__UsernameToken(struct soap *soap, const struct _wsse__UsernameToken *a, const char *tag, const char *type)
{
	if (soap_out__wsse__UsernameToken(soap, tag ? tag : "wsse:UsernameToken", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _wsse__UsernameToken * SOAP_FMAC4 soap_get__wsse__UsernameToken(struct soap *soap, struct _wsse__UsernameToken *p, const char *tag, const char *type)
{
	if ((p = soap_in__wsse__UsernameToken(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_wsse__EncodedString(struct soap *soap, struct wsse__EncodedString *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->__item);
	soap_default_string(soap, &a->EncodingType);
	soap_default_string(soap, &a->wsu__Id);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_wsse__EncodedString(struct soap *soap, const struct wsse__EncodedString *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_string(soap, (char*const*)&a->__item);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_wsse__EncodedString(struct soap *soap, const char *tag, int id, const struct wsse__EncodedString *a, const char *type)
{
	if (a->EncodingType)
		soap_set_attr(soap, "EncodingType", soap_string2s(soap, a->EncodingType), 1);
	if (a->wsu__Id)
		soap_set_attr(soap, "wsu:Id", soap_string2s(soap, a->wsu__Id), 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	return soap_out_string(soap, tag, id, (char*const*)&a->__item, "");
}

SOAP_FMAC3 struct wsse__EncodedString * SOAP_FMAC4 soap_in_wsse__EncodedString(struct soap *soap, const char *tag, struct wsse__EncodedString *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	if (!(a = (struct wsse__EncodedString *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_wsse__EncodedString, sizeof(struct wsse__EncodedString), NULL, NULL, NULL, NULL)))
		return NULL;
	soap_revert(soap);
	*soap->id = '\0';
	soap_default_wsse__EncodedString(soap, a);
	if (soap_s2string(soap, soap_attr_value(soap, "EncodingType", 1, 0), &a->EncodingType))
		return NULL;
	if (soap_s2string(soap, soap_attr_value(soap, "wsu:Id", 1, 0), &a->wsu__Id))
		return NULL;
	if (!soap_in_string(soap, tag, (char**)&a->__item, "wsse:EncodedString"))
		return NULL;
	return a;
}

SOAP_FMAC3 struct wsse__EncodedString * SOAP_FMAC4 soap_new_wsse__EncodedString(struct soap *soap, int n)
{
	struct wsse__EncodedString *p;
	struct wsse__EncodedString *a = (struct wsse__EncodedString*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct wsse__EncodedString));
	for (p = a; p && n--; p++)
		soap_default_wsse__EncodedString(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_wsse__EncodedString(struct soap *soap, const struct wsse__EncodedString *a, const char *tag, const char *type)
{
	if (soap_out_wsse__EncodedString(soap, tag ? tag : "wsse:EncodedString", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct wsse__EncodedString * SOAP_FMAC4 soap_get_wsse__EncodedString(struct soap *soap, struct wsse__EncodedString *p, const char *tag, const char *type)
{
	if ((p = soap_in_wsse__EncodedString(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__wsu__Timestamp(struct soap *soap, struct _wsu__Timestamp *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->wsu__Id);
	soap_default_string(soap, &a->Created);
	soap_default_string(soap, &a->Expires);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__wsu__Timestamp(struct soap *soap, const struct _wsu__Timestamp *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_string(soap, (char*const*)&a->Created);
	soap_serialize_string(soap, (char*const*)&a->Expires);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__wsu__Timestamp(struct soap *soap, const char *tag, int id, const struct _wsu__Timestamp *a, const char *type)
{
	if (a->wsu__Id)
		soap_set_attr(soap, "wsu:Id", soap_string2s(soap, a->wsu__Id), 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__wsu__Timestamp), type))
		return soap->error;
	if (soap_out_string(soap, "wsu:Created", -1, (char*const*)&a->Created, ""))
		return soap->error;
	if (soap_out_string(soap, "wsu:Expires", -1, (char*const*)&a->Expires, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _wsu__Timestamp * SOAP_FMAC4 soap_in__wsu__Timestamp(struct soap *soap, const char *tag, struct _wsu__Timestamp *a, const char *type)
{
	size_t soap_flag_Created = 1;
	size_t soap_flag_Expires = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct _wsu__Timestamp*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__wsu__Timestamp, sizeof(struct _wsu__Timestamp), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__wsu__Timestamp(soap, a);
	if (soap_s2string(soap, soap_attr_value(soap, "wsu:Id", 1, 0), &a->wsu__Id))
		return NULL;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Created && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_string(soap, "wsu:Created", (char**)&a->Created, "xsd:string"))
				{	soap_flag_Created--;
					continue;
				}
			}
			if (soap_flag_Expires && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_string(soap, "wsu:Expires", (char**)&a->Expires, "xsd:string"))
				{	soap_flag_Expires--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _wsu__Timestamp *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__wsu__Timestamp, SOAP_TYPE__wsu__Timestamp, sizeof(struct _wsu__Timestamp), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _wsu__Timestamp * SOAP_FMAC4 soap_new__wsu__Timestamp(struct soap *soap, int n)
{
	struct _wsu__Timestamp *p;
	struct _wsu__Timestamp *a = (struct _wsu__Timestamp*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _wsu__Timestamp));
	for (p = a; p && n--; p++)
		soap_default__wsu__Timestamp(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__wsu__Timestamp(struct soap *soap, const struct _wsu__Timestamp *a, const char *tag, const char *type)
{
	if (soap_out__wsu__Timestamp(soap, tag ? tag : "wsu:Timestamp", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _wsu__Timestamp * SOAP_FMAC4 soap_get__wsu__Timestamp(struct soap *soap, struct _wsu__Timestamp *p, const char *tag, const char *type)
{
	if ((p = soap_in__wsu__Timestamp(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_SOAP_ENV__Fault_alex(struct soap *soap, struct SOAP_ENV__Fault_alex *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default__QName(soap, &a->faultcode);
	soap_default_string(soap, &a->faultstring);
	soap_default_string(soap, &a->faultactor);
	a->detail = NULL;
	a->SOAP_ENV__Code = NULL;
	a->SOAP_ENV__Reason = NULL;
	soap_default_string(soap, &a->SOAP_ENV__Node);
	soap_default_string(soap, &a->SOAP_ENV__Role);
	a->SOAP_ENV__Detail = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_SOAP_ENV__Fault_alex(struct soap *soap, const struct SOAP_ENV__Fault_alex *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize__QName(soap, (char*const*)&a->faultcode);
	soap_serialize_string(soap, (char*const*)&a->faultstring);
	soap_serialize_string(soap, (char*const*)&a->faultactor);
	soap_serialize_PointerToSOAP_ENV__Detail(soap, &a->detail);
	soap_serialize_PointerToSOAP_ENV__Code(soap, &a->SOAP_ENV__Code);
	soap_serialize_PointerToSOAP_ENV__Reason(soap, &a->SOAP_ENV__Reason);
	soap_serialize_string(soap, (char*const*)&a->SOAP_ENV__Node);
	soap_serialize_string(soap, (char*const*)&a->SOAP_ENV__Role);
	soap_serialize_PointerToSOAP_ENV__Detail(soap, &a->SOAP_ENV__Detail);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_SOAP_ENV__Fault_alex(struct soap *soap, const char *tag, int id, const struct SOAP_ENV__Fault_alex *a, const char *type)
{
	const char *soap_tmp_faultcode;
	soap_tmp_faultcode = soap_QName2s(soap, a->faultcode);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_SOAP_ENV__Fault_alex), type))
		return soap->error;
	if (soap_out__QName(soap, "faultcode", -1, (char*const*)(void*)&soap_tmp_faultcode, ""))
		return soap->error;
	if (soap_out_string(soap, "faultstring", -1, (char*const*)&a->faultstring, ""))
		return soap->error;
	if (soap_out_string(soap, "faultactor", -1, (char*const*)&a->faultactor, ""))
		return soap->error;
	if (soap_out_PointerToSOAP_ENV__Detail(soap, "detail", -1, &a->detail, ""))
		return soap->error;
	if (soap_out_PointerToSOAP_ENV__Code(soap, "SOAP-ENV:Code", -1, &a->SOAP_ENV__Code, ""))
		return soap->error;
	if (soap_out_PointerToSOAP_ENV__Reason(soap, "SOAP-ENV:Reason", -1, &a->SOAP_ENV__Reason, ""))
		return soap->error;
	if (soap_out_string(soap, "SOAP-ENV:Node", -1, (char*const*)&a->SOAP_ENV__Node, ""))
		return soap->error;
	if (soap_out_string(soap, "SOAP-ENV:Role", -1, (char*const*)&a->SOAP_ENV__Role, ""))
		return soap->error;
	if (soap_out_PointerToSOAP_ENV__Detail(soap, "SOAP-ENV:Detail", -1, &a->SOAP_ENV__Detail, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct SOAP_ENV__Fault_alex * SOAP_FMAC4 soap_in_SOAP_ENV__Fault_alex(struct soap *soap, const char *tag, struct SOAP_ENV__Fault_alex *a, const char *type)
{
	size_t soap_flag_faultcode = 1;
	size_t soap_flag_faultstring = 1;
	size_t soap_flag_faultactor = 1;
	size_t soap_flag_detail = 1;
	size_t soap_flag_SOAP_ENV__Code = 1;
	size_t soap_flag_SOAP_ENV__Reason = 1;
	size_t soap_flag_SOAP_ENV__Node = 1;
	size_t soap_flag_SOAP_ENV__Role = 1;
	size_t soap_flag_SOAP_ENV__Detail = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct SOAP_ENV__Fault_alex*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_SOAP_ENV__Fault_alex, sizeof(struct SOAP_ENV__Fault_alex), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_SOAP_ENV__Fault_alex(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_faultcode && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in__QName(soap, "faultcode", (char**)&a->faultcode, "xsd:QName"))
				{	soap_flag_faultcode--;
					continue;
				}
			}
			if (soap_flag_faultstring && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_string(soap, "faultstring", (char**)&a->faultstring, "xsd:string"))
				{	soap_flag_faultstring--;
					continue;
				}
			}
			if (soap_flag_faultactor && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_string(soap, "faultactor", (char**)&a->faultactor, "xsd:string"))
				{	soap_flag_faultactor--;
					continue;
				}
			}
			if (soap_flag_detail && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerToSOAP_ENV__Detail(soap, "detail", &a->detail, ""))
				{	soap_flag_detail--;
					continue;
				}
			}
			if (soap_flag_SOAP_ENV__Code && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerToSOAP_ENV__Code(soap, "SOAP-ENV:Code", &a->SOAP_ENV__Code, ""))
				{	soap_flag_SOAP_ENV__Code--;
					continue;
				}
			}
			if (soap_flag_SOAP_ENV__Reason && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerToSOAP_ENV__Reason(soap, "SOAP-ENV:Reason", &a->SOAP_ENV__Reason, ""))
				{	soap_flag_SOAP_ENV__Reason--;
					continue;
				}
			}
			if (soap_flag_SOAP_ENV__Node && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_string(soap, "SOAP-ENV:Node", (char**)&a->SOAP_ENV__Node, "xsd:string"))
				{	soap_flag_SOAP_ENV__Node--;
					continue;
				}
			}
			if (soap_flag_SOAP_ENV__Role && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_string(soap, "SOAP-ENV:Role", (char**)&a->SOAP_ENV__Role, "xsd:string"))
				{	soap_flag_SOAP_ENV__Role--;
					continue;
				}
			}
			if (soap_flag_SOAP_ENV__Detail && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerToSOAP_ENV__Detail(soap, "SOAP-ENV:Detail", &a->SOAP_ENV__Detail, ""))
				{	soap_flag_SOAP_ENV__Detail--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Fault_alex *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_SOAP_ENV__Fault_alex, SOAP_TYPE_SOAP_ENV__Fault_alex, sizeof(struct SOAP_ENV__Fault_alex), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct SOAP_ENV__Fault_alex * SOAP_FMAC4 soap_new_SOAP_ENV__Fault_alex(struct soap *soap, int n)
{
	struct SOAP_ENV__Fault_alex *p;
	struct SOAP_ENV__Fault_alex *a = (struct SOAP_ENV__Fault_alex*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct SOAP_ENV__Fault_alex));
	for (p = a; p && n--; p++)
		soap_default_SOAP_ENV__Fault_alex(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_SOAP_ENV__Fault_alex(struct soap *soap, const struct SOAP_ENV__Fault_alex *a, const char *tag, const char *type)
{
	if (soap_out_SOAP_ENV__Fault_alex(soap, tag ? tag : "SOAP-ENV:Fault-alex", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Fault_alex * SOAP_FMAC4 soap_get_SOAP_ENV__Fault_alex(struct soap *soap, struct SOAP_ENV__Fault_alex *p, const char *tag, const char *type)
{
	if ((p = soap_in_SOAP_ENV__Fault_alex(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_chan__ChannelInstanceType(struct soap *soap, struct chan__ChannelInstanceType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_int(soap, &a->__item);
	a->wsa5__IsReferenceParameter = (enum _wsa5__IsReferenceParameter)0;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_chan__ChannelInstanceType(struct soap *soap, const struct chan__ChannelInstanceType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &a->__item, SOAP_TYPE_int);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_chan__ChannelInstanceType(struct soap *soap, const char *tag, int id, const struct chan__ChannelInstanceType *a, const char *type)
{
	if (a->wsa5__IsReferenceParameter != (enum _wsa5__IsReferenceParameter)0)
	{	soap_set_attr(soap, "wsa5:IsReferenceParameter", soap__wsa5__IsReferenceParameter2s(soap, a->wsa5__IsReferenceParameter), 1);
	}
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	return soap_out_int(soap, tag, id, &a->__item, "");
}

SOAP_FMAC3 struct chan__ChannelInstanceType * SOAP_FMAC4 soap_in_chan__ChannelInstanceType(struct soap *soap, const char *tag, struct chan__ChannelInstanceType *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	if (!(a = (struct chan__ChannelInstanceType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_chan__ChannelInstanceType, sizeof(struct chan__ChannelInstanceType), NULL, NULL, NULL, NULL)))
		return NULL;
	soap_revert(soap);
	*soap->id = '\0';
	soap_default_chan__ChannelInstanceType(soap, a);
	if (soap_s2_wsa5__IsReferenceParameter(soap, soap_attr_value(soap, "wsa5:IsReferenceParameter", 5, 0), &a->wsa5__IsReferenceParameter))
		return NULL;
	if (!soap_in_int(soap, tag, &a->__item, "chan:ChannelInstanceType"))
		return NULL;
	return a;
}

SOAP_FMAC3 struct chan__ChannelInstanceType * SOAP_FMAC4 soap_new_chan__ChannelInstanceType(struct soap *soap, int n)
{
	struct chan__ChannelInstanceType *p;
	struct chan__ChannelInstanceType *a = (struct chan__ChannelInstanceType*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct chan__ChannelInstanceType));
	for (p = a; p && n--; p++)
		soap_default_chan__ChannelInstanceType(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_chan__ChannelInstanceType(struct soap *soap, const struct chan__ChannelInstanceType *a, const char *tag, const char *type)
{
	if (soap_out_chan__ChannelInstanceType(soap, tag ? tag : "chan:ChannelInstanceType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct chan__ChannelInstanceType * SOAP_FMAC4 soap_get_chan__ChannelInstanceType(struct soap *soap, struct chan__ChannelInstanceType *p, const char *tag, const char *type)
{
	if ((p = soap_in_chan__ChannelInstanceType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__wsa5__ProblemAction(struct soap *soap, const struct wsa5__ProblemActionType *a, const char *tag, const char *type)
{
	if (soap_out__wsa5__ProblemAction(soap, tag ? tag : "wsa5:ProblemAction", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__wsa5__FaultTo(struct soap *soap, const struct wsa5__EndpointReferenceType *a, const char *tag, const char *type)
{
	if (soap_out__wsa5__FaultTo(soap, tag ? tag : "wsa5:FaultTo", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__wsa5__From(struct soap *soap, const struct wsa5__EndpointReferenceType *a, const char *tag, const char *type)
{
	if (soap_out__wsa5__From(soap, tag ? tag : "wsa5:From", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__wsa5__ReplyTo(struct soap *soap, const struct wsa5__EndpointReferenceType *a, const char *tag, const char *type)
{
	if (soap_out__wsa5__ReplyTo(soap, tag ? tag : "wsa5:ReplyTo", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__wsa5__RelatesTo(struct soap *soap, const struct wsa5__RelatesToType *a, const char *tag, const char *type)
{
	if (soap_out__wsa5__RelatesTo(soap, tag ? tag : "wsa5:RelatesTo", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__wsa5__Metadata(struct soap *soap, const struct wsa5__MetadataType *a, const char *tag, const char *type)
{
	if (soap_out__wsa5__Metadata(soap, tag ? tag : "wsa5:Metadata", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__wsa5__ReferenceParameters(struct soap *soap, const struct wsa5__ReferenceParametersType *a, const char *tag, const char *type)
{
	if (soap_out__wsa5__ReferenceParameters(soap, tag ? tag : "wsa5:ReferenceParameters", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__wsa5__EndpointReference(struct soap *soap, const struct wsa5__EndpointReferenceType *a, const char *tag, const char *type)
{
	if (soap_out__wsa5__EndpointReference(soap, tag ? tag : "wsa5:EndpointReference", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_wsa5__ProblemActionType(struct soap *soap, struct wsa5__ProblemActionType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->Action);
	soap_default_string(soap, &a->SoapAction);
	a->__anyAttribute = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_wsa5__ProblemActionType(struct soap *soap, const struct wsa5__ProblemActionType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_string(soap, (char*const*)&a->Action);
	soap_serialize_string(soap, (char*const*)&a->SoapAction);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_wsa5__ProblemActionType(struct soap *soap, const char *tag, int id, const struct wsa5__ProblemActionType *a, const char *type)
{
	if (a->__anyAttribute)
		soap_set_attr(soap, "-anyAttribute", a->__anyAttribute, 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_wsa5__ProblemActionType), type))
		return soap->error;
	if (soap_out_string(soap, "wsa5:Action", -1, (char*const*)&a->Action, ""))
		return soap->error;
	if (soap_out_string(soap, "wsa5:SoapAction", -1, (char*const*)&a->SoapAction, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct wsa5__ProblemActionType * SOAP_FMAC4 soap_in_wsa5__ProblemActionType(struct soap *soap, const char *tag, struct wsa5__ProblemActionType *a, const char *type)
{
	size_t soap_flag_Action = 1;
	size_t soap_flag_SoapAction = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct wsa5__ProblemActionType*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_wsa5__ProblemActionType, sizeof(struct wsa5__ProblemActionType), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_wsa5__ProblemActionType(soap, a);
	if (soap_s2char(soap, soap_attr_value(soap, "-anyAttribute", 0, 0), &a->__anyAttribute, 0, 0, -1, NULL))
		return NULL;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Action && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_string(soap, "wsa5:Action", (char**)&a->Action, "xsd:string"))
				{	soap_flag_Action--;
					continue;
				}
			}
			if (soap_flag_SoapAction && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_string(soap, "wsa5:SoapAction", (char**)&a->SoapAction, "xsd:string"))
				{	soap_flag_SoapAction--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct wsa5__ProblemActionType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_wsa5__ProblemActionType, SOAP_TYPE_wsa5__ProblemActionType, sizeof(struct wsa5__ProblemActionType), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct wsa5__ProblemActionType * SOAP_FMAC4 soap_new_wsa5__ProblemActionType(struct soap *soap, int n)
{
	struct wsa5__ProblemActionType *p;
	struct wsa5__ProblemActionType *a = (struct wsa5__ProblemActionType*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct wsa5__ProblemActionType));
	for (p = a; p && n--; p++)
		soap_default_wsa5__ProblemActionType(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_wsa5__ProblemActionType(struct soap *soap, const struct wsa5__ProblemActionType *a, const char *tag, const char *type)
{
	if (soap_out_wsa5__ProblemActionType(soap, tag ? tag : "wsa5:ProblemActionType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct wsa5__ProblemActionType * SOAP_FMAC4 soap_get_wsa5__ProblemActionType(struct soap *soap, struct wsa5__ProblemActionType *p, const char *tag, const char *type)
{
	if ((p = soap_in_wsa5__ProblemActionType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_wsa5__RelatesToType(struct soap *soap, struct wsa5__RelatesToType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->__item);
	soap_default_wsa5__RelationshipTypeOpenEnum(soap, &a->RelationshipType);
	a->__anyAttribute = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_wsa5__RelatesToType(struct soap *soap, const struct wsa5__RelatesToType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_string(soap, (char*const*)&a->__item);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_wsa5__RelatesToType(struct soap *soap, const char *tag, int id, const struct wsa5__RelatesToType *a, const char *type)
{
	if (a->RelationshipType)
		soap_set_attr(soap, "RelationshipType", soap_wsa5__RelationshipTypeOpenEnum2s(soap, a->RelationshipType), 1);
	if (a->__anyAttribute)
		soap_set_attr(soap, "-anyAttribute", a->__anyAttribute, 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	return soap_out_string(soap, tag, id, (char*const*)&a->__item, "");
}

SOAP_FMAC3 struct wsa5__RelatesToType * SOAP_FMAC4 soap_in_wsa5__RelatesToType(struct soap *soap, const char *tag, struct wsa5__RelatesToType *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	if (!(a = (struct wsa5__RelatesToType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_wsa5__RelatesToType, sizeof(struct wsa5__RelatesToType), NULL, NULL, NULL, NULL)))
		return NULL;
	soap_revert(soap);
	*soap->id = '\0';
	soap_default_wsa5__RelatesToType(soap, a);
	if (soap_s2wsa5__RelationshipTypeOpenEnum(soap, soap_attr_value(soap, "RelationshipType", 1, 0), &a->RelationshipType))
		return NULL;
	if (soap_s2char(soap, soap_attr_value(soap, "-anyAttribute", 0, 0), &a->__anyAttribute, 0, 0, -1, NULL))
		return NULL;
	if (!soap_in_string(soap, tag, (char**)&a->__item, "wsa5:RelatesToType"))
		return NULL;
	return a;
}

SOAP_FMAC3 struct wsa5__RelatesToType * SOAP_FMAC4 soap_new_wsa5__RelatesToType(struct soap *soap, int n)
{
	struct wsa5__RelatesToType *p;
	struct wsa5__RelatesToType *a = (struct wsa5__RelatesToType*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct wsa5__RelatesToType));
	for (p = a; p && n--; p++)
		soap_default_wsa5__RelatesToType(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_wsa5__RelatesToType(struct soap *soap, const struct wsa5__RelatesToType *a, const char *tag, const char *type)
{
	if (soap_out_wsa5__RelatesToType(soap, tag ? tag : "wsa5:RelatesToType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct wsa5__RelatesToType * SOAP_FMAC4 soap_get_wsa5__RelatesToType(struct soap *soap, struct wsa5__RelatesToType *p, const char *tag, const char *type)
{
	if ((p = soap_in_wsa5__RelatesToType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_wsa5__MetadataType(struct soap *soap, struct wsa5__MetadataType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__size = 0;
	a->__any = NULL;
	a->__anyAttribute = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_wsa5__MetadataType(struct soap *soap, const struct wsa5__MetadataType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_wsa5__MetadataType(struct soap *soap, const char *tag, int id, const struct wsa5__MetadataType *a, const char *type)
{
	if (a->__anyAttribute)
		soap_set_attr(soap, "-anyAttribute", a->__anyAttribute, 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_wsa5__MetadataType), type))
		return soap->error;
	if (a->__any)
	{	int i;
		for (i = 0; i < (int)a->__size; i++)
			if (soap_outliteral(soap, "-any", (char*const*)(a->__any + i), NULL))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct wsa5__MetadataType * SOAP_FMAC4 soap_in_wsa5__MetadataType(struct soap *soap, const char *tag, struct wsa5__MetadataType *a, const char *type)
{
	struct soap_blist *soap_blist___any = NULL;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct wsa5__MetadataType*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_wsa5__MetadataType, sizeof(struct wsa5__MetadataType), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_wsa5__MetadataType(soap, a);
	if (soap_s2char(soap, soap_attr_value(soap, "-anyAttribute", 0, 0), &a->__anyAttribute, 0, 0, -1, NULL))
		return NULL;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	if (a->__any == NULL)
				{	if (soap_blist___any == NULL)
						soap_blist___any = soap_alloc_block(soap);
					a->__any = (char **)soap_push_block_max(soap, soap_blist___any, sizeof(char *));
					if (a->__any == NULL)
						return NULL;
					*a->__any = NULL;
				}
				if (soap_inliteral(soap, "-any", (char**)a->__any))
				{	a->__size++;
					a->__any = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->__any)
			soap_pop_block(soap, soap_blist___any);
		if (a->__size)
		{	a->__any = (char **)soap_save_block(soap, soap_blist___any, NULL, 1);
		}
		else
		{	a->__any = NULL;
			if (soap_blist___any)
				soap_end_block(soap, soap_blist___any);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct wsa5__MetadataType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_wsa5__MetadataType, SOAP_TYPE_wsa5__MetadataType, sizeof(struct wsa5__MetadataType), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct wsa5__MetadataType * SOAP_FMAC4 soap_new_wsa5__MetadataType(struct soap *soap, int n)
{
	struct wsa5__MetadataType *p;
	struct wsa5__MetadataType *a = (struct wsa5__MetadataType*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct wsa5__MetadataType));
	for (p = a; p && n--; p++)
		soap_default_wsa5__MetadataType(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_wsa5__MetadataType(struct soap *soap, const struct wsa5__MetadataType *a, const char *tag, const char *type)
{
	if (soap_out_wsa5__MetadataType(soap, tag ? tag : "wsa5:MetadataType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct wsa5__MetadataType * SOAP_FMAC4 soap_get_wsa5__MetadataType(struct soap *soap, struct wsa5__MetadataType *p, const char *tag, const char *type)
{
	if ((p = soap_in_wsa5__MetadataType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_wsa5__ReferenceParametersType(struct soap *soap, struct wsa5__ReferenceParametersType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->chan__ChannelInstance = NULL;
	a->__size = 0;
	a->__any = NULL;
	a->__anyAttribute = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_wsa5__ReferenceParametersType(struct soap *soap, const struct wsa5__ReferenceParametersType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerToint(soap, &a->chan__ChannelInstance);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_wsa5__ReferenceParametersType(struct soap *soap, const char *tag, int id, const struct wsa5__ReferenceParametersType *a, const char *type)
{
	if (a->__anyAttribute)
		soap_set_attr(soap, "-anyAttribute", a->__anyAttribute, 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_wsa5__ReferenceParametersType), type))
		return soap->error;
	if (soap_out_PointerToint(soap, "chan:ChannelInstance", -1, &a->chan__ChannelInstance, ""))
		return soap->error;
	if (a->__any)
	{	int i;
		for (i = 0; i < (int)a->__size; i++)
			if (soap_outliteral(soap, "-any", (char*const*)(a->__any + i), NULL))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct wsa5__ReferenceParametersType * SOAP_FMAC4 soap_in_wsa5__ReferenceParametersType(struct soap *soap, const char *tag, struct wsa5__ReferenceParametersType *a, const char *type)
{
	size_t soap_flag_chan__ChannelInstance = 1;
	struct soap_blist *soap_blist___any = NULL;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct wsa5__ReferenceParametersType*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_wsa5__ReferenceParametersType, sizeof(struct wsa5__ReferenceParametersType), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_wsa5__ReferenceParametersType(soap, a);
	if (soap_s2char(soap, soap_attr_value(soap, "-anyAttribute", 0, 0), &a->__anyAttribute, 0, 0, -1, NULL))
		return NULL;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_chan__ChannelInstance && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerToint(soap, "chan:ChannelInstance", &a->chan__ChannelInstance, "xsd:int"))
				{	soap_flag_chan__ChannelInstance--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	if (a->__any == NULL)
				{	if (soap_blist___any == NULL)
						soap_blist___any = soap_alloc_block(soap);
					a->__any = (char **)soap_push_block_max(soap, soap_blist___any, sizeof(char *));
					if (a->__any == NULL)
						return NULL;
					*a->__any = NULL;
				}
				if (soap_inliteral(soap, "-any", (char**)a->__any))
				{	a->__size++;
					a->__any = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->__any)
			soap_pop_block(soap, soap_blist___any);
		if (a->__size)
		{	a->__any = (char **)soap_save_block(soap, soap_blist___any, NULL, 1);
		}
		else
		{	a->__any = NULL;
			if (soap_blist___any)
				soap_end_block(soap, soap_blist___any);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct wsa5__ReferenceParametersType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_wsa5__ReferenceParametersType, SOAP_TYPE_wsa5__ReferenceParametersType, sizeof(struct wsa5__ReferenceParametersType), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct wsa5__ReferenceParametersType * SOAP_FMAC4 soap_new_wsa5__ReferenceParametersType(struct soap *soap, int n)
{
	struct wsa5__ReferenceParametersType *p;
	struct wsa5__ReferenceParametersType *a = (struct wsa5__ReferenceParametersType*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct wsa5__ReferenceParametersType));
	for (p = a; p && n--; p++)
		soap_default_wsa5__ReferenceParametersType(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_wsa5__ReferenceParametersType(struct soap *soap, const struct wsa5__ReferenceParametersType *a, const char *tag, const char *type)
{
	if (soap_out_wsa5__ReferenceParametersType(soap, tag ? tag : "wsa5:ReferenceParametersType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct wsa5__ReferenceParametersType * SOAP_FMAC4 soap_get_wsa5__ReferenceParametersType(struct soap *soap, struct wsa5__ReferenceParametersType *p, const char *tag, const char *type)
{
	if ((p = soap_in_wsa5__ReferenceParametersType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_wsa5__EndpointReferenceType(struct soap *soap, struct wsa5__EndpointReferenceType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->Address);
	a->ReferenceParameters = NULL;
	a->Metadata = NULL;
	a->__size = 0;
	a->__any = NULL;
	a->__anyAttribute = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_wsa5__EndpointReferenceType(struct soap *soap, const struct wsa5__EndpointReferenceType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_string(soap, (char*const*)&a->Address);
	soap_serialize_PointerTowsa5__ReferenceParametersType(soap, &a->ReferenceParameters);
	soap_serialize_PointerTowsa5__MetadataType(soap, &a->Metadata);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_wsa5__EndpointReferenceType(struct soap *soap, const char *tag, int id, const struct wsa5__EndpointReferenceType *a, const char *type)
{
	if (a->__anyAttribute)
		soap_set_attr(soap, "-anyAttribute", a->__anyAttribute, 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_wsa5__EndpointReferenceType), type))
		return soap->error;
	if (!a->Address)
	{	if (soap_element_empty(soap, "wsa5:Address", 0, NULL))
			return soap->error;
	}
	else if (soap_out_string(soap, "wsa5:Address", -1, (char*const*)&a->Address, ""))
		return soap->error;
	if (soap_out_PointerTowsa5__ReferenceParametersType(soap, "wsa5:ReferenceParameters", -1, &a->ReferenceParameters, ""))
		return soap->error;
	if (soap_out_PointerTowsa5__MetadataType(soap, "wsa5:Metadata", -1, &a->Metadata, ""))
		return soap->error;
	if (a->__any)
	{	int i;
		for (i = 0; i < (int)a->__size; i++)
			if (soap_outliteral(soap, "-any", (char*const*)(a->__any + i), NULL))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct wsa5__EndpointReferenceType * SOAP_FMAC4 soap_in_wsa5__EndpointReferenceType(struct soap *soap, const char *tag, struct wsa5__EndpointReferenceType *a, const char *type)
{
	size_t soap_flag_Address = 1;
	size_t soap_flag_ReferenceParameters = 1;
	size_t soap_flag_Metadata = 1;
	struct soap_blist *soap_blist___any = NULL;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct wsa5__EndpointReferenceType*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_wsa5__EndpointReferenceType, sizeof(struct wsa5__EndpointReferenceType), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_wsa5__EndpointReferenceType(soap, a);
	if (soap_s2char(soap, soap_attr_value(soap, "-anyAttribute", 0, 0), &a->__anyAttribute, 0, 0, -1, NULL))
		return NULL;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Address && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_string(soap, "wsa5:Address", (char**)&a->Address, "xsd:string"))
				{	soap_flag_Address--;
					continue;
				}
			}
			if (soap_flag_ReferenceParameters && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTowsa5__ReferenceParametersType(soap, "wsa5:ReferenceParameters", &a->ReferenceParameters, "wsa5:ReferenceParametersType"))
				{	soap_flag_ReferenceParameters--;
					continue;
				}
			}
			if (soap_flag_Metadata && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTowsa5__MetadataType(soap, "wsa5:Metadata", &a->Metadata, "wsa5:MetadataType"))
				{	soap_flag_Metadata--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	if (a->__any == NULL)
				{	if (soap_blist___any == NULL)
						soap_blist___any = soap_alloc_block(soap);
					a->__any = (char **)soap_push_block_max(soap, soap_blist___any, sizeof(char *));
					if (a->__any == NULL)
						return NULL;
					*a->__any = NULL;
				}
				if (soap_inliteral(soap, "-any", (char**)a->__any))
				{	a->__size++;
					a->__any = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->__any)
			soap_pop_block(soap, soap_blist___any);
		if (a->__size)
		{	a->__any = (char **)soap_save_block(soap, soap_blist___any, NULL, 1);
		}
		else
		{	a->__any = NULL;
			if (soap_blist___any)
				soap_end_block(soap, soap_blist___any);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (!a->Address))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct wsa5__EndpointReferenceType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_wsa5__EndpointReferenceType, SOAP_TYPE_wsa5__EndpointReferenceType, sizeof(struct wsa5__EndpointReferenceType), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct wsa5__EndpointReferenceType * SOAP_FMAC4 soap_new_wsa5__EndpointReferenceType(struct soap *soap, int n)
{
	struct wsa5__EndpointReferenceType *p;
	struct wsa5__EndpointReferenceType *a = (struct wsa5__EndpointReferenceType*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct wsa5__EndpointReferenceType));
	for (p = a; p && n--; p++)
		soap_default_wsa5__EndpointReferenceType(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_wsa5__EndpointReferenceType(struct soap *soap, const struct wsa5__EndpointReferenceType *a, const char *tag, const char *type)
{
	if (soap_out_wsa5__EndpointReferenceType(soap, tag ? tag : "wsa5:EndpointReferenceType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct wsa5__EndpointReferenceType * SOAP_FMAC4 soap_get_wsa5__EndpointReferenceType(struct soap *soap, struct wsa5__EndpointReferenceType *p, const char *tag, const char *type)
{
	if ((p = soap_in_wsa5__EndpointReferenceType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___wsdd__ResolveMatches(struct soap *soap, struct __wsdd__ResolveMatches *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->wsdd__ResolveMatches = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___wsdd__ResolveMatches(struct soap *soap, const struct __wsdd__ResolveMatches *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTowsdd__ResolveMatchesType(soap, &a->wsdd__ResolveMatches);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___wsdd__ResolveMatches(struct soap *soap, const char *tag, int id, const struct __wsdd__ResolveMatches *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTowsdd__ResolveMatchesType(soap, "wsdd:ResolveMatches", -1, &a->wsdd__ResolveMatches, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __wsdd__ResolveMatches * SOAP_FMAC4 soap_in___wsdd__ResolveMatches(struct soap *soap, const char *tag, struct __wsdd__ResolveMatches *a, const char *type)
{
	size_t soap_flag_wsdd__ResolveMatches = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __wsdd__ResolveMatches*)soap_id_enter(soap, "", a, SOAP_TYPE___wsdd__ResolveMatches, sizeof(struct __wsdd__ResolveMatches), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___wsdd__ResolveMatches(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_wsdd__ResolveMatches && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTowsdd__ResolveMatchesType(soap, "wsdd:ResolveMatches", &a->wsdd__ResolveMatches, "wsdd:ResolveMatchesType"))
				{	soap_flag_wsdd__ResolveMatches--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 struct __wsdd__ResolveMatches * SOAP_FMAC4 soap_new___wsdd__ResolveMatches(struct soap *soap, int n)
{
	struct __wsdd__ResolveMatches *p;
	struct __wsdd__ResolveMatches *a = (struct __wsdd__ResolveMatches*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct __wsdd__ResolveMatches));
	for (p = a; p && n--; p++)
		soap_default___wsdd__ResolveMatches(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___wsdd__ResolveMatches(struct soap *soap, const struct __wsdd__ResolveMatches *a, const char *tag, const char *type)
{
	if (soap_out___wsdd__ResolveMatches(soap, tag ? tag : "-wsdd:ResolveMatches", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __wsdd__ResolveMatches * SOAP_FMAC4 soap_get___wsdd__ResolveMatches(struct soap *soap, struct __wsdd__ResolveMatches *p, const char *tag, const char *type)
{
	if ((p = soap_in___wsdd__ResolveMatches(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___wsdd__Resolve(struct soap *soap, struct __wsdd__Resolve *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->wsdd__Resolve = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___wsdd__Resolve(struct soap *soap, const struct __wsdd__Resolve *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTowsdd__ResolveType(soap, &a->wsdd__Resolve);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___wsdd__Resolve(struct soap *soap, const char *tag, int id, const struct __wsdd__Resolve *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTowsdd__ResolveType(soap, "wsdd:Resolve", -1, &a->wsdd__Resolve, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __wsdd__Resolve * SOAP_FMAC4 soap_in___wsdd__Resolve(struct soap *soap, const char *tag, struct __wsdd__Resolve *a, const char *type)
{
	size_t soap_flag_wsdd__Resolve = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __wsdd__Resolve*)soap_id_enter(soap, "", a, SOAP_TYPE___wsdd__Resolve, sizeof(struct __wsdd__Resolve), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___wsdd__Resolve(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_wsdd__Resolve && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTowsdd__ResolveType(soap, "wsdd:Resolve", &a->wsdd__Resolve, "wsdd:ResolveType"))
				{	soap_flag_wsdd__Resolve--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 struct __wsdd__Resolve * SOAP_FMAC4 soap_new___wsdd__Resolve(struct soap *soap, int n)
{
	struct __wsdd__Resolve *p;
	struct __wsdd__Resolve *a = (struct __wsdd__Resolve*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct __wsdd__Resolve));
	for (p = a; p && n--; p++)
		soap_default___wsdd__Resolve(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___wsdd__Resolve(struct soap *soap, const struct __wsdd__Resolve *a, const char *tag, const char *type)
{
	if (soap_out___wsdd__Resolve(soap, tag ? tag : "-wsdd:Resolve", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __wsdd__Resolve * SOAP_FMAC4 soap_get___wsdd__Resolve(struct soap *soap, struct __wsdd__Resolve *p, const char *tag, const char *type)
{
	if ((p = soap_in___wsdd__Resolve(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___wsdd__ProbeMatches(struct soap *soap, struct __wsdd__ProbeMatches *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->wsdd__ProbeMatches = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___wsdd__ProbeMatches(struct soap *soap, const struct __wsdd__ProbeMatches *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTowsdd__ProbeMatchesType(soap, &a->wsdd__ProbeMatches);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___wsdd__ProbeMatches(struct soap *soap, const char *tag, int id, const struct __wsdd__ProbeMatches *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTowsdd__ProbeMatchesType(soap, "wsdd:ProbeMatches", -1, &a->wsdd__ProbeMatches, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __wsdd__ProbeMatches * SOAP_FMAC4 soap_in___wsdd__ProbeMatches(struct soap *soap, const char *tag, struct __wsdd__ProbeMatches *a, const char *type)
{
	size_t soap_flag_wsdd__ProbeMatches = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __wsdd__ProbeMatches*)soap_id_enter(soap, "", a, SOAP_TYPE___wsdd__ProbeMatches, sizeof(struct __wsdd__ProbeMatches), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___wsdd__ProbeMatches(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_wsdd__ProbeMatches && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTowsdd__ProbeMatchesType(soap, "wsdd:ProbeMatches", &a->wsdd__ProbeMatches, "wsdd:ProbeMatchesType"))
				{	soap_flag_wsdd__ProbeMatches--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 struct __wsdd__ProbeMatches * SOAP_FMAC4 soap_new___wsdd__ProbeMatches(struct soap *soap, int n)
{
	struct __wsdd__ProbeMatches *p;
	struct __wsdd__ProbeMatches *a = (struct __wsdd__ProbeMatches*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct __wsdd__ProbeMatches));
	for (p = a; p && n--; p++)
		soap_default___wsdd__ProbeMatches(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___wsdd__ProbeMatches(struct soap *soap, const struct __wsdd__ProbeMatches *a, const char *tag, const char *type)
{
	if (soap_out___wsdd__ProbeMatches(soap, tag ? tag : "-wsdd:ProbeMatches", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __wsdd__ProbeMatches * SOAP_FMAC4 soap_get___wsdd__ProbeMatches(struct soap *soap, struct __wsdd__ProbeMatches *p, const char *tag, const char *type)
{
	if ((p = soap_in___wsdd__ProbeMatches(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___wsdd__Probe(struct soap *soap, struct __wsdd__Probe *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->wsdd__Probe = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___wsdd__Probe(struct soap *soap, const struct __wsdd__Probe *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTowsdd__ProbeType(soap, &a->wsdd__Probe);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___wsdd__Probe(struct soap *soap, const char *tag, int id, const struct __wsdd__Probe *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTowsdd__ProbeType(soap, "wsdd:Probe", -1, &a->wsdd__Probe, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __wsdd__Probe * SOAP_FMAC4 soap_in___wsdd__Probe(struct soap *soap, const char *tag, struct __wsdd__Probe *a, const char *type)
{
	size_t soap_flag_wsdd__Probe = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __wsdd__Probe*)soap_id_enter(soap, "", a, SOAP_TYPE___wsdd__Probe, sizeof(struct __wsdd__Probe), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___wsdd__Probe(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_wsdd__Probe && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTowsdd__ProbeType(soap, "wsdd:Probe", &a->wsdd__Probe, "wsdd:ProbeType"))
				{	soap_flag_wsdd__Probe--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 struct __wsdd__Probe * SOAP_FMAC4 soap_new___wsdd__Probe(struct soap *soap, int n)
{
	struct __wsdd__Probe *p;
	struct __wsdd__Probe *a = (struct __wsdd__Probe*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct __wsdd__Probe));
	for (p = a; p && n--; p++)
		soap_default___wsdd__Probe(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___wsdd__Probe(struct soap *soap, const struct __wsdd__Probe *a, const char *tag, const char *type)
{
	if (soap_out___wsdd__Probe(soap, tag ? tag : "-wsdd:Probe", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __wsdd__Probe * SOAP_FMAC4 soap_get___wsdd__Probe(struct soap *soap, struct __wsdd__Probe *p, const char *tag, const char *type)
{
	if ((p = soap_in___wsdd__Probe(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___wsdd__Bye(struct soap *soap, struct __wsdd__Bye *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->wsdd__Bye = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___wsdd__Bye(struct soap *soap, const struct __wsdd__Bye *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTowsdd__ByeType(soap, &a->wsdd__Bye);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___wsdd__Bye(struct soap *soap, const char *tag, int id, const struct __wsdd__Bye *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTowsdd__ByeType(soap, "wsdd:Bye", -1, &a->wsdd__Bye, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __wsdd__Bye * SOAP_FMAC4 soap_in___wsdd__Bye(struct soap *soap, const char *tag, struct __wsdd__Bye *a, const char *type)
{
	size_t soap_flag_wsdd__Bye = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __wsdd__Bye*)soap_id_enter(soap, "", a, SOAP_TYPE___wsdd__Bye, sizeof(struct __wsdd__Bye), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___wsdd__Bye(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_wsdd__Bye && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTowsdd__ByeType(soap, "wsdd:Bye", &a->wsdd__Bye, "wsdd:ByeType"))
				{	soap_flag_wsdd__Bye--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 struct __wsdd__Bye * SOAP_FMAC4 soap_new___wsdd__Bye(struct soap *soap, int n)
{
	struct __wsdd__Bye *p;
	struct __wsdd__Bye *a = (struct __wsdd__Bye*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct __wsdd__Bye));
	for (p = a; p && n--; p++)
		soap_default___wsdd__Bye(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___wsdd__Bye(struct soap *soap, const struct __wsdd__Bye *a, const char *tag, const char *type)
{
	if (soap_out___wsdd__Bye(soap, tag ? tag : "-wsdd:Bye", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __wsdd__Bye * SOAP_FMAC4 soap_get___wsdd__Bye(struct soap *soap, struct __wsdd__Bye *p, const char *tag, const char *type)
{
	if ((p = soap_in___wsdd__Bye(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___wsdd__Hello(struct soap *soap, struct __wsdd__Hello *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->wsdd__Hello = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___wsdd__Hello(struct soap *soap, const struct __wsdd__Hello *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTowsdd__HelloType(soap, &a->wsdd__Hello);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___wsdd__Hello(struct soap *soap, const char *tag, int id, const struct __wsdd__Hello *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTowsdd__HelloType(soap, "wsdd:Hello", -1, &a->wsdd__Hello, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __wsdd__Hello * SOAP_FMAC4 soap_in___wsdd__Hello(struct soap *soap, const char *tag, struct __wsdd__Hello *a, const char *type)
{
	size_t soap_flag_wsdd__Hello = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __wsdd__Hello*)soap_id_enter(soap, "", a, SOAP_TYPE___wsdd__Hello, sizeof(struct __wsdd__Hello), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___wsdd__Hello(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_wsdd__Hello && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTowsdd__HelloType(soap, "wsdd:Hello", &a->wsdd__Hello, "wsdd:HelloType"))
				{	soap_flag_wsdd__Hello--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 struct __wsdd__Hello * SOAP_FMAC4 soap_new___wsdd__Hello(struct soap *soap, int n)
{
	struct __wsdd__Hello *p;
	struct __wsdd__Hello *a = (struct __wsdd__Hello*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct __wsdd__Hello));
	for (p = a; p && n--; p++)
		soap_default___wsdd__Hello(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___wsdd__Hello(struct soap *soap, const struct __wsdd__Hello *a, const char *tag, const char *type)
{
	if (soap_out___wsdd__Hello(soap, tag ? tag : "-wsdd:Hello", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __wsdd__Hello * SOAP_FMAC4 soap_get___wsdd__Hello(struct soap *soap, struct __wsdd__Hello *p, const char *tag, const char *type)
{
	if ((p = soap_in___wsdd__Hello(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__wsdd__AppSequence(struct soap *soap, const struct wsdd__AppSequenceType *a, const char *tag, const char *type)
{
	if (soap_out__wsdd__AppSequence(soap, tag ? tag : "wsdd:AppSequence", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__wsdd__Sig(struct soap *soap, const struct wsdd__SigType *a, const char *tag, const char *type)
{
	if (soap_out__wsdd__Sig(soap, tag ? tag : "wsdd:Sig", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__wsdd__Security(struct soap *soap, const struct wsdd__SecurityType *a, const char *tag, const char *type)
{
	if (soap_out__wsdd__Security(soap, tag ? tag : "wsdd:Security", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__wsdd__Scopes(struct soap *soap, const struct wsdd__ScopesType *a, const char *tag, const char *type)
{
	if (soap_out__wsdd__Scopes(soap, tag ? tag : "wsdd:Scopes", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__wsdd__ResolveMatches(struct soap *soap, const struct wsdd__ResolveMatchesType *a, const char *tag, const char *type)
{
	if (soap_out__wsdd__ResolveMatches(soap, tag ? tag : "wsdd:ResolveMatches", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__wsdd__Resolve(struct soap *soap, const struct wsdd__ResolveType *a, const char *tag, const char *type)
{
	if (soap_out__wsdd__Resolve(soap, tag ? tag : "wsdd:Resolve", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__wsdd__ProbeMatches(struct soap *soap, const struct wsdd__ProbeMatchesType *a, const char *tag, const char *type)
{
	if (soap_out__wsdd__ProbeMatches(soap, tag ? tag : "wsdd:ProbeMatches", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__wsdd__Probe(struct soap *soap, const struct wsdd__ProbeType *a, const char *tag, const char *type)
{
	if (soap_out__wsdd__Probe(soap, tag ? tag : "wsdd:Probe", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__wsdd__Bye(struct soap *soap, const struct wsdd__ByeType *a, const char *tag, const char *type)
{
	if (soap_out__wsdd__Bye(soap, tag ? tag : "wsdd:Bye", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__wsdd__Hello(struct soap *soap, const struct wsdd__HelloType *a, const char *tag, const char *type)
{
	if (soap_out__wsdd__Hello(soap, tag ? tag : "wsdd:Hello", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_wsdd__AppSequenceType(struct soap *soap, struct wsdd__AppSequenceType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_unsignedInt(soap, &a->InstanceId);
	soap_default_string(soap, &a->SequenceId);
	soap_default_unsignedInt(soap, &a->MessageNumber);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_wsdd__AppSequenceType(struct soap *soap, const struct wsdd__AppSequenceType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_wsdd__AppSequenceType(struct soap *soap, const char *tag, int id, const struct wsdd__AppSequenceType *a, const char *type)
{
	soap_set_attr(soap, "InstanceId", soap_unsignedInt2s(soap, a->InstanceId), 1);
	if (a->SequenceId)
		soap_set_attr(soap, "SequenceId", soap_string2s(soap, a->SequenceId), 1);
	soap_set_attr(soap, "MessageNumber", soap_unsignedInt2s(soap, a->MessageNumber), 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_wsdd__AppSequenceType), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct wsdd__AppSequenceType * SOAP_FMAC4 soap_in_wsdd__AppSequenceType(struct soap *soap, const char *tag, struct wsdd__AppSequenceType *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct wsdd__AppSequenceType*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_wsdd__AppSequenceType, sizeof(struct wsdd__AppSequenceType), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_wsdd__AppSequenceType(soap, a);
	if (soap_s2unsignedInt(soap, soap_attr_value(soap, "InstanceId", 5, 1), &a->InstanceId))
		return NULL;
	if (soap_s2string(soap, soap_attr_value(soap, "SequenceId", 1, 0), &a->SequenceId))
		return NULL;
	if (soap_s2unsignedInt(soap, soap_attr_value(soap, "MessageNumber", 5, 1), &a->MessageNumber))
		return NULL;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct wsdd__AppSequenceType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_wsdd__AppSequenceType, SOAP_TYPE_wsdd__AppSequenceType, sizeof(struct wsdd__AppSequenceType), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct wsdd__AppSequenceType * SOAP_FMAC4 soap_new_wsdd__AppSequenceType(struct soap *soap, int n)
{
	struct wsdd__AppSequenceType *p;
	struct wsdd__AppSequenceType *a = (struct wsdd__AppSequenceType*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct wsdd__AppSequenceType));
	for (p = a; p && n--; p++)
		soap_default_wsdd__AppSequenceType(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_wsdd__AppSequenceType(struct soap *soap, const struct wsdd__AppSequenceType *a, const char *tag, const char *type)
{
	if (soap_out_wsdd__AppSequenceType(soap, tag ? tag : "wsdd:AppSequenceType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct wsdd__AppSequenceType * SOAP_FMAC4 soap_get_wsdd__AppSequenceType(struct soap *soap, struct wsdd__AppSequenceType *p, const char *tag, const char *type)
{
	if ((p = soap_in_wsdd__AppSequenceType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_wsdd__SigType(struct soap *soap, struct wsdd__SigType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->Scheme);
	soap_default_string(soap, &a->KeyId);
	soap_default_string(soap, &a->Refs);
	soap_default_string(soap, &a->Sig);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_wsdd__SigType(struct soap *soap, const struct wsdd__SigType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_wsdd__SigType(struct soap *soap, const char *tag, int id, const struct wsdd__SigType *a, const char *type)
{
	soap_set_attr(soap, "Scheme", a->Scheme ? soap_string2s(soap, a->Scheme) : "", 1);
	if (a->KeyId)
		soap_set_attr(soap, "KeyId", soap_string2s(soap, a->KeyId), 1);
	soap_set_attr(soap, "Refs", a->Refs ? soap_string2s(soap, a->Refs) : "", 1);
	soap_set_attr(soap, "Sig", a->Sig ? soap_string2s(soap, a->Sig) : "", 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_wsdd__SigType), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct wsdd__SigType * SOAP_FMAC4 soap_in_wsdd__SigType(struct soap *soap, const char *tag, struct wsdd__SigType *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct wsdd__SigType*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_wsdd__SigType, sizeof(struct wsdd__SigType), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_wsdd__SigType(soap, a);
	if (soap_s2string(soap, soap_attr_value(soap, "Scheme", 1, 1), &a->Scheme))
		return NULL;
	if (soap_s2string(soap, soap_attr_value(soap, "KeyId", 1, 0), &a->KeyId))
		return NULL;
	if (soap_s2string(soap, soap_attr_value(soap, "Refs", 1, 1), &a->Refs))
		return NULL;
	if (soap_s2string(soap, soap_attr_value(soap, "Sig", 1, 1), &a->Sig))
		return NULL;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct wsdd__SigType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_wsdd__SigType, SOAP_TYPE_wsdd__SigType, sizeof(struct wsdd__SigType), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct wsdd__SigType * SOAP_FMAC4 soap_new_wsdd__SigType(struct soap *soap, int n)
{
	struct wsdd__SigType *p;
	struct wsdd__SigType *a = (struct wsdd__SigType*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct wsdd__SigType));
	for (p = a; p && n--; p++)
		soap_default_wsdd__SigType(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_wsdd__SigType(struct soap *soap, const struct wsdd__SigType *a, const char *tag, const char *type)
{
	if (soap_out_wsdd__SigType(soap, tag ? tag : "wsdd:SigType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct wsdd__SigType * SOAP_FMAC4 soap_get_wsdd__SigType(struct soap *soap, struct wsdd__SigType *p, const char *tag, const char *type)
{
	if ((p = soap_in_wsdd__SigType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_wsdd__SecurityType(struct soap *soap, struct wsdd__SecurityType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->Sig = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_wsdd__SecurityType(struct soap *soap, const struct wsdd__SecurityType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTowsdd__SigType(soap, &a->Sig);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_wsdd__SecurityType(struct soap *soap, const char *tag, int id, const struct wsdd__SecurityType *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_wsdd__SecurityType), type))
		return soap->error;
	if (soap_out_PointerTowsdd__SigType(soap, "wsdd:Sig", -1, &a->Sig, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct wsdd__SecurityType * SOAP_FMAC4 soap_in_wsdd__SecurityType(struct soap *soap, const char *tag, struct wsdd__SecurityType *a, const char *type)
{
	size_t soap_flag_Sig = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct wsdd__SecurityType*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_wsdd__SecurityType, sizeof(struct wsdd__SecurityType), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_wsdd__SecurityType(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Sig && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTowsdd__SigType(soap, "wsdd:Sig", &a->Sig, "wsdd:SigType"))
				{	soap_flag_Sig--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct wsdd__SecurityType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_wsdd__SecurityType, SOAP_TYPE_wsdd__SecurityType, sizeof(struct wsdd__SecurityType), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct wsdd__SecurityType * SOAP_FMAC4 soap_new_wsdd__SecurityType(struct soap *soap, int n)
{
	struct wsdd__SecurityType *p;
	struct wsdd__SecurityType *a = (struct wsdd__SecurityType*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct wsdd__SecurityType));
	for (p = a; p && n--; p++)
		soap_default_wsdd__SecurityType(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_wsdd__SecurityType(struct soap *soap, const struct wsdd__SecurityType *a, const char *tag, const char *type)
{
	if (soap_out_wsdd__SecurityType(soap, tag ? tag : "wsdd:SecurityType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct wsdd__SecurityType * SOAP_FMAC4 soap_get_wsdd__SecurityType(struct soap *soap, struct wsdd__SecurityType *p, const char *tag, const char *type)
{
	if ((p = soap_in_wsdd__SecurityType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_wsdd__ScopesType(struct soap *soap, struct wsdd__ScopesType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_wsdd__UriListType(soap, &a->__item);
	soap_default_string(soap, &a->MatchBy);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_wsdd__ScopesType(struct soap *soap, const struct wsdd__ScopesType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_wsdd__UriListType(soap, (char*const*)&a->__item);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_wsdd__ScopesType(struct soap *soap, const char *tag, int id, const struct wsdd__ScopesType *a, const char *type)
{
	if (a->MatchBy)
		soap_set_attr(soap, "MatchBy", soap_string2s(soap, a->MatchBy), 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	return soap_out_wsdd__UriListType(soap, tag, id, (char*const*)&a->__item, "");
}

SOAP_FMAC3 struct wsdd__ScopesType * SOAP_FMAC4 soap_in_wsdd__ScopesType(struct soap *soap, const char *tag, struct wsdd__ScopesType *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	if (!(a = (struct wsdd__ScopesType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_wsdd__ScopesType, sizeof(struct wsdd__ScopesType), NULL, NULL, NULL, NULL)))
		return NULL;
	soap_revert(soap);
	*soap->id = '\0';
	soap_default_wsdd__ScopesType(soap, a);
	if (soap_s2string(soap, soap_attr_value(soap, "MatchBy", 1, 0), &a->MatchBy))
		return NULL;
	if (!soap_in_wsdd__UriListType(soap, tag, (char**)&a->__item, "wsdd:ScopesType"))
		return NULL;
	return a;
}

SOAP_FMAC3 struct wsdd__ScopesType * SOAP_FMAC4 soap_new_wsdd__ScopesType(struct soap *soap, int n)
{
	struct wsdd__ScopesType *p;
	struct wsdd__ScopesType *a = (struct wsdd__ScopesType*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct wsdd__ScopesType));
	for (p = a; p && n--; p++)
		soap_default_wsdd__ScopesType(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_wsdd__ScopesType(struct soap *soap, const struct wsdd__ScopesType *a, const char *tag, const char *type)
{
	if (soap_out_wsdd__ScopesType(soap, tag ? tag : "wsdd:ScopesType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct wsdd__ScopesType * SOAP_FMAC4 soap_get_wsdd__ScopesType(struct soap *soap, struct wsdd__ScopesType *p, const char *tag, const char *type)
{
	if ((p = soap_in_wsdd__ScopesType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_wsdd__ResolveMatchType(struct soap *soap, struct wsdd__ResolveMatchType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default__wsa__EndpointReference(soap, &a->wsa__EndpointReference);
	soap_default_wsdd__QNameListType(soap, &a->Types);
	a->Scopes = NULL;
	soap_default_wsdd__UriListType(soap, &a->XAddrs);
	soap_default_unsignedInt(soap, &a->MetadataVersion);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_wsdd__ResolveMatchType(struct soap *soap, const struct wsdd__ResolveMatchType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize__wsa__EndpointReference(soap, &a->wsa__EndpointReference);
	soap_serialize_wsdd__QNameListType(soap, (char*const*)&a->Types);
	soap_serialize_PointerTowsdd__ScopesType(soap, &a->Scopes);
	soap_serialize_wsdd__UriListType(soap, (char*const*)&a->XAddrs);
	soap_embedded(soap, &a->MetadataVersion, SOAP_TYPE_unsignedInt);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_wsdd__ResolveMatchType(struct soap *soap, const char *tag, int id, const struct wsdd__ResolveMatchType *a, const char *type)
{
	const char *soap_tmp_Types;
	soap_tmp_Types = soap_QName2s(soap, a->Types);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_wsdd__ResolveMatchType), type))
		return soap->error;
	if (soap_out__wsa__EndpointReference(soap, "wsa:EndpointReference", -1, &a->wsa__EndpointReference, ""))
		return soap->error;
	if (soap_out_wsdd__QNameListType(soap, "wsdd:Types", -1, (char*const*)(void*)&soap_tmp_Types, ""))
		return soap->error;
	if (soap_out_PointerTowsdd__ScopesType(soap, "wsdd:Scopes", -1, &a->Scopes, ""))
		return soap->error;
	if (soap_out_wsdd__UriListType(soap, "wsdd:XAddrs", -1, (char*const*)&a->XAddrs, ""))
		return soap->error;
	if (soap_out_unsignedInt(soap, "wsdd:MetadataVersion", -1, &a->MetadataVersion, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct wsdd__ResolveMatchType * SOAP_FMAC4 soap_in_wsdd__ResolveMatchType(struct soap *soap, const char *tag, struct wsdd__ResolveMatchType *a, const char *type)
{
	size_t soap_flag_wsa__EndpointReference = 1;
	size_t soap_flag_Types = 1;
	size_t soap_flag_Scopes = 1;
	size_t soap_flag_XAddrs = 1;
	size_t soap_flag_MetadataVersion = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct wsdd__ResolveMatchType*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_wsdd__ResolveMatchType, sizeof(struct wsdd__ResolveMatchType), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_wsdd__ResolveMatchType(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_wsa__EndpointReference && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in__wsa__EndpointReference(soap, "wsa:EndpointReference", &a->wsa__EndpointReference, ""))
				{	soap_flag_wsa__EndpointReference--;
					continue;
				}
			}
			if (soap_flag_Types && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_wsdd__QNameListType(soap, "wsdd:Types", (char**)&a->Types, "xsd:QName"))
				{	soap_flag_Types--;
					continue;
				}
			}
			if (soap_flag_Scopes && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTowsdd__ScopesType(soap, "wsdd:Scopes", &a->Scopes, "wsdd:ScopesType"))
				{	soap_flag_Scopes--;
					continue;
				}
			}
			if (soap_flag_XAddrs && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_wsdd__UriListType(soap, "wsdd:XAddrs", (char**)&a->XAddrs, "wsdd:UriListType"))
				{	soap_flag_XAddrs--;
					continue;
				}
			}
			if (soap_flag_MetadataVersion && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_unsignedInt(soap, "wsdd:MetadataVersion", &a->MetadataVersion, "xsd:unsignedInt"))
				{	soap_flag_MetadataVersion--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_wsa__EndpointReference > 0 || soap_flag_MetadataVersion > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct wsdd__ResolveMatchType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_wsdd__ResolveMatchType, SOAP_TYPE_wsdd__ResolveMatchType, sizeof(struct wsdd__ResolveMatchType), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct wsdd__ResolveMatchType * SOAP_FMAC4 soap_new_wsdd__ResolveMatchType(struct soap *soap, int n)
{
	struct wsdd__ResolveMatchType *p;
	struct wsdd__ResolveMatchType *a = (struct wsdd__ResolveMatchType*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct wsdd__ResolveMatchType));
	for (p = a; p && n--; p++)
		soap_default_wsdd__ResolveMatchType(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_wsdd__ResolveMatchType(struct soap *soap, const struct wsdd__ResolveMatchType *a, const char *tag, const char *type)
{
	if (soap_out_wsdd__ResolveMatchType(soap, tag ? tag : "wsdd:ResolveMatchType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct wsdd__ResolveMatchType * SOAP_FMAC4 soap_get_wsdd__ResolveMatchType(struct soap *soap, struct wsdd__ResolveMatchType *p, const char *tag, const char *type)
{
	if ((p = soap_in_wsdd__ResolveMatchType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_wsdd__ResolveMatchesType(struct soap *soap, struct wsdd__ResolveMatchesType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ResolveMatch = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_wsdd__ResolveMatchesType(struct soap *soap, const struct wsdd__ResolveMatchesType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTowsdd__ResolveMatchType(soap, &a->ResolveMatch);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_wsdd__ResolveMatchesType(struct soap *soap, const char *tag, int id, const struct wsdd__ResolveMatchesType *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_wsdd__ResolveMatchesType), type))
		return soap->error;
	if (soap_out_PointerTowsdd__ResolveMatchType(soap, "wsdd:ResolveMatch", -1, &a->ResolveMatch, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct wsdd__ResolveMatchesType * SOAP_FMAC4 soap_in_wsdd__ResolveMatchesType(struct soap *soap, const char *tag, struct wsdd__ResolveMatchesType *a, const char *type)
{
	size_t soap_flag_ResolveMatch = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct wsdd__ResolveMatchesType*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_wsdd__ResolveMatchesType, sizeof(struct wsdd__ResolveMatchesType), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_wsdd__ResolveMatchesType(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ResolveMatch && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTowsdd__ResolveMatchType(soap, "wsdd:ResolveMatch", &a->ResolveMatch, "wsdd:ResolveMatchType"))
				{	soap_flag_ResolveMatch--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct wsdd__ResolveMatchesType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_wsdd__ResolveMatchesType, SOAP_TYPE_wsdd__ResolveMatchesType, sizeof(struct wsdd__ResolveMatchesType), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct wsdd__ResolveMatchesType * SOAP_FMAC4 soap_new_wsdd__ResolveMatchesType(struct soap *soap, int n)
{
	struct wsdd__ResolveMatchesType *p;
	struct wsdd__ResolveMatchesType *a = (struct wsdd__ResolveMatchesType*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct wsdd__ResolveMatchesType));
	for (p = a; p && n--; p++)
		soap_default_wsdd__ResolveMatchesType(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_wsdd__ResolveMatchesType(struct soap *soap, const struct wsdd__ResolveMatchesType *a, const char *tag, const char *type)
{
	if (soap_out_wsdd__ResolveMatchesType(soap, tag ? tag : "wsdd:ResolveMatchesType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct wsdd__ResolveMatchesType * SOAP_FMAC4 soap_get_wsdd__ResolveMatchesType(struct soap *soap, struct wsdd__ResolveMatchesType *p, const char *tag, const char *type)
{
	if ((p = soap_in_wsdd__ResolveMatchesType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_wsdd__ResolveType(struct soap *soap, struct wsdd__ResolveType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default__wsa__EndpointReference(soap, &a->wsa__EndpointReference);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_wsdd__ResolveType(struct soap *soap, const struct wsdd__ResolveType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize__wsa__EndpointReference(soap, &a->wsa__EndpointReference);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_wsdd__ResolveType(struct soap *soap, const char *tag, int id, const struct wsdd__ResolveType *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_wsdd__ResolveType), type))
		return soap->error;
	soap_element_result(soap, "wsa:EndpointReference");
	if (soap_out__wsa__EndpointReference(soap, "wsa:EndpointReference", -1, &a->wsa__EndpointReference, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct wsdd__ResolveType * SOAP_FMAC4 soap_in_wsdd__ResolveType(struct soap *soap, const char *tag, struct wsdd__ResolveType *a, const char *type)
{
	size_t soap_flag_wsa__EndpointReference = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct wsdd__ResolveType*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_wsdd__ResolveType, sizeof(struct wsdd__ResolveType), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_wsdd__ResolveType(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_wsa__EndpointReference && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in__wsa__EndpointReference(soap, "wsa:EndpointReference", &a->wsa__EndpointReference, ""))
				{	soap_flag_wsa__EndpointReference--;
					continue;
				}
			}
			soap_check_result(soap, "wsa:EndpointReference");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_wsa__EndpointReference > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct wsdd__ResolveType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_wsdd__ResolveType, SOAP_TYPE_wsdd__ResolveType, sizeof(struct wsdd__ResolveType), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct wsdd__ResolveType * SOAP_FMAC4 soap_new_wsdd__ResolveType(struct soap *soap, int n)
{
	struct wsdd__ResolveType *p;
	struct wsdd__ResolveType *a = (struct wsdd__ResolveType*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct wsdd__ResolveType));
	for (p = a; p && n--; p++)
		soap_default_wsdd__ResolveType(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_wsdd__ResolveType(struct soap *soap, const struct wsdd__ResolveType *a, const char *tag, const char *type)
{
	if (soap_out_wsdd__ResolveType(soap, tag ? tag : "wsdd:ResolveType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct wsdd__ResolveType * SOAP_FMAC4 soap_get_wsdd__ResolveType(struct soap *soap, struct wsdd__ResolveType *p, const char *tag, const char *type)
{
	if ((p = soap_in_wsdd__ResolveType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_wsdd__ProbeMatchType(struct soap *soap, struct wsdd__ProbeMatchType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default__wsa__EndpointReference(soap, &a->wsa__EndpointReference);
	soap_default_wsdd__QNameListType(soap, &a->Types);
	a->Scopes = NULL;
	soap_default_wsdd__UriListType(soap, &a->XAddrs);
	soap_default_unsignedInt(soap, &a->MetadataVersion);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_wsdd__ProbeMatchType(struct soap *soap, const struct wsdd__ProbeMatchType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize__wsa__EndpointReference(soap, &a->wsa__EndpointReference);
	soap_serialize_wsdd__QNameListType(soap, (char*const*)&a->Types);
	soap_serialize_PointerTowsdd__ScopesType(soap, &a->Scopes);
	soap_serialize_wsdd__UriListType(soap, (char*const*)&a->XAddrs);
	soap_embedded(soap, &a->MetadataVersion, SOAP_TYPE_unsignedInt);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_wsdd__ProbeMatchType(struct soap *soap, const char *tag, int id, const struct wsdd__ProbeMatchType *a, const char *type)
{
	const char *soap_tmp_Types;
	soap_tmp_Types = soap_QName2s(soap, a->Types);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_wsdd__ProbeMatchType), type))
		return soap->error;
	if (soap_out__wsa__EndpointReference(soap, "wsa:EndpointReference", -1, &a->wsa__EndpointReference, ""))
		return soap->error;
	if (soap_out_wsdd__QNameListType(soap, "wsdd:Types", -1, (char*const*)(void*)&soap_tmp_Types, ""))
		return soap->error;
	if (soap_out_PointerTowsdd__ScopesType(soap, "wsdd:Scopes", -1, &a->Scopes, ""))
		return soap->error;
	if (soap_out_wsdd__UriListType(soap, "wsdd:XAddrs", -1, (char*const*)&a->XAddrs, ""))
		return soap->error;
	if (soap_out_unsignedInt(soap, "wsdd:MetadataVersion", -1, &a->MetadataVersion, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct wsdd__ProbeMatchType * SOAP_FMAC4 soap_in_wsdd__ProbeMatchType(struct soap *soap, const char *tag, struct wsdd__ProbeMatchType *a, const char *type)
{
	size_t soap_flag_wsa__EndpointReference = 1;
	size_t soap_flag_Types = 1;
	size_t soap_flag_Scopes = 1;
	size_t soap_flag_XAddrs = 1;
	size_t soap_flag_MetadataVersion = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct wsdd__ProbeMatchType*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_wsdd__ProbeMatchType, sizeof(struct wsdd__ProbeMatchType), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_wsdd__ProbeMatchType(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_wsa__EndpointReference && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in__wsa__EndpointReference(soap, "wsa:EndpointReference", &a->wsa__EndpointReference, ""))
				{	soap_flag_wsa__EndpointReference--;
					continue;
				}
			}
			if (soap_flag_Types && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_wsdd__QNameListType(soap, "wsdd:Types", (char**)&a->Types, "xsd:QName"))
				{	soap_flag_Types--;
					continue;
				}
			}
			if (soap_flag_Scopes && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTowsdd__ScopesType(soap, "wsdd:Scopes", &a->Scopes, "wsdd:ScopesType"))
				{	soap_flag_Scopes--;
					continue;
				}
			}
			if (soap_flag_XAddrs && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_wsdd__UriListType(soap, "wsdd:XAddrs", (char**)&a->XAddrs, "wsdd:UriListType"))
				{	soap_flag_XAddrs--;
					continue;
				}
			}
			if (soap_flag_MetadataVersion && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_unsignedInt(soap, "wsdd:MetadataVersion", &a->MetadataVersion, "xsd:unsignedInt"))
				{	soap_flag_MetadataVersion--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_wsa__EndpointReference > 0 || soap_flag_MetadataVersion > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct wsdd__ProbeMatchType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_wsdd__ProbeMatchType, SOAP_TYPE_wsdd__ProbeMatchType, sizeof(struct wsdd__ProbeMatchType), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct wsdd__ProbeMatchType * SOAP_FMAC4 soap_new_wsdd__ProbeMatchType(struct soap *soap, int n)
{
	struct wsdd__ProbeMatchType *p;
	struct wsdd__ProbeMatchType *a = (struct wsdd__ProbeMatchType*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct wsdd__ProbeMatchType));
	for (p = a; p && n--; p++)
		soap_default_wsdd__ProbeMatchType(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_wsdd__ProbeMatchType(struct soap *soap, const struct wsdd__ProbeMatchType *a, const char *tag, const char *type)
{
	if (soap_out_wsdd__ProbeMatchType(soap, tag ? tag : "wsdd:ProbeMatchType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct wsdd__ProbeMatchType * SOAP_FMAC4 soap_get_wsdd__ProbeMatchType(struct soap *soap, struct wsdd__ProbeMatchType *p, const char *tag, const char *type)
{
	if ((p = soap_in_wsdd__ProbeMatchType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_wsdd__ProbeMatchesType(struct soap *soap, struct wsdd__ProbeMatchesType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__sizeProbeMatch = 0;
	a->ProbeMatch = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_wsdd__ProbeMatchesType(struct soap *soap, const struct wsdd__ProbeMatchesType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (a->ProbeMatch)
	{	int i;
		for (i = 0; i < (int)a->__sizeProbeMatch; i++)
		{
			soap_embedded(soap, a->ProbeMatch + i, SOAP_TYPE_wsdd__ProbeMatchType);
			soap_serialize_wsdd__ProbeMatchType(soap, a->ProbeMatch + i);
		}
	}
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_wsdd__ProbeMatchesType(struct soap *soap, const char *tag, int id, const struct wsdd__ProbeMatchesType *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_wsdd__ProbeMatchesType), type))
		return soap->error;
	soap_element_result(soap, "-sizeProbeMatch");
	if (a->ProbeMatch)
	{	int i;
		for (i = 0; i < (int)a->__sizeProbeMatch; i++)
			if (soap_out_wsdd__ProbeMatchType(soap, "wsdd:ProbeMatch", -1, a->ProbeMatch + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct wsdd__ProbeMatchesType * SOAP_FMAC4 soap_in_wsdd__ProbeMatchesType(struct soap *soap, const char *tag, struct wsdd__ProbeMatchesType *a, const char *type)
{
	struct soap_blist *soap_blist_ProbeMatch = NULL;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct wsdd__ProbeMatchesType*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_wsdd__ProbeMatchesType, sizeof(struct wsdd__ProbeMatchesType), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_wsdd__ProbeMatchesType(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "wsdd:ProbeMatch", 1, NULL))
			{	if (a->ProbeMatch == NULL)
				{	if (soap_blist_ProbeMatch == NULL)
						soap_blist_ProbeMatch = soap_alloc_block(soap);
					a->ProbeMatch = (struct wsdd__ProbeMatchType *)soap_push_block_max(soap, soap_blist_ProbeMatch, sizeof(struct wsdd__ProbeMatchType));
					if (a->ProbeMatch == NULL)
						return NULL;
					soap_default_wsdd__ProbeMatchType(soap, a->ProbeMatch);
				}
				soap_revert(soap);
				if (soap_in_wsdd__ProbeMatchType(soap, "wsdd:ProbeMatch", a->ProbeMatch, "wsdd:ProbeMatchType"))
				{	a->__sizeProbeMatch++;
					a->ProbeMatch = NULL;
					continue;
				}
			}
			soap_check_result(soap, "-sizeProbeMatch");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->ProbeMatch)
			soap_pop_block(soap, soap_blist_ProbeMatch);
		if (a->__sizeProbeMatch)
		{	a->ProbeMatch = (struct wsdd__ProbeMatchType *)soap_save_block(soap, soap_blist_ProbeMatch, NULL, 1);
		}
		else
		{	a->ProbeMatch = NULL;
			if (soap_blist_ProbeMatch)
				soap_end_block(soap, soap_blist_ProbeMatch);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct wsdd__ProbeMatchesType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_wsdd__ProbeMatchesType, SOAP_TYPE_wsdd__ProbeMatchesType, sizeof(struct wsdd__ProbeMatchesType), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct wsdd__ProbeMatchesType * SOAP_FMAC4 soap_new_wsdd__ProbeMatchesType(struct soap *soap, int n)
{
	struct wsdd__ProbeMatchesType *p;
	struct wsdd__ProbeMatchesType *a = (struct wsdd__ProbeMatchesType*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct wsdd__ProbeMatchesType));
	for (p = a; p && n--; p++)
		soap_default_wsdd__ProbeMatchesType(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_wsdd__ProbeMatchesType(struct soap *soap, const struct wsdd__ProbeMatchesType *a, const char *tag, const char *type)
{
	if (soap_out_wsdd__ProbeMatchesType(soap, tag ? tag : "wsdd:ProbeMatchesType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct wsdd__ProbeMatchesType * SOAP_FMAC4 soap_get_wsdd__ProbeMatchesType(struct soap *soap, struct wsdd__ProbeMatchesType *p, const char *tag, const char *type)
{
	if ((p = soap_in_wsdd__ProbeMatchesType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_wsdd__ProbeType(struct soap *soap, struct wsdd__ProbeType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_wsdd__QNameListType(soap, &a->Types);
	a->Scopes = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_wsdd__ProbeType(struct soap *soap, const struct wsdd__ProbeType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_wsdd__QNameListType(soap, (char*const*)&a->Types);
	soap_serialize_PointerTowsdd__ScopesType(soap, &a->Scopes);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_wsdd__ProbeType(struct soap *soap, const char *tag, int id, const struct wsdd__ProbeType *a, const char *type)
{
	const char *soap_tmp_Types;
	soap_tmp_Types = soap_QName2s(soap, a->Types);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_wsdd__ProbeType), type))
		return soap->error;
	if (soap_out_wsdd__QNameListType(soap, "wsdd:Types", -1, (char*const*)(void*)&soap_tmp_Types, ""))
		return soap->error;
	if (soap_out_PointerTowsdd__ScopesType(soap, "wsdd:Scopes", -1, &a->Scopes, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct wsdd__ProbeType * SOAP_FMAC4 soap_in_wsdd__ProbeType(struct soap *soap, const char *tag, struct wsdd__ProbeType *a, const char *type)
{
	size_t soap_flag_Types = 1;
	size_t soap_flag_Scopes = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct wsdd__ProbeType*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_wsdd__ProbeType, sizeof(struct wsdd__ProbeType), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_wsdd__ProbeType(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Types && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_wsdd__QNameListType(soap, "wsdd:Types", (char**)&a->Types, "xsd:QName"))
				{	soap_flag_Types--;
					continue;
				}
			}
			if (soap_flag_Scopes && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTowsdd__ScopesType(soap, "wsdd:Scopes", &a->Scopes, "wsdd:ScopesType"))
				{	soap_flag_Scopes--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct wsdd__ProbeType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_wsdd__ProbeType, SOAP_TYPE_wsdd__ProbeType, sizeof(struct wsdd__ProbeType), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct wsdd__ProbeType * SOAP_FMAC4 soap_new_wsdd__ProbeType(struct soap *soap, int n)
{
	struct wsdd__ProbeType *p;
	struct wsdd__ProbeType *a = (struct wsdd__ProbeType*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct wsdd__ProbeType));
	for (p = a; p && n--; p++)
		soap_default_wsdd__ProbeType(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_wsdd__ProbeType(struct soap *soap, const struct wsdd__ProbeType *a, const char *tag, const char *type)
{
	if (soap_out_wsdd__ProbeType(soap, tag ? tag : "wsdd:ProbeType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct wsdd__ProbeType * SOAP_FMAC4 soap_get_wsdd__ProbeType(struct soap *soap, struct wsdd__ProbeType *p, const char *tag, const char *type)
{
	if ((p = soap_in_wsdd__ProbeType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_wsdd__ByeType(struct soap *soap, struct wsdd__ByeType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default__wsa__EndpointReference(soap, &a->wsa__EndpointReference);
	soap_default_wsdd__QNameListType(soap, &a->Types);
	a->Scopes = NULL;
	soap_default_wsdd__UriListType(soap, &a->XAddrs);
	a->MetadataVersion = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_wsdd__ByeType(struct soap *soap, const struct wsdd__ByeType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize__wsa__EndpointReference(soap, &a->wsa__EndpointReference);
	soap_serialize_wsdd__QNameListType(soap, (char*const*)&a->Types);
	soap_serialize_PointerTowsdd__ScopesType(soap, &a->Scopes);
	soap_serialize_wsdd__UriListType(soap, (char*const*)&a->XAddrs);
	soap_serialize_PointerTounsignedInt(soap, &a->MetadataVersion);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_wsdd__ByeType(struct soap *soap, const char *tag, int id, const struct wsdd__ByeType *a, const char *type)
{
	const char *soap_tmp_Types;
	soap_tmp_Types = soap_QName2s(soap, a->Types);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_wsdd__ByeType), type))
		return soap->error;
	if (soap_out__wsa__EndpointReference(soap, "wsa:EndpointReference", -1, &a->wsa__EndpointReference, ""))
		return soap->error;
	if (soap_out_wsdd__QNameListType(soap, "wsdd:Types", -1, (char*const*)(void*)&soap_tmp_Types, ""))
		return soap->error;
	if (soap_out_PointerTowsdd__ScopesType(soap, "wsdd:Scopes", -1, &a->Scopes, ""))
		return soap->error;
	if (soap_out_wsdd__UriListType(soap, "wsdd:XAddrs", -1, (char*const*)&a->XAddrs, ""))
		return soap->error;
	if (soap_out_PointerTounsignedInt(soap, "wsdd:MetadataVersion", -1, &a->MetadataVersion, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct wsdd__ByeType * SOAP_FMAC4 soap_in_wsdd__ByeType(struct soap *soap, const char *tag, struct wsdd__ByeType *a, const char *type)
{
	size_t soap_flag_wsa__EndpointReference = 1;
	size_t soap_flag_Types = 1;
	size_t soap_flag_Scopes = 1;
	size_t soap_flag_XAddrs = 1;
	size_t soap_flag_MetadataVersion = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct wsdd__ByeType*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_wsdd__ByeType, sizeof(struct wsdd__ByeType), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_wsdd__ByeType(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_wsa__EndpointReference && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in__wsa__EndpointReference(soap, "wsa:EndpointReference", &a->wsa__EndpointReference, ""))
				{	soap_flag_wsa__EndpointReference--;
					continue;
				}
			}
			if (soap_flag_Types && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_wsdd__QNameListType(soap, "wsdd:Types", (char**)&a->Types, "xsd:QName"))
				{	soap_flag_Types--;
					continue;
				}
			}
			if (soap_flag_Scopes && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTowsdd__ScopesType(soap, "wsdd:Scopes", &a->Scopes, "wsdd:ScopesType"))
				{	soap_flag_Scopes--;
					continue;
				}
			}
			if (soap_flag_XAddrs && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_wsdd__UriListType(soap, "wsdd:XAddrs", (char**)&a->XAddrs, "wsdd:UriListType"))
				{	soap_flag_XAddrs--;
					continue;
				}
			}
			if (soap_flag_MetadataVersion && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTounsignedInt(soap, "wsdd:MetadataVersion", &a->MetadataVersion, "xsd:unsignedInt"))
				{	soap_flag_MetadataVersion--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_wsa__EndpointReference > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct wsdd__ByeType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_wsdd__ByeType, SOAP_TYPE_wsdd__ByeType, sizeof(struct wsdd__ByeType), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct wsdd__ByeType * SOAP_FMAC4 soap_new_wsdd__ByeType(struct soap *soap, int n)
{
	struct wsdd__ByeType *p;
	struct wsdd__ByeType *a = (struct wsdd__ByeType*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct wsdd__ByeType));
	for (p = a; p && n--; p++)
		soap_default_wsdd__ByeType(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_wsdd__ByeType(struct soap *soap, const struct wsdd__ByeType *a, const char *tag, const char *type)
{
	if (soap_out_wsdd__ByeType(soap, tag ? tag : "wsdd:ByeType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct wsdd__ByeType * SOAP_FMAC4 soap_get_wsdd__ByeType(struct soap *soap, struct wsdd__ByeType *p, const char *tag, const char *type)
{
	if ((p = soap_in_wsdd__ByeType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_wsdd__HelloType(struct soap *soap, struct wsdd__HelloType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default__wsa__EndpointReference(soap, &a->wsa__EndpointReference);
	soap_default_wsdd__QNameListType(soap, &a->Types);
	a->Scopes = NULL;
	soap_default_wsdd__UriListType(soap, &a->XAddrs);
	soap_default_unsignedInt(soap, &a->MetadataVersion);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_wsdd__HelloType(struct soap *soap, const struct wsdd__HelloType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize__wsa__EndpointReference(soap, &a->wsa__EndpointReference);
	soap_serialize_wsdd__QNameListType(soap, (char*const*)&a->Types);
	soap_serialize_PointerTowsdd__ScopesType(soap, &a->Scopes);
	soap_serialize_wsdd__UriListType(soap, (char*const*)&a->XAddrs);
	soap_embedded(soap, &a->MetadataVersion, SOAP_TYPE_unsignedInt);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_wsdd__HelloType(struct soap *soap, const char *tag, int id, const struct wsdd__HelloType *a, const char *type)
{
	const char *soap_tmp_Types;
	soap_tmp_Types = soap_QName2s(soap, a->Types);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_wsdd__HelloType), type))
		return soap->error;
	if (soap_out__wsa__EndpointReference(soap, "wsa:EndpointReference", -1, &a->wsa__EndpointReference, ""))
		return soap->error;
	if (soap_out_wsdd__QNameListType(soap, "wsdd:Types", -1, (char*const*)(void*)&soap_tmp_Types, ""))
		return soap->error;
	if (soap_out_PointerTowsdd__ScopesType(soap, "wsdd:Scopes", -1, &a->Scopes, ""))
		return soap->error;
	if (soap_out_wsdd__UriListType(soap, "wsdd:XAddrs", -1, (char*const*)&a->XAddrs, ""))
		return soap->error;
	if (soap_out_unsignedInt(soap, "wsdd:MetadataVersion", -1, &a->MetadataVersion, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct wsdd__HelloType * SOAP_FMAC4 soap_in_wsdd__HelloType(struct soap *soap, const char *tag, struct wsdd__HelloType *a, const char *type)
{
	size_t soap_flag_wsa__EndpointReference = 1;
	size_t soap_flag_Types = 1;
	size_t soap_flag_Scopes = 1;
	size_t soap_flag_XAddrs = 1;
	size_t soap_flag_MetadataVersion = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct wsdd__HelloType*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_wsdd__HelloType, sizeof(struct wsdd__HelloType), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_wsdd__HelloType(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_wsa__EndpointReference && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in__wsa__EndpointReference(soap, "wsa:EndpointReference", &a->wsa__EndpointReference, ""))
				{	soap_flag_wsa__EndpointReference--;
					continue;
				}
			}
			if (soap_flag_Types && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_wsdd__QNameListType(soap, "wsdd:Types", (char**)&a->Types, "xsd:QName"))
				{	soap_flag_Types--;
					continue;
				}
			}
			if (soap_flag_Scopes && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTowsdd__ScopesType(soap, "wsdd:Scopes", &a->Scopes, "wsdd:ScopesType"))
				{	soap_flag_Scopes--;
					continue;
				}
			}
			if (soap_flag_XAddrs && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_wsdd__UriListType(soap, "wsdd:XAddrs", (char**)&a->XAddrs, "wsdd:UriListType"))
				{	soap_flag_XAddrs--;
					continue;
				}
			}
			if (soap_flag_MetadataVersion && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_unsignedInt(soap, "wsdd:MetadataVersion", &a->MetadataVersion, "xsd:unsignedInt"))
				{	soap_flag_MetadataVersion--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_wsa__EndpointReference > 0 || soap_flag_MetadataVersion > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct wsdd__HelloType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_wsdd__HelloType, SOAP_TYPE_wsdd__HelloType, sizeof(struct wsdd__HelloType), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct wsdd__HelloType * SOAP_FMAC4 soap_new_wsdd__HelloType(struct soap *soap, int n)
{
	struct wsdd__HelloType *p;
	struct wsdd__HelloType *a = (struct wsdd__HelloType*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct wsdd__HelloType));
	for (p = a; p && n--; p++)
		soap_default_wsdd__HelloType(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_wsdd__HelloType(struct soap *soap, const struct wsdd__HelloType *a, const char *tag, const char *type)
{
	if (soap_out_wsdd__HelloType(soap, tag ? tag : "wsdd:HelloType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct wsdd__HelloType * SOAP_FMAC4 soap_get_wsdd__HelloType(struct soap *soap, struct wsdd__HelloType *p, const char *tag, const char *type)
{
	if ((p = soap_in_wsdd__HelloType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_default_SOAP_ENV__Fault(struct soap *soap, struct SOAP_ENV__Fault *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default__QName(soap, &a->faultcode);
	soap_default_string(soap, &a->faultstring);
	soap_default_string(soap, &a->faultactor);
	a->detail = NULL;
	a->SOAP_ENV__Code = NULL;
	a->SOAP_ENV__Reason = NULL;
	soap_default_string(soap, &a->SOAP_ENV__Node);
	soap_default_string(soap, &a->SOAP_ENV__Role);
	a->SOAP_ENV__Detail = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_SOAP_ENV__Fault(struct soap *soap, const struct SOAP_ENV__Fault *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize__QName(soap, (char*const*)&a->faultcode);
	soap_serialize_string(soap, (char*const*)&a->faultstring);
	soap_serialize_string(soap, (char*const*)&a->faultactor);
	soap_serialize_PointerToSOAP_ENV__Detail(soap, &a->detail);
	soap_serialize_PointerToSOAP_ENV__Code(soap, &a->SOAP_ENV__Code);
	soap_serialize_PointerToSOAP_ENV__Reason(soap, &a->SOAP_ENV__Reason);
	soap_serialize_string(soap, (char*const*)&a->SOAP_ENV__Node);
	soap_serialize_string(soap, (char*const*)&a->SOAP_ENV__Role);
	soap_serialize_PointerToSOAP_ENV__Detail(soap, &a->SOAP_ENV__Detail);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_SOAP_ENV__Fault(struct soap *soap, const char *tag, int id, const struct SOAP_ENV__Fault *a, const char *type)
{
	const char *soap_tmp_faultcode;
	soap_tmp_faultcode = soap_QName2s(soap, a->faultcode);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_SOAP_ENV__Fault), type))
		return soap->error;
	if (soap_out__QName(soap, "faultcode", -1, (char*const*)(void*)&soap_tmp_faultcode, ""))
		return soap->error;
	if (soap_out_string(soap, "faultstring", -1, (char*const*)&a->faultstring, ""))
		return soap->error;
	if (soap_out_string(soap, "faultactor", -1, (char*const*)&a->faultactor, ""))
		return soap->error;
	if (soap_out_PointerToSOAP_ENV__Detail(soap, "detail", -1, &a->detail, ""))
		return soap->error;
	if (soap_out_PointerToSOAP_ENV__Code(soap, "SOAP-ENV:Code", -1, &a->SOAP_ENV__Code, ""))
		return soap->error;
	if (soap_out_PointerToSOAP_ENV__Reason(soap, "SOAP-ENV:Reason", -1, &a->SOAP_ENV__Reason, ""))
		return soap->error;
	if (soap_out_string(soap, "SOAP-ENV:Node", -1, (char*const*)&a->SOAP_ENV__Node, ""))
		return soap->error;
	if (soap_out_string(soap, "SOAP-ENV:Role", -1, (char*const*)&a->SOAP_ENV__Role, ""))
		return soap->error;
	if (soap_out_PointerToSOAP_ENV__Detail(soap, "SOAP-ENV:Detail", -1, &a->SOAP_ENV__Detail, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct SOAP_ENV__Fault * SOAP_FMAC4 soap_in_SOAP_ENV__Fault(struct soap *soap, const char *tag, struct SOAP_ENV__Fault *a, const char *type)
{
	size_t soap_flag_faultcode = 1;
	size_t soap_flag_faultstring = 1;
	size_t soap_flag_faultactor = 1;
	size_t soap_flag_detail = 1;
	size_t soap_flag_SOAP_ENV__Code = 1;
	size_t soap_flag_SOAP_ENV__Reason = 1;
	size_t soap_flag_SOAP_ENV__Node = 1;
	size_t soap_flag_SOAP_ENV__Role = 1;
	size_t soap_flag_SOAP_ENV__Detail = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct SOAP_ENV__Fault*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_SOAP_ENV__Fault, sizeof(struct SOAP_ENV__Fault), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_SOAP_ENV__Fault(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_faultcode && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in__QName(soap, "faultcode", (char**)&a->faultcode, "xsd:QName"))
				{	soap_flag_faultcode--;
					continue;
				}
			}
			if (soap_flag_faultstring && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_string(soap, "faultstring", (char**)&a->faultstring, "xsd:string"))
				{	soap_flag_faultstring--;
					continue;
				}
			}
			if (soap_flag_faultactor && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_string(soap, "faultactor", (char**)&a->faultactor, "xsd:string"))
				{	soap_flag_faultactor--;
					continue;
				}
			}
			if (soap_flag_detail && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerToSOAP_ENV__Detail(soap, "detail", &a->detail, ""))
				{	soap_flag_detail--;
					continue;
				}
			}
			if (soap_flag_SOAP_ENV__Code && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerToSOAP_ENV__Code(soap, "SOAP-ENV:Code", &a->SOAP_ENV__Code, ""))
				{	soap_flag_SOAP_ENV__Code--;
					continue;
				}
			}
			if (soap_flag_SOAP_ENV__Reason && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerToSOAP_ENV__Reason(soap, "SOAP-ENV:Reason", &a->SOAP_ENV__Reason, ""))
				{	soap_flag_SOAP_ENV__Reason--;
					continue;
				}
			}
			if (soap_flag_SOAP_ENV__Node && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_string(soap, "SOAP-ENV:Node", (char**)&a->SOAP_ENV__Node, "xsd:string"))
				{	soap_flag_SOAP_ENV__Node--;
					continue;
				}
			}
			if (soap_flag_SOAP_ENV__Role && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_string(soap, "SOAP-ENV:Role", (char**)&a->SOAP_ENV__Role, "xsd:string"))
				{	soap_flag_SOAP_ENV__Role--;
					continue;
				}
			}
			if (soap_flag_SOAP_ENV__Detail && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerToSOAP_ENV__Detail(soap, "SOAP-ENV:Detail", &a->SOAP_ENV__Detail, ""))
				{	soap_flag_SOAP_ENV__Detail--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Fault *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_SOAP_ENV__Fault, SOAP_TYPE_SOAP_ENV__Fault, sizeof(struct SOAP_ENV__Fault), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct SOAP_ENV__Fault * SOAP_FMAC4 soap_new_SOAP_ENV__Fault(struct soap *soap, int n)
{
	struct SOAP_ENV__Fault *p;
	struct SOAP_ENV__Fault *a = (struct SOAP_ENV__Fault*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct SOAP_ENV__Fault));
	for (p = a; p && n--; p++)
		soap_default_SOAP_ENV__Fault(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_SOAP_ENV__Fault(struct soap *soap, const struct SOAP_ENV__Fault *a, const char *tag, const char *type)
{
	if (soap_out_SOAP_ENV__Fault(soap, tag ? tag : "SOAP-ENV:Fault", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Fault * SOAP_FMAC4 soap_get_SOAP_ENV__Fault(struct soap *soap, struct SOAP_ENV__Fault *p, const char *tag, const char *type)
{
	if ((p = soap_in_SOAP_ENV__Fault(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_default_SOAP_ENV__Reason(struct soap *soap, struct SOAP_ENV__Reason *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->SOAP_ENV__Text);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_SOAP_ENV__Reason(struct soap *soap, const struct SOAP_ENV__Reason *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_string(soap, (char*const*)&a->SOAP_ENV__Text);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_SOAP_ENV__Reason(struct soap *soap, const char *tag, int id, const struct SOAP_ENV__Reason *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_SOAP_ENV__Reason), type))
		return soap->error;
	if (soap->lang)
		soap_set_attr(soap, "xml:lang", soap->lang, 1);
	if (soap_out_string(soap, "SOAP-ENV:Text", -1, (char*const*)&a->SOAP_ENV__Text, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct SOAP_ENV__Reason * SOAP_FMAC4 soap_in_SOAP_ENV__Reason(struct soap *soap, const char *tag, struct SOAP_ENV__Reason *a, const char *type)
{
	size_t soap_flag_SOAP_ENV__Text = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct SOAP_ENV__Reason*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_SOAP_ENV__Reason, sizeof(struct SOAP_ENV__Reason), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_SOAP_ENV__Reason(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_SOAP_ENV__Text && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_string(soap, "SOAP-ENV:Text", (char**)&a->SOAP_ENV__Text, "xsd:string"))
				{	soap_flag_SOAP_ENV__Text--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Reason *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_SOAP_ENV__Reason, SOAP_TYPE_SOAP_ENV__Reason, sizeof(struct SOAP_ENV__Reason), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct SOAP_ENV__Reason * SOAP_FMAC4 soap_new_SOAP_ENV__Reason(struct soap *soap, int n)
{
	struct SOAP_ENV__Reason *p;
	struct SOAP_ENV__Reason *a = (struct SOAP_ENV__Reason*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct SOAP_ENV__Reason));
	for (p = a; p && n--; p++)
		soap_default_SOAP_ENV__Reason(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_SOAP_ENV__Reason(struct soap *soap, const struct SOAP_ENV__Reason *a, const char *tag, const char *type)
{
	if (soap_out_SOAP_ENV__Reason(soap, tag ? tag : "SOAP-ENV:Reason", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Reason * SOAP_FMAC4 soap_get_SOAP_ENV__Reason(struct soap *soap, struct SOAP_ENV__Reason *p, const char *tag, const char *type)
{
	if ((p = soap_in_SOAP_ENV__Reason(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_default_SOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default__QName(soap, &a->SOAP_ENV__Value);
	a->SOAP_ENV__Subcode = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_SOAP_ENV__Code(struct soap *soap, const struct SOAP_ENV__Code *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize__QName(soap, (char*const*)&a->SOAP_ENV__Value);
	soap_serialize_PointerToSOAP_ENV__Code(soap, &a->SOAP_ENV__Subcode);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_SOAP_ENV__Code(struct soap *soap, const char *tag, int id, const struct SOAP_ENV__Code *a, const char *type)
{
	const char *soap_tmp_SOAP_ENV__Value;
	soap_tmp_SOAP_ENV__Value = soap_QName2s(soap, a->SOAP_ENV__Value);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_SOAP_ENV__Code), type))
		return soap->error;
	if (soap_out__QName(soap, "SOAP-ENV:Value", -1, (char*const*)(void*)&soap_tmp_SOAP_ENV__Value, ""))
		return soap->error;
	if (soap_out_PointerToSOAP_ENV__Code(soap, "SOAP-ENV:Subcode", -1, &a->SOAP_ENV__Subcode, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct SOAP_ENV__Code * SOAP_FMAC4 soap_in_SOAP_ENV__Code(struct soap *soap, const char *tag, struct SOAP_ENV__Code *a, const char *type)
{
	size_t soap_flag_SOAP_ENV__Value = 1;
	size_t soap_flag_SOAP_ENV__Subcode = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct SOAP_ENV__Code*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_SOAP_ENV__Code, sizeof(struct SOAP_ENV__Code), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_SOAP_ENV__Code(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_SOAP_ENV__Value && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in__QName(soap, "SOAP-ENV:Value", (char**)&a->SOAP_ENV__Value, "xsd:QName"))
				{	soap_flag_SOAP_ENV__Value--;
					continue;
				}
			}
			if (soap_flag_SOAP_ENV__Subcode && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerToSOAP_ENV__Code(soap, "SOAP-ENV:Subcode", &a->SOAP_ENV__Subcode, ""))
				{	soap_flag_SOAP_ENV__Subcode--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Code *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_SOAP_ENV__Code, SOAP_TYPE_SOAP_ENV__Code, sizeof(struct SOAP_ENV__Code), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct SOAP_ENV__Code * SOAP_FMAC4 soap_new_SOAP_ENV__Code(struct soap *soap, int n)
{
	struct SOAP_ENV__Code *p;
	struct SOAP_ENV__Code *a = (struct SOAP_ENV__Code*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct SOAP_ENV__Code));
	for (p = a; p && n--; p++)
		soap_default_SOAP_ENV__Code(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_SOAP_ENV__Code(struct soap *soap, const struct SOAP_ENV__Code *a, const char *tag, const char *type)
{
	if (soap_out_SOAP_ENV__Code(soap, tag ? tag : "SOAP-ENV:Code", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Code * SOAP_FMAC4 soap_get_SOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code *p, const char *tag, const char *type)
{
	if ((p = soap_in_SOAP_ENV__Code(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_default_SOAP_ENV__Detail(struct soap *soap, struct SOAP_ENV__Detail *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__any = NULL;
	a->__type = 0;
	a->fault = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_SOAP_ENV__Detail(struct soap *soap, const struct SOAP_ENV__Detail *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_markelement(soap, a->fault, a->__type);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_SOAP_ENV__Detail(struct soap *soap, const char *tag, int id, const struct SOAP_ENV__Detail *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_SOAP_ENV__Detail), type))
		return soap->error;
	if (soap_outliteral(soap, "-any", (char*const*)&a->__any, NULL))
		return soap->error;
	if (soap_putelement(soap, a->fault, "fault", -1, a->__type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct SOAP_ENV__Detail * SOAP_FMAC4 soap_in_SOAP_ENV__Detail(struct soap *soap, const char *tag, struct SOAP_ENV__Detail *a, const char *type)
{
	size_t soap_flag___any = 1;
	size_t soap_flag_fault = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct SOAP_ENV__Detail*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_SOAP_ENV__Detail, sizeof(struct SOAP_ENV__Detail), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_SOAP_ENV__Detail(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_fault && soap->error == SOAP_TAG_MISMATCH)
			{	if ((a->fault = soap_getelement(soap, "fault", &a->__type)))
				{	soap_flag_fault = 0;
					continue;
				}
			}
			if (soap_flag___any && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_inliteral(soap, "-any", (char**)&a->__any))
				{	soap_flag___any--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Detail *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_SOAP_ENV__Detail, SOAP_TYPE_SOAP_ENV__Detail, sizeof(struct SOAP_ENV__Detail), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct SOAP_ENV__Detail * SOAP_FMAC4 soap_new_SOAP_ENV__Detail(struct soap *soap, int n)
{
	struct SOAP_ENV__Detail *p;
	struct SOAP_ENV__Detail *a = (struct SOAP_ENV__Detail*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct SOAP_ENV__Detail));
	for (p = a; p && n--; p++)
		soap_default_SOAP_ENV__Detail(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_SOAP_ENV__Detail(struct soap *soap, const struct SOAP_ENV__Detail *a, const char *tag, const char *type)
{
	if (soap_out_SOAP_ENV__Detail(soap, tag ? tag : "SOAP-ENV:Detail", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Detail * SOAP_FMAC4 soap_get_SOAP_ENV__Detail(struct soap *soap, struct SOAP_ENV__Detail *p, const char *tag, const char *type)
{
	if ((p = soap_in_SOAP_ENV__Detail(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_default_SOAP_ENV__Header(struct soap *soap, struct SOAP_ENV__Header *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default__wsa__MessageID(soap, &a->wsa__MessageID);
	a->wsa__RelatesTo = NULL;
	a->wsa__From = NULL;
	a->wsa__ReplyTo = NULL;
	a->wsa__FaultTo = NULL;
	soap_default__wsa__To(soap, &a->wsa__To);
	soap_default__wsa__Action(soap, &a->wsa__Action);
	a->wsdd__AppSequence = NULL;
	soap_default__wsa5__MessageID(soap, &a->wsa5__MessageID);
	a->wsa5__RelatesTo = NULL;
	a->wsa5__From = NULL;
	a->wsa5__ReplyTo = NULL;
	a->wsa5__FaultTo = NULL;
	soap_default__wsa5__To(soap, &a->wsa5__To);
	soap_default__wsa5__Action(soap, &a->wsa5__Action);
	a->chan__ChannelInstance = NULL;
	a->wsse__Security = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_SOAP_ENV__Header(struct soap *soap, const struct SOAP_ENV__Header *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize__wsa__MessageID(soap, (char*const*)&a->wsa__MessageID);
	soap_serialize_PointerTo_wsa__RelatesTo(soap, &a->wsa__RelatesTo);
	soap_serialize_PointerTo_wsa__From(soap, &a->wsa__From);
	soap_serialize_PointerTo_wsa__ReplyTo(soap, &a->wsa__ReplyTo);
	soap_serialize_PointerTo_wsa__FaultTo(soap, &a->wsa__FaultTo);
	soap_serialize__wsa__To(soap, (char*const*)&a->wsa__To);
	soap_serialize__wsa__Action(soap, (char*const*)&a->wsa__Action);
	soap_serialize_PointerTowsdd__AppSequenceType(soap, &a->wsdd__AppSequence);
	soap_serialize__wsa5__MessageID(soap, (char*const*)&a->wsa5__MessageID);
	soap_serialize_PointerTo_wsa5__RelatesTo(soap, &a->wsa5__RelatesTo);
	soap_serialize_PointerTo_wsa5__From(soap, &a->wsa5__From);
	soap_serialize_PointerTo_wsa5__ReplyTo(soap, &a->wsa5__ReplyTo);
	soap_serialize_PointerTo_wsa5__FaultTo(soap, &a->wsa5__FaultTo);
	soap_serialize__wsa5__To(soap, (char*const*)&a->wsa5__To);
	soap_serialize__wsa5__Action(soap, (char*const*)&a->wsa5__Action);
	soap_serialize_PointerTochan__ChannelInstanceType(soap, &a->chan__ChannelInstance);
	soap_serialize_PointerTo_wsse__Security(soap, &a->wsse__Security);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_SOAP_ENV__Header(struct soap *soap, const char *tag, int id, const struct SOAP_ENV__Header *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_SOAP_ENV__Header), type))
		return soap->error;
	if (soap_out__wsa__MessageID(soap, "wsa:MessageID", -1, (char*const*)&a->wsa__MessageID, ""))
		return soap->error;
	if (soap_out_PointerTo_wsa__RelatesTo(soap, "wsa:RelatesTo", -1, &a->wsa__RelatesTo, ""))
		return soap->error;
	if (soap_out_PointerTo_wsa__From(soap, "wsa:From", -1, &a->wsa__From, ""))
		return soap->error;
	soap->mustUnderstand = 1;
	if (soap_out_PointerTo_wsa__ReplyTo(soap, "wsa:ReplyTo", -1, &a->wsa__ReplyTo, ""))
		return soap->error;
	soap->mustUnderstand = 1;
	if (soap_out_PointerTo_wsa__FaultTo(soap, "wsa:FaultTo", -1, &a->wsa__FaultTo, ""))
		return soap->error;
	soap->mustUnderstand = 1;
	if (soap_out__wsa__To(soap, "wsa:To", -1, (char*const*)&a->wsa__To, ""))
		return soap->error;
	soap->mustUnderstand = 1;
	if (soap_out__wsa__Action(soap, "wsa:Action", -1, (char*const*)&a->wsa__Action, ""))
		return soap->error;
	if (soap_out_PointerTowsdd__AppSequenceType(soap, "wsdd:AppSequence", -1, &a->wsdd__AppSequence, ""))
		return soap->error;
	if (soap_out__wsa5__MessageID(soap, "wsa5:MessageID", -1, (char*const*)&a->wsa5__MessageID, ""))
		return soap->error;
	if (soap_out_PointerTo_wsa5__RelatesTo(soap, "wsa5:RelatesTo", -1, &a->wsa5__RelatesTo, ""))
		return soap->error;
	if (soap_out_PointerTo_wsa5__From(soap, "wsa5:From", -1, &a->wsa5__From, ""))
		return soap->error;
	soap->mustUnderstand = 1;
	if (soap_out_PointerTo_wsa5__ReplyTo(soap, "wsa5:ReplyTo", -1, &a->wsa5__ReplyTo, ""))
		return soap->error;
	soap->mustUnderstand = 1;
	if (soap_out_PointerTo_wsa5__FaultTo(soap, "wsa5:FaultTo", -1, &a->wsa5__FaultTo, ""))
		return soap->error;
	soap->mustUnderstand = 1;
	if (soap_out__wsa5__To(soap, "wsa5:To", -1, (char*const*)&a->wsa5__To, ""))
		return soap->error;
	soap->mustUnderstand = 1;
	if (soap_out__wsa5__Action(soap, "wsa5:Action", -1, (char*const*)&a->wsa5__Action, ""))
		return soap->error;
	if (soap_out_PointerTochan__ChannelInstanceType(soap, "chan:ChannelInstance", -1, &a->chan__ChannelInstance, ""))
		return soap->error;
	soap->mustUnderstand = 1;
	if (soap_out_PointerTo_wsse__Security(soap, "wsse:Security", -1, &a->wsse__Security, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct SOAP_ENV__Header * SOAP_FMAC4 soap_in_SOAP_ENV__Header(struct soap *soap, const char *tag, struct SOAP_ENV__Header *a, const char *type)
{
	size_t soap_flag_wsa__MessageID = 1;
	size_t soap_flag_wsa__RelatesTo = 1;
	size_t soap_flag_wsa__From = 1;
	size_t soap_flag_wsa__ReplyTo = 1;
	size_t soap_flag_wsa__FaultTo = 1;
	size_t soap_flag_wsa__To = 1;
	size_t soap_flag_wsa__Action = 1;
	size_t soap_flag_wsdd__AppSequence = 1;
	size_t soap_flag_wsa5__MessageID = 1;
	size_t soap_flag_wsa5__RelatesTo = 1;
	size_t soap_flag_wsa5__From = 1;
	size_t soap_flag_wsa5__ReplyTo = 1;
	size_t soap_flag_wsa5__FaultTo = 1;
	size_t soap_flag_wsa5__To = 1;
	size_t soap_flag_wsa5__Action = 1;
	size_t soap_flag_chan__ChannelInstance = 1;
	size_t soap_flag_wsse__Security = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct SOAP_ENV__Header*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_SOAP_ENV__Header, sizeof(struct SOAP_ENV__Header), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_SOAP_ENV__Header(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_wsa__MessageID && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in__wsa__MessageID(soap, "wsa:MessageID", (char**)&a->wsa__MessageID, ""))
				{	soap_flag_wsa__MessageID--;
					continue;
				}
			}
			if (soap_flag_wsa__RelatesTo && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_wsa__RelatesTo(soap, "wsa:RelatesTo", &a->wsa__RelatesTo, ""))
				{	soap_flag_wsa__RelatesTo--;
					continue;
				}
			}
			if (soap_flag_wsa__From && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_wsa__From(soap, "wsa:From", &a->wsa__From, ""))
				{	soap_flag_wsa__From--;
					continue;
				}
			}
			if (soap_flag_wsa__ReplyTo && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_wsa__ReplyTo(soap, "wsa:ReplyTo", &a->wsa__ReplyTo, ""))
				{	soap_flag_wsa__ReplyTo--;
					continue;
				}
			}
			if (soap_flag_wsa__FaultTo && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_wsa__FaultTo(soap, "wsa:FaultTo", &a->wsa__FaultTo, ""))
				{	soap_flag_wsa__FaultTo--;
					continue;
				}
			}
			if (soap_flag_wsa__To && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in__wsa__To(soap, "wsa:To", (char**)&a->wsa__To, ""))
				{	soap_flag_wsa__To--;
					continue;
				}
			}
			if (soap_flag_wsa__Action && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in__wsa__Action(soap, "wsa:Action", (char**)&a->wsa__Action, ""))
				{	soap_flag_wsa__Action--;
					continue;
				}
			}
			if (soap_flag_wsdd__AppSequence && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTowsdd__AppSequenceType(soap, "wsdd:AppSequence", &a->wsdd__AppSequence, "wsdd:AppSequenceType"))
				{	soap_flag_wsdd__AppSequence--;
					continue;
				}
			}
			if (soap_flag_wsa5__MessageID && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in__wsa5__MessageID(soap, "wsa5:MessageID", (char**)&a->wsa5__MessageID, ""))
				{	soap_flag_wsa5__MessageID--;
					continue;
				}
			}
			if (soap_flag_wsa5__RelatesTo && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_wsa5__RelatesTo(soap, "wsa5:RelatesTo", &a->wsa5__RelatesTo, ""))
				{	soap_flag_wsa5__RelatesTo--;
					continue;
				}
			}
			if (soap_flag_wsa5__From && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_wsa5__From(soap, "wsa5:From", &a->wsa5__From, ""))
				{	soap_flag_wsa5__From--;
					continue;
				}
			}
			if (soap_flag_wsa5__ReplyTo && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_wsa5__ReplyTo(soap, "wsa5:ReplyTo", &a->wsa5__ReplyTo, ""))
				{	soap_flag_wsa5__ReplyTo--;
					continue;
				}
			}
			if (soap_flag_wsa5__FaultTo && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_wsa5__FaultTo(soap, "wsa5:FaultTo", &a->wsa5__FaultTo, ""))
				{	soap_flag_wsa5__FaultTo--;
					continue;
				}
			}
			if (soap_flag_wsa5__To && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in__wsa5__To(soap, "wsa5:To", (char**)&a->wsa5__To, ""))
				{	soap_flag_wsa5__To--;
					continue;
				}
			}
			if (soap_flag_wsa5__Action && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in__wsa5__Action(soap, "wsa5:Action", (char**)&a->wsa5__Action, ""))
				{	soap_flag_wsa5__Action--;
					continue;
				}
			}
			if (soap_flag_chan__ChannelInstance && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTochan__ChannelInstanceType(soap, "chan:ChannelInstance", &a->chan__ChannelInstance, "chan:ChannelInstanceType"))
				{	soap_flag_chan__ChannelInstance--;
					continue;
				}
			}
			if (soap_flag_wsse__Security && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_wsse__Security(soap, "wsse:Security", &a->wsse__Security, ""))
				{	soap_flag_wsse__Security--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Header *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_SOAP_ENV__Header, SOAP_TYPE_SOAP_ENV__Header, sizeof(struct SOAP_ENV__Header), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct SOAP_ENV__Header * SOAP_FMAC4 soap_new_SOAP_ENV__Header(struct soap *soap, int n)
{
	struct SOAP_ENV__Header *p;
	struct SOAP_ENV__Header *a = (struct SOAP_ENV__Header*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct SOAP_ENV__Header));
	for (p = a; p && n--; p++)
		soap_default_SOAP_ENV__Header(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_SOAP_ENV__Header(struct soap *soap, const struct SOAP_ENV__Header *a, const char *tag, const char *type)
{
	if (soap_out_SOAP_ENV__Header(soap, tag ? tag : "SOAP-ENV:Header", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Header * SOAP_FMAC4 soap_get_SOAP_ENV__Header(struct soap *soap, struct SOAP_ENV__Header *p, const char *tag, const char *type)
{
	if ((p = soap_in_SOAP_ENV__Header(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

#endif

SOAP_FMAC3 int SOAP_FMAC4 soap_put__wsa__FaultTo(struct soap *soap, const struct wsa__EndpointReferenceType *a, const char *tag, const char *type)
{
	if (soap_out__wsa__FaultTo(soap, tag ? tag : "wsa:FaultTo", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__wsa__ReplyTo(struct soap *soap, const struct wsa__EndpointReferenceType *a, const char *tag, const char *type)
{
	if (soap_out__wsa__ReplyTo(soap, tag ? tag : "wsa:ReplyTo", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__wsa__From(struct soap *soap, const struct wsa__EndpointReferenceType *a, const char *tag, const char *type)
{
	if (soap_out__wsa__From(soap, tag ? tag : "wsa:From", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__wsa__RelatesTo(struct soap *soap, const struct wsa__Relationship *a, const char *tag, const char *type)
{
	if (soap_out__wsa__RelatesTo(soap, tag ? tag : "wsa:RelatesTo", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__wsa__EndpointReference(struct soap *soap, const struct wsa__EndpointReferenceType *a, const char *tag, const char *type)
{
	if (soap_out__wsa__EndpointReference(soap, tag ? tag : "wsa:EndpointReference", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_wsa__Relationship(struct soap *soap, struct wsa__Relationship *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->__item);
	soap_default__QName(soap, &a->RelationshipType);
	a->__anyAttribute = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_wsa__Relationship(struct soap *soap, const struct wsa__Relationship *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_string(soap, (char*const*)&a->__item);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_wsa__Relationship(struct soap *soap, const char *tag, int id, const struct wsa__Relationship *a, const char *type)
{
	if (a->RelationshipType)
		soap_set_attr(soap, "RelationshipType", soap__QName2s(soap, a->RelationshipType), 1);
	if (a->__anyAttribute)
		soap_set_attr(soap, "-anyAttribute", a->__anyAttribute, 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	return soap_out_string(soap, tag, id, (char*const*)&a->__item, "");
}

SOAP_FMAC3 struct wsa__Relationship * SOAP_FMAC4 soap_in_wsa__Relationship(struct soap *soap, const char *tag, struct wsa__Relationship *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	if (!(a = (struct wsa__Relationship *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_wsa__Relationship, sizeof(struct wsa__Relationship), NULL, NULL, NULL, NULL)))
		return NULL;
	soap_revert(soap);
	*soap->id = '\0';
	soap_default_wsa__Relationship(soap, a);
	if (soap_s2_QName(soap, soap_attr_value(soap, "RelationshipType", 2, 0), &a->RelationshipType))
		return NULL;
	if (soap_s2char(soap, soap_attr_value(soap, "-anyAttribute", 0, 0), &a->__anyAttribute, 0, 0, -1, NULL))
		return NULL;
	if (!soap_in_string(soap, tag, (char**)&a->__item, "wsa:Relationship"))
		return NULL;
	return a;
}

SOAP_FMAC3 struct wsa__Relationship * SOAP_FMAC4 soap_new_wsa__Relationship(struct soap *soap, int n)
{
	struct wsa__Relationship *p;
	struct wsa__Relationship *a = (struct wsa__Relationship*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct wsa__Relationship));
	for (p = a; p && n--; p++)
		soap_default_wsa__Relationship(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_wsa__Relationship(struct soap *soap, const struct wsa__Relationship *a, const char *tag, const char *type)
{
	if (soap_out_wsa__Relationship(soap, tag ? tag : "wsa:Relationship", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct wsa__Relationship * SOAP_FMAC4 soap_get_wsa__Relationship(struct soap *soap, struct wsa__Relationship *p, const char *tag, const char *type)
{
	if ((p = soap_in_wsa__Relationship(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_wsa__ServiceNameType(struct soap *soap, struct wsa__ServiceNameType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default__QName(soap, &a->__item);
	soap_default_string(soap, &a->PortName);
	a->__anyAttribute = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_wsa__ServiceNameType(struct soap *soap, const struct wsa__ServiceNameType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize__QName(soap, (char*const*)&a->__item);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_wsa__ServiceNameType(struct soap *soap, const char *tag, int id, const struct wsa__ServiceNameType *a, const char *type)
{
	const char *soap_tmp___item;
	soap_tmp___item = soap_QName2s(soap, a->__item);
	if (a->PortName)
		soap_set_attr(soap, "PortName", soap_string2s(soap, a->PortName), 1);
	if (a->__anyAttribute)
		soap_set_attr(soap, "-anyAttribute", a->__anyAttribute, 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	return soap_out__QName(soap, tag, id, (char*const*)(void*)&soap_tmp___item, "");
}

SOAP_FMAC3 struct wsa__ServiceNameType * SOAP_FMAC4 soap_in_wsa__ServiceNameType(struct soap *soap, const char *tag, struct wsa__ServiceNameType *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	if (!(a = (struct wsa__ServiceNameType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_wsa__ServiceNameType, sizeof(struct wsa__ServiceNameType), NULL, NULL, NULL, NULL)))
		return NULL;
	soap_revert(soap);
	*soap->id = '\0';
	soap_default_wsa__ServiceNameType(soap, a);
	if (soap_s2string(soap, soap_attr_value(soap, "PortName", 1, 0), &a->PortName))
		return NULL;
	if (soap_s2char(soap, soap_attr_value(soap, "-anyAttribute", 0, 0), &a->__anyAttribute, 0, 0, -1, NULL))
		return NULL;
	if (!soap_in__QName(soap, tag, (char**)&a->__item, "wsa:ServiceNameType"))
		return NULL;
	return a;
}

SOAP_FMAC3 struct wsa__ServiceNameType * SOAP_FMAC4 soap_new_wsa__ServiceNameType(struct soap *soap, int n)
{
	struct wsa__ServiceNameType *p;
	struct wsa__ServiceNameType *a = (struct wsa__ServiceNameType*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct wsa__ServiceNameType));
	for (p = a; p && n--; p++)
		soap_default_wsa__ServiceNameType(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_wsa__ServiceNameType(struct soap *soap, const struct wsa__ServiceNameType *a, const char *tag, const char *type)
{
	if (soap_out_wsa__ServiceNameType(soap, tag ? tag : "wsa:ServiceNameType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct wsa__ServiceNameType * SOAP_FMAC4 soap_get_wsa__ServiceNameType(struct soap *soap, struct wsa__ServiceNameType *p, const char *tag, const char *type)
{
	if ((p = soap_in_wsa__ServiceNameType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_wsa__ReferenceParametersType(struct soap *soap, struct wsa__ReferenceParametersType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__size = 0;
	a->__any = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_wsa__ReferenceParametersType(struct soap *soap, const struct wsa__ReferenceParametersType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_wsa__ReferenceParametersType(struct soap *soap, const char *tag, int id, const struct wsa__ReferenceParametersType *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_wsa__ReferenceParametersType), type))
		return soap->error;
	if (a->__any)
	{	int i;
		for (i = 0; i < (int)a->__size; i++)
			if (soap_outliteral(soap, "-any", (char*const*)(a->__any + i), NULL))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct wsa__ReferenceParametersType * SOAP_FMAC4 soap_in_wsa__ReferenceParametersType(struct soap *soap, const char *tag, struct wsa__ReferenceParametersType *a, const char *type)
{
	struct soap_blist *soap_blist___any = NULL;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct wsa__ReferenceParametersType*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_wsa__ReferenceParametersType, sizeof(struct wsa__ReferenceParametersType), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_wsa__ReferenceParametersType(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	if (a->__any == NULL)
				{	if (soap_blist___any == NULL)
						soap_blist___any = soap_alloc_block(soap);
					a->__any = (char **)soap_push_block_max(soap, soap_blist___any, sizeof(char *));
					if (a->__any == NULL)
						return NULL;
					*a->__any = NULL;
				}
				if (soap_inliteral(soap, "-any", (char**)a->__any))
				{	a->__size++;
					a->__any = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->__any)
			soap_pop_block(soap, soap_blist___any);
		if (a->__size)
		{	a->__any = (char **)soap_save_block(soap, soap_blist___any, NULL, 1);
		}
		else
		{	a->__any = NULL;
			if (soap_blist___any)
				soap_end_block(soap, soap_blist___any);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct wsa__ReferenceParametersType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_wsa__ReferenceParametersType, SOAP_TYPE_wsa__ReferenceParametersType, sizeof(struct wsa__ReferenceParametersType), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct wsa__ReferenceParametersType * SOAP_FMAC4 soap_new_wsa__ReferenceParametersType(struct soap *soap, int n)
{
	struct wsa__ReferenceParametersType *p;
	struct wsa__ReferenceParametersType *a = (struct wsa__ReferenceParametersType*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct wsa__ReferenceParametersType));
	for (p = a; p && n--; p++)
		soap_default_wsa__ReferenceParametersType(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_wsa__ReferenceParametersType(struct soap *soap, const struct wsa__ReferenceParametersType *a, const char *tag, const char *type)
{
	if (soap_out_wsa__ReferenceParametersType(soap, tag ? tag : "wsa:ReferenceParametersType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct wsa__ReferenceParametersType * SOAP_FMAC4 soap_get_wsa__ReferenceParametersType(struct soap *soap, struct wsa__ReferenceParametersType *p, const char *tag, const char *type)
{
	if ((p = soap_in_wsa__ReferenceParametersType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_wsa__ReferencePropertiesType(struct soap *soap, struct wsa__ReferencePropertiesType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__size = 0;
	a->__any = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_wsa__ReferencePropertiesType(struct soap *soap, const struct wsa__ReferencePropertiesType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_wsa__ReferencePropertiesType(struct soap *soap, const char *tag, int id, const struct wsa__ReferencePropertiesType *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_wsa__ReferencePropertiesType), type))
		return soap->error;
	if (a->__any)
	{	int i;
		for (i = 0; i < (int)a->__size; i++)
			if (soap_outliteral(soap, "-any", (char*const*)(a->__any + i), NULL))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct wsa__ReferencePropertiesType * SOAP_FMAC4 soap_in_wsa__ReferencePropertiesType(struct soap *soap, const char *tag, struct wsa__ReferencePropertiesType *a, const char *type)
{
	struct soap_blist *soap_blist___any = NULL;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct wsa__ReferencePropertiesType*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_wsa__ReferencePropertiesType, sizeof(struct wsa__ReferencePropertiesType), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_wsa__ReferencePropertiesType(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	if (a->__any == NULL)
				{	if (soap_blist___any == NULL)
						soap_blist___any = soap_alloc_block(soap);
					a->__any = (char **)soap_push_block_max(soap, soap_blist___any, sizeof(char *));
					if (a->__any == NULL)
						return NULL;
					*a->__any = NULL;
				}
				if (soap_inliteral(soap, "-any", (char**)a->__any))
				{	a->__size++;
					a->__any = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->__any)
			soap_pop_block(soap, soap_blist___any);
		if (a->__size)
		{	a->__any = (char **)soap_save_block(soap, soap_blist___any, NULL, 1);
		}
		else
		{	a->__any = NULL;
			if (soap_blist___any)
				soap_end_block(soap, soap_blist___any);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct wsa__ReferencePropertiesType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_wsa__ReferencePropertiesType, SOAP_TYPE_wsa__ReferencePropertiesType, sizeof(struct wsa__ReferencePropertiesType), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct wsa__ReferencePropertiesType * SOAP_FMAC4 soap_new_wsa__ReferencePropertiesType(struct soap *soap, int n)
{
	struct wsa__ReferencePropertiesType *p;
	struct wsa__ReferencePropertiesType *a = (struct wsa__ReferencePropertiesType*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct wsa__ReferencePropertiesType));
	for (p = a; p && n--; p++)
		soap_default_wsa__ReferencePropertiesType(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_wsa__ReferencePropertiesType(struct soap *soap, const struct wsa__ReferencePropertiesType *a, const char *tag, const char *type)
{
	if (soap_out_wsa__ReferencePropertiesType(soap, tag ? tag : "wsa:ReferencePropertiesType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct wsa__ReferencePropertiesType * SOAP_FMAC4 soap_get_wsa__ReferencePropertiesType(struct soap *soap, struct wsa__ReferencePropertiesType *p, const char *tag, const char *type)
{
	if ((p = soap_in_wsa__ReferencePropertiesType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_wsa__EndpointReferenceType(struct soap *soap, struct wsa__EndpointReferenceType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->Address);
	a->ReferenceProperties = NULL;
	a->ReferenceParameters = NULL;
	a->PortType = NULL;
	a->ServiceName = NULL;
	a->__size = 0;
	a->__any = NULL;
	a->__anyAttribute = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_wsa__EndpointReferenceType(struct soap *soap, const struct wsa__EndpointReferenceType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_string(soap, (char*const*)&a->Address);
	soap_serialize_PointerTowsa__ReferencePropertiesType(soap, &a->ReferenceProperties);
	soap_serialize_PointerTowsa__ReferenceParametersType(soap, &a->ReferenceParameters);
	soap_serialize_PointerTo_QName(soap, &a->PortType);
	soap_serialize_PointerTowsa__ServiceNameType(soap, &a->ServiceName);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_wsa__EndpointReferenceType(struct soap *soap, const char *tag, int id, const struct wsa__EndpointReferenceType *a, const char *type)
{
	const char *soap_tmp_PortType;
	soap_tmp_PortType = a->PortType ? soap_QName2s(soap, *a->PortType) : NULL;
	if (a->__anyAttribute)
		soap_set_attr(soap, "-anyAttribute", a->__anyAttribute, 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_wsa__EndpointReferenceType), type))
		return soap->error;
	if (!a->Address)
	{	if (soap_element_empty(soap, "wsa:Address", 0, NULL))
			return soap->error;
	}
	else if (soap_out_string(soap, "wsa:Address", -1, (char*const*)&a->Address, ""))
		return soap->error;
	if (soap_out_PointerTowsa__ReferencePropertiesType(soap, "wsa:ReferenceProperties", -1, &a->ReferenceProperties, ""))
		return soap->error;
	if (soap_out_PointerTowsa__ReferenceParametersType(soap, "wsa:ReferenceParameters", -1, &a->ReferenceParameters, ""))
		return soap->error;
	if (soap_out__QName(soap, "wsa:PortType", -1, (char*const*)(void*)&soap_tmp_PortType, ""))
		return soap->error;
	if (soap_out_PointerTowsa__ServiceNameType(soap, "wsa:ServiceName", -1, &a->ServiceName, ""))
		return soap->error;
	if (a->__any)
	{	int i;
		for (i = 0; i < (int)a->__size; i++)
			if (soap_outliteral(soap, "-any", (char*const*)(a->__any + i), NULL))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct wsa__EndpointReferenceType * SOAP_FMAC4 soap_in_wsa__EndpointReferenceType(struct soap *soap, const char *tag, struct wsa__EndpointReferenceType *a, const char *type)
{
	size_t soap_flag_Address = 1;
	size_t soap_flag_ReferenceProperties = 1;
	size_t soap_flag_ReferenceParameters = 1;
	size_t soap_flag_PortType = 1;
	size_t soap_flag_ServiceName = 1;
	struct soap_blist *soap_blist___any = NULL;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct wsa__EndpointReferenceType*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_wsa__EndpointReferenceType, sizeof(struct wsa__EndpointReferenceType), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_wsa__EndpointReferenceType(soap, a);
	if (soap_s2char(soap, soap_attr_value(soap, "-anyAttribute", 0, 0), &a->__anyAttribute, 0, 0, -1, NULL))
		return NULL;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Address && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_string(soap, "wsa:Address", (char**)&a->Address, "xsd:string"))
				{	soap_flag_Address--;
					continue;
				}
			}
			if (soap_flag_ReferenceProperties && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTowsa__ReferencePropertiesType(soap, "wsa:ReferenceProperties", &a->ReferenceProperties, "wsa:ReferencePropertiesType"))
				{	soap_flag_ReferenceProperties--;
					continue;
				}
			}
			if (soap_flag_ReferenceParameters && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTowsa__ReferenceParametersType(soap, "wsa:ReferenceParameters", &a->ReferenceParameters, "wsa:ReferenceParametersType"))
				{	soap_flag_ReferenceParameters--;
					continue;
				}
			}
			if (soap_flag_PortType && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_QName(soap, "wsa:PortType", &a->PortType, ""))
				{	soap_flag_PortType--;
					continue;
				}
			}
			if (soap_flag_ServiceName && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTowsa__ServiceNameType(soap, "wsa:ServiceName", &a->ServiceName, "wsa:ServiceNameType"))
				{	soap_flag_ServiceName--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	if (a->__any == NULL)
				{	if (soap_blist___any == NULL)
						soap_blist___any = soap_alloc_block(soap);
					a->__any = (char **)soap_push_block_max(soap, soap_blist___any, sizeof(char *));
					if (a->__any == NULL)
						return NULL;
					*a->__any = NULL;
				}
				if (soap_inliteral(soap, "-any", (char**)a->__any))
				{	a->__size++;
					a->__any = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->__any)
			soap_pop_block(soap, soap_blist___any);
		if (a->__size)
		{	a->__any = (char **)soap_save_block(soap, soap_blist___any, NULL, 1);
		}
		else
		{	a->__any = NULL;
			if (soap_blist___any)
				soap_end_block(soap, soap_blist___any);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (!a->Address))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct wsa__EndpointReferenceType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_wsa__EndpointReferenceType, SOAP_TYPE_wsa__EndpointReferenceType, sizeof(struct wsa__EndpointReferenceType), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct wsa__EndpointReferenceType * SOAP_FMAC4 soap_new_wsa__EndpointReferenceType(struct soap *soap, int n)
{
	struct wsa__EndpointReferenceType *p;
	struct wsa__EndpointReferenceType *a = (struct wsa__EndpointReferenceType*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct wsa__EndpointReferenceType));
	for (p = a; p && n--; p++)
		soap_default_wsa__EndpointReferenceType(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_wsa__EndpointReferenceType(struct soap *soap, const struct wsa__EndpointReferenceType *a, const char *tag, const char *type)
{
	if (soap_out_wsa__EndpointReferenceType(soap, tag ? tag : "wsa:EndpointReferenceType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct wsa__EndpointReferenceType * SOAP_FMAC4 soap_get_wsa__EndpointReferenceType(struct soap *soap, struct wsa__EndpointReferenceType *p, const char *tag, const char *type)
{
	if ((p = soap_in_wsa__EndpointReferenceType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__wsc__union_DerivedKeyTokenType(struct soap *soap, int choice, const union _wsc__union_DerivedKeyTokenType *a)
{
	(void)soap; (void)choice; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	switch (choice)
	{
	case SOAP_UNION__wsc__union_DerivedKeyTokenType_Generation:
		soap_embedded(soap, &a->Generation, SOAP_TYPE_ULONG64);
		break;
	case SOAP_UNION__wsc__union_DerivedKeyTokenType_Offset:
		soap_embedded(soap, &a->Offset, SOAP_TYPE_ULONG64);
		break;
	default:
		break;
	}
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__wsc__union_DerivedKeyTokenType(struct soap *soap, int choice, const union _wsc__union_DerivedKeyTokenType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	switch (choice)
	{
	case SOAP_UNION__wsc__union_DerivedKeyTokenType_Generation:
		return soap_out_ULONG64(soap, "wsc:Generation", -1, &a->Generation, "");
	case SOAP_UNION__wsc__union_DerivedKeyTokenType_Offset:
		return soap_out_ULONG64(soap, "wsc:Offset", -1, &a->Offset, "");
	default:
		break;
	}
	return SOAP_OK;
}

SOAP_FMAC3 union _wsc__union_DerivedKeyTokenType * SOAP_FMAC4 soap_in__wsc__union_DerivedKeyTokenType(struct soap *soap, int *choice, union _wsc__union_DerivedKeyTokenType *a)
{
	(void)a; /* appease -Wall -Werror */
	soap->error = SOAP_TAG_MISMATCH;
	if (soap->error == SOAP_TAG_MISMATCH && soap_in_ULONG64(soap, "wsc:Generation", &a->Generation, "xsd:unsignedLong"))
	{	*choice = SOAP_UNION__wsc__union_DerivedKeyTokenType_Generation;
		return a;
	}
	if (soap->error == SOAP_TAG_MISMATCH && soap_in_ULONG64(soap, "wsc:Offset", &a->Offset, "xsd:unsignedLong"))
	{	*choice = SOAP_UNION__wsc__union_DerivedKeyTokenType_Offset;
		return a;
	}
	*choice = -1;
	if (!soap->error)
		soap->error = SOAP_TAG_MISMATCH;
	return NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_trt__GetSnapshotUriResponse(struct soap *soap, struct _trt__GetSnapshotUriResponse *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__trt__GetSnapshotUriResponse))
		soap_serialize__trt__GetSnapshotUriResponse(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_trt__GetSnapshotUriResponse(struct soap *soap, const char *tag, int id, struct _trt__GetSnapshotUriResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__trt__GetSnapshotUriResponse, NULL);
	if (id < 0)
		return soap->error;
	return soap_out__trt__GetSnapshotUriResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _trt__GetSnapshotUriResponse ** SOAP_FMAC4 soap_in_PointerTo_trt__GetSnapshotUriResponse(struct soap *soap, const char *tag, struct _trt__GetSnapshotUriResponse **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _trt__GetSnapshotUriResponse **)soap_malloc(soap, sizeof(struct _trt__GetSnapshotUriResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__trt__GetSnapshotUriResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _trt__GetSnapshotUriResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__trt__GetSnapshotUriResponse, sizeof(struct _trt__GetSnapshotUriResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_trt__GetSnapshotUriResponse(struct soap *soap, struct _trt__GetSnapshotUriResponse *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_trt__GetSnapshotUriResponse(soap, tag ? tag : "trt:GetSnapshotUriResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _trt__GetSnapshotUriResponse ** SOAP_FMAC4 soap_get_PointerTo_trt__GetSnapshotUriResponse(struct soap *soap, struct _trt__GetSnapshotUriResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_trt__GetSnapshotUriResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_trt__GetSnapshotUri(struct soap *soap, struct _trt__GetSnapshotUri *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__trt__GetSnapshotUri))
		soap_serialize__trt__GetSnapshotUri(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_trt__GetSnapshotUri(struct soap *soap, const char *tag, int id, struct _trt__GetSnapshotUri *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__trt__GetSnapshotUri, NULL);
	if (id < 0)
		return soap->error;
	return soap_out__trt__GetSnapshotUri(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _trt__GetSnapshotUri ** SOAP_FMAC4 soap_in_PointerTo_trt__GetSnapshotUri(struct soap *soap, const char *tag, struct _trt__GetSnapshotUri **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _trt__GetSnapshotUri **)soap_malloc(soap, sizeof(struct _trt__GetSnapshotUri *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__trt__GetSnapshotUri(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _trt__GetSnapshotUri **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__trt__GetSnapshotUri, sizeof(struct _trt__GetSnapshotUri), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_trt__GetSnapshotUri(struct soap *soap, struct _trt__GetSnapshotUri *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_trt__GetSnapshotUri(soap, tag ? tag : "trt:GetSnapshotUri", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _trt__GetSnapshotUri ** SOAP_FMAC4 soap_get_PointerTo_trt__GetSnapshotUri(struct soap *soap, struct _trt__GetSnapshotUri **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_trt__GetSnapshotUri(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_trt__GetProfilesResponse(struct soap *soap, struct _trt__GetProfilesResponse *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__trt__GetProfilesResponse))
		soap_serialize__trt__GetProfilesResponse(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_trt__GetProfilesResponse(struct soap *soap, const char *tag, int id, struct _trt__GetProfilesResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__trt__GetProfilesResponse, NULL);
	if (id < 0)
		return soap->error;
	return soap_out__trt__GetProfilesResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _trt__GetProfilesResponse ** SOAP_FMAC4 soap_in_PointerTo_trt__GetProfilesResponse(struct soap *soap, const char *tag, struct _trt__GetProfilesResponse **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _trt__GetProfilesResponse **)soap_malloc(soap, sizeof(struct _trt__GetProfilesResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__trt__GetProfilesResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _trt__GetProfilesResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__trt__GetProfilesResponse, sizeof(struct _trt__GetProfilesResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_trt__GetProfilesResponse(struct soap *soap, struct _trt__GetProfilesResponse *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_trt__GetProfilesResponse(soap, tag ? tag : "trt:GetProfilesResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _trt__GetProfilesResponse ** SOAP_FMAC4 soap_get_PointerTo_trt__GetProfilesResponse(struct soap *soap, struct _trt__GetProfilesResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_trt__GetProfilesResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_trt__GetProfiles(struct soap *soap, struct _trt__GetProfiles *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__trt__GetProfiles))
		soap_serialize__trt__GetProfiles(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_trt__GetProfiles(struct soap *soap, const char *tag, int id, struct _trt__GetProfiles *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__trt__GetProfiles, NULL);
	if (id < 0)
		return soap->error;
	return soap_out__trt__GetProfiles(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _trt__GetProfiles ** SOAP_FMAC4 soap_in_PointerTo_trt__GetProfiles(struct soap *soap, const char *tag, struct _trt__GetProfiles **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _trt__GetProfiles **)soap_malloc(soap, sizeof(struct _trt__GetProfiles *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__trt__GetProfiles(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _trt__GetProfiles **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__trt__GetProfiles, sizeof(struct _trt__GetProfiles), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_trt__GetProfiles(struct soap *soap, struct _trt__GetProfiles *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_trt__GetProfiles(soap, tag ? tag : "trt:GetProfiles", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _trt__GetProfiles ** SOAP_FMAC4 soap_get_PointerTo_trt__GetProfiles(struct soap *soap, struct _trt__GetProfiles **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_trt__GetProfiles(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_trt__GetProfileResponse(struct soap *soap, struct _trt__GetProfileResponse *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__trt__GetProfileResponse))
		soap_serialize__trt__GetProfileResponse(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_trt__GetProfileResponse(struct soap *soap, const char *tag, int id, struct _trt__GetProfileResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__trt__GetProfileResponse, NULL);
	if (id < 0)
		return soap->error;
	return soap_out__trt__GetProfileResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _trt__GetProfileResponse ** SOAP_FMAC4 soap_in_PointerTo_trt__GetProfileResponse(struct soap *soap, const char *tag, struct _trt__GetProfileResponse **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _trt__GetProfileResponse **)soap_malloc(soap, sizeof(struct _trt__GetProfileResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__trt__GetProfileResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _trt__GetProfileResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__trt__GetProfileResponse, sizeof(struct _trt__GetProfileResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_trt__GetProfileResponse(struct soap *soap, struct _trt__GetProfileResponse *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_trt__GetProfileResponse(soap, tag ? tag : "trt:GetProfileResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _trt__GetProfileResponse ** SOAP_FMAC4 soap_get_PointerTo_trt__GetProfileResponse(struct soap *soap, struct _trt__GetProfileResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_trt__GetProfileResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_trt__GetProfile(struct soap *soap, struct _trt__GetProfile *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__trt__GetProfile))
		soap_serialize__trt__GetProfile(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_trt__GetProfile(struct soap *soap, const char *tag, int id, struct _trt__GetProfile *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__trt__GetProfile, NULL);
	if (id < 0)
		return soap->error;
	return soap_out__trt__GetProfile(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _trt__GetProfile ** SOAP_FMAC4 soap_in_PointerTo_trt__GetProfile(struct soap *soap, const char *tag, struct _trt__GetProfile **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _trt__GetProfile **)soap_malloc(soap, sizeof(struct _trt__GetProfile *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__trt__GetProfile(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _trt__GetProfile **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__trt__GetProfile, sizeof(struct _trt__GetProfile), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_trt__GetProfile(struct soap *soap, struct _trt__GetProfile *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_trt__GetProfile(soap, tag ? tag : "trt:GetProfile", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _trt__GetProfile ** SOAP_FMAC4 soap_get_PointerTo_trt__GetProfile(struct soap *soap, struct _trt__GetProfile **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_trt__GetProfile(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_trt__CreateProfileResponse(struct soap *soap, struct _trt__CreateProfileResponse *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__trt__CreateProfileResponse))
		soap_serialize__trt__CreateProfileResponse(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_trt__CreateProfileResponse(struct soap *soap, const char *tag, int id, struct _trt__CreateProfileResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__trt__CreateProfileResponse, NULL);
	if (id < 0)
		return soap->error;
	return soap_out__trt__CreateProfileResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _trt__CreateProfileResponse ** SOAP_FMAC4 soap_in_PointerTo_trt__CreateProfileResponse(struct soap *soap, const char *tag, struct _trt__CreateProfileResponse **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _trt__CreateProfileResponse **)soap_malloc(soap, sizeof(struct _trt__CreateProfileResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__trt__CreateProfileResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _trt__CreateProfileResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__trt__CreateProfileResponse, sizeof(struct _trt__CreateProfileResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_trt__CreateProfileResponse(struct soap *soap, struct _trt__CreateProfileResponse *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_trt__CreateProfileResponse(soap, tag ? tag : "trt:CreateProfileResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _trt__CreateProfileResponse ** SOAP_FMAC4 soap_get_PointerTo_trt__CreateProfileResponse(struct soap *soap, struct _trt__CreateProfileResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_trt__CreateProfileResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_trt__CreateProfile(struct soap *soap, struct _trt__CreateProfile *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__trt__CreateProfile))
		soap_serialize__trt__CreateProfile(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_trt__CreateProfile(struct soap *soap, const char *tag, int id, struct _trt__CreateProfile *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__trt__CreateProfile, NULL);
	if (id < 0)
		return soap->error;
	return soap_out__trt__CreateProfile(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _trt__CreateProfile ** SOAP_FMAC4 soap_in_PointerTo_trt__CreateProfile(struct soap *soap, const char *tag, struct _trt__CreateProfile **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _trt__CreateProfile **)soap_malloc(soap, sizeof(struct _trt__CreateProfile *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__trt__CreateProfile(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _trt__CreateProfile **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__trt__CreateProfile, sizeof(struct _trt__CreateProfile), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_trt__CreateProfile(struct soap *soap, struct _trt__CreateProfile *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_trt__CreateProfile(soap, tag ? tag : "trt:CreateProfile", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _trt__CreateProfile ** SOAP_FMAC4 soap_get_PointerTo_trt__CreateProfile(struct soap *soap, struct _trt__CreateProfile **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_trt__CreateProfile(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_trt__GetServiceCapabilitiesResponse(struct soap *soap, struct _trt__GetServiceCapabilitiesResponse *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__trt__GetServiceCapabilitiesResponse))
		soap_serialize__trt__GetServiceCapabilitiesResponse(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_trt__GetServiceCapabilitiesResponse(struct soap *soap, const char *tag, int id, struct _trt__GetServiceCapabilitiesResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__trt__GetServiceCapabilitiesResponse, NULL);
	if (id < 0)
		return soap->error;
	return soap_out__trt__GetServiceCapabilitiesResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _trt__GetServiceCapabilitiesResponse ** SOAP_FMAC4 soap_in_PointerTo_trt__GetServiceCapabilitiesResponse(struct soap *soap, const char *tag, struct _trt__GetServiceCapabilitiesResponse **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _trt__GetServiceCapabilitiesResponse **)soap_malloc(soap, sizeof(struct _trt__GetServiceCapabilitiesResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__trt__GetServiceCapabilitiesResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _trt__GetServiceCapabilitiesResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__trt__GetServiceCapabilitiesResponse, sizeof(struct _trt__GetServiceCapabilitiesResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_trt__GetServiceCapabilitiesResponse(struct soap *soap, struct _trt__GetServiceCapabilitiesResponse *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_trt__GetServiceCapabilitiesResponse(soap, tag ? tag : "trt:GetServiceCapabilitiesResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _trt__GetServiceCapabilitiesResponse ** SOAP_FMAC4 soap_get_PointerTo_trt__GetServiceCapabilitiesResponse(struct soap *soap, struct _trt__GetServiceCapabilitiesResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_trt__GetServiceCapabilitiesResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_trt__GetServiceCapabilities(struct soap *soap, struct _trt__GetServiceCapabilities *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__trt__GetServiceCapabilities))
		soap_serialize__trt__GetServiceCapabilities(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_trt__GetServiceCapabilities(struct soap *soap, const char *tag, int id, struct _trt__GetServiceCapabilities *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__trt__GetServiceCapabilities, NULL);
	if (id < 0)
		return soap->error;
	return soap_out__trt__GetServiceCapabilities(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _trt__GetServiceCapabilities ** SOAP_FMAC4 soap_in_PointerTo_trt__GetServiceCapabilities(struct soap *soap, const char *tag, struct _trt__GetServiceCapabilities **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _trt__GetServiceCapabilities **)soap_malloc(soap, sizeof(struct _trt__GetServiceCapabilities *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__trt__GetServiceCapabilities(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _trt__GetServiceCapabilities **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__trt__GetServiceCapabilities, sizeof(struct _trt__GetServiceCapabilities), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_trt__GetServiceCapabilities(struct soap *soap, struct _trt__GetServiceCapabilities *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_trt__GetServiceCapabilities(soap, tag ? tag : "trt:GetServiceCapabilities", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _trt__GetServiceCapabilities ** SOAP_FMAC4 soap_get_PointerTo_trt__GetServiceCapabilities(struct soap *soap, struct _trt__GetServiceCapabilities **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_trt__GetServiceCapabilities(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tds__GetCapabilitiesResponse(struct soap *soap, struct _tds__GetCapabilitiesResponse *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tds__GetCapabilitiesResponse))
		soap_serialize__tds__GetCapabilitiesResponse(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tds__GetCapabilitiesResponse(struct soap *soap, const char *tag, int id, struct _tds__GetCapabilitiesResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tds__GetCapabilitiesResponse, NULL);
	if (id < 0)
		return soap->error;
	return soap_out__tds__GetCapabilitiesResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _tds__GetCapabilitiesResponse ** SOAP_FMAC4 soap_in_PointerTo_tds__GetCapabilitiesResponse(struct soap *soap, const char *tag, struct _tds__GetCapabilitiesResponse **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _tds__GetCapabilitiesResponse **)soap_malloc(soap, sizeof(struct _tds__GetCapabilitiesResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__tds__GetCapabilitiesResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _tds__GetCapabilitiesResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tds__GetCapabilitiesResponse, sizeof(struct _tds__GetCapabilitiesResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tds__GetCapabilitiesResponse(struct soap *soap, struct _tds__GetCapabilitiesResponse *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_tds__GetCapabilitiesResponse(soap, tag ? tag : "tds:GetCapabilitiesResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tds__GetCapabilitiesResponse ** SOAP_FMAC4 soap_get_PointerTo_tds__GetCapabilitiesResponse(struct soap *soap, struct _tds__GetCapabilitiesResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tds__GetCapabilitiesResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tds__GetCapabilities(struct soap *soap, struct _tds__GetCapabilities *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tds__GetCapabilities))
		soap_serialize__tds__GetCapabilities(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tds__GetCapabilities(struct soap *soap, const char *tag, int id, struct _tds__GetCapabilities *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tds__GetCapabilities, NULL);
	if (id < 0)
		return soap->error;
	return soap_out__tds__GetCapabilities(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _tds__GetCapabilities ** SOAP_FMAC4 soap_in_PointerTo_tds__GetCapabilities(struct soap *soap, const char *tag, struct _tds__GetCapabilities **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _tds__GetCapabilities **)soap_malloc(soap, sizeof(struct _tds__GetCapabilities *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__tds__GetCapabilities(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _tds__GetCapabilities **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tds__GetCapabilities, sizeof(struct _tds__GetCapabilities), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tds__GetCapabilities(struct soap *soap, struct _tds__GetCapabilities *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_tds__GetCapabilities(soap, tag ? tag : "tds:GetCapabilities", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tds__GetCapabilities ** SOAP_FMAC4 soap_get_PointerTo_tds__GetCapabilities(struct soap *soap, struct _tds__GetCapabilities **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tds__GetCapabilities(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tds__SystemRebootResponse(struct soap *soap, struct _tds__SystemRebootResponse *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tds__SystemRebootResponse))
		soap_serialize__tds__SystemRebootResponse(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tds__SystemRebootResponse(struct soap *soap, const char *tag, int id, struct _tds__SystemRebootResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tds__SystemRebootResponse, NULL);
	if (id < 0)
		return soap->error;
	return soap_out__tds__SystemRebootResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _tds__SystemRebootResponse ** SOAP_FMAC4 soap_in_PointerTo_tds__SystemRebootResponse(struct soap *soap, const char *tag, struct _tds__SystemRebootResponse **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _tds__SystemRebootResponse **)soap_malloc(soap, sizeof(struct _tds__SystemRebootResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__tds__SystemRebootResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _tds__SystemRebootResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tds__SystemRebootResponse, sizeof(struct _tds__SystemRebootResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tds__SystemRebootResponse(struct soap *soap, struct _tds__SystemRebootResponse *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_tds__SystemRebootResponse(soap, tag ? tag : "tds:SystemRebootResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tds__SystemRebootResponse ** SOAP_FMAC4 soap_get_PointerTo_tds__SystemRebootResponse(struct soap *soap, struct _tds__SystemRebootResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tds__SystemRebootResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tds__SystemReboot(struct soap *soap, struct _tds__SystemReboot *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tds__SystemReboot))
		soap_serialize__tds__SystemReboot(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tds__SystemReboot(struct soap *soap, const char *tag, int id, struct _tds__SystemReboot *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tds__SystemReboot, NULL);
	if (id < 0)
		return soap->error;
	return soap_out__tds__SystemReboot(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _tds__SystemReboot ** SOAP_FMAC4 soap_in_PointerTo_tds__SystemReboot(struct soap *soap, const char *tag, struct _tds__SystemReboot **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _tds__SystemReboot **)soap_malloc(soap, sizeof(struct _tds__SystemReboot *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__tds__SystemReboot(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _tds__SystemReboot **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tds__SystemReboot, sizeof(struct _tds__SystemReboot), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tds__SystemReboot(struct soap *soap, struct _tds__SystemReboot *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_tds__SystemReboot(soap, tag ? tag : "tds:SystemReboot", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tds__SystemReboot ** SOAP_FMAC4 soap_get_PointerTo_tds__SystemReboot(struct soap *soap, struct _tds__SystemReboot **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tds__SystemReboot(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tds__GetDeviceInformationResponse(struct soap *soap, struct _tds__GetDeviceInformationResponse *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tds__GetDeviceInformationResponse))
		soap_serialize__tds__GetDeviceInformationResponse(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tds__GetDeviceInformationResponse(struct soap *soap, const char *tag, int id, struct _tds__GetDeviceInformationResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tds__GetDeviceInformationResponse, NULL);
	if (id < 0)
		return soap->error;
	return soap_out__tds__GetDeviceInformationResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _tds__GetDeviceInformationResponse ** SOAP_FMAC4 soap_in_PointerTo_tds__GetDeviceInformationResponse(struct soap *soap, const char *tag, struct _tds__GetDeviceInformationResponse **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _tds__GetDeviceInformationResponse **)soap_malloc(soap, sizeof(struct _tds__GetDeviceInformationResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__tds__GetDeviceInformationResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _tds__GetDeviceInformationResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tds__GetDeviceInformationResponse, sizeof(struct _tds__GetDeviceInformationResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tds__GetDeviceInformationResponse(struct soap *soap, struct _tds__GetDeviceInformationResponse *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_tds__GetDeviceInformationResponse(soap, tag ? tag : "tds:GetDeviceInformationResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tds__GetDeviceInformationResponse ** SOAP_FMAC4 soap_get_PointerTo_tds__GetDeviceInformationResponse(struct soap *soap, struct _tds__GetDeviceInformationResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tds__GetDeviceInformationResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tds__GetDeviceInformation(struct soap *soap, struct _tds__GetDeviceInformation *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tds__GetDeviceInformation))
		soap_serialize__tds__GetDeviceInformation(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tds__GetDeviceInformation(struct soap *soap, const char *tag, int id, struct _tds__GetDeviceInformation *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tds__GetDeviceInformation, NULL);
	if (id < 0)
		return soap->error;
	return soap_out__tds__GetDeviceInformation(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _tds__GetDeviceInformation ** SOAP_FMAC4 soap_in_PointerTo_tds__GetDeviceInformation(struct soap *soap, const char *tag, struct _tds__GetDeviceInformation **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _tds__GetDeviceInformation **)soap_malloc(soap, sizeof(struct _tds__GetDeviceInformation *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__tds__GetDeviceInformation(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _tds__GetDeviceInformation **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tds__GetDeviceInformation, sizeof(struct _tds__GetDeviceInformation), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tds__GetDeviceInformation(struct soap *soap, struct _tds__GetDeviceInformation *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_tds__GetDeviceInformation(soap, tag ? tag : "tds:GetDeviceInformation", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tds__GetDeviceInformation ** SOAP_FMAC4 soap_get_PointerTo_tds__GetDeviceInformation(struct soap *soap, struct _tds__GetDeviceInformation **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tds__GetDeviceInformation(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tds__GetServiceCapabilitiesResponse(struct soap *soap, struct _tds__GetServiceCapabilitiesResponse *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tds__GetServiceCapabilitiesResponse))
		soap_serialize__tds__GetServiceCapabilitiesResponse(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tds__GetServiceCapabilitiesResponse(struct soap *soap, const char *tag, int id, struct _tds__GetServiceCapabilitiesResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tds__GetServiceCapabilitiesResponse, NULL);
	if (id < 0)
		return soap->error;
	return soap_out__tds__GetServiceCapabilitiesResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _tds__GetServiceCapabilitiesResponse ** SOAP_FMAC4 soap_in_PointerTo_tds__GetServiceCapabilitiesResponse(struct soap *soap, const char *tag, struct _tds__GetServiceCapabilitiesResponse **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _tds__GetServiceCapabilitiesResponse **)soap_malloc(soap, sizeof(struct _tds__GetServiceCapabilitiesResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__tds__GetServiceCapabilitiesResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _tds__GetServiceCapabilitiesResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tds__GetServiceCapabilitiesResponse, sizeof(struct _tds__GetServiceCapabilitiesResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tds__GetServiceCapabilitiesResponse(struct soap *soap, struct _tds__GetServiceCapabilitiesResponse *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_tds__GetServiceCapabilitiesResponse(soap, tag ? tag : "tds:GetServiceCapabilitiesResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tds__GetServiceCapabilitiesResponse ** SOAP_FMAC4 soap_get_PointerTo_tds__GetServiceCapabilitiesResponse(struct soap *soap, struct _tds__GetServiceCapabilitiesResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tds__GetServiceCapabilitiesResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tds__GetServiceCapabilities(struct soap *soap, struct _tds__GetServiceCapabilities *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tds__GetServiceCapabilities))
		soap_serialize__tds__GetServiceCapabilities(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tds__GetServiceCapabilities(struct soap *soap, const char *tag, int id, struct _tds__GetServiceCapabilities *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tds__GetServiceCapabilities, NULL);
	if (id < 0)
		return soap->error;
	return soap_out__tds__GetServiceCapabilities(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _tds__GetServiceCapabilities ** SOAP_FMAC4 soap_in_PointerTo_tds__GetServiceCapabilities(struct soap *soap, const char *tag, struct _tds__GetServiceCapabilities **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _tds__GetServiceCapabilities **)soap_malloc(soap, sizeof(struct _tds__GetServiceCapabilities *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__tds__GetServiceCapabilities(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _tds__GetServiceCapabilities **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tds__GetServiceCapabilities, sizeof(struct _tds__GetServiceCapabilities), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tds__GetServiceCapabilities(struct soap *soap, struct _tds__GetServiceCapabilities *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_tds__GetServiceCapabilities(soap, tag ? tag : "tds:GetServiceCapabilities", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tds__GetServiceCapabilities ** SOAP_FMAC4 soap_get_PointerTo_tds__GetServiceCapabilities(struct soap *soap, struct _tds__GetServiceCapabilities **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tds__GetServiceCapabilities(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tds__GetServicesResponse(struct soap *soap, struct _tds__GetServicesResponse *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tds__GetServicesResponse))
		soap_serialize__tds__GetServicesResponse(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tds__GetServicesResponse(struct soap *soap, const char *tag, int id, struct _tds__GetServicesResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tds__GetServicesResponse, NULL);
	if (id < 0)
		return soap->error;
	return soap_out__tds__GetServicesResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _tds__GetServicesResponse ** SOAP_FMAC4 soap_in_PointerTo_tds__GetServicesResponse(struct soap *soap, const char *tag, struct _tds__GetServicesResponse **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _tds__GetServicesResponse **)soap_malloc(soap, sizeof(struct _tds__GetServicesResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__tds__GetServicesResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _tds__GetServicesResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tds__GetServicesResponse, sizeof(struct _tds__GetServicesResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tds__GetServicesResponse(struct soap *soap, struct _tds__GetServicesResponse *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_tds__GetServicesResponse(soap, tag ? tag : "tds:GetServicesResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tds__GetServicesResponse ** SOAP_FMAC4 soap_get_PointerTo_tds__GetServicesResponse(struct soap *soap, struct _tds__GetServicesResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tds__GetServicesResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tds__GetServices(struct soap *soap, struct _tds__GetServices *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tds__GetServices))
		soap_serialize__tds__GetServices(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tds__GetServices(struct soap *soap, const char *tag, int id, struct _tds__GetServices *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tds__GetServices, NULL);
	if (id < 0)
		return soap->error;
	return soap_out__tds__GetServices(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _tds__GetServices ** SOAP_FMAC4 soap_in_PointerTo_tds__GetServices(struct soap *soap, const char *tag, struct _tds__GetServices **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _tds__GetServices **)soap_malloc(soap, sizeof(struct _tds__GetServices *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__tds__GetServices(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _tds__GetServices **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tds__GetServices, sizeof(struct _tds__GetServices), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tds__GetServices(struct soap *soap, struct _tds__GetServices *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_tds__GetServices(soap, tag ? tag : "tds:GetServices", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tds__GetServices ** SOAP_FMAC4 soap_get_PointerTo_tds__GetServices(struct soap *soap, struct _tds__GetServices **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tds__GetServices(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_wstop__TopicNamespaceType_Topic(struct soap *soap, struct _wstop__TopicNamespaceType_Topic *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__wstop__TopicNamespaceType_Topic))
		soap_serialize__wstop__TopicNamespaceType_Topic(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_wstop__TopicNamespaceType_Topic(struct soap *soap, const char *tag, int id, struct _wstop__TopicNamespaceType_Topic *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__wstop__TopicNamespaceType_Topic, NULL);
	if (id < 0)
		return soap->error;
	return soap_out__wstop__TopicNamespaceType_Topic(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _wstop__TopicNamespaceType_Topic ** SOAP_FMAC4 soap_in_PointerTo_wstop__TopicNamespaceType_Topic(struct soap *soap, const char *tag, struct _wstop__TopicNamespaceType_Topic **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _wstop__TopicNamespaceType_Topic **)soap_malloc(soap, sizeof(struct _wstop__TopicNamespaceType_Topic *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__wstop__TopicNamespaceType_Topic(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _wstop__TopicNamespaceType_Topic **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__wstop__TopicNamespaceType_Topic, sizeof(struct _wstop__TopicNamespaceType_Topic), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_wstop__TopicNamespaceType_Topic(struct soap *soap, struct _wstop__TopicNamespaceType_Topic *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_wstop__TopicNamespaceType_Topic(soap, tag ? tag : "wstop:TopicNamespaceType-Topic", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _wstop__TopicNamespaceType_Topic ** SOAP_FMAC4 soap_get_PointerTo_wstop__TopicNamespaceType_Topic(struct soap *soap, struct _wstop__TopicNamespaceType_Topic **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_wstop__TopicNamespaceType_Topic(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTowstop__TopicType(struct soap *soap, struct wstop__TopicType *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_wstop__TopicType))
		soap_serialize_wstop__TopicType(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTowstop__TopicType(struct soap *soap, const char *tag, int id, struct wstop__TopicType *const*a, const char *type)
{
	char *mark;
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_wstop__TopicType, &mark);
	if (id < 0)
		return soap->error;
	(void)soap_out_wstop__TopicType(soap, tag, id, *a, type);
	soap_unmark(soap, mark);
	return soap->error;
}

SOAP_FMAC3 struct wstop__TopicType ** SOAP_FMAC4 soap_in_PointerTowstop__TopicType(struct soap *soap, const char *tag, struct wstop__TopicType **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct wstop__TopicType **)soap_malloc(soap, sizeof(struct wstop__TopicType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_wstop__TopicType(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct wstop__TopicType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_wstop__TopicType, sizeof(struct wstop__TopicType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTowstop__TopicType(struct soap *soap, struct wstop__TopicType *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTowstop__TopicType(soap, tag ? tag : "wstop:TopicType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct wstop__TopicType ** SOAP_FMAC4 soap_get_PointerTowstop__TopicType(struct soap *soap, struct wstop__TopicType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTowstop__TopicType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTowstop__QueryExpressionType(struct soap *soap, struct wstop__QueryExpressionType *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_wstop__QueryExpressionType))
		soap_serialize_wstop__QueryExpressionType(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTowstop__QueryExpressionType(struct soap *soap, const char *tag, int id, struct wstop__QueryExpressionType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_wstop__QueryExpressionType, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_wstop__QueryExpressionType(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct wstop__QueryExpressionType ** SOAP_FMAC4 soap_in_PointerTowstop__QueryExpressionType(struct soap *soap, const char *tag, struct wstop__QueryExpressionType **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct wstop__QueryExpressionType **)soap_malloc(soap, sizeof(struct wstop__QueryExpressionType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_wstop__QueryExpressionType(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct wstop__QueryExpressionType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_wstop__QueryExpressionType, sizeof(struct wstop__QueryExpressionType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTowstop__QueryExpressionType(struct soap *soap, struct wstop__QueryExpressionType *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTowstop__QueryExpressionType(soap, tag ? tag : "wstop:QueryExpressionType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct wstop__QueryExpressionType ** SOAP_FMAC4 soap_get_PointerTowstop__QueryExpressionType(struct soap *soap, struct wstop__QueryExpressionType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTowstop__QueryExpressionType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_wsnt__ResumeFailedFaultType_FaultCause(struct soap *soap, struct _wsnt__ResumeFailedFaultType_FaultCause *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__wsnt__ResumeFailedFaultType_FaultCause))
		soap_serialize__wsnt__ResumeFailedFaultType_FaultCause(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_wsnt__ResumeFailedFaultType_FaultCause(struct soap *soap, const char *tag, int id, struct _wsnt__ResumeFailedFaultType_FaultCause *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__wsnt__ResumeFailedFaultType_FaultCause, NULL);
	if (id < 0)
		return soap->error;
	return soap_out__wsnt__ResumeFailedFaultType_FaultCause(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _wsnt__ResumeFailedFaultType_FaultCause ** SOAP_FMAC4 soap_in_PointerTo_wsnt__ResumeFailedFaultType_FaultCause(struct soap *soap, const char *tag, struct _wsnt__ResumeFailedFaultType_FaultCause **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _wsnt__ResumeFailedFaultType_FaultCause **)soap_malloc(soap, sizeof(struct _wsnt__ResumeFailedFaultType_FaultCause *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__wsnt__ResumeFailedFaultType_FaultCause(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _wsnt__ResumeFailedFaultType_FaultCause **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__wsnt__ResumeFailedFaultType_FaultCause, sizeof(struct _wsnt__ResumeFailedFaultType_FaultCause), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_wsnt__ResumeFailedFaultType_FaultCause(struct soap *soap, struct _wsnt__ResumeFailedFaultType_FaultCause *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_wsnt__ResumeFailedFaultType_FaultCause(soap, tag ? tag : "wsnt:ResumeFailedFaultType-FaultCause", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _wsnt__ResumeFailedFaultType_FaultCause ** SOAP_FMAC4 soap_get_PointerTo_wsnt__ResumeFailedFaultType_FaultCause(struct soap *soap, struct _wsnt__ResumeFailedFaultType_FaultCause **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_wsnt__ResumeFailedFaultType_FaultCause(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_wsnt__ResumeFailedFaultType_Description(struct soap *soap, struct _wsnt__ResumeFailedFaultType_Description *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__wsnt__ResumeFailedFaultType_Description))
		soap_serialize__wsnt__ResumeFailedFaultType_Description(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_wsnt__ResumeFailedFaultType_Description(struct soap *soap, const char *tag, int id, struct _wsnt__ResumeFailedFaultType_Description *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__wsnt__ResumeFailedFaultType_Description, NULL);
	if (id < 0)
		return soap->error;
	return soap_out__wsnt__ResumeFailedFaultType_Description(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _wsnt__ResumeFailedFaultType_Description ** SOAP_FMAC4 soap_in_PointerTo_wsnt__ResumeFailedFaultType_Description(struct soap *soap, const char *tag, struct _wsnt__ResumeFailedFaultType_Description **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _wsnt__ResumeFailedFaultType_Description **)soap_malloc(soap, sizeof(struct _wsnt__ResumeFailedFaultType_Description *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__wsnt__ResumeFailedFaultType_Description(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _wsnt__ResumeFailedFaultType_Description **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__wsnt__ResumeFailedFaultType_Description, sizeof(struct _wsnt__ResumeFailedFaultType_Description), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_wsnt__ResumeFailedFaultType_Description(struct soap *soap, struct _wsnt__ResumeFailedFaultType_Description *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_wsnt__ResumeFailedFaultType_Description(soap, tag ? tag : "wsnt:ResumeFailedFaultType-Description", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _wsnt__ResumeFailedFaultType_Description ** SOAP_FMAC4 soap_get_PointerTo_wsnt__ResumeFailedFaultType_Description(struct soap *soap, struct _wsnt__ResumeFailedFaultType_Description **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_wsnt__ResumeFailedFaultType_Description(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_wsnt__ResumeFailedFaultType_ErrorCode(struct soap *soap, struct _wsnt__ResumeFailedFaultType_ErrorCode *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__wsnt__ResumeFailedFaultType_ErrorCode))
		soap_serialize__wsnt__ResumeFailedFaultType_ErrorCode(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_wsnt__ResumeFailedFaultType_ErrorCode(struct soap *soap, const char *tag, int id, struct _wsnt__ResumeFailedFaultType_ErrorCode *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__wsnt__ResumeFailedFaultType_ErrorCode, NULL);
	if (id < 0)
		return soap->error;
	return soap_out__wsnt__ResumeFailedFaultType_ErrorCode(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _wsnt__ResumeFailedFaultType_ErrorCode ** SOAP_FMAC4 soap_in_PointerTo_wsnt__ResumeFailedFaultType_ErrorCode(struct soap *soap, const char *tag, struct _wsnt__ResumeFailedFaultType_ErrorCode **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _wsnt__ResumeFailedFaultType_ErrorCode **)soap_malloc(soap, sizeof(struct _wsnt__ResumeFailedFaultType_ErrorCode *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__wsnt__ResumeFailedFaultType_ErrorCode(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _wsnt__ResumeFailedFaultType_ErrorCode **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__wsnt__ResumeFailedFaultType_ErrorCode, sizeof(struct _wsnt__ResumeFailedFaultType_ErrorCode), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_wsnt__ResumeFailedFaultType_ErrorCode(struct soap *soap, struct _wsnt__ResumeFailedFaultType_ErrorCode *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_wsnt__ResumeFailedFaultType_ErrorCode(soap, tag ? tag : "wsnt:ResumeFailedFaultType-ErrorCode", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _wsnt__ResumeFailedFaultType_ErrorCode ** SOAP_FMAC4 soap_get_PointerTo_wsnt__ResumeFailedFaultType_ErrorCode(struct soap *soap, struct _wsnt__ResumeFailedFaultType_ErrorCode **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_wsnt__ResumeFailedFaultType_ErrorCode(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_wsnt__PauseFailedFaultType_FaultCause(struct soap *soap, struct _wsnt__PauseFailedFaultType_FaultCause *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__wsnt__PauseFailedFaultType_FaultCause))
		soap_serialize__wsnt__PauseFailedFaultType_FaultCause(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_wsnt__PauseFailedFaultType_FaultCause(struct soap *soap, const char *tag, int id, struct _wsnt__PauseFailedFaultType_FaultCause *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__wsnt__PauseFailedFaultType_FaultCause, NULL);
	if (id < 0)
		return soap->error;
	return soap_out__wsnt__PauseFailedFaultType_FaultCause(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _wsnt__PauseFailedFaultType_FaultCause ** SOAP_FMAC4 soap_in_PointerTo_wsnt__PauseFailedFaultType_FaultCause(struct soap *soap, const char *tag, struct _wsnt__PauseFailedFaultType_FaultCause **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _wsnt__PauseFailedFaultType_FaultCause **)soap_malloc(soap, sizeof(struct _wsnt__PauseFailedFaultType_FaultCause *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__wsnt__PauseFailedFaultType_FaultCause(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _wsnt__PauseFailedFaultType_FaultCause **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__wsnt__PauseFailedFaultType_FaultCause, sizeof(struct _wsnt__PauseFailedFaultType_FaultCause), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_wsnt__PauseFailedFaultType_FaultCause(struct soap *soap, struct _wsnt__PauseFailedFaultType_FaultCause *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_wsnt__PauseFailedFaultType_FaultCause(soap, tag ? tag : "wsnt:PauseFailedFaultType-FaultCause", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _wsnt__PauseFailedFaultType_FaultCause ** SOAP_FMAC4 soap_get_PointerTo_wsnt__PauseFailedFaultType_FaultCause(struct soap *soap, struct _wsnt__PauseFailedFaultType_FaultCause **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_wsnt__PauseFailedFaultType_FaultCause(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_wsnt__PauseFailedFaultType_Description(struct soap *soap, struct _wsnt__PauseFailedFaultType_Description *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__wsnt__PauseFailedFaultType_Description))
		soap_serialize__wsnt__PauseFailedFaultType_Description(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_wsnt__PauseFailedFaultType_Description(struct soap *soap, const char *tag, int id, struct _wsnt__PauseFailedFaultType_Description *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__wsnt__PauseFailedFaultType_Description, NULL);
	if (id < 0)
		return soap->error;
	return soap_out__wsnt__PauseFailedFaultType_Description(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _wsnt__PauseFailedFaultType_Description ** SOAP_FMAC4 soap_in_PointerTo_wsnt__PauseFailedFaultType_Description(struct soap *soap, const char *tag, struct _wsnt__PauseFailedFaultType_Description **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _wsnt__PauseFailedFaultType_Description **)soap_malloc(soap, sizeof(struct _wsnt__PauseFailedFaultType_Description *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__wsnt__PauseFailedFaultType_Description(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _wsnt__PauseFailedFaultType_Description **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__wsnt__PauseFailedFaultType_Description, sizeof(struct _wsnt__PauseFailedFaultType_Description), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_wsnt__PauseFailedFaultType_Description(struct soap *soap, struct _wsnt__PauseFailedFaultType_Description *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_wsnt__PauseFailedFaultType_Description(soap, tag ? tag : "wsnt:PauseFailedFaultType-Description", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _wsnt__PauseFailedFaultType_Description ** SOAP_FMAC4 soap_get_PointerTo_wsnt__PauseFailedFaultType_Description(struct soap *soap, struct _wsnt__PauseFailedFaultType_Description **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_wsnt__PauseFailedFaultType_Description(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_wsnt__PauseFailedFaultType_ErrorCode(struct soap *soap, struct _wsnt__PauseFailedFaultType_ErrorCode *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__wsnt__PauseFailedFaultType_ErrorCode))
		soap_serialize__wsnt__PauseFailedFaultType_ErrorCode(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_wsnt__PauseFailedFaultType_ErrorCode(struct soap *soap, const char *tag, int id, struct _wsnt__PauseFailedFaultType_ErrorCode *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__wsnt__PauseFailedFaultType_ErrorCode, NULL);
	if (id < 0)
		return soap->error;
	return soap_out__wsnt__PauseFailedFaultType_ErrorCode(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _wsnt__PauseFailedFaultType_ErrorCode ** SOAP_FMAC4 soap_in_PointerTo_wsnt__PauseFailedFaultType_ErrorCode(struct soap *soap, const char *tag, struct _wsnt__PauseFailedFaultType_ErrorCode **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _wsnt__PauseFailedFaultType_ErrorCode **)soap_malloc(soap, sizeof(struct _wsnt__PauseFailedFaultType_ErrorCode *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__wsnt__PauseFailedFaultType_ErrorCode(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _wsnt__PauseFailedFaultType_ErrorCode **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__wsnt__PauseFailedFaultType_ErrorCode, sizeof(struct _wsnt__PauseFailedFaultType_ErrorCode), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_wsnt__PauseFailedFaultType_ErrorCode(struct soap *soap, struct _wsnt__PauseFailedFaultType_ErrorCode *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_wsnt__PauseFailedFaultType_ErrorCode(soap, tag ? tag : "wsnt:PauseFailedFaultType-ErrorCode", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _wsnt__PauseFailedFaultType_ErrorCode ** SOAP_FMAC4 soap_get_PointerTo_wsnt__PauseFailedFaultType_ErrorCode(struct soap *soap, struct _wsnt__PauseFailedFaultType_ErrorCode **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_wsnt__PauseFailedFaultType_ErrorCode(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_wsnt__UnableToDestroySubscriptionFaultType_FaultCause(struct soap *soap, struct _wsnt__UnableToDestroySubscriptionFaultType_FaultCause *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__wsnt__UnableToDestroySubscriptionFaultType_FaultCause))
		soap_serialize__wsnt__UnableToDestroySubscriptionFaultType_FaultCause(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_wsnt__UnableToDestroySubscriptionFaultType_FaultCause(struct soap *soap, const char *tag, int id, struct _wsnt__UnableToDestroySubscriptionFaultType_FaultCause *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__wsnt__UnableToDestroySubscriptionFaultType_FaultCause, NULL);
	if (id < 0)
		return soap->error;
	return soap_out__wsnt__UnableToDestroySubscriptionFaultType_FaultCause(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _wsnt__UnableToDestroySubscriptionFaultType_FaultCause ** SOAP_FMAC4 soap_in_PointerTo_wsnt__UnableToDestroySubscriptionFaultType_FaultCause(struct soap *soap, const char *tag, struct _wsnt__UnableToDestroySubscriptionFaultType_FaultCause **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _wsnt__UnableToDestroySubscriptionFaultType_FaultCause **)soap_malloc(soap, sizeof(struct _wsnt__UnableToDestroySubscriptionFaultType_FaultCause *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__wsnt__UnableToDestroySubscriptionFaultType_FaultCause(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _wsnt__UnableToDestroySubscriptionFaultType_FaultCause **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__wsnt__UnableToDestroySubscriptionFaultType_FaultCause, sizeof(struct _wsnt__UnableToDestroySubscriptionFaultType_FaultCause), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_wsnt__UnableToDestroySubscriptionFaultType_FaultCause(struct soap *soap, struct _wsnt__UnableToDestroySubscriptionFaultType_FaultCause *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_wsnt__UnableToDestroySubscriptionFaultType_FaultCause(soap, tag ? tag : "wsnt:UnableToDestroySubscriptionFaultType-FaultCause", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _wsnt__UnableToDestroySubscriptionFaultType_FaultCause ** SOAP_FMAC4 soap_get_PointerTo_wsnt__UnableToDestroySubscriptionFaultType_FaultCause(struct soap *soap, struct _wsnt__UnableToDestroySubscriptionFaultType_FaultCause **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_wsnt__UnableToDestroySubscriptionFaultType_FaultCause(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_wsnt__UnableToDestroySubscriptionFaultType_Description(struct soap *soap, struct _wsnt__UnableToDestroySubscriptionFaultType_Description *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__wsnt__UnableToDestroySubscriptionFaultType_Description))
		soap_serialize__wsnt__UnableToDestroySubscriptionFaultType_Description(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_wsnt__UnableToDestroySubscriptionFaultType_Description(struct soap *soap, const char *tag, int id, struct _wsnt__UnableToDestroySubscriptionFaultType_Description *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__wsnt__UnableToDestroySubscriptionFaultType_Description, NULL);
	if (id < 0)
		return soap->error;
	return soap_out__wsnt__UnableToDestroySubscriptionFaultType_Description(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _wsnt__UnableToDestroySubscriptionFaultType_Description ** SOAP_FMAC4 soap_in_PointerTo_wsnt__UnableToDestroySubscriptionFaultType_Description(struct soap *soap, const char *tag, struct _wsnt__UnableToDestroySubscriptionFaultType_Description **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _wsnt__UnableToDestroySubscriptionFaultType_Description **)soap_malloc(soap, sizeof(struct _wsnt__UnableToDestroySubscriptionFaultType_Description *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__wsnt__UnableToDestroySubscriptionFaultType_Description(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _wsnt__UnableToDestroySubscriptionFaultType_Description **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__wsnt__UnableToDestroySubscriptionFaultType_Description, sizeof(struct _wsnt__UnableToDestroySubscriptionFaultType_Description), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_wsnt__UnableToDestroySubscriptionFaultType_Description(struct soap *soap, struct _wsnt__UnableToDestroySubscriptionFaultType_Description *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_wsnt__UnableToDestroySubscriptionFaultType_Description(soap, tag ? tag : "wsnt:UnableToDestroySubscriptionFaultType-Description", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _wsnt__UnableToDestroySubscriptionFaultType_Description ** SOAP_FMAC4 soap_get_PointerTo_wsnt__UnableToDestroySubscriptionFaultType_Description(struct soap *soap, struct _wsnt__UnableToDestroySubscriptionFaultType_Description **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_wsnt__UnableToDestroySubscriptionFaultType_Description(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_wsnt__UnableToDestroySubscriptionFaultType_ErrorCode(struct soap *soap, struct _wsnt__UnableToDestroySubscriptionFaultType_ErrorCode *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__wsnt__UnableToDestroySubscriptionFaultType_ErrorCode))
		soap_serialize__wsnt__UnableToDestroySubscriptionFaultType_ErrorCode(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_wsnt__UnableToDestroySubscriptionFaultType_ErrorCode(struct soap *soap, const char *tag, int id, struct _wsnt__UnableToDestroySubscriptionFaultType_ErrorCode *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__wsnt__UnableToDestroySubscriptionFaultType_ErrorCode, NULL);
	if (id < 0)
		return soap->error;
	return soap_out__wsnt__UnableToDestroySubscriptionFaultType_ErrorCode(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _wsnt__UnableToDestroySubscriptionFaultType_ErrorCode ** SOAP_FMAC4 soap_in_PointerTo_wsnt__UnableToDestroySubscriptionFaultType_ErrorCode(struct soap *soap, const char *tag, struct _wsnt__UnableToDestroySubscriptionFaultType_ErrorCode **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _wsnt__UnableToDestroySubscriptionFaultType_ErrorCode **)soap_malloc(soap, sizeof(struct _wsnt__UnableToDestroySubscriptionFaultType_ErrorCode *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__wsnt__UnableToDestroySubscriptionFaultType_ErrorCode(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _wsnt__UnableToDestroySubscriptionFaultType_ErrorCode **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__wsnt__UnableToDestroySubscriptionFaultType_ErrorCode, sizeof(struct _wsnt__UnableToDestroySubscriptionFaultType_ErrorCode), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_wsnt__UnableToDestroySubscriptionFaultType_ErrorCode(struct soap *soap, struct _wsnt__UnableToDestroySubscriptionFaultType_ErrorCode *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_wsnt__UnableToDestroySubscriptionFaultType_ErrorCode(soap, tag ? tag : "wsnt:UnableToDestroySubscriptionFaultType-ErrorCode", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _wsnt__UnableToDestroySubscriptionFaultType_ErrorCode ** SOAP_FMAC4 soap_get_PointerTo_wsnt__UnableToDestroySubscriptionFaultType_ErrorCode(struct soap *soap, struct _wsnt__UnableToDestroySubscriptionFaultType_ErrorCode **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_wsnt__UnableToDestroySubscriptionFaultType_ErrorCode(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_wsnt__UnacceptableTerminationTimeFaultType_FaultCause(struct soap *soap, struct _wsnt__UnacceptableTerminationTimeFaultType_FaultCause *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__wsnt__UnacceptableTerminationTimeFaultType_FaultCause))
		soap_serialize__wsnt__UnacceptableTerminationTimeFaultType_FaultCause(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_wsnt__UnacceptableTerminationTimeFaultType_FaultCause(struct soap *soap, const char *tag, int id, struct _wsnt__UnacceptableTerminationTimeFaultType_FaultCause *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__wsnt__UnacceptableTerminationTimeFaultType_FaultCause, NULL);
	if (id < 0)
		return soap->error;
	return soap_out__wsnt__UnacceptableTerminationTimeFaultType_FaultCause(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _wsnt__UnacceptableTerminationTimeFaultType_FaultCause ** SOAP_FMAC4 soap_in_PointerTo_wsnt__UnacceptableTerminationTimeFaultType_FaultCause(struct soap *soap, const char *tag, struct _wsnt__UnacceptableTerminationTimeFaultType_FaultCause **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _wsnt__UnacceptableTerminationTimeFaultType_FaultCause **)soap_malloc(soap, sizeof(struct _wsnt__UnacceptableTerminationTimeFaultType_FaultCause *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__wsnt__UnacceptableTerminationTimeFaultType_FaultCause(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _wsnt__UnacceptableTerminationTimeFaultType_FaultCause **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__wsnt__UnacceptableTerminationTimeFaultType_FaultCause, sizeof(struct _wsnt__UnacceptableTerminationTimeFaultType_FaultCause), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_wsnt__UnacceptableTerminationTimeFaultType_FaultCause(struct soap *soap, struct _wsnt__UnacceptableTerminationTimeFaultType_FaultCause *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_wsnt__UnacceptableTerminationTimeFaultType_FaultCause(soap, tag ? tag : "wsnt:UnacceptableTerminationTimeFaultType-FaultCause", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _wsnt__UnacceptableTerminationTimeFaultType_FaultCause ** SOAP_FMAC4 soap_get_PointerTo_wsnt__UnacceptableTerminationTimeFaultType_FaultCause(struct soap *soap, struct _wsnt__UnacceptableTerminationTimeFaultType_FaultCause **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_wsnt__UnacceptableTerminationTimeFaultType_FaultCause(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_wsnt__UnacceptableTerminationTimeFaultType_Description(struct soap *soap, struct _wsnt__UnacceptableTerminationTimeFaultType_Description *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__wsnt__UnacceptableTerminationTimeFaultType_Description))
		soap_serialize__wsnt__UnacceptableTerminationTimeFaultType_Description(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_wsnt__UnacceptableTerminationTimeFaultType_Description(struct soap *soap, const char *tag, int id, struct _wsnt__UnacceptableTerminationTimeFaultType_Description *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__wsnt__UnacceptableTerminationTimeFaultType_Description, NULL);
	if (id < 0)
		return soap->error;
	return soap_out__wsnt__UnacceptableTerminationTimeFaultType_Description(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _wsnt__UnacceptableTerminationTimeFaultType_Description ** SOAP_FMAC4 soap_in_PointerTo_wsnt__UnacceptableTerminationTimeFaultType_Description(struct soap *soap, const char *tag, struct _wsnt__UnacceptableTerminationTimeFaultType_Description **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _wsnt__UnacceptableTerminationTimeFaultType_Description **)soap_malloc(soap, sizeof(struct _wsnt__UnacceptableTerminationTimeFaultType_Description *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__wsnt__UnacceptableTerminationTimeFaultType_Description(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _wsnt__UnacceptableTerminationTimeFaultType_Description **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__wsnt__UnacceptableTerminationTimeFaultType_Description, sizeof(struct _wsnt__UnacceptableTerminationTimeFaultType_Description), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_wsnt__UnacceptableTerminationTimeFaultType_Description(struct soap *soap, struct _wsnt__UnacceptableTerminationTimeFaultType_Description *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_wsnt__UnacceptableTerminationTimeFaultType_Description(soap, tag ? tag : "wsnt:UnacceptableTerminationTimeFaultType-Description", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _wsnt__UnacceptableTerminationTimeFaultType_Description ** SOAP_FMAC4 soap_get_PointerTo_wsnt__UnacceptableTerminationTimeFaultType_Description(struct soap *soap, struct _wsnt__UnacceptableTerminationTimeFaultType_Description **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_wsnt__UnacceptableTerminationTimeFaultType_Description(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_wsnt__UnacceptableTerminationTimeFaultType_ErrorCode(struct soap *soap, struct _wsnt__UnacceptableTerminationTimeFaultType_ErrorCode *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__wsnt__UnacceptableTerminationTimeFaultType_ErrorCode))
		soap_serialize__wsnt__UnacceptableTerminationTimeFaultType_ErrorCode(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_wsnt__UnacceptableTerminationTimeFaultType_ErrorCode(struct soap *soap, const char *tag, int id, struct _wsnt__UnacceptableTerminationTimeFaultType_ErrorCode *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__wsnt__UnacceptableTerminationTimeFaultType_ErrorCode, NULL);
	if (id < 0)
		return soap->error;
	return soap_out__wsnt__UnacceptableTerminationTimeFaultType_ErrorCode(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _wsnt__UnacceptableTerminationTimeFaultType_ErrorCode ** SOAP_FMAC4 soap_in_PointerTo_wsnt__UnacceptableTerminationTimeFaultType_ErrorCode(struct soap *soap, const char *tag, struct _wsnt__UnacceptableTerminationTimeFaultType_ErrorCode **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _wsnt__UnacceptableTerminationTimeFaultType_ErrorCode **)soap_malloc(soap, sizeof(struct _wsnt__UnacceptableTerminationTimeFaultType_ErrorCode *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__wsnt__UnacceptableTerminationTimeFaultType_ErrorCode(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _wsnt__UnacceptableTerminationTimeFaultType_ErrorCode **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__wsnt__UnacceptableTerminationTimeFaultType_ErrorCode, sizeof(struct _wsnt__UnacceptableTerminationTimeFaultType_ErrorCode), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_wsnt__UnacceptableTerminationTimeFaultType_ErrorCode(struct soap *soap, struct _wsnt__UnacceptableTerminationTimeFaultType_ErrorCode *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_wsnt__UnacceptableTerminationTimeFaultType_ErrorCode(soap, tag ? tag : "wsnt:UnacceptableTerminationTimeFaultType-ErrorCode", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _wsnt__UnacceptableTerminationTimeFaultType_ErrorCode ** SOAP_FMAC4 soap_get_PointerTo_wsnt__UnacceptableTerminationTimeFaultType_ErrorCode(struct soap *soap, struct _wsnt__UnacceptableTerminationTimeFaultType_ErrorCode **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_wsnt__UnacceptableTerminationTimeFaultType_ErrorCode(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_wsnt__UnableToCreatePullPointFaultType_FaultCause(struct soap *soap, struct _wsnt__UnableToCreatePullPointFaultType_FaultCause *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__wsnt__UnableToCreatePullPointFaultType_FaultCause))
		soap_serialize__wsnt__UnableToCreatePullPointFaultType_FaultCause(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_wsnt__UnableToCreatePullPointFaultType_FaultCause(struct soap *soap, const char *tag, int id, struct _wsnt__UnableToCreatePullPointFaultType_FaultCause *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__wsnt__UnableToCreatePullPointFaultType_FaultCause, NULL);
	if (id < 0)
		return soap->error;
	return soap_out__wsnt__UnableToCreatePullPointFaultType_FaultCause(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _wsnt__UnableToCreatePullPointFaultType_FaultCause ** SOAP_FMAC4 soap_in_PointerTo_wsnt__UnableToCreatePullPointFaultType_FaultCause(struct soap *soap, const char *tag, struct _wsnt__UnableToCreatePullPointFaultType_FaultCause **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _wsnt__UnableToCreatePullPointFaultType_FaultCause **)soap_malloc(soap, sizeof(struct _wsnt__UnableToCreatePullPointFaultType_FaultCause *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__wsnt__UnableToCreatePullPointFaultType_FaultCause(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _wsnt__UnableToCreatePullPointFaultType_FaultCause **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__wsnt__UnableToCreatePullPointFaultType_FaultCause, sizeof(struct _wsnt__UnableToCreatePullPointFaultType_FaultCause), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_wsnt__UnableToCreatePullPointFaultType_FaultCause(struct soap *soap, struct _wsnt__UnableToCreatePullPointFaultType_FaultCause *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_wsnt__UnableToCreatePullPointFaultType_FaultCause(soap, tag ? tag : "wsnt:UnableToCreatePullPointFaultType-FaultCause", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _wsnt__UnableToCreatePullPointFaultType_FaultCause ** SOAP_FMAC4 soap_get_PointerTo_wsnt__UnableToCreatePullPointFaultType_FaultCause(struct soap *soap, struct _wsnt__UnableToCreatePullPointFaultType_FaultCause **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_wsnt__UnableToCreatePullPointFaultType_FaultCause(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_wsnt__UnableToCreatePullPointFaultType_Description(struct soap *soap, struct _wsnt__UnableToCreatePullPointFaultType_Description *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__wsnt__UnableToCreatePullPointFaultType_Description))
		soap_serialize__wsnt__UnableToCreatePullPointFaultType_Description(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_wsnt__UnableToCreatePullPointFaultType_Description(struct soap *soap, const char *tag, int id, struct _wsnt__UnableToCreatePullPointFaultType_Description *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__wsnt__UnableToCreatePullPointFaultType_Description, NULL);
	if (id < 0)
		return soap->error;
	return soap_out__wsnt__UnableToCreatePullPointFaultType_Description(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _wsnt__UnableToCreatePullPointFaultType_Description ** SOAP_FMAC4 soap_in_PointerTo_wsnt__UnableToCreatePullPointFaultType_Description(struct soap *soap, const char *tag, struct _wsnt__UnableToCreatePullPointFaultType_Description **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _wsnt__UnableToCreatePullPointFaultType_Description **)soap_malloc(soap, sizeof(struct _wsnt__UnableToCreatePullPointFaultType_Description *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__wsnt__UnableToCreatePullPointFaultType_Description(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _wsnt__UnableToCreatePullPointFaultType_Description **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__wsnt__UnableToCreatePullPointFaultType_Description, sizeof(struct _wsnt__UnableToCreatePullPointFaultType_Description), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_wsnt__UnableToCreatePullPointFaultType_Description(struct soap *soap, struct _wsnt__UnableToCreatePullPointFaultType_Description *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_wsnt__UnableToCreatePullPointFaultType_Description(soap, tag ? tag : "wsnt:UnableToCreatePullPointFaultType-Description", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _wsnt__UnableToCreatePullPointFaultType_Description ** SOAP_FMAC4 soap_get_PointerTo_wsnt__UnableToCreatePullPointFaultType_Description(struct soap *soap, struct _wsnt__UnableToCreatePullPointFaultType_Description **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_wsnt__UnableToCreatePullPointFaultType_Description(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_wsnt__UnableToCreatePullPointFaultType_ErrorCode(struct soap *soap, struct _wsnt__UnableToCreatePullPointFaultType_ErrorCode *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__wsnt__UnableToCreatePullPointFaultType_ErrorCode))
		soap_serialize__wsnt__UnableToCreatePullPointFaultType_ErrorCode(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_wsnt__UnableToCreatePullPointFaultType_ErrorCode(struct soap *soap, const char *tag, int id, struct _wsnt__UnableToCreatePullPointFaultType_ErrorCode *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__wsnt__UnableToCreatePullPointFaultType_ErrorCode, NULL);
	if (id < 0)
		return soap->error;
	return soap_out__wsnt__UnableToCreatePullPointFaultType_ErrorCode(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _wsnt__UnableToCreatePullPointFaultType_ErrorCode ** SOAP_FMAC4 soap_in_PointerTo_wsnt__UnableToCreatePullPointFaultType_ErrorCode(struct soap *soap, const char *tag, struct _wsnt__UnableToCreatePullPointFaultType_ErrorCode **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _wsnt__UnableToCreatePullPointFaultType_ErrorCode **)soap_malloc(soap, sizeof(struct _wsnt__UnableToCreatePullPointFaultType_ErrorCode *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__wsnt__UnableToCreatePullPointFaultType_ErrorCode(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _wsnt__UnableToCreatePullPointFaultType_ErrorCode **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__wsnt__UnableToCreatePullPointFaultType_ErrorCode, sizeof(struct _wsnt__UnableToCreatePullPointFaultType_ErrorCode), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_wsnt__UnableToCreatePullPointFaultType_ErrorCode(struct soap *soap, struct _wsnt__UnableToCreatePullPointFaultType_ErrorCode *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_wsnt__UnableToCreatePullPointFaultType_ErrorCode(soap, tag ? tag : "wsnt:UnableToCreatePullPointFaultType-ErrorCode", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _wsnt__UnableToCreatePullPointFaultType_ErrorCode ** SOAP_FMAC4 soap_get_PointerTo_wsnt__UnableToCreatePullPointFaultType_ErrorCode(struct soap *soap, struct _wsnt__UnableToCreatePullPointFaultType_ErrorCode **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_wsnt__UnableToCreatePullPointFaultType_ErrorCode(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_wsnt__UnableToDestroyPullPointFaultType_FaultCause(struct soap *soap, struct _wsnt__UnableToDestroyPullPointFaultType_FaultCause *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__wsnt__UnableToDestroyPullPointFaultType_FaultCause))
		soap_serialize__wsnt__UnableToDestroyPullPointFaultType_FaultCause(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_wsnt__UnableToDestroyPullPointFaultType_FaultCause(struct soap *soap, const char *tag, int id, struct _wsnt__UnableToDestroyPullPointFaultType_FaultCause *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__wsnt__UnableToDestroyPullPointFaultType_FaultCause, NULL);
	if (id < 0)
		return soap->error;
	return soap_out__wsnt__UnableToDestroyPullPointFaultType_FaultCause(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _wsnt__UnableToDestroyPullPointFaultType_FaultCause ** SOAP_FMAC4 soap_in_PointerTo_wsnt__UnableToDestroyPullPointFaultType_FaultCause(struct soap *soap, const char *tag, struct _wsnt__UnableToDestroyPullPointFaultType_FaultCause **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _wsnt__UnableToDestroyPullPointFaultType_FaultCause **)soap_malloc(soap, sizeof(struct _wsnt__UnableToDestroyPullPointFaultType_FaultCause *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__wsnt__UnableToDestroyPullPointFaultType_FaultCause(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _wsnt__UnableToDestroyPullPointFaultType_FaultCause **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__wsnt__UnableToDestroyPullPointFaultType_FaultCause, sizeof(struct _wsnt__UnableToDestroyPullPointFaultType_FaultCause), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_wsnt__UnableToDestroyPullPointFaultType_FaultCause(struct soap *soap, struct _wsnt__UnableToDestroyPullPointFaultType_FaultCause *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_wsnt__UnableToDestroyPullPointFaultType_FaultCause(soap, tag ? tag : "wsnt:UnableToDestroyPullPointFaultType-FaultCause", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _wsnt__UnableToDestroyPullPointFaultType_FaultCause ** SOAP_FMAC4 soap_get_PointerTo_wsnt__UnableToDestroyPullPointFaultType_FaultCause(struct soap *soap, struct _wsnt__UnableToDestroyPullPointFaultType_FaultCause **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_wsnt__UnableToDestroyPullPointFaultType_FaultCause(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_wsnt__UnableToDestroyPullPointFaultType_Description(struct soap *soap, struct _wsnt__UnableToDestroyPullPointFaultType_Description *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__wsnt__UnableToDestroyPullPointFaultType_Description))
		soap_serialize__wsnt__UnableToDestroyPullPointFaultType_Description(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_wsnt__UnableToDestroyPullPointFaultType_Description(struct soap *soap, const char *tag, int id, struct _wsnt__UnableToDestroyPullPointFaultType_Description *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__wsnt__UnableToDestroyPullPointFaultType_Description, NULL);
	if (id < 0)
		return soap->error;
	return soap_out__wsnt__UnableToDestroyPullPointFaultType_Description(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _wsnt__UnableToDestroyPullPointFaultType_Description ** SOAP_FMAC4 soap_in_PointerTo_wsnt__UnableToDestroyPullPointFaultType_Description(struct soap *soap, const char *tag, struct _wsnt__UnableToDestroyPullPointFaultType_Description **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _wsnt__UnableToDestroyPullPointFaultType_Description **)soap_malloc(soap, sizeof(struct _wsnt__UnableToDestroyPullPointFaultType_Description *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__wsnt__UnableToDestroyPullPointFaultType_Description(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _wsnt__UnableToDestroyPullPointFaultType_Description **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__wsnt__UnableToDestroyPullPointFaultType_Description, sizeof(struct _wsnt__UnableToDestroyPullPointFaultType_Description), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_wsnt__UnableToDestroyPullPointFaultType_Description(struct soap *soap, struct _wsnt__UnableToDestroyPullPointFaultType_Description *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_wsnt__UnableToDestroyPullPointFaultType_Description(soap, tag ? tag : "wsnt:UnableToDestroyPullPointFaultType-Description", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _wsnt__UnableToDestroyPullPointFaultType_Description ** SOAP_FMAC4 soap_get_PointerTo_wsnt__UnableToDestroyPullPointFaultType_Description(struct soap *soap, struct _wsnt__UnableToDestroyPullPointFaultType_Description **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_wsnt__UnableToDestroyPullPointFaultType_Description(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_wsnt__UnableToDestroyPullPointFaultType_ErrorCode(struct soap *soap, struct _wsnt__UnableToDestroyPullPointFaultType_ErrorCode *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__wsnt__UnableToDestroyPullPointFaultType_ErrorCode))
		soap_serialize__wsnt__UnableToDestroyPullPointFaultType_ErrorCode(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_wsnt__UnableToDestroyPullPointFaultType_ErrorCode(struct soap *soap, const char *tag, int id, struct _wsnt__UnableToDestroyPullPointFaultType_ErrorCode *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__wsnt__UnableToDestroyPullPointFaultType_ErrorCode, NULL);
	if (id < 0)
		return soap->error;
	return soap_out__wsnt__UnableToDestroyPullPointFaultType_ErrorCode(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _wsnt__UnableToDestroyPullPointFaultType_ErrorCode ** SOAP_FMAC4 soap_in_PointerTo_wsnt__UnableToDestroyPullPointFaultType_ErrorCode(struct soap *soap, const char *tag, struct _wsnt__UnableToDestroyPullPointFaultType_ErrorCode **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _wsnt__UnableToDestroyPullPointFaultType_ErrorCode **)soap_malloc(soap, sizeof(struct _wsnt__UnableToDestroyPullPointFaultType_ErrorCode *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__wsnt__UnableToDestroyPullPointFaultType_ErrorCode(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _wsnt__UnableToDestroyPullPointFaultType_ErrorCode **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__wsnt__UnableToDestroyPullPointFaultType_ErrorCode, sizeof(struct _wsnt__UnableToDestroyPullPointFaultType_ErrorCode), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_wsnt__UnableToDestroyPullPointFaultType_ErrorCode(struct soap *soap, struct _wsnt__UnableToDestroyPullPointFaultType_ErrorCode *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_wsnt__UnableToDestroyPullPointFaultType_ErrorCode(soap, tag ? tag : "wsnt:UnableToDestroyPullPointFaultType-ErrorCode", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _wsnt__UnableToDestroyPullPointFaultType_ErrorCode ** SOAP_FMAC4 soap_get_PointerTo_wsnt__UnableToDestroyPullPointFaultType_ErrorCode(struct soap *soap, struct _wsnt__UnableToDestroyPullPointFaultType_ErrorCode **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_wsnt__UnableToDestroyPullPointFaultType_ErrorCode(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_wsnt__UnableToGetMessagesFaultType_FaultCause(struct soap *soap, struct _wsnt__UnableToGetMessagesFaultType_FaultCause *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__wsnt__UnableToGetMessagesFaultType_FaultCause))
		soap_serialize__wsnt__UnableToGetMessagesFaultType_FaultCause(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_wsnt__UnableToGetMessagesFaultType_FaultCause(struct soap *soap, const char *tag, int id, struct _wsnt__UnableToGetMessagesFaultType_FaultCause *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__wsnt__UnableToGetMessagesFaultType_FaultCause, NULL);
	if (id < 0)
		return soap->error;
	return soap_out__wsnt__UnableToGetMessagesFaultType_FaultCause(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _wsnt__UnableToGetMessagesFaultType_FaultCause ** SOAP_FMAC4 soap_in_PointerTo_wsnt__UnableToGetMessagesFaultType_FaultCause(struct soap *soap, const char *tag, struct _wsnt__UnableToGetMessagesFaultType_FaultCause **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _wsnt__UnableToGetMessagesFaultType_FaultCause **)soap_malloc(soap, sizeof(struct _wsnt__UnableToGetMessagesFaultType_FaultCause *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__wsnt__UnableToGetMessagesFaultType_FaultCause(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _wsnt__UnableToGetMessagesFaultType_FaultCause **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__wsnt__UnableToGetMessagesFaultType_FaultCause, sizeof(struct _wsnt__UnableToGetMessagesFaultType_FaultCause), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_wsnt__UnableToGetMessagesFaultType_FaultCause(struct soap *soap, struct _wsnt__UnableToGetMessagesFaultType_FaultCause *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_wsnt__UnableToGetMessagesFaultType_FaultCause(soap, tag ? tag : "wsnt:UnableToGetMessagesFaultType-FaultCause", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _wsnt__UnableToGetMessagesFaultType_FaultCause ** SOAP_FMAC4 soap_get_PointerTo_wsnt__UnableToGetMessagesFaultType_FaultCause(struct soap *soap, struct _wsnt__UnableToGetMessagesFaultType_FaultCause **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_wsnt__UnableToGetMessagesFaultType_FaultCause(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_wsnt__UnableToGetMessagesFaultType_Description(struct soap *soap, struct _wsnt__UnableToGetMessagesFaultType_Description *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__wsnt__UnableToGetMessagesFaultType_Description))
		soap_serialize__wsnt__UnableToGetMessagesFaultType_Description(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_wsnt__UnableToGetMessagesFaultType_Description(struct soap *soap, const char *tag, int id, struct _wsnt__UnableToGetMessagesFaultType_Description *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__wsnt__UnableToGetMessagesFaultType_Description, NULL);
	if (id < 0)
		return soap->error;
	return soap_out__wsnt__UnableToGetMessagesFaultType_Description(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _wsnt__UnableToGetMessagesFaultType_Description ** SOAP_FMAC4 soap_in_PointerTo_wsnt__UnableToGetMessagesFaultType_Description(struct soap *soap, const char *tag, struct _wsnt__UnableToGetMessagesFaultType_Description **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _wsnt__UnableToGetMessagesFaultType_Description **)soap_malloc(soap, sizeof(struct _wsnt__UnableToGetMessagesFaultType_Description *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__wsnt__UnableToGetMessagesFaultType_Description(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _wsnt__UnableToGetMessagesFaultType_Description **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__wsnt__UnableToGetMessagesFaultType_Description, sizeof(struct _wsnt__UnableToGetMessagesFaultType_Description), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_wsnt__UnableToGetMessagesFaultType_Description(struct soap *soap, struct _wsnt__UnableToGetMessagesFaultType_Description *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_wsnt__UnableToGetMessagesFaultType_Description(soap, tag ? tag : "wsnt:UnableToGetMessagesFaultType-Description", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _wsnt__UnableToGetMessagesFaultType_Description ** SOAP_FMAC4 soap_get_PointerTo_wsnt__UnableToGetMessagesFaultType_Description(struct soap *soap, struct _wsnt__UnableToGetMessagesFaultType_Description **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_wsnt__UnableToGetMessagesFaultType_Description(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_wsnt__UnableToGetMessagesFaultType_ErrorCode(struct soap *soap, struct _wsnt__UnableToGetMessagesFaultType_ErrorCode *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__wsnt__UnableToGetMessagesFaultType_ErrorCode))
		soap_serialize__wsnt__UnableToGetMessagesFaultType_ErrorCode(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_wsnt__UnableToGetMessagesFaultType_ErrorCode(struct soap *soap, const char *tag, int id, struct _wsnt__UnableToGetMessagesFaultType_ErrorCode *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__wsnt__UnableToGetMessagesFaultType_ErrorCode, NULL);
	if (id < 0)
		return soap->error;
	return soap_out__wsnt__UnableToGetMessagesFaultType_ErrorCode(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _wsnt__UnableToGetMessagesFaultType_ErrorCode ** SOAP_FMAC4 soap_in_PointerTo_wsnt__UnableToGetMessagesFaultType_ErrorCode(struct soap *soap, const char *tag, struct _wsnt__UnableToGetMessagesFaultType_ErrorCode **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _wsnt__UnableToGetMessagesFaultType_ErrorCode **)soap_malloc(soap, sizeof(struct _wsnt__UnableToGetMessagesFaultType_ErrorCode *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__wsnt__UnableToGetMessagesFaultType_ErrorCode(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _wsnt__UnableToGetMessagesFaultType_ErrorCode **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__wsnt__UnableToGetMessagesFaultType_ErrorCode, sizeof(struct _wsnt__UnableToGetMessagesFaultType_ErrorCode), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_wsnt__UnableToGetMessagesFaultType_ErrorCode(struct soap *soap, struct _wsnt__UnableToGetMessagesFaultType_ErrorCode *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_wsnt__UnableToGetMessagesFaultType_ErrorCode(soap, tag ? tag : "wsnt:UnableToGetMessagesFaultType-ErrorCode", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _wsnt__UnableToGetMessagesFaultType_ErrorCode ** SOAP_FMAC4 soap_get_PointerTo_wsnt__UnableToGetMessagesFaultType_ErrorCode(struct soap *soap, struct _wsnt__UnableToGetMessagesFaultType_ErrorCode **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_wsnt__UnableToGetMessagesFaultType_ErrorCode(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_wsnt__NoCurrentMessageOnTopicFaultType_FaultCause(struct soap *soap, struct _wsnt__NoCurrentMessageOnTopicFaultType_FaultCause *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__wsnt__NoCurrentMessageOnTopicFaultType_FaultCause))
		soap_serialize__wsnt__NoCurrentMessageOnTopicFaultType_FaultCause(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_wsnt__NoCurrentMessageOnTopicFaultType_FaultCause(struct soap *soap, const char *tag, int id, struct _wsnt__NoCurrentMessageOnTopicFaultType_FaultCause *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__wsnt__NoCurrentMessageOnTopicFaultType_FaultCause, NULL);
	if (id < 0)
		return soap->error;
	return soap_out__wsnt__NoCurrentMessageOnTopicFaultType_FaultCause(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _wsnt__NoCurrentMessageOnTopicFaultType_FaultCause ** SOAP_FMAC4 soap_in_PointerTo_wsnt__NoCurrentMessageOnTopicFaultType_FaultCause(struct soap *soap, const char *tag, struct _wsnt__NoCurrentMessageOnTopicFaultType_FaultCause **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _wsnt__NoCurrentMessageOnTopicFaultType_FaultCause **)soap_malloc(soap, sizeof(struct _wsnt__NoCurrentMessageOnTopicFaultType_FaultCause *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__wsnt__NoCurrentMessageOnTopicFaultType_FaultCause(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _wsnt__NoCurrentMessageOnTopicFaultType_FaultCause **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__wsnt__NoCurrentMessageOnTopicFaultType_FaultCause, sizeof(struct _wsnt__NoCurrentMessageOnTopicFaultType_FaultCause), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_wsnt__NoCurrentMessageOnTopicFaultType_FaultCause(struct soap *soap, struct _wsnt__NoCurrentMessageOnTopicFaultType_FaultCause *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_wsnt__NoCurrentMessageOnTopicFaultType_FaultCause(soap, tag ? tag : "wsnt:NoCurrentMessageOnTopicFaultType-FaultCause", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _wsnt__NoCurrentMessageOnTopicFaultType_FaultCause ** SOAP_FMAC4 soap_get_PointerTo_wsnt__NoCurrentMessageOnTopicFaultType_FaultCause(struct soap *soap, struct _wsnt__NoCurrentMessageOnTopicFaultType_FaultCause **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_wsnt__NoCurrentMessageOnTopicFaultType_FaultCause(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_wsnt__NoCurrentMessageOnTopicFaultType_Description(struct soap *soap, struct _wsnt__NoCurrentMessageOnTopicFaultType_Description *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__wsnt__NoCurrentMessageOnTopicFaultType_Description))
		soap_serialize__wsnt__NoCurrentMessageOnTopicFaultType_Description(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_wsnt__NoCurrentMessageOnTopicFaultType_Description(struct soap *soap, const char *tag, int id, struct _wsnt__NoCurrentMessageOnTopicFaultType_Description *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__wsnt__NoCurrentMessageOnTopicFaultType_Description, NULL);
	if (id < 0)
		return soap->error;
	return soap_out__wsnt__NoCurrentMessageOnTopicFaultType_Description(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _wsnt__NoCurrentMessageOnTopicFaultType_Description ** SOAP_FMAC4 soap_in_PointerTo_wsnt__NoCurrentMessageOnTopicFaultType_Description(struct soap *soap, const char *tag, struct _wsnt__NoCurrentMessageOnTopicFaultType_Description **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _wsnt__NoCurrentMessageOnTopicFaultType_Description **)soap_malloc(soap, sizeof(struct _wsnt__NoCurrentMessageOnTopicFaultType_Description *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__wsnt__NoCurrentMessageOnTopicFaultType_Description(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _wsnt__NoCurrentMessageOnTopicFaultType_Description **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__wsnt__NoCurrentMessageOnTopicFaultType_Description, sizeof(struct _wsnt__NoCurrentMessageOnTopicFaultType_Description), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_wsnt__NoCurrentMessageOnTopicFaultType_Description(struct soap *soap, struct _wsnt__NoCurrentMessageOnTopicFaultType_Description *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_wsnt__NoCurrentMessageOnTopicFaultType_Description(soap, tag ? tag : "wsnt:NoCurrentMessageOnTopicFaultType-Description", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _wsnt__NoCurrentMessageOnTopicFaultType_Description ** SOAP_FMAC4 soap_get_PointerTo_wsnt__NoCurrentMessageOnTopicFaultType_Description(struct soap *soap, struct _wsnt__NoCurrentMessageOnTopicFaultType_Description **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_wsnt__NoCurrentMessageOnTopicFaultType_Description(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_wsnt__NoCurrentMessageOnTopicFaultType_ErrorCode(struct soap *soap, struct _wsnt__NoCurrentMessageOnTopicFaultType_ErrorCode *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__wsnt__NoCurrentMessageOnTopicFaultType_ErrorCode))
		soap_serialize__wsnt__NoCurrentMessageOnTopicFaultType_ErrorCode(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_wsnt__NoCurrentMessageOnTopicFaultType_ErrorCode(struct soap *soap, const char *tag, int id, struct _wsnt__NoCurrentMessageOnTopicFaultType_ErrorCode *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__wsnt__NoCurrentMessageOnTopicFaultType_ErrorCode, NULL);
	if (id < 0)
		return soap->error;
	return soap_out__wsnt__NoCurrentMessageOnTopicFaultType_ErrorCode(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _wsnt__NoCurrentMessageOnTopicFaultType_ErrorCode ** SOAP_FMAC4 soap_in_PointerTo_wsnt__NoCurrentMessageOnTopicFaultType_ErrorCode(struct soap *soap, const char *tag, struct _wsnt__NoCurrentMessageOnTopicFaultType_ErrorCode **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _wsnt__NoCurrentMessageOnTopicFaultType_ErrorCode **)soap_malloc(soap, sizeof(struct _wsnt__NoCurrentMessageOnTopicFaultType_ErrorCode *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__wsnt__NoCurrentMessageOnTopicFaultType_ErrorCode(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _wsnt__NoCurrentMessageOnTopicFaultType_ErrorCode **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__wsnt__NoCurrentMessageOnTopicFaultType_ErrorCode, sizeof(struct _wsnt__NoCurrentMessageOnTopicFaultType_ErrorCode), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_wsnt__NoCurrentMessageOnTopicFaultType_ErrorCode(struct soap *soap, struct _wsnt__NoCurrentMessageOnTopicFaultType_ErrorCode *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_wsnt__NoCurrentMessageOnTopicFaultType_ErrorCode(soap, tag ? tag : "wsnt:NoCurrentMessageOnTopicFaultType-ErrorCode", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _wsnt__NoCurrentMessageOnTopicFaultType_ErrorCode ** SOAP_FMAC4 soap_get_PointerTo_wsnt__NoCurrentMessageOnTopicFaultType_ErrorCode(struct soap *soap, struct _wsnt__NoCurrentMessageOnTopicFaultType_ErrorCode **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_wsnt__NoCurrentMessageOnTopicFaultType_ErrorCode(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_wsnt__UnacceptableInitialTerminationTimeFaultType_FaultCause(struct soap *soap, struct _wsnt__UnacceptableInitialTerminationTimeFaultType_FaultCause *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__wsnt__UnacceptableInitialTerminationTimeFaultType_FaultCause))
		soap_serialize__wsnt__UnacceptableInitialTerminationTimeFaultType_FaultCause(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_wsnt__UnacceptableInitialTerminationTimeFaultType_FaultCause(struct soap *soap, const char *tag, int id, struct _wsnt__UnacceptableInitialTerminationTimeFaultType_FaultCause *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__wsnt__UnacceptableInitialTerminationTimeFaultType_FaultCause, NULL);
	if (id < 0)
		return soap->error;
	return soap_out__wsnt__UnacceptableInitialTerminationTimeFaultType_FaultCause(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _wsnt__UnacceptableInitialTerminationTimeFaultType_FaultCause ** SOAP_FMAC4 soap_in_PointerTo_wsnt__UnacceptableInitialTerminationTimeFaultType_FaultCause(struct soap *soap, const char *tag, struct _wsnt__UnacceptableInitialTerminationTimeFaultType_FaultCause **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _wsnt__UnacceptableInitialTerminationTimeFaultType_FaultCause **)soap_malloc(soap, sizeof(struct _wsnt__UnacceptableInitialTerminationTimeFaultType_FaultCause *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__wsnt__UnacceptableInitialTerminationTimeFaultType_FaultCause(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _wsnt__UnacceptableInitialTerminationTimeFaultType_FaultCause **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__wsnt__UnacceptableInitialTerminationTimeFaultType_FaultCause, sizeof(struct _wsnt__UnacceptableInitialTerminationTimeFaultType_FaultCause), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_wsnt__UnacceptableInitialTerminationTimeFaultType_FaultCause(struct soap *soap, struct _wsnt__UnacceptableInitialTerminationTimeFaultType_FaultCause *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_wsnt__UnacceptableInitialTerminationTimeFaultType_FaultCause(soap, tag ? tag : "wsnt:UnacceptableInitialTerminationTimeFaultType-FaultCause", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _wsnt__UnacceptableInitialTerminationTimeFaultType_FaultCause ** SOAP_FMAC4 soap_get_PointerTo_wsnt__UnacceptableInitialTerminationTimeFaultType_FaultCause(struct soap *soap, struct _wsnt__UnacceptableInitialTerminationTimeFaultType_FaultCause **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_wsnt__UnacceptableInitialTerminationTimeFaultType_FaultCause(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_wsnt__UnacceptableInitialTerminationTimeFaultType_Description(struct soap *soap, struct _wsnt__UnacceptableInitialTerminationTimeFaultType_Description *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__wsnt__UnacceptableInitialTerminationTimeFaultType_Description))
		soap_serialize__wsnt__UnacceptableInitialTerminationTimeFaultType_Description(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_wsnt__UnacceptableInitialTerminationTimeFaultType_Description(struct soap *soap, const char *tag, int id, struct _wsnt__UnacceptableInitialTerminationTimeFaultType_Description *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__wsnt__UnacceptableInitialTerminationTimeFaultType_Description, NULL);
	if (id < 0)
		return soap->error;
	return soap_out__wsnt__UnacceptableInitialTerminationTimeFaultType_Description(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _wsnt__UnacceptableInitialTerminationTimeFaultType_Description ** SOAP_FMAC4 soap_in_PointerTo_wsnt__UnacceptableInitialTerminationTimeFaultType_Description(struct soap *soap, const char *tag, struct _wsnt__UnacceptableInitialTerminationTimeFaultType_Description **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _wsnt__UnacceptableInitialTerminationTimeFaultType_Description **)soap_malloc(soap, sizeof(struct _wsnt__UnacceptableInitialTerminationTimeFaultType_Description *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__wsnt__UnacceptableInitialTerminationTimeFaultType_Description(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _wsnt__UnacceptableInitialTerminationTimeFaultType_Description **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__wsnt__UnacceptableInitialTerminationTimeFaultType_Description, sizeof(struct _wsnt__UnacceptableInitialTerminationTimeFaultType_Description), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_wsnt__UnacceptableInitialTerminationTimeFaultType_Description(struct soap *soap, struct _wsnt__UnacceptableInitialTerminationTimeFaultType_Description *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_wsnt__UnacceptableInitialTerminationTimeFaultType_Description(soap, tag ? tag : "wsnt:UnacceptableInitialTerminationTimeFaultType-Description", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _wsnt__UnacceptableInitialTerminationTimeFaultType_Description ** SOAP_FMAC4 soap_get_PointerTo_wsnt__UnacceptableInitialTerminationTimeFaultType_Description(struct soap *soap, struct _wsnt__UnacceptableInitialTerminationTimeFaultType_Description **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_wsnt__UnacceptableInitialTerminationTimeFaultType_Description(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_wsnt__UnacceptableInitialTerminationTimeFaultType_ErrorCode(struct soap *soap, struct _wsnt__UnacceptableInitialTerminationTimeFaultType_ErrorCode *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__wsnt__UnacceptableInitialTerminationTimeFaultType_ErrorCode))
		soap_serialize__wsnt__UnacceptableInitialTerminationTimeFaultType_ErrorCode(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_wsnt__UnacceptableInitialTerminationTimeFaultType_ErrorCode(struct soap *soap, const char *tag, int id, struct _wsnt__UnacceptableInitialTerminationTimeFaultType_ErrorCode *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__wsnt__UnacceptableInitialTerminationTimeFaultType_ErrorCode, NULL);
	if (id < 0)
		return soap->error;
	return soap_out__wsnt__UnacceptableInitialTerminationTimeFaultType_ErrorCode(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _wsnt__UnacceptableInitialTerminationTimeFaultType_ErrorCode ** SOAP_FMAC4 soap_in_PointerTo_wsnt__UnacceptableInitialTerminationTimeFaultType_ErrorCode(struct soap *soap, const char *tag, struct _wsnt__UnacceptableInitialTerminationTimeFaultType_ErrorCode **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _wsnt__UnacceptableInitialTerminationTimeFaultType_ErrorCode **)soap_malloc(soap, sizeof(struct _wsnt__UnacceptableInitialTerminationTimeFaultType_ErrorCode *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__wsnt__UnacceptableInitialTerminationTimeFaultType_ErrorCode(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _wsnt__UnacceptableInitialTerminationTimeFaultType_ErrorCode **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__wsnt__UnacceptableInitialTerminationTimeFaultType_ErrorCode, sizeof(struct _wsnt__UnacceptableInitialTerminationTimeFaultType_ErrorCode), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_wsnt__UnacceptableInitialTerminationTimeFaultType_ErrorCode(struct soap *soap, struct _wsnt__UnacceptableInitialTerminationTimeFaultType_ErrorCode *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_wsnt__UnacceptableInitialTerminationTimeFaultType_ErrorCode(soap, tag ? tag : "wsnt:UnacceptableInitialTerminationTimeFaultType-ErrorCode", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _wsnt__UnacceptableInitialTerminationTimeFaultType_ErrorCode ** SOAP_FMAC4 soap_get_PointerTo_wsnt__UnacceptableInitialTerminationTimeFaultType_ErrorCode(struct soap *soap, struct _wsnt__UnacceptableInitialTerminationTimeFaultType_ErrorCode **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_wsnt__UnacceptableInitialTerminationTimeFaultType_ErrorCode(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_wsnt__NotifyMessageNotSupportedFaultType_FaultCause(struct soap *soap, struct _wsnt__NotifyMessageNotSupportedFaultType_FaultCause *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__wsnt__NotifyMessageNotSupportedFaultType_FaultCause))
		soap_serialize__wsnt__NotifyMessageNotSupportedFaultType_FaultCause(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_wsnt__NotifyMessageNotSupportedFaultType_FaultCause(struct soap *soap, const char *tag, int id, struct _wsnt__NotifyMessageNotSupportedFaultType_FaultCause *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__wsnt__NotifyMessageNotSupportedFaultType_FaultCause, NULL);
	if (id < 0)
		return soap->error;
	return soap_out__wsnt__NotifyMessageNotSupportedFaultType_FaultCause(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _wsnt__NotifyMessageNotSupportedFaultType_FaultCause ** SOAP_FMAC4 soap_in_PointerTo_wsnt__NotifyMessageNotSupportedFaultType_FaultCause(struct soap *soap, const char *tag, struct _wsnt__NotifyMessageNotSupportedFaultType_FaultCause **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _wsnt__NotifyMessageNotSupportedFaultType_FaultCause **)soap_malloc(soap, sizeof(struct _wsnt__NotifyMessageNotSupportedFaultType_FaultCause *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__wsnt__NotifyMessageNotSupportedFaultType_FaultCause(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _wsnt__NotifyMessageNotSupportedFaultType_FaultCause **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__wsnt__NotifyMessageNotSupportedFaultType_FaultCause, sizeof(struct _wsnt__NotifyMessageNotSupportedFaultType_FaultCause), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_wsnt__NotifyMessageNotSupportedFaultType_FaultCause(struct soap *soap, struct _wsnt__NotifyMessageNotSupportedFaultType_FaultCause *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_wsnt__NotifyMessageNotSupportedFaultType_FaultCause(soap, tag ? tag : "wsnt:NotifyMessageNotSupportedFaultType-FaultCause", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _wsnt__NotifyMessageNotSupportedFaultType_FaultCause ** SOAP_FMAC4 soap_get_PointerTo_wsnt__NotifyMessageNotSupportedFaultType_FaultCause(struct soap *soap, struct _wsnt__NotifyMessageNotSupportedFaultType_FaultCause **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_wsnt__NotifyMessageNotSupportedFaultType_FaultCause(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_wsnt__NotifyMessageNotSupportedFaultType_Description(struct soap *soap, struct _wsnt__NotifyMessageNotSupportedFaultType_Description *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__wsnt__NotifyMessageNotSupportedFaultType_Description))
		soap_serialize__wsnt__NotifyMessageNotSupportedFaultType_Description(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_wsnt__NotifyMessageNotSupportedFaultType_Description(struct soap *soap, const char *tag, int id, struct _wsnt__NotifyMessageNotSupportedFaultType_Description *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__wsnt__NotifyMessageNotSupportedFaultType_Description, NULL);
	if (id < 0)
		return soap->error;
	return soap_out__wsnt__NotifyMessageNotSupportedFaultType_Description(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _wsnt__NotifyMessageNotSupportedFaultType_Description ** SOAP_FMAC4 soap_in_PointerTo_wsnt__NotifyMessageNotSupportedFaultType_Description(struct soap *soap, const char *tag, struct _wsnt__NotifyMessageNotSupportedFaultType_Description **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _wsnt__NotifyMessageNotSupportedFaultType_Description **)soap_malloc(soap, sizeof(struct _wsnt__NotifyMessageNotSupportedFaultType_Description *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__wsnt__NotifyMessageNotSupportedFaultType_Description(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _wsnt__NotifyMessageNotSupportedFaultType_Description **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__wsnt__NotifyMessageNotSupportedFaultType_Description, sizeof(struct _wsnt__NotifyMessageNotSupportedFaultType_Description), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_wsnt__NotifyMessageNotSupportedFaultType_Description(struct soap *soap, struct _wsnt__NotifyMessageNotSupportedFaultType_Description *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_wsnt__NotifyMessageNotSupportedFaultType_Description(soap, tag ? tag : "wsnt:NotifyMessageNotSupportedFaultType-Description", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _wsnt__NotifyMessageNotSupportedFaultType_Description ** SOAP_FMAC4 soap_get_PointerTo_wsnt__NotifyMessageNotSupportedFaultType_Description(struct soap *soap, struct _wsnt__NotifyMessageNotSupportedFaultType_Description **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_wsnt__NotifyMessageNotSupportedFaultType_Description(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_wsnt__NotifyMessageNotSupportedFaultType_ErrorCode(struct soap *soap, struct _wsnt__NotifyMessageNotSupportedFaultType_ErrorCode *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__wsnt__NotifyMessageNotSupportedFaultType_ErrorCode))
		soap_serialize__wsnt__NotifyMessageNotSupportedFaultType_ErrorCode(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_wsnt__NotifyMessageNotSupportedFaultType_ErrorCode(struct soap *soap, const char *tag, int id, struct _wsnt__NotifyMessageNotSupportedFaultType_ErrorCode *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__wsnt__NotifyMessageNotSupportedFaultType_ErrorCode, NULL);
	if (id < 0)
		return soap->error;
	return soap_out__wsnt__NotifyMessageNotSupportedFaultType_ErrorCode(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _wsnt__NotifyMessageNotSupportedFaultType_ErrorCode ** SOAP_FMAC4 soap_in_PointerTo_wsnt__NotifyMessageNotSupportedFaultType_ErrorCode(struct soap *soap, const char *tag, struct _wsnt__NotifyMessageNotSupportedFaultType_ErrorCode **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _wsnt__NotifyMessageNotSupportedFaultType_ErrorCode **)soap_malloc(soap, sizeof(struct _wsnt__NotifyMessageNotSupportedFaultType_ErrorCode *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__wsnt__NotifyMessageNotSupportedFaultType_ErrorCode(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _wsnt__NotifyMessageNotSupportedFaultType_ErrorCode **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__wsnt__NotifyMessageNotSupportedFaultType_ErrorCode, sizeof(struct _wsnt__NotifyMessageNotSupportedFaultType_ErrorCode), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_wsnt__NotifyMessageNotSupportedFaultType_ErrorCode(struct soap *soap, struct _wsnt__NotifyMessageNotSupportedFaultType_ErrorCode *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_wsnt__NotifyMessageNotSupportedFaultType_ErrorCode(soap, tag ? tag : "wsnt:NotifyMessageNotSupportedFaultType-ErrorCode", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _wsnt__NotifyMessageNotSupportedFaultType_ErrorCode ** SOAP_FMAC4 soap_get_PointerTo_wsnt__NotifyMessageNotSupportedFaultType_ErrorCode(struct soap *soap, struct _wsnt__NotifyMessageNotSupportedFaultType_ErrorCode **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_wsnt__NotifyMessageNotSupportedFaultType_ErrorCode(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_wsnt__UnsupportedPolicyRequestFaultType_FaultCause(struct soap *soap, struct _wsnt__UnsupportedPolicyRequestFaultType_FaultCause *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__wsnt__UnsupportedPolicyRequestFaultType_FaultCause))
		soap_serialize__wsnt__UnsupportedPolicyRequestFaultType_FaultCause(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_wsnt__UnsupportedPolicyRequestFaultType_FaultCause(struct soap *soap, const char *tag, int id, struct _wsnt__UnsupportedPolicyRequestFaultType_FaultCause *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__wsnt__UnsupportedPolicyRequestFaultType_FaultCause, NULL);
	if (id < 0)
		return soap->error;
	return soap_out__wsnt__UnsupportedPolicyRequestFaultType_FaultCause(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _wsnt__UnsupportedPolicyRequestFaultType_FaultCause ** SOAP_FMAC4 soap_in_PointerTo_wsnt__UnsupportedPolicyRequestFaultType_FaultCause(struct soap *soap, const char *tag, struct _wsnt__UnsupportedPolicyRequestFaultType_FaultCause **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _wsnt__UnsupportedPolicyRequestFaultType_FaultCause **)soap_malloc(soap, sizeof(struct _wsnt__UnsupportedPolicyRequestFaultType_FaultCause *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__wsnt__UnsupportedPolicyRequestFaultType_FaultCause(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _wsnt__UnsupportedPolicyRequestFaultType_FaultCause **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__wsnt__UnsupportedPolicyRequestFaultType_FaultCause, sizeof(struct _wsnt__UnsupportedPolicyRequestFaultType_FaultCause), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_wsnt__UnsupportedPolicyRequestFaultType_FaultCause(struct soap *soap, struct _wsnt__UnsupportedPolicyRequestFaultType_FaultCause *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_wsnt__UnsupportedPolicyRequestFaultType_FaultCause(soap, tag ? tag : "wsnt:UnsupportedPolicyRequestFaultType-FaultCause", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _wsnt__UnsupportedPolicyRequestFaultType_FaultCause ** SOAP_FMAC4 soap_get_PointerTo_wsnt__UnsupportedPolicyRequestFaultType_FaultCause(struct soap *soap, struct _wsnt__UnsupportedPolicyRequestFaultType_FaultCause **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_wsnt__UnsupportedPolicyRequestFaultType_FaultCause(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_wsnt__UnsupportedPolicyRequestFaultType_Description(struct soap *soap, struct _wsnt__UnsupportedPolicyRequestFaultType_Description *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__wsnt__UnsupportedPolicyRequestFaultType_Description))
		soap_serialize__wsnt__UnsupportedPolicyRequestFaultType_Description(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_wsnt__UnsupportedPolicyRequestFaultType_Description(struct soap *soap, const char *tag, int id, struct _wsnt__UnsupportedPolicyRequestFaultType_Description *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__wsnt__UnsupportedPolicyRequestFaultType_Description, NULL);
	if (id < 0)
		return soap->error;
	return soap_out__wsnt__UnsupportedPolicyRequestFaultType_Description(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _wsnt__UnsupportedPolicyRequestFaultType_Description ** SOAP_FMAC4 soap_in_PointerTo_wsnt__UnsupportedPolicyRequestFaultType_Description(struct soap *soap, const char *tag, struct _wsnt__UnsupportedPolicyRequestFaultType_Description **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _wsnt__UnsupportedPolicyRequestFaultType_Description **)soap_malloc(soap, sizeof(struct _wsnt__UnsupportedPolicyRequestFaultType_Description *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__wsnt__UnsupportedPolicyRequestFaultType_Description(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _wsnt__UnsupportedPolicyRequestFaultType_Description **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__wsnt__UnsupportedPolicyRequestFaultType_Description, sizeof(struct _wsnt__UnsupportedPolicyRequestFaultType_Description), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_wsnt__UnsupportedPolicyRequestFaultType_Description(struct soap *soap, struct _wsnt__UnsupportedPolicyRequestFaultType_Description *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_wsnt__UnsupportedPolicyRequestFaultType_Description(soap, tag ? tag : "wsnt:UnsupportedPolicyRequestFaultType-Description", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _wsnt__UnsupportedPolicyRequestFaultType_Description ** SOAP_FMAC4 soap_get_PointerTo_wsnt__UnsupportedPolicyRequestFaultType_Description(struct soap *soap, struct _wsnt__UnsupportedPolicyRequestFaultType_Description **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_wsnt__UnsupportedPolicyRequestFaultType_Description(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_wsnt__UnsupportedPolicyRequestFaultType_ErrorCode(struct soap *soap, struct _wsnt__UnsupportedPolicyRequestFaultType_ErrorCode *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__wsnt__UnsupportedPolicyRequestFaultType_ErrorCode))
		soap_serialize__wsnt__UnsupportedPolicyRequestFaultType_ErrorCode(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_wsnt__UnsupportedPolicyRequestFaultType_ErrorCode(struct soap *soap, const char *tag, int id, struct _wsnt__UnsupportedPolicyRequestFaultType_ErrorCode *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__wsnt__UnsupportedPolicyRequestFaultType_ErrorCode, NULL);
	if (id < 0)
		return soap->error;
	return soap_out__wsnt__UnsupportedPolicyRequestFaultType_ErrorCode(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _wsnt__UnsupportedPolicyRequestFaultType_ErrorCode ** SOAP_FMAC4 soap_in_PointerTo_wsnt__UnsupportedPolicyRequestFaultType_ErrorCode(struct soap *soap, const char *tag, struct _wsnt__UnsupportedPolicyRequestFaultType_ErrorCode **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _wsnt__UnsupportedPolicyRequestFaultType_ErrorCode **)soap_malloc(soap, sizeof(struct _wsnt__UnsupportedPolicyRequestFaultType_ErrorCode *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__wsnt__UnsupportedPolicyRequestFaultType_ErrorCode(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _wsnt__UnsupportedPolicyRequestFaultType_ErrorCode **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__wsnt__UnsupportedPolicyRequestFaultType_ErrorCode, sizeof(struct _wsnt__UnsupportedPolicyRequestFaultType_ErrorCode), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_wsnt__UnsupportedPolicyRequestFaultType_ErrorCode(struct soap *soap, struct _wsnt__UnsupportedPolicyRequestFaultType_ErrorCode *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_wsnt__UnsupportedPolicyRequestFaultType_ErrorCode(soap, tag ? tag : "wsnt:UnsupportedPolicyRequestFaultType-ErrorCode", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _wsnt__UnsupportedPolicyRequestFaultType_ErrorCode ** SOAP_FMAC4 soap_get_PointerTo_wsnt__UnsupportedPolicyRequestFaultType_ErrorCode(struct soap *soap, struct _wsnt__UnsupportedPolicyRequestFaultType_ErrorCode **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_wsnt__UnsupportedPolicyRequestFaultType_ErrorCode(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_wsnt__UnrecognizedPolicyRequestFaultType_FaultCause(struct soap *soap, struct _wsnt__UnrecognizedPolicyRequestFaultType_FaultCause *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__wsnt__UnrecognizedPolicyRequestFaultType_FaultCause))
		soap_serialize__wsnt__UnrecognizedPolicyRequestFaultType_FaultCause(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_wsnt__UnrecognizedPolicyRequestFaultType_FaultCause(struct soap *soap, const char *tag, int id, struct _wsnt__UnrecognizedPolicyRequestFaultType_FaultCause *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__wsnt__UnrecognizedPolicyRequestFaultType_FaultCause, NULL);
	if (id < 0)
		return soap->error;
	return soap_out__wsnt__UnrecognizedPolicyRequestFaultType_FaultCause(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _wsnt__UnrecognizedPolicyRequestFaultType_FaultCause ** SOAP_FMAC4 soap_in_PointerTo_wsnt__UnrecognizedPolicyRequestFaultType_FaultCause(struct soap *soap, const char *tag, struct _wsnt__UnrecognizedPolicyRequestFaultType_FaultCause **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _wsnt__UnrecognizedPolicyRequestFaultType_FaultCause **)soap_malloc(soap, sizeof(struct _wsnt__UnrecognizedPolicyRequestFaultType_FaultCause *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__wsnt__UnrecognizedPolicyRequestFaultType_FaultCause(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _wsnt__UnrecognizedPolicyRequestFaultType_FaultCause **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__wsnt__UnrecognizedPolicyRequestFaultType_FaultCause, sizeof(struct _wsnt__UnrecognizedPolicyRequestFaultType_FaultCause), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_wsnt__UnrecognizedPolicyRequestFaultType_FaultCause(struct soap *soap, struct _wsnt__UnrecognizedPolicyRequestFaultType_FaultCause *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_wsnt__UnrecognizedPolicyRequestFaultType_FaultCause(soap, tag ? tag : "wsnt:UnrecognizedPolicyRequestFaultType-FaultCause", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _wsnt__UnrecognizedPolicyRequestFaultType_FaultCause ** SOAP_FMAC4 soap_get_PointerTo_wsnt__UnrecognizedPolicyRequestFaultType_FaultCause(struct soap *soap, struct _wsnt__UnrecognizedPolicyRequestFaultType_FaultCause **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_wsnt__UnrecognizedPolicyRequestFaultType_FaultCause(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_wsnt__UnrecognizedPolicyRequestFaultType_Description(struct soap *soap, struct _wsnt__UnrecognizedPolicyRequestFaultType_Description *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__wsnt__UnrecognizedPolicyRequestFaultType_Description))
		soap_serialize__wsnt__UnrecognizedPolicyRequestFaultType_Description(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_wsnt__UnrecognizedPolicyRequestFaultType_Description(struct soap *soap, const char *tag, int id, struct _wsnt__UnrecognizedPolicyRequestFaultType_Description *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__wsnt__UnrecognizedPolicyRequestFaultType_Description, NULL);
	if (id < 0)
		return soap->error;
	return soap_out__wsnt__UnrecognizedPolicyRequestFaultType_Description(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _wsnt__UnrecognizedPolicyRequestFaultType_Description ** SOAP_FMAC4 soap_in_PointerTo_wsnt__UnrecognizedPolicyRequestFaultType_Description(struct soap *soap, const char *tag, struct _wsnt__UnrecognizedPolicyRequestFaultType_Description **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _wsnt__UnrecognizedPolicyRequestFaultType_Description **)soap_malloc(soap, sizeof(struct _wsnt__UnrecognizedPolicyRequestFaultType_Description *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__wsnt__UnrecognizedPolicyRequestFaultType_Description(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _wsnt__UnrecognizedPolicyRequestFaultType_Description **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__wsnt__UnrecognizedPolicyRequestFaultType_Description, sizeof(struct _wsnt__UnrecognizedPolicyRequestFaultType_Description), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_wsnt__UnrecognizedPolicyRequestFaultType_Description(struct soap *soap, struct _wsnt__UnrecognizedPolicyRequestFaultType_Description *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_wsnt__UnrecognizedPolicyRequestFaultType_Description(soap, tag ? tag : "wsnt:UnrecognizedPolicyRequestFaultType-Description", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _wsnt__UnrecognizedPolicyRequestFaultType_Description ** SOAP_FMAC4 soap_get_PointerTo_wsnt__UnrecognizedPolicyRequestFaultType_Description(struct soap *soap, struct _wsnt__UnrecognizedPolicyRequestFaultType_Description **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_wsnt__UnrecognizedPolicyRequestFaultType_Description(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_wsnt__UnrecognizedPolicyRequestFaultType_ErrorCode(struct soap *soap, struct _wsnt__UnrecognizedPolicyRequestFaultType_ErrorCode *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__wsnt__UnrecognizedPolicyRequestFaultType_ErrorCode))
		soap_serialize__wsnt__UnrecognizedPolicyRequestFaultType_ErrorCode(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_wsnt__UnrecognizedPolicyRequestFaultType_ErrorCode(struct soap *soap, const char *tag, int id, struct _wsnt__UnrecognizedPolicyRequestFaultType_ErrorCode *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__wsnt__UnrecognizedPolicyRequestFaultType_ErrorCode, NULL);
	if (id < 0)
		return soap->error;
	return soap_out__wsnt__UnrecognizedPolicyRequestFaultType_ErrorCode(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _wsnt__UnrecognizedPolicyRequestFaultType_ErrorCode ** SOAP_FMAC4 soap_in_PointerTo_wsnt__UnrecognizedPolicyRequestFaultType_ErrorCode(struct soap *soap, const char *tag, struct _wsnt__UnrecognizedPolicyRequestFaultType_ErrorCode **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _wsnt__UnrecognizedPolicyRequestFaultType_ErrorCode **)soap_malloc(soap, sizeof(struct _wsnt__UnrecognizedPolicyRequestFaultType_ErrorCode *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__wsnt__UnrecognizedPolicyRequestFaultType_ErrorCode(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _wsnt__UnrecognizedPolicyRequestFaultType_ErrorCode **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__wsnt__UnrecognizedPolicyRequestFaultType_ErrorCode, sizeof(struct _wsnt__UnrecognizedPolicyRequestFaultType_ErrorCode), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_wsnt__UnrecognizedPolicyRequestFaultType_ErrorCode(struct soap *soap, struct _wsnt__UnrecognizedPolicyRequestFaultType_ErrorCode *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_wsnt__UnrecognizedPolicyRequestFaultType_ErrorCode(soap, tag ? tag : "wsnt:UnrecognizedPolicyRequestFaultType-ErrorCode", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _wsnt__UnrecognizedPolicyRequestFaultType_ErrorCode ** SOAP_FMAC4 soap_get_PointerTo_wsnt__UnrecognizedPolicyRequestFaultType_ErrorCode(struct soap *soap, struct _wsnt__UnrecognizedPolicyRequestFaultType_ErrorCode **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_wsnt__UnrecognizedPolicyRequestFaultType_ErrorCode(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_wsnt__InvalidMessageContentExpressionFaultType_FaultCause(struct soap *soap, struct _wsnt__InvalidMessageContentExpressionFaultType_FaultCause *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__wsnt__InvalidMessageContentExpressionFaultType_FaultCause))
		soap_serialize__wsnt__InvalidMessageContentExpressionFaultType_FaultCause(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_wsnt__InvalidMessageContentExpressionFaultType_FaultCause(struct soap *soap, const char *tag, int id, struct _wsnt__InvalidMessageContentExpressionFaultType_FaultCause *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__wsnt__InvalidMessageContentExpressionFaultType_FaultCause, NULL);
	if (id < 0)
		return soap->error;
	return soap_out__wsnt__InvalidMessageContentExpressionFaultType_FaultCause(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _wsnt__InvalidMessageContentExpressionFaultType_FaultCause ** SOAP_FMAC4 soap_in_PointerTo_wsnt__InvalidMessageContentExpressionFaultType_FaultCause(struct soap *soap, const char *tag, struct _wsnt__InvalidMessageContentExpressionFaultType_FaultCause **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _wsnt__InvalidMessageContentExpressionFaultType_FaultCause **)soap_malloc(soap, sizeof(struct _wsnt__InvalidMessageContentExpressionFaultType_FaultCause *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__wsnt__InvalidMessageContentExpressionFaultType_FaultCause(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _wsnt__InvalidMessageContentExpressionFaultType_FaultCause **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__wsnt__InvalidMessageContentExpressionFaultType_FaultCause, sizeof(struct _wsnt__InvalidMessageContentExpressionFaultType_FaultCause), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_wsnt__InvalidMessageContentExpressionFaultType_FaultCause(struct soap *soap, struct _wsnt__InvalidMessageContentExpressionFaultType_FaultCause *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_wsnt__InvalidMessageContentExpressionFaultType_FaultCause(soap, tag ? tag : "wsnt:InvalidMessageContentExpressionFaultType-FaultCause", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _wsnt__InvalidMessageContentExpressionFaultType_FaultCause ** SOAP_FMAC4 soap_get_PointerTo_wsnt__InvalidMessageContentExpressionFaultType_FaultCause(struct soap *soap, struct _wsnt__InvalidMessageContentExpressionFaultType_FaultCause **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_wsnt__InvalidMessageContentExpressionFaultType_FaultCause(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_wsnt__InvalidMessageContentExpressionFaultType_Description(struct soap *soap, struct _wsnt__InvalidMessageContentExpressionFaultType_Description *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__wsnt__InvalidMessageContentExpressionFaultType_Description))
		soap_serialize__wsnt__InvalidMessageContentExpressionFaultType_Description(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_wsnt__InvalidMessageContentExpressionFaultType_Description(struct soap *soap, const char *tag, int id, struct _wsnt__InvalidMessageContentExpressionFaultType_Description *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__wsnt__InvalidMessageContentExpressionFaultType_Description, NULL);
	if (id < 0)
		return soap->error;
	return soap_out__wsnt__InvalidMessageContentExpressionFaultType_Description(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _wsnt__InvalidMessageContentExpressionFaultType_Description ** SOAP_FMAC4 soap_in_PointerTo_wsnt__InvalidMessageContentExpressionFaultType_Description(struct soap *soap, const char *tag, struct _wsnt__InvalidMessageContentExpressionFaultType_Description **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _wsnt__InvalidMessageContentExpressionFaultType_Description **)soap_malloc(soap, sizeof(struct _wsnt__InvalidMessageContentExpressionFaultType_Description *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__wsnt__InvalidMessageContentExpressionFaultType_Description(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _wsnt__InvalidMessageContentExpressionFaultType_Description **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__wsnt__InvalidMessageContentExpressionFaultType_Description, sizeof(struct _wsnt__InvalidMessageContentExpressionFaultType_Description), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_wsnt__InvalidMessageContentExpressionFaultType_Description(struct soap *soap, struct _wsnt__InvalidMessageContentExpressionFaultType_Description *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_wsnt__InvalidMessageContentExpressionFaultType_Description(soap, tag ? tag : "wsnt:InvalidMessageContentExpressionFaultType-Description", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _wsnt__InvalidMessageContentExpressionFaultType_Description ** SOAP_FMAC4 soap_get_PointerTo_wsnt__InvalidMessageContentExpressionFaultType_Description(struct soap *soap, struct _wsnt__InvalidMessageContentExpressionFaultType_Description **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_wsnt__InvalidMessageContentExpressionFaultType_Description(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_wsnt__InvalidMessageContentExpressionFaultType_ErrorCode(struct soap *soap, struct _wsnt__InvalidMessageContentExpressionFaultType_ErrorCode *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__wsnt__InvalidMessageContentExpressionFaultType_ErrorCode))
		soap_serialize__wsnt__InvalidMessageContentExpressionFaultType_ErrorCode(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_wsnt__InvalidMessageContentExpressionFaultType_ErrorCode(struct soap *soap, const char *tag, int id, struct _wsnt__InvalidMessageContentExpressionFaultType_ErrorCode *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__wsnt__InvalidMessageContentExpressionFaultType_ErrorCode, NULL);
	if (id < 0)
		return soap->error;
	return soap_out__wsnt__InvalidMessageContentExpressionFaultType_ErrorCode(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _wsnt__InvalidMessageContentExpressionFaultType_ErrorCode ** SOAP_FMAC4 soap_in_PointerTo_wsnt__InvalidMessageContentExpressionFaultType_ErrorCode(struct soap *soap, const char *tag, struct _wsnt__InvalidMessageContentExpressionFaultType_ErrorCode **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _wsnt__InvalidMessageContentExpressionFaultType_ErrorCode **)soap_malloc(soap, sizeof(struct _wsnt__InvalidMessageContentExpressionFaultType_ErrorCode *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__wsnt__InvalidMessageContentExpressionFaultType_ErrorCode(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _wsnt__InvalidMessageContentExpressionFaultType_ErrorCode **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__wsnt__InvalidMessageContentExpressionFaultType_ErrorCode, sizeof(struct _wsnt__InvalidMessageContentExpressionFaultType_ErrorCode), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_wsnt__InvalidMessageContentExpressionFaultType_ErrorCode(struct soap *soap, struct _wsnt__InvalidMessageContentExpressionFaultType_ErrorCode *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_wsnt__InvalidMessageContentExpressionFaultType_ErrorCode(soap, tag ? tag : "wsnt:InvalidMessageContentExpressionFaultType-ErrorCode", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _wsnt__InvalidMessageContentExpressionFaultType_ErrorCode ** SOAP_FMAC4 soap_get_PointerTo_wsnt__InvalidMessageContentExpressionFaultType_ErrorCode(struct soap *soap, struct _wsnt__InvalidMessageContentExpressionFaultType_ErrorCode **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_wsnt__InvalidMessageContentExpressionFaultType_ErrorCode(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_wsnt__InvalidProducerPropertiesExpressionFaultType_FaultCause(struct soap *soap, struct _wsnt__InvalidProducerPropertiesExpressionFaultType_FaultCause *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__wsnt__InvalidProducerPropertiesExpressionFaultType_FaultCause))
		soap_serialize__wsnt__InvalidProducerPropertiesExpressionFaultType_FaultCause(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_wsnt__InvalidProducerPropertiesExpressionFaultType_FaultCause(struct soap *soap, const char *tag, int id, struct _wsnt__InvalidProducerPropertiesExpressionFaultType_FaultCause *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__wsnt__InvalidProducerPropertiesExpressionFaultType_FaultCause, NULL);
	if (id < 0)
		return soap->error;
	return soap_out__wsnt__InvalidProducerPropertiesExpressionFaultType_FaultCause(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _wsnt__InvalidProducerPropertiesExpressionFaultType_FaultCause ** SOAP_FMAC4 soap_in_PointerTo_wsnt__InvalidProducerPropertiesExpressionFaultType_FaultCause(struct soap *soap, const char *tag, struct _wsnt__InvalidProducerPropertiesExpressionFaultType_FaultCause **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _wsnt__InvalidProducerPropertiesExpressionFaultType_FaultCause **)soap_malloc(soap, sizeof(struct _wsnt__InvalidProducerPropertiesExpressionFaultType_FaultCause *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__wsnt__InvalidProducerPropertiesExpressionFaultType_FaultCause(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _wsnt__InvalidProducerPropertiesExpressionFaultType_FaultCause **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__wsnt__InvalidProducerPropertiesExpressionFaultType_FaultCause, sizeof(struct _wsnt__InvalidProducerPropertiesExpressionFaultType_FaultCause), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_wsnt__InvalidProducerPropertiesExpressionFaultType_FaultCause(struct soap *soap, struct _wsnt__InvalidProducerPropertiesExpressionFaultType_FaultCause *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_wsnt__InvalidProducerPropertiesExpressionFaultType_FaultCause(soap, tag ? tag : "wsnt:InvalidProducerPropertiesExpressionFaultType-FaultCause", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _wsnt__InvalidProducerPropertiesExpressionFaultType_FaultCause ** SOAP_FMAC4 soap_get_PointerTo_wsnt__InvalidProducerPropertiesExpressionFaultType_FaultCause(struct soap *soap, struct _wsnt__InvalidProducerPropertiesExpressionFaultType_FaultCause **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_wsnt__InvalidProducerPropertiesExpressionFaultType_FaultCause(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_wsnt__InvalidProducerPropertiesExpressionFaultType_Description(struct soap *soap, struct _wsnt__InvalidProducerPropertiesExpressionFaultType_Description *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__wsnt__InvalidProducerPropertiesExpressionFaultType_Description))
		soap_serialize__wsnt__InvalidProducerPropertiesExpressionFaultType_Description(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_wsnt__InvalidProducerPropertiesExpressionFaultType_Description(struct soap *soap, const char *tag, int id, struct _wsnt__InvalidProducerPropertiesExpressionFaultType_Description *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__wsnt__InvalidProducerPropertiesExpressionFaultType_Description, NULL);
	if (id < 0)
		return soap->error;
	return soap_out__wsnt__InvalidProducerPropertiesExpressionFaultType_Description(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _wsnt__InvalidProducerPropertiesExpressionFaultType_Description ** SOAP_FMAC4 soap_in_PointerTo_wsnt__InvalidProducerPropertiesExpressionFaultType_Description(struct soap *soap, const char *tag, struct _wsnt__InvalidProducerPropertiesExpressionFaultType_Description **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _wsnt__InvalidProducerPropertiesExpressionFaultType_Description **)soap_malloc(soap, sizeof(struct _wsnt__InvalidProducerPropertiesExpressionFaultType_Description *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__wsnt__InvalidProducerPropertiesExpressionFaultType_Description(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _wsnt__InvalidProducerPropertiesExpressionFaultType_Description **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__wsnt__InvalidProducerPropertiesExpressionFaultType_Description, sizeof(struct _wsnt__InvalidProducerPropertiesExpressionFaultType_Description), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_wsnt__InvalidProducerPropertiesExpressionFaultType_Description(struct soap *soap, struct _wsnt__InvalidProducerPropertiesExpressionFaultType_Description *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_wsnt__InvalidProducerPropertiesExpressionFaultType_Description(soap, tag ? tag : "wsnt:InvalidProducerPropertiesExpressionFaultType-Description", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _wsnt__InvalidProducerPropertiesExpressionFaultType_Description ** SOAP_FMAC4 soap_get_PointerTo_wsnt__InvalidProducerPropertiesExpressionFaultType_Description(struct soap *soap, struct _wsnt__InvalidProducerPropertiesExpressionFaultType_Description **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_wsnt__InvalidProducerPropertiesExpressionFaultType_Description(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_wsnt__InvalidProducerPropertiesExpressionFaultType_ErrorCode(struct soap *soap, struct _wsnt__InvalidProducerPropertiesExpressionFaultType_ErrorCode *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__wsnt__InvalidProducerPropertiesExpressionFaultType_ErrorCode))
		soap_serialize__wsnt__InvalidProducerPropertiesExpressionFaultType_ErrorCode(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_wsnt__InvalidProducerPropertiesExpressionFaultType_ErrorCode(struct soap *soap, const char *tag, int id, struct _wsnt__InvalidProducerPropertiesExpressionFaultType_ErrorCode *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__wsnt__InvalidProducerPropertiesExpressionFaultType_ErrorCode, NULL);
	if (id < 0)
		return soap->error;
	return soap_out__wsnt__InvalidProducerPropertiesExpressionFaultType_ErrorCode(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _wsnt__InvalidProducerPropertiesExpressionFaultType_ErrorCode ** SOAP_FMAC4 soap_in_PointerTo_wsnt__InvalidProducerPropertiesExpressionFaultType_ErrorCode(struct soap *soap, const char *tag, struct _wsnt__InvalidProducerPropertiesExpressionFaultType_ErrorCode **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _wsnt__InvalidProducerPropertiesExpressionFaultType_ErrorCode **)soap_malloc(soap, sizeof(struct _wsnt__InvalidProducerPropertiesExpressionFaultType_ErrorCode *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__wsnt__InvalidProducerPropertiesExpressionFaultType_ErrorCode(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _wsnt__InvalidProducerPropertiesExpressionFaultType_ErrorCode **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__wsnt__InvalidProducerPropertiesExpressionFaultType_ErrorCode, sizeof(struct _wsnt__InvalidProducerPropertiesExpressionFaultType_ErrorCode), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_wsnt__InvalidProducerPropertiesExpressionFaultType_ErrorCode(struct soap *soap, struct _wsnt__InvalidProducerPropertiesExpressionFaultType_ErrorCode *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_wsnt__InvalidProducerPropertiesExpressionFaultType_ErrorCode(soap, tag ? tag : "wsnt:InvalidProducerPropertiesExpressionFaultType-ErrorCode", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _wsnt__InvalidProducerPropertiesExpressionFaultType_ErrorCode ** SOAP_FMAC4 soap_get_PointerTo_wsnt__InvalidProducerPropertiesExpressionFaultType_ErrorCode(struct soap *soap, struct _wsnt__InvalidProducerPropertiesExpressionFaultType_ErrorCode **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_wsnt__InvalidProducerPropertiesExpressionFaultType_ErrorCode(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_wsnt__MultipleTopicsSpecifiedFaultType_FaultCause(struct soap *soap, struct _wsnt__MultipleTopicsSpecifiedFaultType_FaultCause *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__wsnt__MultipleTopicsSpecifiedFaultType_FaultCause))
		soap_serialize__wsnt__MultipleTopicsSpecifiedFaultType_FaultCause(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_wsnt__MultipleTopicsSpecifiedFaultType_FaultCause(struct soap *soap, const char *tag, int id, struct _wsnt__MultipleTopicsSpecifiedFaultType_FaultCause *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__wsnt__MultipleTopicsSpecifiedFaultType_FaultCause, NULL);
	if (id < 0)
		return soap->error;
	return soap_out__wsnt__MultipleTopicsSpecifiedFaultType_FaultCause(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _wsnt__MultipleTopicsSpecifiedFaultType_FaultCause ** SOAP_FMAC4 soap_in_PointerTo_wsnt__MultipleTopicsSpecifiedFaultType_FaultCause(struct soap *soap, const char *tag, struct _wsnt__MultipleTopicsSpecifiedFaultType_FaultCause **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _wsnt__MultipleTopicsSpecifiedFaultType_FaultCause **)soap_malloc(soap, sizeof(struct _wsnt__MultipleTopicsSpecifiedFaultType_FaultCause *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__wsnt__MultipleTopicsSpecifiedFaultType_FaultCause(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _wsnt__MultipleTopicsSpecifiedFaultType_FaultCause **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__wsnt__MultipleTopicsSpecifiedFaultType_FaultCause, sizeof(struct _wsnt__MultipleTopicsSpecifiedFaultType_FaultCause), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_wsnt__MultipleTopicsSpecifiedFaultType_FaultCause(struct soap *soap, struct _wsnt__MultipleTopicsSpecifiedFaultType_FaultCause *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_wsnt__MultipleTopicsSpecifiedFaultType_FaultCause(soap, tag ? tag : "wsnt:MultipleTopicsSpecifiedFaultType-FaultCause", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _wsnt__MultipleTopicsSpecifiedFaultType_FaultCause ** SOAP_FMAC4 soap_get_PointerTo_wsnt__MultipleTopicsSpecifiedFaultType_FaultCause(struct soap *soap, struct _wsnt__MultipleTopicsSpecifiedFaultType_FaultCause **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_wsnt__MultipleTopicsSpecifiedFaultType_FaultCause(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_wsnt__MultipleTopicsSpecifiedFaultType_Description(struct soap *soap, struct _wsnt__MultipleTopicsSpecifiedFaultType_Description *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__wsnt__MultipleTopicsSpecifiedFaultType_Description))
		soap_serialize__wsnt__MultipleTopicsSpecifiedFaultType_Description(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_wsnt__MultipleTopicsSpecifiedFaultType_Description(struct soap *soap, const char *tag, int id, struct _wsnt__MultipleTopicsSpecifiedFaultType_Description *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__wsnt__MultipleTopicsSpecifiedFaultType_Description, NULL);
	if (id < 0)
		return soap->error;
	return soap_out__wsnt__MultipleTopicsSpecifiedFaultType_Description(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _wsnt__MultipleTopicsSpecifiedFaultType_Description ** SOAP_FMAC4 soap_in_PointerTo_wsnt__MultipleTopicsSpecifiedFaultType_Description(struct soap *soap, const char *tag, struct _wsnt__MultipleTopicsSpecifiedFaultType_Description **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _wsnt__MultipleTopicsSpecifiedFaultType_Description **)soap_malloc(soap, sizeof(struct _wsnt__MultipleTopicsSpecifiedFaultType_Description *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__wsnt__MultipleTopicsSpecifiedFaultType_Description(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _wsnt__MultipleTopicsSpecifiedFaultType_Description **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__wsnt__MultipleTopicsSpecifiedFaultType_Description, sizeof(struct _wsnt__MultipleTopicsSpecifiedFaultType_Description), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_wsnt__MultipleTopicsSpecifiedFaultType_Description(struct soap *soap, struct _wsnt__MultipleTopicsSpecifiedFaultType_Description *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_wsnt__MultipleTopicsSpecifiedFaultType_Description(soap, tag ? tag : "wsnt:MultipleTopicsSpecifiedFaultType-Description", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _wsnt__MultipleTopicsSpecifiedFaultType_Description ** SOAP_FMAC4 soap_get_PointerTo_wsnt__MultipleTopicsSpecifiedFaultType_Description(struct soap *soap, struct _wsnt__MultipleTopicsSpecifiedFaultType_Description **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_wsnt__MultipleTopicsSpecifiedFaultType_Description(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_wsnt__MultipleTopicsSpecifiedFaultType_ErrorCode(struct soap *soap, struct _wsnt__MultipleTopicsSpecifiedFaultType_ErrorCode *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__wsnt__MultipleTopicsSpecifiedFaultType_ErrorCode))
		soap_serialize__wsnt__MultipleTopicsSpecifiedFaultType_ErrorCode(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_wsnt__MultipleTopicsSpecifiedFaultType_ErrorCode(struct soap *soap, const char *tag, int id, struct _wsnt__MultipleTopicsSpecifiedFaultType_ErrorCode *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__wsnt__MultipleTopicsSpecifiedFaultType_ErrorCode, NULL);
	if (id < 0)
		return soap->error;
	return soap_out__wsnt__MultipleTopicsSpecifiedFaultType_ErrorCode(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _wsnt__MultipleTopicsSpecifiedFaultType_ErrorCode ** SOAP_FMAC4 soap_in_PointerTo_wsnt__MultipleTopicsSpecifiedFaultType_ErrorCode(struct soap *soap, const char *tag, struct _wsnt__MultipleTopicsSpecifiedFaultType_ErrorCode **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _wsnt__MultipleTopicsSpecifiedFaultType_ErrorCode **)soap_malloc(soap, sizeof(struct _wsnt__MultipleTopicsSpecifiedFaultType_ErrorCode *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__wsnt__MultipleTopicsSpecifiedFaultType_ErrorCode(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _wsnt__MultipleTopicsSpecifiedFaultType_ErrorCode **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__wsnt__MultipleTopicsSpecifiedFaultType_ErrorCode, sizeof(struct _wsnt__MultipleTopicsSpecifiedFaultType_ErrorCode), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_wsnt__MultipleTopicsSpecifiedFaultType_ErrorCode(struct soap *soap, struct _wsnt__MultipleTopicsSpecifiedFaultType_ErrorCode *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_wsnt__MultipleTopicsSpecifiedFaultType_ErrorCode(soap, tag ? tag : "wsnt:MultipleTopicsSpecifiedFaultType-ErrorCode", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _wsnt__MultipleTopicsSpecifiedFaultType_ErrorCode ** SOAP_FMAC4 soap_get_PointerTo_wsnt__MultipleTopicsSpecifiedFaultType_ErrorCode(struct soap *soap, struct _wsnt__MultipleTopicsSpecifiedFaultType_ErrorCode **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_wsnt__MultipleTopicsSpecifiedFaultType_ErrorCode(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_wsnt__TopicNotSupportedFaultType_FaultCause(struct soap *soap, struct _wsnt__TopicNotSupportedFaultType_FaultCause *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__wsnt__TopicNotSupportedFaultType_FaultCause))
		soap_serialize__wsnt__TopicNotSupportedFaultType_FaultCause(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_wsnt__TopicNotSupportedFaultType_FaultCause(struct soap *soap, const char *tag, int id, struct _wsnt__TopicNotSupportedFaultType_FaultCause *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__wsnt__TopicNotSupportedFaultType_FaultCause, NULL);
	if (id < 0)
		return soap->error;
	return soap_out__wsnt__TopicNotSupportedFaultType_FaultCause(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _wsnt__TopicNotSupportedFaultType_FaultCause ** SOAP_FMAC4 soap_in_PointerTo_wsnt__TopicNotSupportedFaultType_FaultCause(struct soap *soap, const char *tag, struct _wsnt__TopicNotSupportedFaultType_FaultCause **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _wsnt__TopicNotSupportedFaultType_FaultCause **)soap_malloc(soap, sizeof(struct _wsnt__TopicNotSupportedFaultType_FaultCause *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__wsnt__TopicNotSupportedFaultType_FaultCause(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _wsnt__TopicNotSupportedFaultType_FaultCause **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__wsnt__TopicNotSupportedFaultType_FaultCause, sizeof(struct _wsnt__TopicNotSupportedFaultType_FaultCause), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_wsnt__TopicNotSupportedFaultType_FaultCause(struct soap *soap, struct _wsnt__TopicNotSupportedFaultType_FaultCause *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_wsnt__TopicNotSupportedFaultType_FaultCause(soap, tag ? tag : "wsnt:TopicNotSupportedFaultType-FaultCause", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _wsnt__TopicNotSupportedFaultType_FaultCause ** SOAP_FMAC4 soap_get_PointerTo_wsnt__TopicNotSupportedFaultType_FaultCause(struct soap *soap, struct _wsnt__TopicNotSupportedFaultType_FaultCause **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_wsnt__TopicNotSupportedFaultType_FaultCause(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_wsnt__TopicNotSupportedFaultType_Description(struct soap *soap, struct _wsnt__TopicNotSupportedFaultType_Description *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__wsnt__TopicNotSupportedFaultType_Description))
		soap_serialize__wsnt__TopicNotSupportedFaultType_Description(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_wsnt__TopicNotSupportedFaultType_Description(struct soap *soap, const char *tag, int id, struct _wsnt__TopicNotSupportedFaultType_Description *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__wsnt__TopicNotSupportedFaultType_Description, NULL);
	if (id < 0)
		return soap->error;
	return soap_out__wsnt__TopicNotSupportedFaultType_Description(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _wsnt__TopicNotSupportedFaultType_Description ** SOAP_FMAC4 soap_in_PointerTo_wsnt__TopicNotSupportedFaultType_Description(struct soap *soap, const char *tag, struct _wsnt__TopicNotSupportedFaultType_Description **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _wsnt__TopicNotSupportedFaultType_Description **)soap_malloc(soap, sizeof(struct _wsnt__TopicNotSupportedFaultType_Description *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__wsnt__TopicNotSupportedFaultType_Description(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _wsnt__TopicNotSupportedFaultType_Description **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__wsnt__TopicNotSupportedFaultType_Description, sizeof(struct _wsnt__TopicNotSupportedFaultType_Description), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_wsnt__TopicNotSupportedFaultType_Description(struct soap *soap, struct _wsnt__TopicNotSupportedFaultType_Description *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_wsnt__TopicNotSupportedFaultType_Description(soap, tag ? tag : "wsnt:TopicNotSupportedFaultType-Description", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _wsnt__TopicNotSupportedFaultType_Description ** SOAP_FMAC4 soap_get_PointerTo_wsnt__TopicNotSupportedFaultType_Description(struct soap *soap, struct _wsnt__TopicNotSupportedFaultType_Description **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_wsnt__TopicNotSupportedFaultType_Description(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_wsnt__TopicNotSupportedFaultType_ErrorCode(struct soap *soap, struct _wsnt__TopicNotSupportedFaultType_ErrorCode *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__wsnt__TopicNotSupportedFaultType_ErrorCode))
		soap_serialize__wsnt__TopicNotSupportedFaultType_ErrorCode(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_wsnt__TopicNotSupportedFaultType_ErrorCode(struct soap *soap, const char *tag, int id, struct _wsnt__TopicNotSupportedFaultType_ErrorCode *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__wsnt__TopicNotSupportedFaultType_ErrorCode, NULL);
	if (id < 0)
		return soap->error;
	return soap_out__wsnt__TopicNotSupportedFaultType_ErrorCode(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _wsnt__TopicNotSupportedFaultType_ErrorCode ** SOAP_FMAC4 soap_in_PointerTo_wsnt__TopicNotSupportedFaultType_ErrorCode(struct soap *soap, const char *tag, struct _wsnt__TopicNotSupportedFaultType_ErrorCode **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _wsnt__TopicNotSupportedFaultType_ErrorCode **)soap_malloc(soap, sizeof(struct _wsnt__TopicNotSupportedFaultType_ErrorCode *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__wsnt__TopicNotSupportedFaultType_ErrorCode(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _wsnt__TopicNotSupportedFaultType_ErrorCode **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__wsnt__TopicNotSupportedFaultType_ErrorCode, sizeof(struct _wsnt__TopicNotSupportedFaultType_ErrorCode), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_wsnt__TopicNotSupportedFaultType_ErrorCode(struct soap *soap, struct _wsnt__TopicNotSupportedFaultType_ErrorCode *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_wsnt__TopicNotSupportedFaultType_ErrorCode(soap, tag ? tag : "wsnt:TopicNotSupportedFaultType-ErrorCode", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _wsnt__TopicNotSupportedFaultType_ErrorCode ** SOAP_FMAC4 soap_get_PointerTo_wsnt__TopicNotSupportedFaultType_ErrorCode(struct soap *soap, struct _wsnt__TopicNotSupportedFaultType_ErrorCode **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_wsnt__TopicNotSupportedFaultType_ErrorCode(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_wsnt__InvalidTopicExpressionFaultType_FaultCause(struct soap *soap, struct _wsnt__InvalidTopicExpressionFaultType_FaultCause *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__wsnt__InvalidTopicExpressionFaultType_FaultCause))
		soap_serialize__wsnt__InvalidTopicExpressionFaultType_FaultCause(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_wsnt__InvalidTopicExpressionFaultType_FaultCause(struct soap *soap, const char *tag, int id, struct _wsnt__InvalidTopicExpressionFaultType_FaultCause *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__wsnt__InvalidTopicExpressionFaultType_FaultCause, NULL);
	if (id < 0)
		return soap->error;
	return soap_out__wsnt__InvalidTopicExpressionFaultType_FaultCause(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _wsnt__InvalidTopicExpressionFaultType_FaultCause ** SOAP_FMAC4 soap_in_PointerTo_wsnt__InvalidTopicExpressionFaultType_FaultCause(struct soap *soap, const char *tag, struct _wsnt__InvalidTopicExpressionFaultType_FaultCause **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _wsnt__InvalidTopicExpressionFaultType_FaultCause **)soap_malloc(soap, sizeof(struct _wsnt__InvalidTopicExpressionFaultType_FaultCause *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__wsnt__InvalidTopicExpressionFaultType_FaultCause(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _wsnt__InvalidTopicExpressionFaultType_FaultCause **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__wsnt__InvalidTopicExpressionFaultType_FaultCause, sizeof(struct _wsnt__InvalidTopicExpressionFaultType_FaultCause), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_wsnt__InvalidTopicExpressionFaultType_FaultCause(struct soap *soap, struct _wsnt__InvalidTopicExpressionFaultType_FaultCause *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_wsnt__InvalidTopicExpressionFaultType_FaultCause(soap, tag ? tag : "wsnt:InvalidTopicExpressionFaultType-FaultCause", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _wsnt__InvalidTopicExpressionFaultType_FaultCause ** SOAP_FMAC4 soap_get_PointerTo_wsnt__InvalidTopicExpressionFaultType_FaultCause(struct soap *soap, struct _wsnt__InvalidTopicExpressionFaultType_FaultCause **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_wsnt__InvalidTopicExpressionFaultType_FaultCause(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_wsnt__InvalidTopicExpressionFaultType_Description(struct soap *soap, struct _wsnt__InvalidTopicExpressionFaultType_Description *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__wsnt__InvalidTopicExpressionFaultType_Description))
		soap_serialize__wsnt__InvalidTopicExpressionFaultType_Description(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_wsnt__InvalidTopicExpressionFaultType_Description(struct soap *soap, const char *tag, int id, struct _wsnt__InvalidTopicExpressionFaultType_Description *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__wsnt__InvalidTopicExpressionFaultType_Description, NULL);
	if (id < 0)
		return soap->error;
	return soap_out__wsnt__InvalidTopicExpressionFaultType_Description(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _wsnt__InvalidTopicExpressionFaultType_Description ** SOAP_FMAC4 soap_in_PointerTo_wsnt__InvalidTopicExpressionFaultType_Description(struct soap *soap, const char *tag, struct _wsnt__InvalidTopicExpressionFaultType_Description **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _wsnt__InvalidTopicExpressionFaultType_Description **)soap_malloc(soap, sizeof(struct _wsnt__InvalidTopicExpressionFaultType_Description *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__wsnt__InvalidTopicExpressionFaultType_Description(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _wsnt__InvalidTopicExpressionFaultType_Description **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__wsnt__InvalidTopicExpressionFaultType_Description, sizeof(struct _wsnt__InvalidTopicExpressionFaultType_Description), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_wsnt__InvalidTopicExpressionFaultType_Description(struct soap *soap, struct _wsnt__InvalidTopicExpressionFaultType_Description *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_wsnt__InvalidTopicExpressionFaultType_Description(soap, tag ? tag : "wsnt:InvalidTopicExpressionFaultType-Description", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _wsnt__InvalidTopicExpressionFaultType_Description ** SOAP_FMAC4 soap_get_PointerTo_wsnt__InvalidTopicExpressionFaultType_Description(struct soap *soap, struct _wsnt__InvalidTopicExpressionFaultType_Description **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_wsnt__InvalidTopicExpressionFaultType_Description(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_wsnt__InvalidTopicExpressionFaultType_ErrorCode(struct soap *soap, struct _wsnt__InvalidTopicExpressionFaultType_ErrorCode *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__wsnt__InvalidTopicExpressionFaultType_ErrorCode))
		soap_serialize__wsnt__InvalidTopicExpressionFaultType_ErrorCode(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_wsnt__InvalidTopicExpressionFaultType_ErrorCode(struct soap *soap, const char *tag, int id, struct _wsnt__InvalidTopicExpressionFaultType_ErrorCode *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__wsnt__InvalidTopicExpressionFaultType_ErrorCode, NULL);
	if (id < 0)
		return soap->error;
	return soap_out__wsnt__InvalidTopicExpressionFaultType_ErrorCode(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _wsnt__InvalidTopicExpressionFaultType_ErrorCode ** SOAP_FMAC4 soap_in_PointerTo_wsnt__InvalidTopicExpressionFaultType_ErrorCode(struct soap *soap, const char *tag, struct _wsnt__InvalidTopicExpressionFaultType_ErrorCode **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _wsnt__InvalidTopicExpressionFaultType_ErrorCode **)soap_malloc(soap, sizeof(struct _wsnt__InvalidTopicExpressionFaultType_ErrorCode *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__wsnt__InvalidTopicExpressionFaultType_ErrorCode(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _wsnt__InvalidTopicExpressionFaultType_ErrorCode **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__wsnt__InvalidTopicExpressionFaultType_ErrorCode, sizeof(struct _wsnt__InvalidTopicExpressionFaultType_ErrorCode), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_wsnt__InvalidTopicExpressionFaultType_ErrorCode(struct soap *soap, struct _wsnt__InvalidTopicExpressionFaultType_ErrorCode *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_wsnt__InvalidTopicExpressionFaultType_ErrorCode(soap, tag ? tag : "wsnt:InvalidTopicExpressionFaultType-ErrorCode", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _wsnt__InvalidTopicExpressionFaultType_ErrorCode ** SOAP_FMAC4 soap_get_PointerTo_wsnt__InvalidTopicExpressionFaultType_ErrorCode(struct soap *soap, struct _wsnt__InvalidTopicExpressionFaultType_ErrorCode **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_wsnt__InvalidTopicExpressionFaultType_ErrorCode(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_wsnt__TopicExpressionDialectUnknownFaultType_FaultCause(struct soap *soap, struct _wsnt__TopicExpressionDialectUnknownFaultType_FaultCause *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__wsnt__TopicExpressionDialectUnknownFaultType_FaultCause))
		soap_serialize__wsnt__TopicExpressionDialectUnknownFaultType_FaultCause(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_wsnt__TopicExpressionDialectUnknownFaultType_FaultCause(struct soap *soap, const char *tag, int id, struct _wsnt__TopicExpressionDialectUnknownFaultType_FaultCause *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__wsnt__TopicExpressionDialectUnknownFaultType_FaultCause, NULL);
	if (id < 0)
		return soap->error;
	return soap_out__wsnt__TopicExpressionDialectUnknownFaultType_FaultCause(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _wsnt__TopicExpressionDialectUnknownFaultType_FaultCause ** SOAP_FMAC4 soap_in_PointerTo_wsnt__TopicExpressionDialectUnknownFaultType_FaultCause(struct soap *soap, const char *tag, struct _wsnt__TopicExpressionDialectUnknownFaultType_FaultCause **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _wsnt__TopicExpressionDialectUnknownFaultType_FaultCause **)soap_malloc(soap, sizeof(struct _wsnt__TopicExpressionDialectUnknownFaultType_FaultCause *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__wsnt__TopicExpressionDialectUnknownFaultType_FaultCause(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _wsnt__TopicExpressionDialectUnknownFaultType_FaultCause **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__wsnt__TopicExpressionDialectUnknownFaultType_FaultCause, sizeof(struct _wsnt__TopicExpressionDialectUnknownFaultType_FaultCause), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_wsnt__TopicExpressionDialectUnknownFaultType_FaultCause(struct soap *soap, struct _wsnt__TopicExpressionDialectUnknownFaultType_FaultCause *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_wsnt__TopicExpressionDialectUnknownFaultType_FaultCause(soap, tag ? tag : "wsnt:TopicExpressionDialectUnknownFaultType-FaultCause", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _wsnt__TopicExpressionDialectUnknownFaultType_FaultCause ** SOAP_FMAC4 soap_get_PointerTo_wsnt__TopicExpressionDialectUnknownFaultType_FaultCause(struct soap *soap, struct _wsnt__TopicExpressionDialectUnknownFaultType_FaultCause **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_wsnt__TopicExpressionDialectUnknownFaultType_FaultCause(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_wsnt__TopicExpressionDialectUnknownFaultType_Description(struct soap *soap, struct _wsnt__TopicExpressionDialectUnknownFaultType_Description *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__wsnt__TopicExpressionDialectUnknownFaultType_Description))
		soap_serialize__wsnt__TopicExpressionDialectUnknownFaultType_Description(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_wsnt__TopicExpressionDialectUnknownFaultType_Description(struct soap *soap, const char *tag, int id, struct _wsnt__TopicExpressionDialectUnknownFaultType_Description *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__wsnt__TopicExpressionDialectUnknownFaultType_Description, NULL);
	if (id < 0)
		return soap->error;
	return soap_out__wsnt__TopicExpressionDialectUnknownFaultType_Description(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _wsnt__TopicExpressionDialectUnknownFaultType_Description ** SOAP_FMAC4 soap_in_PointerTo_wsnt__TopicExpressionDialectUnknownFaultType_Description(struct soap *soap, const char *tag, struct _wsnt__TopicExpressionDialectUnknownFaultType_Description **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _wsnt__TopicExpressionDialectUnknownFaultType_Description **)soap_malloc(soap, sizeof(struct _wsnt__TopicExpressionDialectUnknownFaultType_Description *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__wsnt__TopicExpressionDialectUnknownFaultType_Description(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _wsnt__TopicExpressionDialectUnknownFaultType_Description **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__wsnt__TopicExpressionDialectUnknownFaultType_Description, sizeof(struct _wsnt__TopicExpressionDialectUnknownFaultType_Description), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_wsnt__TopicExpressionDialectUnknownFaultType_Description(struct soap *soap, struct _wsnt__TopicExpressionDialectUnknownFaultType_Description *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_wsnt__TopicExpressionDialectUnknownFaultType_Description(soap, tag ? tag : "wsnt:TopicExpressionDialectUnknownFaultType-Description", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _wsnt__TopicExpressionDialectUnknownFaultType_Description ** SOAP_FMAC4 soap_get_PointerTo_wsnt__TopicExpressionDialectUnknownFaultType_Description(struct soap *soap, struct _wsnt__TopicExpressionDialectUnknownFaultType_Description **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_wsnt__TopicExpressionDialectUnknownFaultType_Description(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_wsnt__TopicExpressionDialectUnknownFaultType_ErrorCode(struct soap *soap, struct _wsnt__TopicExpressionDialectUnknownFaultType_ErrorCode *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__wsnt__TopicExpressionDialectUnknownFaultType_ErrorCode))
		soap_serialize__wsnt__TopicExpressionDialectUnknownFaultType_ErrorCode(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_wsnt__TopicExpressionDialectUnknownFaultType_ErrorCode(struct soap *soap, const char *tag, int id, struct _wsnt__TopicExpressionDialectUnknownFaultType_ErrorCode *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__wsnt__TopicExpressionDialectUnknownFaultType_ErrorCode, NULL);
	if (id < 0)
		return soap->error;
	return soap_out__wsnt__TopicExpressionDialectUnknownFaultType_ErrorCode(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _wsnt__TopicExpressionDialectUnknownFaultType_ErrorCode ** SOAP_FMAC4 soap_in_PointerTo_wsnt__TopicExpressionDialectUnknownFaultType_ErrorCode(struct soap *soap, const char *tag, struct _wsnt__TopicExpressionDialectUnknownFaultType_ErrorCode **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _wsnt__TopicExpressionDialectUnknownFaultType_ErrorCode **)soap_malloc(soap, sizeof(struct _wsnt__TopicExpressionDialectUnknownFaultType_ErrorCode *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__wsnt__TopicExpressionDialectUnknownFaultType_ErrorCode(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _wsnt__TopicExpressionDialectUnknownFaultType_ErrorCode **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__wsnt__TopicExpressionDialectUnknownFaultType_ErrorCode, sizeof(struct _wsnt__TopicExpressionDialectUnknownFaultType_ErrorCode), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_wsnt__TopicExpressionDialectUnknownFaultType_ErrorCode(struct soap *soap, struct _wsnt__TopicExpressionDialectUnknownFaultType_ErrorCode *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_wsnt__TopicExpressionDialectUnknownFaultType_ErrorCode(soap, tag ? tag : "wsnt:TopicExpressionDialectUnknownFaultType-ErrorCode", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _wsnt__TopicExpressionDialectUnknownFaultType_ErrorCode ** SOAP_FMAC4 soap_get_PointerTo_wsnt__TopicExpressionDialectUnknownFaultType_ErrorCode(struct soap *soap, struct _wsnt__TopicExpressionDialectUnknownFaultType_ErrorCode **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_wsnt__TopicExpressionDialectUnknownFaultType_ErrorCode(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_wsnt__InvalidFilterFaultType_FaultCause(struct soap *soap, struct _wsnt__InvalidFilterFaultType_FaultCause *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__wsnt__InvalidFilterFaultType_FaultCause))
		soap_serialize__wsnt__InvalidFilterFaultType_FaultCause(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_wsnt__InvalidFilterFaultType_FaultCause(struct soap *soap, const char *tag, int id, struct _wsnt__InvalidFilterFaultType_FaultCause *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__wsnt__InvalidFilterFaultType_FaultCause, NULL);
	if (id < 0)
		return soap->error;
	return soap_out__wsnt__InvalidFilterFaultType_FaultCause(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _wsnt__InvalidFilterFaultType_FaultCause ** SOAP_FMAC4 soap_in_PointerTo_wsnt__InvalidFilterFaultType_FaultCause(struct soap *soap, const char *tag, struct _wsnt__InvalidFilterFaultType_FaultCause **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _wsnt__InvalidFilterFaultType_FaultCause **)soap_malloc(soap, sizeof(struct _wsnt__InvalidFilterFaultType_FaultCause *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__wsnt__InvalidFilterFaultType_FaultCause(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _wsnt__InvalidFilterFaultType_FaultCause **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__wsnt__InvalidFilterFaultType_FaultCause, sizeof(struct _wsnt__InvalidFilterFaultType_FaultCause), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_wsnt__InvalidFilterFaultType_FaultCause(struct soap *soap, struct _wsnt__InvalidFilterFaultType_FaultCause *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_wsnt__InvalidFilterFaultType_FaultCause(soap, tag ? tag : "wsnt:InvalidFilterFaultType-FaultCause", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _wsnt__InvalidFilterFaultType_FaultCause ** SOAP_FMAC4 soap_get_PointerTo_wsnt__InvalidFilterFaultType_FaultCause(struct soap *soap, struct _wsnt__InvalidFilterFaultType_FaultCause **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_wsnt__InvalidFilterFaultType_FaultCause(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_wsnt__InvalidFilterFaultType_Description(struct soap *soap, struct _wsnt__InvalidFilterFaultType_Description *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__wsnt__InvalidFilterFaultType_Description))
		soap_serialize__wsnt__InvalidFilterFaultType_Description(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_wsnt__InvalidFilterFaultType_Description(struct soap *soap, const char *tag, int id, struct _wsnt__InvalidFilterFaultType_Description *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__wsnt__InvalidFilterFaultType_Description, NULL);
	if (id < 0)
		return soap->error;
	return soap_out__wsnt__InvalidFilterFaultType_Description(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _wsnt__InvalidFilterFaultType_Description ** SOAP_FMAC4 soap_in_PointerTo_wsnt__InvalidFilterFaultType_Description(struct soap *soap, const char *tag, struct _wsnt__InvalidFilterFaultType_Description **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _wsnt__InvalidFilterFaultType_Description **)soap_malloc(soap, sizeof(struct _wsnt__InvalidFilterFaultType_Description *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__wsnt__InvalidFilterFaultType_Description(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _wsnt__InvalidFilterFaultType_Description **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__wsnt__InvalidFilterFaultType_Description, sizeof(struct _wsnt__InvalidFilterFaultType_Description), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_wsnt__InvalidFilterFaultType_Description(struct soap *soap, struct _wsnt__InvalidFilterFaultType_Description *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_wsnt__InvalidFilterFaultType_Description(soap, tag ? tag : "wsnt:InvalidFilterFaultType-Description", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _wsnt__InvalidFilterFaultType_Description ** SOAP_FMAC4 soap_get_PointerTo_wsnt__InvalidFilterFaultType_Description(struct soap *soap, struct _wsnt__InvalidFilterFaultType_Description **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_wsnt__InvalidFilterFaultType_Description(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_wsnt__InvalidFilterFaultType_ErrorCode(struct soap *soap, struct _wsnt__InvalidFilterFaultType_ErrorCode *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__wsnt__InvalidFilterFaultType_ErrorCode))
		soap_serialize__wsnt__InvalidFilterFaultType_ErrorCode(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_wsnt__InvalidFilterFaultType_ErrorCode(struct soap *soap, const char *tag, int id, struct _wsnt__InvalidFilterFaultType_ErrorCode *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__wsnt__InvalidFilterFaultType_ErrorCode, NULL);
	if (id < 0)
		return soap->error;
	return soap_out__wsnt__InvalidFilterFaultType_ErrorCode(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _wsnt__InvalidFilterFaultType_ErrorCode ** SOAP_FMAC4 soap_in_PointerTo_wsnt__InvalidFilterFaultType_ErrorCode(struct soap *soap, const char *tag, struct _wsnt__InvalidFilterFaultType_ErrorCode **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _wsnt__InvalidFilterFaultType_ErrorCode **)soap_malloc(soap, sizeof(struct _wsnt__InvalidFilterFaultType_ErrorCode *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__wsnt__InvalidFilterFaultType_ErrorCode(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _wsnt__InvalidFilterFaultType_ErrorCode **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__wsnt__InvalidFilterFaultType_ErrorCode, sizeof(struct _wsnt__InvalidFilterFaultType_ErrorCode), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_wsnt__InvalidFilterFaultType_ErrorCode(struct soap *soap, struct _wsnt__InvalidFilterFaultType_ErrorCode *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_wsnt__InvalidFilterFaultType_ErrorCode(soap, tag ? tag : "wsnt:InvalidFilterFaultType-ErrorCode", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _wsnt__InvalidFilterFaultType_ErrorCode ** SOAP_FMAC4 soap_get_PointerTo_wsnt__InvalidFilterFaultType_ErrorCode(struct soap *soap, struct _wsnt__InvalidFilterFaultType_ErrorCode **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_wsnt__InvalidFilterFaultType_ErrorCode(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_wsnt__SubscribeCreationFailedFaultType_FaultCause(struct soap *soap, struct _wsnt__SubscribeCreationFailedFaultType_FaultCause *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__wsnt__SubscribeCreationFailedFaultType_FaultCause))
		soap_serialize__wsnt__SubscribeCreationFailedFaultType_FaultCause(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_wsnt__SubscribeCreationFailedFaultType_FaultCause(struct soap *soap, const char *tag, int id, struct _wsnt__SubscribeCreationFailedFaultType_FaultCause *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__wsnt__SubscribeCreationFailedFaultType_FaultCause, NULL);
	if (id < 0)
		return soap->error;
	return soap_out__wsnt__SubscribeCreationFailedFaultType_FaultCause(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _wsnt__SubscribeCreationFailedFaultType_FaultCause ** SOAP_FMAC4 soap_in_PointerTo_wsnt__SubscribeCreationFailedFaultType_FaultCause(struct soap *soap, const char *tag, struct _wsnt__SubscribeCreationFailedFaultType_FaultCause **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _wsnt__SubscribeCreationFailedFaultType_FaultCause **)soap_malloc(soap, sizeof(struct _wsnt__SubscribeCreationFailedFaultType_FaultCause *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__wsnt__SubscribeCreationFailedFaultType_FaultCause(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _wsnt__SubscribeCreationFailedFaultType_FaultCause **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__wsnt__SubscribeCreationFailedFaultType_FaultCause, sizeof(struct _wsnt__SubscribeCreationFailedFaultType_FaultCause), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_wsnt__SubscribeCreationFailedFaultType_FaultCause(struct soap *soap, struct _wsnt__SubscribeCreationFailedFaultType_FaultCause *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_wsnt__SubscribeCreationFailedFaultType_FaultCause(soap, tag ? tag : "wsnt:SubscribeCreationFailedFaultType-FaultCause", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _wsnt__SubscribeCreationFailedFaultType_FaultCause ** SOAP_FMAC4 soap_get_PointerTo_wsnt__SubscribeCreationFailedFaultType_FaultCause(struct soap *soap, struct _wsnt__SubscribeCreationFailedFaultType_FaultCause **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_wsnt__SubscribeCreationFailedFaultType_FaultCause(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_wsnt__SubscribeCreationFailedFaultType_Description(struct soap *soap, struct _wsnt__SubscribeCreationFailedFaultType_Description *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__wsnt__SubscribeCreationFailedFaultType_Description))
		soap_serialize__wsnt__SubscribeCreationFailedFaultType_Description(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_wsnt__SubscribeCreationFailedFaultType_Description(struct soap *soap, const char *tag, int id, struct _wsnt__SubscribeCreationFailedFaultType_Description *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__wsnt__SubscribeCreationFailedFaultType_Description, NULL);
	if (id < 0)
		return soap->error;
	return soap_out__wsnt__SubscribeCreationFailedFaultType_Description(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _wsnt__SubscribeCreationFailedFaultType_Description ** SOAP_FMAC4 soap_in_PointerTo_wsnt__SubscribeCreationFailedFaultType_Description(struct soap *soap, const char *tag, struct _wsnt__SubscribeCreationFailedFaultType_Description **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _wsnt__SubscribeCreationFailedFaultType_Description **)soap_malloc(soap, sizeof(struct _wsnt__SubscribeCreationFailedFaultType_Description *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__wsnt__SubscribeCreationFailedFaultType_Description(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _wsnt__SubscribeCreationFailedFaultType_Description **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__wsnt__SubscribeCreationFailedFaultType_Description, sizeof(struct _wsnt__SubscribeCreationFailedFaultType_Description), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_wsnt__SubscribeCreationFailedFaultType_Description(struct soap *soap, struct _wsnt__SubscribeCreationFailedFaultType_Description *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_wsnt__SubscribeCreationFailedFaultType_Description(soap, tag ? tag : "wsnt:SubscribeCreationFailedFaultType-Description", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _wsnt__SubscribeCreationFailedFaultType_Description ** SOAP_FMAC4 soap_get_PointerTo_wsnt__SubscribeCreationFailedFaultType_Description(struct soap *soap, struct _wsnt__SubscribeCreationFailedFaultType_Description **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_wsnt__SubscribeCreationFailedFaultType_Description(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_wsnt__SubscribeCreationFailedFaultType_ErrorCode(struct soap *soap, struct _wsnt__SubscribeCreationFailedFaultType_ErrorCode *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__wsnt__SubscribeCreationFailedFaultType_ErrorCode))
		soap_serialize__wsnt__SubscribeCreationFailedFaultType_ErrorCode(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_wsnt__SubscribeCreationFailedFaultType_ErrorCode(struct soap *soap, const char *tag, int id, struct _wsnt__SubscribeCreationFailedFaultType_ErrorCode *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__wsnt__SubscribeCreationFailedFaultType_ErrorCode, NULL);
	if (id < 0)
		return soap->error;
	return soap_out__wsnt__SubscribeCreationFailedFaultType_ErrorCode(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _wsnt__SubscribeCreationFailedFaultType_ErrorCode ** SOAP_FMAC4 soap_in_PointerTo_wsnt__SubscribeCreationFailedFaultType_ErrorCode(struct soap *soap, const char *tag, struct _wsnt__SubscribeCreationFailedFaultType_ErrorCode **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _wsnt__SubscribeCreationFailedFaultType_ErrorCode **)soap_malloc(soap, sizeof(struct _wsnt__SubscribeCreationFailedFaultType_ErrorCode *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__wsnt__SubscribeCreationFailedFaultType_ErrorCode(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _wsnt__SubscribeCreationFailedFaultType_ErrorCode **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__wsnt__SubscribeCreationFailedFaultType_ErrorCode, sizeof(struct _wsnt__SubscribeCreationFailedFaultType_ErrorCode), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_wsnt__SubscribeCreationFailedFaultType_ErrorCode(struct soap *soap, struct _wsnt__SubscribeCreationFailedFaultType_ErrorCode *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_wsnt__SubscribeCreationFailedFaultType_ErrorCode(soap, tag ? tag : "wsnt:SubscribeCreationFailedFaultType-ErrorCode", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _wsnt__SubscribeCreationFailedFaultType_ErrorCode ** SOAP_FMAC4 soap_get_PointerTo_wsnt__SubscribeCreationFailedFaultType_ErrorCode(struct soap *soap, struct _wsnt__SubscribeCreationFailedFaultType_ErrorCode **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_wsnt__SubscribeCreationFailedFaultType_ErrorCode(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__MulticastConfiguration(struct soap *soap, struct tt__MulticastConfiguration *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__MulticastConfiguration))
		soap_serialize_tt__MulticastConfiguration(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__MulticastConfiguration(struct soap *soap, const char *tag, int id, struct tt__MulticastConfiguration *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__MulticastConfiguration, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_tt__MulticastConfiguration(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__MulticastConfiguration ** SOAP_FMAC4 soap_in_PointerTott__MulticastConfiguration(struct soap *soap, const char *tag, struct tt__MulticastConfiguration **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__MulticastConfiguration **)soap_malloc(soap, sizeof(struct tt__MulticastConfiguration *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__MulticastConfiguration(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__MulticastConfiguration **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__MulticastConfiguration, sizeof(struct tt__MulticastConfiguration), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__MulticastConfiguration(struct soap *soap, struct tt__MulticastConfiguration *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__MulticastConfiguration(soap, tag ? tag : "tt:MulticastConfiguration", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__MulticastConfiguration ** SOAP_FMAC4 soap_get_PointerTott__MulticastConfiguration(struct soap *soap, struct tt__MulticastConfiguration **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__MulticastConfiguration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__H264Configuration(struct soap *soap, struct tt__H264Configuration *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__H264Configuration))
		soap_serialize_tt__H264Configuration(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__H264Configuration(struct soap *soap, const char *tag, int id, struct tt__H264Configuration *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__H264Configuration, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_tt__H264Configuration(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__H264Configuration ** SOAP_FMAC4 soap_in_PointerTott__H264Configuration(struct soap *soap, const char *tag, struct tt__H264Configuration **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__H264Configuration **)soap_malloc(soap, sizeof(struct tt__H264Configuration *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__H264Configuration(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__H264Configuration **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__H264Configuration, sizeof(struct tt__H264Configuration), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__H264Configuration(struct soap *soap, struct tt__H264Configuration *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__H264Configuration(soap, tag ? tag : "tt:H264Configuration", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__H264Configuration ** SOAP_FMAC4 soap_get_PointerTott__H264Configuration(struct soap *soap, struct tt__H264Configuration **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__H264Configuration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__Mpeg4Configuration(struct soap *soap, struct tt__Mpeg4Configuration *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__Mpeg4Configuration))
		soap_serialize_tt__Mpeg4Configuration(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__Mpeg4Configuration(struct soap *soap, const char *tag, int id, struct tt__Mpeg4Configuration *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__Mpeg4Configuration, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_tt__Mpeg4Configuration(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__Mpeg4Configuration ** SOAP_FMAC4 soap_in_PointerTott__Mpeg4Configuration(struct soap *soap, const char *tag, struct tt__Mpeg4Configuration **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__Mpeg4Configuration **)soap_malloc(soap, sizeof(struct tt__Mpeg4Configuration *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__Mpeg4Configuration(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__Mpeg4Configuration **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__Mpeg4Configuration, sizeof(struct tt__Mpeg4Configuration), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__Mpeg4Configuration(struct soap *soap, struct tt__Mpeg4Configuration *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__Mpeg4Configuration(soap, tag ? tag : "tt:Mpeg4Configuration", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__Mpeg4Configuration ** SOAP_FMAC4 soap_get_PointerTott__Mpeg4Configuration(struct soap *soap, struct tt__Mpeg4Configuration **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__Mpeg4Configuration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__VideoRateControl(struct soap *soap, struct tt__VideoRateControl *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__VideoRateControl))
		soap_serialize_tt__VideoRateControl(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__VideoRateControl(struct soap *soap, const char *tag, int id, struct tt__VideoRateControl *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__VideoRateControl, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_tt__VideoRateControl(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__VideoRateControl ** SOAP_FMAC4 soap_in_PointerTott__VideoRateControl(struct soap *soap, const char *tag, struct tt__VideoRateControl **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__VideoRateControl **)soap_malloc(soap, sizeof(struct tt__VideoRateControl *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__VideoRateControl(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__VideoRateControl **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__VideoRateControl, sizeof(struct tt__VideoRateControl), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__VideoRateControl(struct soap *soap, struct tt__VideoRateControl *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__VideoRateControl(soap, tag ? tag : "tt:VideoRateControl", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__VideoRateControl ** SOAP_FMAC4 soap_get_PointerTott__VideoRateControl(struct soap *soap, struct tt__VideoRateControl **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__VideoRateControl(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__MediaUri(struct soap *soap, struct tt__MediaUri *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__MediaUri))
		soap_serialize_tt__MediaUri(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__MediaUri(struct soap *soap, const char *tag, int id, struct tt__MediaUri *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__MediaUri, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_tt__MediaUri(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__MediaUri ** SOAP_FMAC4 soap_in_PointerTott__MediaUri(struct soap *soap, const char *tag, struct tt__MediaUri **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__MediaUri **)soap_malloc(soap, sizeof(struct tt__MediaUri *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__MediaUri(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__MediaUri **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__MediaUri, sizeof(struct tt__MediaUri), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__MediaUri(struct soap *soap, struct tt__MediaUri *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__MediaUri(soap, tag ? tag : "tt:MediaUri", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__MediaUri ** SOAP_FMAC4 soap_get_PointerTott__MediaUri(struct soap *soap, struct tt__MediaUri **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__MediaUri(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__Profile(struct soap *soap, struct tt__Profile *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__Profile))
		soap_serialize_tt__Profile(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__Profile(struct soap *soap, const char *tag, int id, struct tt__Profile *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__Profile, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_tt__Profile(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__Profile ** SOAP_FMAC4 soap_in_PointerTott__Profile(struct soap *soap, const char *tag, struct tt__Profile **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__Profile **)soap_malloc(soap, sizeof(struct tt__Profile *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__Profile(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__Profile **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__Profile, sizeof(struct tt__Profile), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__Profile(struct soap *soap, struct tt__Profile *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__Profile(soap, tag ? tag : "tt:Profile", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__Profile ** SOAP_FMAC4 soap_get_PointerTott__Profile(struct soap *soap, struct tt__Profile **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__Profile(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTotrt__Capabilities(struct soap *soap, struct trt__Capabilities *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_trt__Capabilities))
		soap_serialize_trt__Capabilities(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTotrt__Capabilities(struct soap *soap, const char *tag, int id, struct trt__Capabilities *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_trt__Capabilities, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_trt__Capabilities(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct trt__Capabilities ** SOAP_FMAC4 soap_in_PointerTotrt__Capabilities(struct soap *soap, const char *tag, struct trt__Capabilities **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct trt__Capabilities **)soap_malloc(soap, sizeof(struct trt__Capabilities *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_trt__Capabilities(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct trt__Capabilities **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_trt__Capabilities, sizeof(struct trt__Capabilities), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTotrt__Capabilities(struct soap *soap, struct trt__Capabilities *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTotrt__Capabilities(soap, tag ? tag : "trt:Capabilities", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct trt__Capabilities ** SOAP_FMAC4 soap_get_PointerTotrt__Capabilities(struct soap *soap, struct trt__Capabilities **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTotrt__Capabilities(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTotrt__ProfileCapabilities(struct soap *soap, struct trt__ProfileCapabilities *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_trt__ProfileCapabilities))
		soap_serialize_trt__ProfileCapabilities(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTotrt__ProfileCapabilities(struct soap *soap, const char *tag, int id, struct trt__ProfileCapabilities *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_trt__ProfileCapabilities, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_trt__ProfileCapabilities(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct trt__ProfileCapabilities ** SOAP_FMAC4 soap_in_PointerTotrt__ProfileCapabilities(struct soap *soap, const char *tag, struct trt__ProfileCapabilities **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct trt__ProfileCapabilities **)soap_malloc(soap, sizeof(struct trt__ProfileCapabilities *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_trt__ProfileCapabilities(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct trt__ProfileCapabilities **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_trt__ProfileCapabilities, sizeof(struct trt__ProfileCapabilities), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTotrt__ProfileCapabilities(struct soap *soap, struct trt__ProfileCapabilities *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTotrt__ProfileCapabilities(soap, tag ? tag : "trt:ProfileCapabilities", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct trt__ProfileCapabilities ** SOAP_FMAC4 soap_get_PointerTotrt__ProfileCapabilities(struct soap *soap, struct trt__ProfileCapabilities **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTotrt__ProfileCapabilities(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTowstop__Documentation(struct soap *soap, struct wstop__Documentation *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_wstop__Documentation))
		soap_serialize_wstop__Documentation(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTowstop__Documentation(struct soap *soap, const char *tag, int id, struct wstop__Documentation *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_wstop__Documentation, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_wstop__Documentation(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct wstop__Documentation ** SOAP_FMAC4 soap_in_PointerTowstop__Documentation(struct soap *soap, const char *tag, struct wstop__Documentation **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct wstop__Documentation **)soap_malloc(soap, sizeof(struct wstop__Documentation *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_wstop__Documentation(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct wstop__Documentation **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_wstop__Documentation, sizeof(struct wstop__Documentation), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTowstop__Documentation(struct soap *soap, struct wstop__Documentation *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTowstop__Documentation(soap, tag ? tag : "wstop:Documentation", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct wstop__Documentation ** SOAP_FMAC4 soap_get_PointerTowstop__Documentation(struct soap *soap, struct wstop__Documentation **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTowstop__Documentation(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_wsrfbf__BaseFaultType_FaultCause(struct soap *soap, struct _wsrfbf__BaseFaultType_FaultCause *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__wsrfbf__BaseFaultType_FaultCause))
		soap_serialize__wsrfbf__BaseFaultType_FaultCause(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_wsrfbf__BaseFaultType_FaultCause(struct soap *soap, const char *tag, int id, struct _wsrfbf__BaseFaultType_FaultCause *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__wsrfbf__BaseFaultType_FaultCause, NULL);
	if (id < 0)
		return soap->error;
	return soap_out__wsrfbf__BaseFaultType_FaultCause(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _wsrfbf__BaseFaultType_FaultCause ** SOAP_FMAC4 soap_in_PointerTo_wsrfbf__BaseFaultType_FaultCause(struct soap *soap, const char *tag, struct _wsrfbf__BaseFaultType_FaultCause **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _wsrfbf__BaseFaultType_FaultCause **)soap_malloc(soap, sizeof(struct _wsrfbf__BaseFaultType_FaultCause *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__wsrfbf__BaseFaultType_FaultCause(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _wsrfbf__BaseFaultType_FaultCause **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__wsrfbf__BaseFaultType_FaultCause, sizeof(struct _wsrfbf__BaseFaultType_FaultCause), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_wsrfbf__BaseFaultType_FaultCause(struct soap *soap, struct _wsrfbf__BaseFaultType_FaultCause *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_wsrfbf__BaseFaultType_FaultCause(soap, tag ? tag : "wsrfbf:BaseFaultType-FaultCause", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _wsrfbf__BaseFaultType_FaultCause ** SOAP_FMAC4 soap_get_PointerTo_wsrfbf__BaseFaultType_FaultCause(struct soap *soap, struct _wsrfbf__BaseFaultType_FaultCause **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_wsrfbf__BaseFaultType_FaultCause(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_wsrfbf__BaseFaultType_Description(struct soap *soap, struct _wsrfbf__BaseFaultType_Description *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__wsrfbf__BaseFaultType_Description))
		soap_serialize__wsrfbf__BaseFaultType_Description(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_wsrfbf__BaseFaultType_Description(struct soap *soap, const char *tag, int id, struct _wsrfbf__BaseFaultType_Description *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__wsrfbf__BaseFaultType_Description, NULL);
	if (id < 0)
		return soap->error;
	return soap_out__wsrfbf__BaseFaultType_Description(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _wsrfbf__BaseFaultType_Description ** SOAP_FMAC4 soap_in_PointerTo_wsrfbf__BaseFaultType_Description(struct soap *soap, const char *tag, struct _wsrfbf__BaseFaultType_Description **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _wsrfbf__BaseFaultType_Description **)soap_malloc(soap, sizeof(struct _wsrfbf__BaseFaultType_Description *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__wsrfbf__BaseFaultType_Description(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _wsrfbf__BaseFaultType_Description **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__wsrfbf__BaseFaultType_Description, sizeof(struct _wsrfbf__BaseFaultType_Description), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_wsrfbf__BaseFaultType_Description(struct soap *soap, struct _wsrfbf__BaseFaultType_Description *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_wsrfbf__BaseFaultType_Description(soap, tag ? tag : "wsrfbf:BaseFaultType-Description", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _wsrfbf__BaseFaultType_Description ** SOAP_FMAC4 soap_get_PointerTo_wsrfbf__BaseFaultType_Description(struct soap *soap, struct _wsrfbf__BaseFaultType_Description **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_wsrfbf__BaseFaultType_Description(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_wsrfbf__BaseFaultType_ErrorCode(struct soap *soap, struct _wsrfbf__BaseFaultType_ErrorCode *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__wsrfbf__BaseFaultType_ErrorCode))
		soap_serialize__wsrfbf__BaseFaultType_ErrorCode(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_wsrfbf__BaseFaultType_ErrorCode(struct soap *soap, const char *tag, int id, struct _wsrfbf__BaseFaultType_ErrorCode *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__wsrfbf__BaseFaultType_ErrorCode, NULL);
	if (id < 0)
		return soap->error;
	return soap_out__wsrfbf__BaseFaultType_ErrorCode(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _wsrfbf__BaseFaultType_ErrorCode ** SOAP_FMAC4 soap_in_PointerTo_wsrfbf__BaseFaultType_ErrorCode(struct soap *soap, const char *tag, struct _wsrfbf__BaseFaultType_ErrorCode **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _wsrfbf__BaseFaultType_ErrorCode **)soap_malloc(soap, sizeof(struct _wsrfbf__BaseFaultType_ErrorCode *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__wsrfbf__BaseFaultType_ErrorCode(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _wsrfbf__BaseFaultType_ErrorCode **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__wsrfbf__BaseFaultType_ErrorCode, sizeof(struct _wsrfbf__BaseFaultType_ErrorCode), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_wsrfbf__BaseFaultType_ErrorCode(struct soap *soap, struct _wsrfbf__BaseFaultType_ErrorCode *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_wsrfbf__BaseFaultType_ErrorCode(soap, tag ? tag : "wsrfbf:BaseFaultType-ErrorCode", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _wsrfbf__BaseFaultType_ErrorCode ** SOAP_FMAC4 soap_get_PointerTo_wsrfbf__BaseFaultType_ErrorCode(struct soap *soap, struct _wsrfbf__BaseFaultType_ErrorCode **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_wsrfbf__BaseFaultType_ErrorCode(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_wsnt__Subscribe_SubscriptionPolicy(struct soap *soap, struct _wsnt__Subscribe_SubscriptionPolicy *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__wsnt__Subscribe_SubscriptionPolicy))
		soap_serialize__wsnt__Subscribe_SubscriptionPolicy(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_wsnt__Subscribe_SubscriptionPolicy(struct soap *soap, const char *tag, int id, struct _wsnt__Subscribe_SubscriptionPolicy *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__wsnt__Subscribe_SubscriptionPolicy, NULL);
	if (id < 0)
		return soap->error;
	return soap_out__wsnt__Subscribe_SubscriptionPolicy(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _wsnt__Subscribe_SubscriptionPolicy ** SOAP_FMAC4 soap_in_PointerTo_wsnt__Subscribe_SubscriptionPolicy(struct soap *soap, const char *tag, struct _wsnt__Subscribe_SubscriptionPolicy **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _wsnt__Subscribe_SubscriptionPolicy **)soap_malloc(soap, sizeof(struct _wsnt__Subscribe_SubscriptionPolicy *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__wsnt__Subscribe_SubscriptionPolicy(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _wsnt__Subscribe_SubscriptionPolicy **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__wsnt__Subscribe_SubscriptionPolicy, sizeof(struct _wsnt__Subscribe_SubscriptionPolicy), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_wsnt__Subscribe_SubscriptionPolicy(struct soap *soap, struct _wsnt__Subscribe_SubscriptionPolicy *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_wsnt__Subscribe_SubscriptionPolicy(soap, tag ? tag : "wsnt:Subscribe-SubscriptionPolicy", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _wsnt__Subscribe_SubscriptionPolicy ** SOAP_FMAC4 soap_get_PointerTo_wsnt__Subscribe_SubscriptionPolicy(struct soap *soap, struct _wsnt__Subscribe_SubscriptionPolicy **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_wsnt__Subscribe_SubscriptionPolicy(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTowsnt__NotificationMessageHolderType(struct soap *soap, struct wsnt__NotificationMessageHolderType *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_wsnt__NotificationMessageHolderType))
		soap_serialize_wsnt__NotificationMessageHolderType(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTowsnt__NotificationMessageHolderType(struct soap *soap, const char *tag, int id, struct wsnt__NotificationMessageHolderType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_wsnt__NotificationMessageHolderType, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_wsnt__NotificationMessageHolderType(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct wsnt__NotificationMessageHolderType ** SOAP_FMAC4 soap_in_PointerTowsnt__NotificationMessageHolderType(struct soap *soap, const char *tag, struct wsnt__NotificationMessageHolderType **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct wsnt__NotificationMessageHolderType **)soap_malloc(soap, sizeof(struct wsnt__NotificationMessageHolderType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_wsnt__NotificationMessageHolderType(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct wsnt__NotificationMessageHolderType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_wsnt__NotificationMessageHolderType, sizeof(struct wsnt__NotificationMessageHolderType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTowsnt__NotificationMessageHolderType(struct soap *soap, struct wsnt__NotificationMessageHolderType *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTowsnt__NotificationMessageHolderType(soap, tag ? tag : "wsnt:NotificationMessageHolderType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct wsnt__NotificationMessageHolderType ** SOAP_FMAC4 soap_get_PointerTowsnt__NotificationMessageHolderType(struct soap *soap, struct wsnt__NotificationMessageHolderType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTowsnt__NotificationMessageHolderType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTodateTime(struct soap *soap, time_t *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	(void)soap_reference(soap, *a, SOAP_TYPE_dateTime);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTodateTime(struct soap *soap, const char *tag, int id, time_t *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_dateTime, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_dateTime(soap, tag, id, *a, type);
}

SOAP_FMAC3 time_t ** SOAP_FMAC4 soap_in_PointerTodateTime(struct soap *soap, const char *tag, time_t **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (time_t **)soap_malloc(soap, sizeof(time_t *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_dateTime(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (time_t **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_dateTime, sizeof(time_t), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTodateTime(struct soap *soap, time_t *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTodateTime(soap, tag ? tag : "dateTime", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 time_t ** SOAP_FMAC4 soap_get_PointerTodateTime(struct soap *soap, time_t **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTodateTime(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTowsnt__SubscriptionPolicyType(struct soap *soap, struct wsnt__SubscriptionPolicyType *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_wsnt__SubscriptionPolicyType))
		soap_serialize_wsnt__SubscriptionPolicyType(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTowsnt__SubscriptionPolicyType(struct soap *soap, const char *tag, int id, struct wsnt__SubscriptionPolicyType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_wsnt__SubscriptionPolicyType, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_wsnt__SubscriptionPolicyType(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct wsnt__SubscriptionPolicyType ** SOAP_FMAC4 soap_in_PointerTowsnt__SubscriptionPolicyType(struct soap *soap, const char *tag, struct wsnt__SubscriptionPolicyType **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct wsnt__SubscriptionPolicyType **)soap_malloc(soap, sizeof(struct wsnt__SubscriptionPolicyType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_wsnt__SubscriptionPolicyType(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct wsnt__SubscriptionPolicyType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_wsnt__SubscriptionPolicyType, sizeof(struct wsnt__SubscriptionPolicyType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTowsnt__SubscriptionPolicyType(struct soap *soap, struct wsnt__SubscriptionPolicyType *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTowsnt__SubscriptionPolicyType(soap, tag ? tag : "wsnt:SubscriptionPolicyType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct wsnt__SubscriptionPolicyType ** SOAP_FMAC4 soap_get_PointerTowsnt__SubscriptionPolicyType(struct soap *soap, struct wsnt__SubscriptionPolicyType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTowsnt__SubscriptionPolicyType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTowsnt__FilterType(struct soap *soap, struct wsnt__FilterType *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_wsnt__FilterType))
		soap_serialize_wsnt__FilterType(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTowsnt__FilterType(struct soap *soap, const char *tag, int id, struct wsnt__FilterType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_wsnt__FilterType, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_wsnt__FilterType(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct wsnt__FilterType ** SOAP_FMAC4 soap_in_PointerTowsnt__FilterType(struct soap *soap, const char *tag, struct wsnt__FilterType **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct wsnt__FilterType **)soap_malloc(soap, sizeof(struct wsnt__FilterType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_wsnt__FilterType(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct wsnt__FilterType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_wsnt__FilterType, sizeof(struct wsnt__FilterType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTowsnt__FilterType(struct soap *soap, struct wsnt__FilterType *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTowsnt__FilterType(soap, tag ? tag : "wsnt:FilterType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct wsnt__FilterType ** SOAP_FMAC4 soap_get_PointerTowsnt__FilterType(struct soap *soap, struct wsnt__FilterType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTowsnt__FilterType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTowstop__TopicSetType(struct soap *soap, struct wstop__TopicSetType *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_wstop__TopicSetType))
		soap_serialize_wstop__TopicSetType(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTowstop__TopicSetType(struct soap *soap, const char *tag, int id, struct wstop__TopicSetType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_wstop__TopicSetType, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_wstop__TopicSetType(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct wstop__TopicSetType ** SOAP_FMAC4 soap_in_PointerTowstop__TopicSetType(struct soap *soap, const char *tag, struct wstop__TopicSetType **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct wstop__TopicSetType **)soap_malloc(soap, sizeof(struct wstop__TopicSetType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_wstop__TopicSetType(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct wstop__TopicSetType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_wstop__TopicSetType, sizeof(struct wstop__TopicSetType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTowstop__TopicSetType(struct soap *soap, struct wstop__TopicSetType *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTowstop__TopicSetType(soap, tag ? tag : "wstop:TopicSetType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct wstop__TopicSetType ** SOAP_FMAC4 soap_get_PointerTowstop__TopicSetType(struct soap *soap, struct wstop__TopicSetType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTowstop__TopicSetType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToxsd__anyURI(struct soap *soap, char **const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_xsd__anyURI))
		soap_serialize_xsd__anyURI(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToxsd__anyURI(struct soap *soap, const char *tag, int id, char **const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_xsd__anyURI, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_xsd__anyURI(soap, tag, id, *a, type);
}

SOAP_FMAC3 char *** SOAP_FMAC4 soap_in_PointerToxsd__anyURI(struct soap *soap, const char *tag, char ***a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (char ***)soap_malloc(soap, sizeof(char **))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_xsd__anyURI(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (char ***)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_xsd__anyURI, sizeof(char *), 1, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToxsd__anyURI(struct soap *soap, char **const*a, const char *tag, const char *type)
{
	if (soap_out_PointerToxsd__anyURI(soap, tag ? tag : "xsd:anyURI", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 char *** SOAP_FMAC4 soap_get_PointerToxsd__anyURI(struct soap *soap, char ***p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToxsd__anyURI(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTowsnt__TopicExpressionType(struct soap *soap, struct wsnt__TopicExpressionType *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_wsnt__TopicExpressionType))
		soap_serialize_wsnt__TopicExpressionType(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTowsnt__TopicExpressionType(struct soap *soap, const char *tag, int id, struct wsnt__TopicExpressionType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_wsnt__TopicExpressionType, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_wsnt__TopicExpressionType(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct wsnt__TopicExpressionType ** SOAP_FMAC4 soap_in_PointerTowsnt__TopicExpressionType(struct soap *soap, const char *tag, struct wsnt__TopicExpressionType **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct wsnt__TopicExpressionType **)soap_malloc(soap, sizeof(struct wsnt__TopicExpressionType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_wsnt__TopicExpressionType(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct wsnt__TopicExpressionType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_wsnt__TopicExpressionType, sizeof(struct wsnt__TopicExpressionType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTowsnt__TopicExpressionType(struct soap *soap, struct wsnt__TopicExpressionType *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTowsnt__TopicExpressionType(soap, tag ? tag : "wsnt:TopicExpressionType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct wsnt__TopicExpressionType ** SOAP_FMAC4 soap_get_PointerTowsnt__TopicExpressionType(struct soap *soap, struct wsnt__TopicExpressionType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTowsnt__TopicExpressionType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTowsa5__EndpointReferenceType(struct soap *soap, struct wsa5__EndpointReferenceType *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_wsa5__EndpointReferenceType))
		soap_serialize_wsa5__EndpointReferenceType(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTowsa5__EndpointReferenceType(struct soap *soap, const char *tag, int id, struct wsa5__EndpointReferenceType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_wsa5__EndpointReferenceType, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_wsa5__EndpointReferenceType(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct wsa5__EndpointReferenceType ** SOAP_FMAC4 soap_in_PointerTowsa5__EndpointReferenceType(struct soap *soap, const char *tag, struct wsa5__EndpointReferenceType **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct wsa5__EndpointReferenceType **)soap_malloc(soap, sizeof(struct wsa5__EndpointReferenceType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_wsa5__EndpointReferenceType(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct wsa5__EndpointReferenceType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_wsa5__EndpointReferenceType, sizeof(struct wsa5__EndpointReferenceType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTowsa5__EndpointReferenceType(struct soap *soap, struct wsa5__EndpointReferenceType *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTowsa5__EndpointReferenceType(soap, tag ? tag : "wsa5:EndpointReferenceType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct wsa5__EndpointReferenceType ** SOAP_FMAC4 soap_get_PointerTowsa5__EndpointReferenceType(struct soap *soap, struct wsa5__EndpointReferenceType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTowsa5__EndpointReferenceType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__PropertyOperation(struct soap *soap, enum tt__PropertyOperation *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	(void)soap_reference(soap, *a, SOAP_TYPE_tt__PropertyOperation);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__PropertyOperation(struct soap *soap, const char *tag, int id, enum tt__PropertyOperation *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__PropertyOperation, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_tt__PropertyOperation(soap, tag, id, *a, type);
}

SOAP_FMAC3 enum tt__PropertyOperation ** SOAP_FMAC4 soap_in_PointerTott__PropertyOperation(struct soap *soap, const char *tag, enum tt__PropertyOperation **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (enum tt__PropertyOperation **)soap_malloc(soap, sizeof(enum tt__PropertyOperation *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__PropertyOperation(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (enum tt__PropertyOperation **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__PropertyOperation, sizeof(enum tt__PropertyOperation), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__PropertyOperation(struct soap *soap, enum tt__PropertyOperation *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__PropertyOperation(soap, tag ? tag : "tt:PropertyOperation", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum tt__PropertyOperation ** SOAP_FMAC4 soap_get_PointerTott__PropertyOperation(struct soap *soap, enum tt__PropertyOperation **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__PropertyOperation(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__MessageExtension(struct soap *soap, struct tt__MessageExtension *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__MessageExtension))
		soap_serialize_tt__MessageExtension(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__MessageExtension(struct soap *soap, const char *tag, int id, struct tt__MessageExtension *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__MessageExtension, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_tt__MessageExtension(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__MessageExtension ** SOAP_FMAC4 soap_in_PointerTott__MessageExtension(struct soap *soap, const char *tag, struct tt__MessageExtension **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__MessageExtension **)soap_malloc(soap, sizeof(struct tt__MessageExtension *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__MessageExtension(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__MessageExtension **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__MessageExtension, sizeof(struct tt__MessageExtension), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__MessageExtension(struct soap *soap, struct tt__MessageExtension *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__MessageExtension(soap, tag ? tag : "tt:MessageExtension", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__MessageExtension ** SOAP_FMAC4 soap_get_PointerTott__MessageExtension(struct soap *soap, struct tt__MessageExtension **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__MessageExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__ItemList(struct soap *soap, struct tt__ItemList *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__ItemList))
		soap_serialize_tt__ItemList(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__ItemList(struct soap *soap, const char *tag, int id, struct tt__ItemList *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__ItemList, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_tt__ItemList(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__ItemList ** SOAP_FMAC4 soap_in_PointerTott__ItemList(struct soap *soap, const char *tag, struct tt__ItemList **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__ItemList **)soap_malloc(soap, sizeof(struct tt__ItemList *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__ItemList(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__ItemList **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__ItemList, sizeof(struct tt__ItemList), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__ItemList(struct soap *soap, struct tt__ItemList *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__ItemList(soap, tag ? tag : "tt:ItemList", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__ItemList ** SOAP_FMAC4 soap_get_PointerTott__ItemList(struct soap *soap, struct tt__ItemList **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__ItemList(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__IPAddress(struct soap *soap, struct tt__IPAddress *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__IPAddress))
		soap_serialize_tt__IPAddress(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__IPAddress(struct soap *soap, const char *tag, int id, struct tt__IPAddress *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__IPAddress, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_tt__IPAddress(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__IPAddress ** SOAP_FMAC4 soap_in_PointerTott__IPAddress(struct soap *soap, const char *tag, struct tt__IPAddress **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__IPAddress **)soap_malloc(soap, sizeof(struct tt__IPAddress *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__IPAddress(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__IPAddress **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__IPAddress, sizeof(struct tt__IPAddress), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__IPAddress(struct soap *soap, struct tt__IPAddress *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__IPAddress(soap, tag ? tag : "tt:IPAddress", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__IPAddress ** SOAP_FMAC4 soap_get_PointerTott__IPAddress(struct soap *soap, struct tt__IPAddress **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__IPAddress(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__H264Profile(struct soap *soap, enum tt__H264Profile *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	(void)soap_reference(soap, *a, SOAP_TYPE_tt__H264Profile);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__H264Profile(struct soap *soap, const char *tag, int id, enum tt__H264Profile *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__H264Profile, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_tt__H264Profile(soap, tag, id, *a, type);
}

SOAP_FMAC3 enum tt__H264Profile ** SOAP_FMAC4 soap_in_PointerTott__H264Profile(struct soap *soap, const char *tag, enum tt__H264Profile **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (enum tt__H264Profile **)soap_malloc(soap, sizeof(enum tt__H264Profile *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__H264Profile(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (enum tt__H264Profile **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__H264Profile, sizeof(enum tt__H264Profile), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__H264Profile(struct soap *soap, enum tt__H264Profile *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__H264Profile(soap, tag ? tag : "tt:H264Profile", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum tt__H264Profile ** SOAP_FMAC4 soap_get_PointerTott__H264Profile(struct soap *soap, enum tt__H264Profile **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__H264Profile(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__Mpeg4Profile(struct soap *soap, enum tt__Mpeg4Profile *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	(void)soap_reference(soap, *a, SOAP_TYPE_tt__Mpeg4Profile);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__Mpeg4Profile(struct soap *soap, const char *tag, int id, enum tt__Mpeg4Profile *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__Mpeg4Profile, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_tt__Mpeg4Profile(soap, tag, id, *a, type);
}

SOAP_FMAC3 enum tt__Mpeg4Profile ** SOAP_FMAC4 soap_in_PointerTott__Mpeg4Profile(struct soap *soap, const char *tag, enum tt__Mpeg4Profile **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (enum tt__Mpeg4Profile **)soap_malloc(soap, sizeof(enum tt__Mpeg4Profile *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__Mpeg4Profile(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (enum tt__Mpeg4Profile **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__Mpeg4Profile, sizeof(enum tt__Mpeg4Profile), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__Mpeg4Profile(struct soap *soap, enum tt__Mpeg4Profile *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__Mpeg4Profile(soap, tag ? tag : "tt:Mpeg4Profile", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum tt__Mpeg4Profile ** SOAP_FMAC4 soap_get_PointerTott__Mpeg4Profile(struct soap *soap, enum tt__Mpeg4Profile **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__Mpeg4Profile(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__VideoResolution(struct soap *soap, struct tt__VideoResolution *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__VideoResolution))
		soap_serialize_tt__VideoResolution(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__VideoResolution(struct soap *soap, const char *tag, int id, struct tt__VideoResolution *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__VideoResolution, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_tt__VideoResolution(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__VideoResolution ** SOAP_FMAC4 soap_in_PointerTott__VideoResolution(struct soap *soap, const char *tag, struct tt__VideoResolution **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__VideoResolution **)soap_malloc(soap, sizeof(struct tt__VideoResolution *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__VideoResolution(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__VideoResolution **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__VideoResolution, sizeof(struct tt__VideoResolution), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__VideoResolution(struct soap *soap, struct tt__VideoResolution *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__VideoResolution(soap, tag ? tag : "tt:VideoResolution", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__VideoResolution ** SOAP_FMAC4 soap_get_PointerTott__VideoResolution(struct soap *soap, struct tt__VideoResolution **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__VideoResolution(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__VideoEncoderOptionsExtension2(struct soap *soap, struct tt__VideoEncoderOptionsExtension2 *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__VideoEncoderOptionsExtension2))
		soap_serialize_tt__VideoEncoderOptionsExtension2(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__VideoEncoderOptionsExtension2(struct soap *soap, const char *tag, int id, struct tt__VideoEncoderOptionsExtension2 *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__VideoEncoderOptionsExtension2, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_tt__VideoEncoderOptionsExtension2(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__VideoEncoderOptionsExtension2 ** SOAP_FMAC4 soap_in_PointerTott__VideoEncoderOptionsExtension2(struct soap *soap, const char *tag, struct tt__VideoEncoderOptionsExtension2 **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__VideoEncoderOptionsExtension2 **)soap_malloc(soap, sizeof(struct tt__VideoEncoderOptionsExtension2 *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__VideoEncoderOptionsExtension2(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__VideoEncoderOptionsExtension2 **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__VideoEncoderOptionsExtension2, sizeof(struct tt__VideoEncoderOptionsExtension2), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__VideoEncoderOptionsExtension2(struct soap *soap, struct tt__VideoEncoderOptionsExtension2 *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__VideoEncoderOptionsExtension2(soap, tag ? tag : "tt:VideoEncoderOptionsExtension2", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__VideoEncoderOptionsExtension2 ** SOAP_FMAC4 soap_get_PointerTott__VideoEncoderOptionsExtension2(struct soap *soap, struct tt__VideoEncoderOptionsExtension2 **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__VideoEncoderOptionsExtension2(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__H264Options2(struct soap *soap, struct tt__H264Options2 *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__H264Options2))
		soap_serialize_tt__H264Options2(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__H264Options2(struct soap *soap, const char *tag, int id, struct tt__H264Options2 *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__H264Options2, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_tt__H264Options2(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__H264Options2 ** SOAP_FMAC4 soap_in_PointerTott__H264Options2(struct soap *soap, const char *tag, struct tt__H264Options2 **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__H264Options2 **)soap_malloc(soap, sizeof(struct tt__H264Options2 *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__H264Options2(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__H264Options2 **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__H264Options2, sizeof(struct tt__H264Options2), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__H264Options2(struct soap *soap, struct tt__H264Options2 *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__H264Options2(soap, tag ? tag : "tt:H264Options2", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__H264Options2 ** SOAP_FMAC4 soap_get_PointerTott__H264Options2(struct soap *soap, struct tt__H264Options2 **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__H264Options2(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__Mpeg4Options2(struct soap *soap, struct tt__Mpeg4Options2 *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__Mpeg4Options2))
		soap_serialize_tt__Mpeg4Options2(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__Mpeg4Options2(struct soap *soap, const char *tag, int id, struct tt__Mpeg4Options2 *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__Mpeg4Options2, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_tt__Mpeg4Options2(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__Mpeg4Options2 ** SOAP_FMAC4 soap_in_PointerTott__Mpeg4Options2(struct soap *soap, const char *tag, struct tt__Mpeg4Options2 **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__Mpeg4Options2 **)soap_malloc(soap, sizeof(struct tt__Mpeg4Options2 *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__Mpeg4Options2(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__Mpeg4Options2 **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__Mpeg4Options2, sizeof(struct tt__Mpeg4Options2), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__Mpeg4Options2(struct soap *soap, struct tt__Mpeg4Options2 *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__Mpeg4Options2(soap, tag ? tag : "tt:Mpeg4Options2", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__Mpeg4Options2 ** SOAP_FMAC4 soap_get_PointerTott__Mpeg4Options2(struct soap *soap, struct tt__Mpeg4Options2 **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__Mpeg4Options2(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__JpegOptions2(struct soap *soap, struct tt__JpegOptions2 *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__JpegOptions2))
		soap_serialize_tt__JpegOptions2(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__JpegOptions2(struct soap *soap, const char *tag, int id, struct tt__JpegOptions2 *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__JpegOptions2, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_tt__JpegOptions2(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__JpegOptions2 ** SOAP_FMAC4 soap_in_PointerTott__JpegOptions2(struct soap *soap, const char *tag, struct tt__JpegOptions2 **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__JpegOptions2 **)soap_malloc(soap, sizeof(struct tt__JpegOptions2 *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__JpegOptions2(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__JpegOptions2 **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__JpegOptions2, sizeof(struct tt__JpegOptions2), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__JpegOptions2(struct soap *soap, struct tt__JpegOptions2 *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__JpegOptions2(soap, tag ? tag : "tt:JpegOptions2", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__JpegOptions2 ** SOAP_FMAC4 soap_get_PointerTott__JpegOptions2(struct soap *soap, struct tt__JpegOptions2 **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__JpegOptions2(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__VideoEncoderOptionsExtension(struct soap *soap, struct tt__VideoEncoderOptionsExtension *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__VideoEncoderOptionsExtension))
		soap_serialize_tt__VideoEncoderOptionsExtension(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__VideoEncoderOptionsExtension(struct soap *soap, const char *tag, int id, struct tt__VideoEncoderOptionsExtension *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__VideoEncoderOptionsExtension, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_tt__VideoEncoderOptionsExtension(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__VideoEncoderOptionsExtension ** SOAP_FMAC4 soap_in_PointerTott__VideoEncoderOptionsExtension(struct soap *soap, const char *tag, struct tt__VideoEncoderOptionsExtension **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__VideoEncoderOptionsExtension **)soap_malloc(soap, sizeof(struct tt__VideoEncoderOptionsExtension *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__VideoEncoderOptionsExtension(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__VideoEncoderOptionsExtension **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__VideoEncoderOptionsExtension, sizeof(struct tt__VideoEncoderOptionsExtension), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__VideoEncoderOptionsExtension(struct soap *soap, struct tt__VideoEncoderOptionsExtension *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__VideoEncoderOptionsExtension(soap, tag ? tag : "tt:VideoEncoderOptionsExtension", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__VideoEncoderOptionsExtension ** SOAP_FMAC4 soap_get_PointerTott__VideoEncoderOptionsExtension(struct soap *soap, struct tt__VideoEncoderOptionsExtension **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__VideoEncoderOptionsExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__H264Options(struct soap *soap, struct tt__H264Options *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__H264Options))
		soap_serialize_tt__H264Options(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__H264Options(struct soap *soap, const char *tag, int id, struct tt__H264Options *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__H264Options, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_tt__H264Options(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__H264Options ** SOAP_FMAC4 soap_in_PointerTott__H264Options(struct soap *soap, const char *tag, struct tt__H264Options **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__H264Options **)soap_malloc(soap, sizeof(struct tt__H264Options *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__H264Options(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__H264Options **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__H264Options, sizeof(struct tt__H264Options), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__H264Options(struct soap *soap, struct tt__H264Options *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__H264Options(soap, tag ? tag : "tt:H264Options", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__H264Options ** SOAP_FMAC4 soap_get_PointerTott__H264Options(struct soap *soap, struct tt__H264Options **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__H264Options(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__Mpeg4Options(struct soap *soap, struct tt__Mpeg4Options *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__Mpeg4Options))
		soap_serialize_tt__Mpeg4Options(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__Mpeg4Options(struct soap *soap, const char *tag, int id, struct tt__Mpeg4Options *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__Mpeg4Options, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_tt__Mpeg4Options(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__Mpeg4Options ** SOAP_FMAC4 soap_in_PointerTott__Mpeg4Options(struct soap *soap, const char *tag, struct tt__Mpeg4Options **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__Mpeg4Options **)soap_malloc(soap, sizeof(struct tt__Mpeg4Options *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__Mpeg4Options(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__Mpeg4Options **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__Mpeg4Options, sizeof(struct tt__Mpeg4Options), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__Mpeg4Options(struct soap *soap, struct tt__Mpeg4Options *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__Mpeg4Options(soap, tag ? tag : "tt:Mpeg4Options", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__Mpeg4Options ** SOAP_FMAC4 soap_get_PointerTott__Mpeg4Options(struct soap *soap, struct tt__Mpeg4Options **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__Mpeg4Options(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__JpegOptions(struct soap *soap, struct tt__JpegOptions *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__JpegOptions))
		soap_serialize_tt__JpegOptions(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__JpegOptions(struct soap *soap, const char *tag, int id, struct tt__JpegOptions *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__JpegOptions, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_tt__JpegOptions(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__JpegOptions ** SOAP_FMAC4 soap_in_PointerTott__JpegOptions(struct soap *soap, const char *tag, struct tt__JpegOptions **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__JpegOptions **)soap_malloc(soap, sizeof(struct tt__JpegOptions *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__JpegOptions(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__JpegOptions **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__JpegOptions, sizeof(struct tt__JpegOptions), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__JpegOptions(struct soap *soap, struct tt__JpegOptions *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__JpegOptions(soap, tag ? tag : "tt:JpegOptions", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__JpegOptions ** SOAP_FMAC4 soap_get_PointerTott__JpegOptions(struct soap *soap, struct tt__JpegOptions **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__JpegOptions(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__ItemListDescriptionExtension(struct soap *soap, struct tt__ItemListDescriptionExtension *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__ItemListDescriptionExtension))
		soap_serialize_tt__ItemListDescriptionExtension(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__ItemListDescriptionExtension(struct soap *soap, const char *tag, int id, struct tt__ItemListDescriptionExtension *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__ItemListDescriptionExtension, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_tt__ItemListDescriptionExtension(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__ItemListDescriptionExtension ** SOAP_FMAC4 soap_in_PointerTott__ItemListDescriptionExtension(struct soap *soap, const char *tag, struct tt__ItemListDescriptionExtension **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__ItemListDescriptionExtension **)soap_malloc(soap, sizeof(struct tt__ItemListDescriptionExtension *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__ItemListDescriptionExtension(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__ItemListDescriptionExtension **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__ItemListDescriptionExtension, sizeof(struct tt__ItemListDescriptionExtension), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__ItemListDescriptionExtension(struct soap *soap, struct tt__ItemListDescriptionExtension *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__ItemListDescriptionExtension(soap, tag ? tag : "tt:ItemListDescriptionExtension", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__ItemListDescriptionExtension ** SOAP_FMAC4 soap_get_PointerTott__ItemListDescriptionExtension(struct soap *soap, struct tt__ItemListDescriptionExtension **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__ItemListDescriptionExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tt__ItemListDescription_ElementItemDescription(struct soap *soap, struct _tt__ItemListDescription_ElementItemDescription *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tt__ItemListDescription_ElementItemDescription))
		soap_serialize__tt__ItemListDescription_ElementItemDescription(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tt__ItemListDescription_ElementItemDescription(struct soap *soap, const char *tag, int id, struct _tt__ItemListDescription_ElementItemDescription *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tt__ItemListDescription_ElementItemDescription, NULL);
	if (id < 0)
		return soap->error;
	return soap_out__tt__ItemListDescription_ElementItemDescription(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _tt__ItemListDescription_ElementItemDescription ** SOAP_FMAC4 soap_in_PointerTo_tt__ItemListDescription_ElementItemDescription(struct soap *soap, const char *tag, struct _tt__ItemListDescription_ElementItemDescription **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _tt__ItemListDescription_ElementItemDescription **)soap_malloc(soap, sizeof(struct _tt__ItemListDescription_ElementItemDescription *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__tt__ItemListDescription_ElementItemDescription(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _tt__ItemListDescription_ElementItemDescription **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tt__ItemListDescription_ElementItemDescription, sizeof(struct _tt__ItemListDescription_ElementItemDescription), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tt__ItemListDescription_ElementItemDescription(struct soap *soap, struct _tt__ItemListDescription_ElementItemDescription *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_tt__ItemListDescription_ElementItemDescription(soap, tag ? tag : "tt:ItemListDescription-ElementItemDescription", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tt__ItemListDescription_ElementItemDescription ** SOAP_FMAC4 soap_get_PointerTo_tt__ItemListDescription_ElementItemDescription(struct soap *soap, struct _tt__ItemListDescription_ElementItemDescription **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tt__ItemListDescription_ElementItemDescription(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tt__ItemListDescription_SimpleItemDescription(struct soap *soap, struct _tt__ItemListDescription_SimpleItemDescription *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tt__ItemListDescription_SimpleItemDescription))
		soap_serialize__tt__ItemListDescription_SimpleItemDescription(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tt__ItemListDescription_SimpleItemDescription(struct soap *soap, const char *tag, int id, struct _tt__ItemListDescription_SimpleItemDescription *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tt__ItemListDescription_SimpleItemDescription, NULL);
	if (id < 0)
		return soap->error;
	return soap_out__tt__ItemListDescription_SimpleItemDescription(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _tt__ItemListDescription_SimpleItemDescription ** SOAP_FMAC4 soap_in_PointerTo_tt__ItemListDescription_SimpleItemDescription(struct soap *soap, const char *tag, struct _tt__ItemListDescription_SimpleItemDescription **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _tt__ItemListDescription_SimpleItemDescription **)soap_malloc(soap, sizeof(struct _tt__ItemListDescription_SimpleItemDescription *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__tt__ItemListDescription_SimpleItemDescription(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _tt__ItemListDescription_SimpleItemDescription **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tt__ItemListDescription_SimpleItemDescription, sizeof(struct _tt__ItemListDescription_SimpleItemDescription), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tt__ItemListDescription_SimpleItemDescription(struct soap *soap, struct _tt__ItemListDescription_SimpleItemDescription *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_tt__ItemListDescription_SimpleItemDescription(soap, tag ? tag : "tt:ItemListDescription-SimpleItemDescription", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tt__ItemListDescription_SimpleItemDescription ** SOAP_FMAC4 soap_get_PointerTo_tt__ItemListDescription_SimpleItemDescription(struct soap *soap, struct _tt__ItemListDescription_SimpleItemDescription **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tt__ItemListDescription_SimpleItemDescription(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__MessageDescriptionExtension(struct soap *soap, struct tt__MessageDescriptionExtension *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__MessageDescriptionExtension))
		soap_serialize_tt__MessageDescriptionExtension(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__MessageDescriptionExtension(struct soap *soap, const char *tag, int id, struct tt__MessageDescriptionExtension *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__MessageDescriptionExtension, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_tt__MessageDescriptionExtension(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__MessageDescriptionExtension ** SOAP_FMAC4 soap_in_PointerTott__MessageDescriptionExtension(struct soap *soap, const char *tag, struct tt__MessageDescriptionExtension **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__MessageDescriptionExtension **)soap_malloc(soap, sizeof(struct tt__MessageDescriptionExtension *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__MessageDescriptionExtension(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__MessageDescriptionExtension **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__MessageDescriptionExtension, sizeof(struct tt__MessageDescriptionExtension), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__MessageDescriptionExtension(struct soap *soap, struct tt__MessageDescriptionExtension *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__MessageDescriptionExtension(soap, tag ? tag : "tt:MessageDescriptionExtension", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__MessageDescriptionExtension ** SOAP_FMAC4 soap_get_PointerTott__MessageDescriptionExtension(struct soap *soap, struct tt__MessageDescriptionExtension **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__MessageDescriptionExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__ItemListDescription(struct soap *soap, struct tt__ItemListDescription *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__ItemListDescription))
		soap_serialize_tt__ItemListDescription(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__ItemListDescription(struct soap *soap, const char *tag, int id, struct tt__ItemListDescription *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__ItemListDescription, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_tt__ItemListDescription(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__ItemListDescription ** SOAP_FMAC4 soap_in_PointerTott__ItemListDescription(struct soap *soap, const char *tag, struct tt__ItemListDescription **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__ItemListDescription **)soap_malloc(soap, sizeof(struct tt__ItemListDescription *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__ItemListDescription(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__ItemListDescription **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__ItemListDescription, sizeof(struct tt__ItemListDescription), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__ItemListDescription(struct soap *soap, struct tt__ItemListDescription *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__ItemListDescription(soap, tag ? tag : "tt:ItemListDescription", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__ItemListDescription ** SOAP_FMAC4 soap_get_PointerTott__ItemListDescription(struct soap *soap, struct tt__ItemListDescription **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__ItemListDescription(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__ItemListExtension(struct soap *soap, struct tt__ItemListExtension *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__ItemListExtension))
		soap_serialize_tt__ItemListExtension(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__ItemListExtension(struct soap *soap, const char *tag, int id, struct tt__ItemListExtension *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__ItemListExtension, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_tt__ItemListExtension(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__ItemListExtension ** SOAP_FMAC4 soap_in_PointerTott__ItemListExtension(struct soap *soap, const char *tag, struct tt__ItemListExtension **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__ItemListExtension **)soap_malloc(soap, sizeof(struct tt__ItemListExtension *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__ItemListExtension(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__ItemListExtension **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__ItemListExtension, sizeof(struct tt__ItemListExtension), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__ItemListExtension(struct soap *soap, struct tt__ItemListExtension *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__ItemListExtension(soap, tag ? tag : "tt:ItemListExtension", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__ItemListExtension ** SOAP_FMAC4 soap_get_PointerTott__ItemListExtension(struct soap *soap, struct tt__ItemListExtension **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__ItemListExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tt__ItemList_ElementItem(struct soap *soap, struct _tt__ItemList_ElementItem *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tt__ItemList_ElementItem))
		soap_serialize__tt__ItemList_ElementItem(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tt__ItemList_ElementItem(struct soap *soap, const char *tag, int id, struct _tt__ItemList_ElementItem *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tt__ItemList_ElementItem, NULL);
	if (id < 0)
		return soap->error;
	return soap_out__tt__ItemList_ElementItem(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _tt__ItemList_ElementItem ** SOAP_FMAC4 soap_in_PointerTo_tt__ItemList_ElementItem(struct soap *soap, const char *tag, struct _tt__ItemList_ElementItem **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _tt__ItemList_ElementItem **)soap_malloc(soap, sizeof(struct _tt__ItemList_ElementItem *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__tt__ItemList_ElementItem(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _tt__ItemList_ElementItem **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tt__ItemList_ElementItem, sizeof(struct _tt__ItemList_ElementItem), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tt__ItemList_ElementItem(struct soap *soap, struct _tt__ItemList_ElementItem *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_tt__ItemList_ElementItem(soap, tag ? tag : "tt:ItemList-ElementItem", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tt__ItemList_ElementItem ** SOAP_FMAC4 soap_get_PointerTo_tt__ItemList_ElementItem(struct soap *soap, struct _tt__ItemList_ElementItem **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tt__ItemList_ElementItem(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tt__ItemList_SimpleItem(struct soap *soap, struct _tt__ItemList_SimpleItem *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tt__ItemList_SimpleItem))
		soap_serialize__tt__ItemList_SimpleItem(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tt__ItemList_SimpleItem(struct soap *soap, const char *tag, int id, struct _tt__ItemList_SimpleItem *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tt__ItemList_SimpleItem, NULL);
	if (id < 0)
		return soap->error;
	return soap_out__tt__ItemList_SimpleItem(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _tt__ItemList_SimpleItem ** SOAP_FMAC4 soap_in_PointerTo_tt__ItemList_SimpleItem(struct soap *soap, const char *tag, struct _tt__ItemList_SimpleItem **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _tt__ItemList_SimpleItem **)soap_malloc(soap, sizeof(struct _tt__ItemList_SimpleItem *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__tt__ItemList_SimpleItem(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _tt__ItemList_SimpleItem **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tt__ItemList_SimpleItem, sizeof(struct _tt__ItemList_SimpleItem), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tt__ItemList_SimpleItem(struct soap *soap, struct _tt__ItemList_SimpleItem *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_tt__ItemList_SimpleItem(soap, tag ? tag : "tt:ItemList-SimpleItem", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tt__ItemList_SimpleItem ** SOAP_FMAC4 soap_get_PointerTo_tt__ItemList_SimpleItem(struct soap *soap, struct _tt__ItemList_SimpleItem **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tt__ItemList_SimpleItem(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__MoveStatus(struct soap *soap, enum tt__MoveStatus *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	(void)soap_reference(soap, *a, SOAP_TYPE_tt__MoveStatus);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__MoveStatus(struct soap *soap, const char *tag, int id, enum tt__MoveStatus *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__MoveStatus, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_tt__MoveStatus(soap, tag, id, *a, type);
}

SOAP_FMAC3 enum tt__MoveStatus ** SOAP_FMAC4 soap_in_PointerTott__MoveStatus(struct soap *soap, const char *tag, enum tt__MoveStatus **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (enum tt__MoveStatus **)soap_malloc(soap, sizeof(enum tt__MoveStatus *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__MoveStatus(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (enum tt__MoveStatus **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__MoveStatus, sizeof(enum tt__MoveStatus), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__MoveStatus(struct soap *soap, enum tt__MoveStatus *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__MoveStatus(soap, tag ? tag : "tt:MoveStatus", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum tt__MoveStatus ** SOAP_FMAC4 soap_get_PointerTott__MoveStatus(struct soap *soap, enum tt__MoveStatus **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__MoveStatus(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__PTZVector(struct soap *soap, struct tt__PTZVector *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__PTZVector))
		soap_serialize_tt__PTZVector(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__PTZVector(struct soap *soap, const char *tag, int id, struct tt__PTZVector *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__PTZVector, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_tt__PTZVector(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__PTZVector ** SOAP_FMAC4 soap_in_PointerTott__PTZVector(struct soap *soap, const char *tag, struct tt__PTZVector **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__PTZVector **)soap_malloc(soap, sizeof(struct tt__PTZVector *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__PTZVector(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__PTZVector **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__PTZVector, sizeof(struct tt__PTZVector), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__PTZVector(struct soap *soap, struct tt__PTZVector *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__PTZVector(soap, tag ? tag : "tt:PTZVector", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__PTZVector ** SOAP_FMAC4 soap_get_PointerTott__PTZVector(struct soap *soap, struct tt__PTZVector **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__PTZVector(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__Vector1D(struct soap *soap, struct tt__Vector1D *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__Vector1D))
		soap_serialize_tt__Vector1D(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__Vector1D(struct soap *soap, const char *tag, int id, struct tt__Vector1D *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__Vector1D, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_tt__Vector1D(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__Vector1D ** SOAP_FMAC4 soap_in_PointerTott__Vector1D(struct soap *soap, const char *tag, struct tt__Vector1D **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__Vector1D **)soap_malloc(soap, sizeof(struct tt__Vector1D *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__Vector1D(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__Vector1D **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__Vector1D, sizeof(struct tt__Vector1D), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__Vector1D(struct soap *soap, struct tt__Vector1D *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__Vector1D(soap, tag ? tag : "tt:Vector1D", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__Vector1D ** SOAP_FMAC4 soap_get_PointerTott__Vector1D(struct soap *soap, struct tt__Vector1D **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__Vector1D(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__Vector2D(struct soap *soap, struct tt__Vector2D *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__Vector2D))
		soap_serialize_tt__Vector2D(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__Vector2D(struct soap *soap, const char *tag, int id, struct tt__Vector2D *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__Vector2D, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_tt__Vector2D(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__Vector2D ** SOAP_FMAC4 soap_in_PointerTott__Vector2D(struct soap *soap, const char *tag, struct tt__Vector2D **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__Vector2D **)soap_malloc(soap, sizeof(struct tt__Vector2D *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__Vector2D(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__Vector2D **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__Vector2D, sizeof(struct tt__Vector2D), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__Vector2D(struct soap *soap, struct tt__Vector2D *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__Vector2D(soap, tag ? tag : "tt:Vector2D", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__Vector2D ** SOAP_FMAC4 soap_get_PointerTott__Vector2D(struct soap *soap, struct tt__Vector2D **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__Vector2D(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__FloatRange(struct soap *soap, struct tt__FloatRange *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__FloatRange))
		soap_serialize_tt__FloatRange(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__FloatRange(struct soap *soap, const char *tag, int id, struct tt__FloatRange *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__FloatRange, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_tt__FloatRange(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__FloatRange ** SOAP_FMAC4 soap_in_PointerTott__FloatRange(struct soap *soap, const char *tag, struct tt__FloatRange **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__FloatRange **)soap_malloc(soap, sizeof(struct tt__FloatRange *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__FloatRange(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__FloatRange **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__FloatRange, sizeof(struct tt__FloatRange), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__FloatRange(struct soap *soap, struct tt__FloatRange *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__FloatRange(soap, tag ? tag : "tt:FloatRange", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__FloatRange ** SOAP_FMAC4 soap_get_PointerTott__FloatRange(struct soap *soap, struct tt__FloatRange **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__FloatRange(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__Space1DDescription(struct soap *soap, struct tt__Space1DDescription *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__Space1DDescription))
		soap_serialize_tt__Space1DDescription(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__Space1DDescription(struct soap *soap, const char *tag, int id, struct tt__Space1DDescription *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__Space1DDescription, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_tt__Space1DDescription(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__Space1DDescription ** SOAP_FMAC4 soap_in_PointerTott__Space1DDescription(struct soap *soap, const char *tag, struct tt__Space1DDescription **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__Space1DDescription **)soap_malloc(soap, sizeof(struct tt__Space1DDescription *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__Space1DDescription(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__Space1DDescription **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__Space1DDescription, sizeof(struct tt__Space1DDescription), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__Space1DDescription(struct soap *soap, struct tt__Space1DDescription *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__Space1DDescription(soap, tag ? tag : "tt:Space1DDescription", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__Space1DDescription ** SOAP_FMAC4 soap_get_PointerTott__Space1DDescription(struct soap *soap, struct tt__Space1DDescription **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__Space1DDescription(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__Space2DDescription(struct soap *soap, struct tt__Space2DDescription *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__Space2DDescription))
		soap_serialize_tt__Space2DDescription(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__Space2DDescription(struct soap *soap, const char *tag, int id, struct tt__Space2DDescription *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__Space2DDescription, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_tt__Space2DDescription(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__Space2DDescription ** SOAP_FMAC4 soap_in_PointerTott__Space2DDescription(struct soap *soap, const char *tag, struct tt__Space2DDescription **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__Space2DDescription **)soap_malloc(soap, sizeof(struct tt__Space2DDescription *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__Space2DDescription(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__Space2DDescription **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__Space2DDescription, sizeof(struct tt__Space2DDescription), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__Space2DDescription(struct soap *soap, struct tt__Space2DDescription *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__Space2DDescription(soap, tag ? tag : "tt:Space2DDescription", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__Space2DDescription ** SOAP_FMAC4 soap_get_PointerTott__Space2DDescription(struct soap *soap, struct tt__Space2DDescription **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__Space2DDescription(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__ProfileCapabilities(struct soap *soap, struct tt__ProfileCapabilities *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__ProfileCapabilities))
		soap_serialize_tt__ProfileCapabilities(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__ProfileCapabilities(struct soap *soap, const char *tag, int id, struct tt__ProfileCapabilities *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__ProfileCapabilities, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_tt__ProfileCapabilities(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__ProfileCapabilities ** SOAP_FMAC4 soap_in_PointerTott__ProfileCapabilities(struct soap *soap, const char *tag, struct tt__ProfileCapabilities **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__ProfileCapabilities **)soap_malloc(soap, sizeof(struct tt__ProfileCapabilities *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__ProfileCapabilities(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__ProfileCapabilities **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__ProfileCapabilities, sizeof(struct tt__ProfileCapabilities), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__ProfileCapabilities(struct soap *soap, struct tt__ProfileCapabilities *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__ProfileCapabilities(soap, tag ? tag : "tt:ProfileCapabilities", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__ProfileCapabilities ** SOAP_FMAC4 soap_get_PointerTott__ProfileCapabilities(struct soap *soap, struct tt__ProfileCapabilities **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__ProfileCapabilities(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__MediaCapabilitiesExtension(struct soap *soap, struct tt__MediaCapabilitiesExtension *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__MediaCapabilitiesExtension))
		soap_serialize_tt__MediaCapabilitiesExtension(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__MediaCapabilitiesExtension(struct soap *soap, const char *tag, int id, struct tt__MediaCapabilitiesExtension *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__MediaCapabilitiesExtension, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_tt__MediaCapabilitiesExtension(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__MediaCapabilitiesExtension ** SOAP_FMAC4 soap_in_PointerTott__MediaCapabilitiesExtension(struct soap *soap, const char *tag, struct tt__MediaCapabilitiesExtension **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__MediaCapabilitiesExtension **)soap_malloc(soap, sizeof(struct tt__MediaCapabilitiesExtension *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__MediaCapabilitiesExtension(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__MediaCapabilitiesExtension **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__MediaCapabilitiesExtension, sizeof(struct tt__MediaCapabilitiesExtension), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__MediaCapabilitiesExtension(struct soap *soap, struct tt__MediaCapabilitiesExtension *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__MediaCapabilitiesExtension(soap, tag ? tag : "tt:MediaCapabilitiesExtension", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__MediaCapabilitiesExtension ** SOAP_FMAC4 soap_get_PointerTott__MediaCapabilitiesExtension(struct soap *soap, struct tt__MediaCapabilitiesExtension **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__MediaCapabilitiesExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__RealTimeStreamingCapabilities(struct soap *soap, struct tt__RealTimeStreamingCapabilities *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__RealTimeStreamingCapabilities))
		soap_serialize_tt__RealTimeStreamingCapabilities(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__RealTimeStreamingCapabilities(struct soap *soap, const char *tag, int id, struct tt__RealTimeStreamingCapabilities *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__RealTimeStreamingCapabilities, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_tt__RealTimeStreamingCapabilities(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__RealTimeStreamingCapabilities ** SOAP_FMAC4 soap_in_PointerTott__RealTimeStreamingCapabilities(struct soap *soap, const char *tag, struct tt__RealTimeStreamingCapabilities **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__RealTimeStreamingCapabilities **)soap_malloc(soap, sizeof(struct tt__RealTimeStreamingCapabilities *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__RealTimeStreamingCapabilities(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__RealTimeStreamingCapabilities **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__RealTimeStreamingCapabilities, sizeof(struct tt__RealTimeStreamingCapabilities), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__RealTimeStreamingCapabilities(struct soap *soap, struct tt__RealTimeStreamingCapabilities *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__RealTimeStreamingCapabilities(soap, tag ? tag : "tt:RealTimeStreamingCapabilities", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__RealTimeStreamingCapabilities ** SOAP_FMAC4 soap_get_PointerTott__RealTimeStreamingCapabilities(struct soap *soap, struct tt__RealTimeStreamingCapabilities **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__RealTimeStreamingCapabilities(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__SystemCapabilities(struct soap *soap, struct tt__SystemCapabilities *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__SystemCapabilities))
		soap_serialize_tt__SystemCapabilities(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__SystemCapabilities(struct soap *soap, const char *tag, int id, struct tt__SystemCapabilities *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__SystemCapabilities, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_tt__SystemCapabilities(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__SystemCapabilities ** SOAP_FMAC4 soap_in_PointerTott__SystemCapabilities(struct soap *soap, const char *tag, struct tt__SystemCapabilities **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__SystemCapabilities **)soap_malloc(soap, sizeof(struct tt__SystemCapabilities *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__SystemCapabilities(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__SystemCapabilities **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__SystemCapabilities, sizeof(struct tt__SystemCapabilities), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__SystemCapabilities(struct soap *soap, struct tt__SystemCapabilities *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__SystemCapabilities(soap, tag ? tag : "tt:SystemCapabilities", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__SystemCapabilities ** SOAP_FMAC4 soap_get_PointerTott__SystemCapabilities(struct soap *soap, struct tt__SystemCapabilities **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__SystemCapabilities(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__PTZCapabilities(struct soap *soap, struct tt__PTZCapabilities *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__PTZCapabilities))
		soap_serialize_tt__PTZCapabilities(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__PTZCapabilities(struct soap *soap, const char *tag, int id, struct tt__PTZCapabilities *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__PTZCapabilities, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_tt__PTZCapabilities(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__PTZCapabilities ** SOAP_FMAC4 soap_in_PointerTott__PTZCapabilities(struct soap *soap, const char *tag, struct tt__PTZCapabilities **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__PTZCapabilities **)soap_malloc(soap, sizeof(struct tt__PTZCapabilities *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__PTZCapabilities(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__PTZCapabilities **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__PTZCapabilities, sizeof(struct tt__PTZCapabilities), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__PTZCapabilities(struct soap *soap, struct tt__PTZCapabilities *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__PTZCapabilities(soap, tag ? tag : "tt:PTZCapabilities", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__PTZCapabilities ** SOAP_FMAC4 soap_get_PointerTott__PTZCapabilities(struct soap *soap, struct tt__PTZCapabilities **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__PTZCapabilities(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__MediaCapabilities(struct soap *soap, struct tt__MediaCapabilities *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__MediaCapabilities))
		soap_serialize_tt__MediaCapabilities(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__MediaCapabilities(struct soap *soap, const char *tag, int id, struct tt__MediaCapabilities *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__MediaCapabilities, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_tt__MediaCapabilities(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__MediaCapabilities ** SOAP_FMAC4 soap_in_PointerTott__MediaCapabilities(struct soap *soap, const char *tag, struct tt__MediaCapabilities **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__MediaCapabilities **)soap_malloc(soap, sizeof(struct tt__MediaCapabilities *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__MediaCapabilities(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__MediaCapabilities **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__MediaCapabilities, sizeof(struct tt__MediaCapabilities), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__MediaCapabilities(struct soap *soap, struct tt__MediaCapabilities *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__MediaCapabilities(soap, tag ? tag : "tt:MediaCapabilities", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__MediaCapabilities ** SOAP_FMAC4 soap_get_PointerTott__MediaCapabilities(struct soap *soap, struct tt__MediaCapabilities **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__MediaCapabilities(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__EventCapabilities(struct soap *soap, struct tt__EventCapabilities *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__EventCapabilities))
		soap_serialize_tt__EventCapabilities(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__EventCapabilities(struct soap *soap, const char *tag, int id, struct tt__EventCapabilities *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__EventCapabilities, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_tt__EventCapabilities(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__EventCapabilities ** SOAP_FMAC4 soap_in_PointerTott__EventCapabilities(struct soap *soap, const char *tag, struct tt__EventCapabilities **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__EventCapabilities **)soap_malloc(soap, sizeof(struct tt__EventCapabilities *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__EventCapabilities(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__EventCapabilities **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__EventCapabilities, sizeof(struct tt__EventCapabilities), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__EventCapabilities(struct soap *soap, struct tt__EventCapabilities *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__EventCapabilities(soap, tag ? tag : "tt:EventCapabilities", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__EventCapabilities ** SOAP_FMAC4 soap_get_PointerTott__EventCapabilities(struct soap *soap, struct tt__EventCapabilities **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__EventCapabilities(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__DeviceCapabilities(struct soap *soap, struct tt__DeviceCapabilities *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__DeviceCapabilities))
		soap_serialize_tt__DeviceCapabilities(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__DeviceCapabilities(struct soap *soap, const char *tag, int id, struct tt__DeviceCapabilities *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__DeviceCapabilities, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_tt__DeviceCapabilities(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__DeviceCapabilities ** SOAP_FMAC4 soap_in_PointerTott__DeviceCapabilities(struct soap *soap, const char *tag, struct tt__DeviceCapabilities **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__DeviceCapabilities **)soap_malloc(soap, sizeof(struct tt__DeviceCapabilities *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__DeviceCapabilities(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__DeviceCapabilities **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__DeviceCapabilities, sizeof(struct tt__DeviceCapabilities), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__DeviceCapabilities(struct soap *soap, struct tt__DeviceCapabilities *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__DeviceCapabilities(soap, tag ? tag : "tt:DeviceCapabilities", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__DeviceCapabilities ** SOAP_FMAC4 soap_get_PointerTott__DeviceCapabilities(struct soap *soap, struct tt__DeviceCapabilities **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__DeviceCapabilities(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToxsd__boolean(struct soap *soap, enum xsd__boolean *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	(void)soap_reference(soap, *a, SOAP_TYPE_xsd__boolean);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToxsd__boolean(struct soap *soap, const char *tag, int id, enum xsd__boolean *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_xsd__boolean, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_xsd__boolean(soap, tag, id, *a, type);
}

SOAP_FMAC3 enum xsd__boolean ** SOAP_FMAC4 soap_in_PointerToxsd__boolean(struct soap *soap, const char *tag, enum xsd__boolean **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (enum xsd__boolean **)soap_malloc(soap, sizeof(enum xsd__boolean *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_xsd__boolean(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (enum xsd__boolean **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_xsd__boolean, sizeof(enum xsd__boolean), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToxsd__boolean(struct soap *soap, enum xsd__boolean *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerToxsd__boolean(soap, tag ? tag : "xsd:boolean", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum xsd__boolean ** SOAP_FMAC4 soap_get_PointerToxsd__boolean(struct soap *soap, enum xsd__boolean **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToxsd__boolean(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__VideoEncoderConfiguration(struct soap *soap, struct tt__VideoEncoderConfiguration *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__VideoEncoderConfiguration))
		soap_serialize_tt__VideoEncoderConfiguration(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__VideoEncoderConfiguration(struct soap *soap, const char *tag, int id, struct tt__VideoEncoderConfiguration *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__VideoEncoderConfiguration, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_tt__VideoEncoderConfiguration(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__VideoEncoderConfiguration ** SOAP_FMAC4 soap_in_PointerTott__VideoEncoderConfiguration(struct soap *soap, const char *tag, struct tt__VideoEncoderConfiguration **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__VideoEncoderConfiguration **)soap_malloc(soap, sizeof(struct tt__VideoEncoderConfiguration *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__VideoEncoderConfiguration(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__VideoEncoderConfiguration **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__VideoEncoderConfiguration, sizeof(struct tt__VideoEncoderConfiguration), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__VideoEncoderConfiguration(struct soap *soap, struct tt__VideoEncoderConfiguration *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__VideoEncoderConfiguration(soap, tag ? tag : "tt:VideoEncoderConfiguration", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__VideoEncoderConfiguration ** SOAP_FMAC4 soap_get_PointerTott__VideoEncoderConfiguration(struct soap *soap, struct tt__VideoEncoderConfiguration **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__VideoEncoderConfiguration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTofloat(struct soap *soap, float *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	(void)soap_reference(soap, *a, SOAP_TYPE_float);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTofloat(struct soap *soap, const char *tag, int id, float *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_float, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_float(soap, tag, id, *a, type);
}

SOAP_FMAC3 float ** SOAP_FMAC4 soap_in_PointerTofloat(struct soap *soap, const char *tag, float **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (float **)soap_malloc(soap, sizeof(float *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_float(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (float **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_float, sizeof(float), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTofloat(struct soap *soap, float *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTofloat(soap, tag ? tag : "float", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 float ** SOAP_FMAC4 soap_get_PointerTofloat(struct soap *soap, float **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTofloat(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__IntRange(struct soap *soap, struct tt__IntRange *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__IntRange))
		soap_serialize_tt__IntRange(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__IntRange(struct soap *soap, const char *tag, int id, struct tt__IntRange *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__IntRange, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_tt__IntRange(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__IntRange ** SOAP_FMAC4 soap_in_PointerTott__IntRange(struct soap *soap, const char *tag, struct tt__IntRange **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__IntRange **)soap_malloc(soap, sizeof(struct tt__IntRange *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__IntRange(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__IntRange **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__IntRange, sizeof(struct tt__IntRange), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__IntRange(struct soap *soap, struct tt__IntRange *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__IntRange(soap, tag ? tag : "tt:IntRange", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__IntRange ** SOAP_FMAC4 soap_get_PointerTott__IntRange(struct soap *soap, struct tt__IntRange **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__IntRange(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__Capabilities(struct soap *soap, struct tt__Capabilities *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__Capabilities))
		soap_serialize_tt__Capabilities(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__Capabilities(struct soap *soap, const char *tag, int id, struct tt__Capabilities *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__Capabilities, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_tt__Capabilities(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__Capabilities ** SOAP_FMAC4 soap_in_PointerTott__Capabilities(struct soap *soap, const char *tag, struct tt__Capabilities **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__Capabilities **)soap_malloc(soap, sizeof(struct tt__Capabilities *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__Capabilities(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__Capabilities **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__Capabilities, sizeof(struct tt__Capabilities), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__Capabilities(struct soap *soap, struct tt__Capabilities *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__Capabilities(soap, tag ? tag : "tt:Capabilities", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__Capabilities ** SOAP_FMAC4 soap_get_PointerTott__Capabilities(struct soap *soap, struct tt__Capabilities **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__Capabilities(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__CapabilityCategory(struct soap *soap, enum tt__CapabilityCategory *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	(void)soap_reference(soap, *a, SOAP_TYPE_tt__CapabilityCategory);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__CapabilityCategory(struct soap *soap, const char *tag, int id, enum tt__CapabilityCategory *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__CapabilityCategory, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_tt__CapabilityCategory(soap, tag, id, *a, type);
}

SOAP_FMAC3 enum tt__CapabilityCategory ** SOAP_FMAC4 soap_in_PointerTott__CapabilityCategory(struct soap *soap, const char *tag, enum tt__CapabilityCategory **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (enum tt__CapabilityCategory **)soap_malloc(soap, sizeof(enum tt__CapabilityCategory *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__CapabilityCategory(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (enum tt__CapabilityCategory **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__CapabilityCategory, sizeof(enum tt__CapabilityCategory), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__CapabilityCategory(struct soap *soap, enum tt__CapabilityCategory *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__CapabilityCategory(soap, tag ? tag : "tt:CapabilityCategory", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum tt__CapabilityCategory ** SOAP_FMAC4 soap_get_PointerTott__CapabilityCategory(struct soap *soap, enum tt__CapabilityCategory **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__CapabilityCategory(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTotds__DeviceServiceCapabilities(struct soap *soap, struct tds__DeviceServiceCapabilities *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tds__DeviceServiceCapabilities))
		soap_serialize_tds__DeviceServiceCapabilities(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTotds__DeviceServiceCapabilities(struct soap *soap, const char *tag, int id, struct tds__DeviceServiceCapabilities *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tds__DeviceServiceCapabilities, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_tds__DeviceServiceCapabilities(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tds__DeviceServiceCapabilities ** SOAP_FMAC4 soap_in_PointerTotds__DeviceServiceCapabilities(struct soap *soap, const char *tag, struct tds__DeviceServiceCapabilities **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tds__DeviceServiceCapabilities **)soap_malloc(soap, sizeof(struct tds__DeviceServiceCapabilities *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tds__DeviceServiceCapabilities(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tds__DeviceServiceCapabilities **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tds__DeviceServiceCapabilities, sizeof(struct tds__DeviceServiceCapabilities), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTotds__DeviceServiceCapabilities(struct soap *soap, struct tds__DeviceServiceCapabilities *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTotds__DeviceServiceCapabilities(soap, tag ? tag : "tds:DeviceServiceCapabilities", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tds__DeviceServiceCapabilities ** SOAP_FMAC4 soap_get_PointerTotds__DeviceServiceCapabilities(struct soap *soap, struct tds__DeviceServiceCapabilities **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTotds__DeviceServiceCapabilities(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTotds__Service(struct soap *soap, struct tds__Service *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tds__Service))
		soap_serialize_tds__Service(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTotds__Service(struct soap *soap, const char *tag, int id, struct tds__Service *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tds__Service, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_tds__Service(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tds__Service ** SOAP_FMAC4 soap_in_PointerTotds__Service(struct soap *soap, const char *tag, struct tds__Service **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tds__Service **)soap_malloc(soap, sizeof(struct tds__Service *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tds__Service(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tds__Service **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tds__Service, sizeof(struct tds__Service), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTotds__Service(struct soap *soap, struct tds__Service *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTotds__Service(soap, tag ? tag : "tds:Service", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tds__Service ** SOAP_FMAC4 soap_get_PointerTotds__Service(struct soap *soap, struct tds__Service **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTotds__Service(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__OnvifVersion(struct soap *soap, struct tt__OnvifVersion *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__OnvifVersion))
		soap_serialize_tt__OnvifVersion(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__OnvifVersion(struct soap *soap, const char *tag, int id, struct tt__OnvifVersion *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__OnvifVersion, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_tt__OnvifVersion(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__OnvifVersion ** SOAP_FMAC4 soap_in_PointerTott__OnvifVersion(struct soap *soap, const char *tag, struct tt__OnvifVersion **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__OnvifVersion **)soap_malloc(soap, sizeof(struct tt__OnvifVersion *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__OnvifVersion(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__OnvifVersion **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__OnvifVersion, sizeof(struct tt__OnvifVersion), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__OnvifVersion(struct soap *soap, struct tt__OnvifVersion *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__OnvifVersion(soap, tag ? tag : "tt:OnvifVersion", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__OnvifVersion ** SOAP_FMAC4 soap_get_PointerTott__OnvifVersion(struct soap *soap, struct tt__OnvifVersion **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__OnvifVersion(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tds__Service_Capabilities(struct soap *soap, struct _tds__Service_Capabilities *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tds__Service_Capabilities))
		soap_serialize__tds__Service_Capabilities(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tds__Service_Capabilities(struct soap *soap, const char *tag, int id, struct _tds__Service_Capabilities *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tds__Service_Capabilities, NULL);
	if (id < 0)
		return soap->error;
	return soap_out__tds__Service_Capabilities(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _tds__Service_Capabilities ** SOAP_FMAC4 soap_in_PointerTo_tds__Service_Capabilities(struct soap *soap, const char *tag, struct _tds__Service_Capabilities **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _tds__Service_Capabilities **)soap_malloc(soap, sizeof(struct _tds__Service_Capabilities *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__tds__Service_Capabilities(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _tds__Service_Capabilities **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tds__Service_Capabilities, sizeof(struct _tds__Service_Capabilities), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tds__Service_Capabilities(struct soap *soap, struct _tds__Service_Capabilities *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_tds__Service_Capabilities(soap, tag ? tag : "tds:Service-Capabilities", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tds__Service_Capabilities ** SOAP_FMAC4 soap_get_PointerTo_tds__Service_Capabilities(struct soap *soap, struct _tds__Service_Capabilities **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tds__Service_Capabilities(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_wstop__ConcreteTopicExpression(struct soap *soap, const char *tag, int id, char *const*a, const char *type)
{
	return soap_outstring(soap, tag, id, a, type, SOAP_TYPE_wstop__ConcreteTopicExpression);
}

SOAP_FMAC3 char * * SOAP_FMAC4 soap_in_wstop__ConcreteTopicExpression(struct soap *soap, const char *tag, char **a, const char *type)
{
	a = soap_instring(soap, tag, a, type, SOAP_TYPE_wstop__ConcreteTopicExpression, 5, 0, -1, "(([\\i-[:]][\\c-[:]]*:)?[\\i-[:]][\\c-[:]]*)(/([\\i-[:]][\\c-[:]]*:)?[\\i-[:]][\\c-[:]]*)*");
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_wstop__ConcreteTopicExpression(struct soap *soap, char *const*a, const char *tag, const char *type)
{
	if (soap_out_wstop__ConcreteTopicExpression(soap, tag ? tag : "wstop:ConcreteTopicExpression", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 char ** SOAP_FMAC4 soap_get_wstop__ConcreteTopicExpression(struct soap *soap, char **p, const char *tag, const char *type)
{
	if ((p = soap_in_wstop__ConcreteTopicExpression(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_wstop__FullTopicExpression(struct soap *soap, const char *tag, int id, char *const*a, const char *type)
{
	return soap_outstring(soap, tag, id, a, type, SOAP_TYPE_wstop__FullTopicExpression);
}

SOAP_FMAC3 char * * SOAP_FMAC4 soap_in_wstop__FullTopicExpression(struct soap *soap, const char *tag, char **a, const char *type)
{
	a = soap_instring(soap, tag, a, type, SOAP_TYPE_wstop__FullTopicExpression, 5, 0, -1, "([\\i-[:]][\\c-[:]]*:)?(//)?([\\i-[:]][\\c-[:]]*|\\*)((/|//)(([\\i-[:]][\\c-[:]]*:)?[\\i-[:]][\\c-[:]]*|\\*|[.]))*(\\|([\\i-[:]][\\c-[:]]*:)?(//)?([\\i-[:]][\\c-[:]]*|\\*)((/|//)(([\\i-[:]][\\c-[:]]*:)?[\\i-[:]][\\c-[:]]*|\\*|[.]))*)*");
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_wstop__FullTopicExpression(struct soap *soap, char *const*a, const char *tag, const char *type)
{
	if (soap_out_wstop__FullTopicExpression(soap, tag ? tag : "wstop:FullTopicExpression", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 char ** SOAP_FMAC4 soap_get_wstop__FullTopicExpression(struct soap *soap, char **p, const char *tag, const char *type)
{
	if ((p = soap_in_wstop__FullTopicExpression(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__Name(struct soap *soap, char *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	(void)soap_reference(soap, *a, SOAP_TYPE_tt__Name);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__Name(struct soap *soap, const char *tag, int id, char *const*a, const char *type)
{
	return soap_outstring(soap, tag, id, a, type, SOAP_TYPE_tt__Name);
}

SOAP_FMAC3 char * * SOAP_FMAC4 soap_in_tt__Name(struct soap *soap, const char *tag, char **a, const char *type)
{
	a = soap_instring(soap, tag, a, type, SOAP_TYPE_tt__Name, 1, 0, 64, NULL);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__Name(struct soap *soap, char *const*a, const char *tag, const char *type)
{
	if (soap_out_tt__Name(soap, tag ? tag : "tt:Name", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 char ** SOAP_FMAC4 soap_get_tt__Name(struct soap *soap, char **p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__Name(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__ReferenceToken(struct soap *soap, char *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	(void)soap_reference(soap, *a, SOAP_TYPE_tt__ReferenceToken);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__ReferenceToken(struct soap *soap, const char *tag, int id, char *const*a, const char *type)
{
	return soap_outstring(soap, tag, id, a, type, SOAP_TYPE_tt__ReferenceToken);
}

SOAP_FMAC3 char * * SOAP_FMAC4 soap_in_tt__ReferenceToken(struct soap *soap, const char *tag, char **a, const char *type)
{
	a = soap_instring(soap, tag, a, type, SOAP_TYPE_tt__ReferenceToken, 1, 0, 64, NULL);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__ReferenceToken(struct soap *soap, char *const*a, const char *tag, const char *type)
{
	if (soap_out_tt__ReferenceToken(soap, tag ? tag : "tt:ReferenceToken", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 char ** SOAP_FMAC4 soap_get_tt__ReferenceToken(struct soap *soap, char **p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__ReferenceToken(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_wsnt__AbsoluteOrRelativeTimeType(struct soap *soap, char *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	(void)soap_reference(soap, *a, SOAP_TYPE_wsnt__AbsoluteOrRelativeTimeType);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_wsnt__AbsoluteOrRelativeTimeType(struct soap *soap, const char *tag, int id, char *const*a, const char *type)
{
	return soap_outstring(soap, tag, id, a, type, SOAP_TYPE_wsnt__AbsoluteOrRelativeTimeType);
}

SOAP_FMAC3 char * * SOAP_FMAC4 soap_in_wsnt__AbsoluteOrRelativeTimeType(struct soap *soap, const char *tag, char **a, const char *type)
{
	a = soap_instring(soap, tag, a, type, SOAP_TYPE_wsnt__AbsoluteOrRelativeTimeType, 1, 0, -1, NULL);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_wsnt__AbsoluteOrRelativeTimeType(struct soap *soap, char *const*a, const char *tag, const char *type)
{
	if (soap_out_wsnt__AbsoluteOrRelativeTimeType(soap, tag ? tag : "wsnt:AbsoluteOrRelativeTimeType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 char ** SOAP_FMAC4 soap_get_wsnt__AbsoluteOrRelativeTimeType(struct soap *soap, char **p, const char *tag, const char *type)
{
	if ((p = soap_in_wsnt__AbsoluteOrRelativeTimeType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__StringAttrList(struct soap *soap, char *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	(void)soap_reference(soap, *a, SOAP_TYPE_tt__StringAttrList);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__StringAttrList(struct soap *soap, const char *tag, int id, char *const*a, const char *type)
{
	return soap_outstring(soap, tag, id, a, type, SOAP_TYPE_tt__StringAttrList);
}

SOAP_FMAC3 char * * SOAP_FMAC4 soap_in_tt__StringAttrList(struct soap *soap, const char *tag, char **a, const char *type)
{
	a = soap_instring(soap, tag, a, type, SOAP_TYPE_tt__StringAttrList, 1, 0, -1, NULL);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__StringAttrList(struct soap *soap, char *const*a, const char *tag, const char *type)
{
	if (soap_out_tt__StringAttrList(soap, tag ? tag : "tt:StringAttrList", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 char ** SOAP_FMAC4 soap_get_tt__StringAttrList(struct soap *soap, char **p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__StringAttrList(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__FloatAttrList(struct soap *soap, char *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	(void)soap_reference(soap, *a, SOAP_TYPE_tt__FloatAttrList);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__FloatAttrList(struct soap *soap, const char *tag, int id, char *const*a, const char *type)
{
	return soap_outstring(soap, tag, id, a, type, SOAP_TYPE_tt__FloatAttrList);
}

SOAP_FMAC3 char * * SOAP_FMAC4 soap_in_tt__FloatAttrList(struct soap *soap, const char *tag, char **a, const char *type)
{
	a = soap_instring(soap, tag, a, type, SOAP_TYPE_tt__FloatAttrList, 1, 0, -1, NULL);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__FloatAttrList(struct soap *soap, char *const*a, const char *tag, const char *type)
{
	if (soap_out_tt__FloatAttrList(soap, tag ? tag : "tt:FloatAttrList", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 char ** SOAP_FMAC4 soap_get_tt__FloatAttrList(struct soap *soap, char **p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__FloatAttrList(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__IntAttrList(struct soap *soap, char *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	(void)soap_reference(soap, *a, SOAP_TYPE_tt__IntAttrList);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__IntAttrList(struct soap *soap, const char *tag, int id, char *const*a, const char *type)
{
	return soap_outstring(soap, tag, id, a, type, SOAP_TYPE_tt__IntAttrList);
}

SOAP_FMAC3 char * * SOAP_FMAC4 soap_in_tt__IntAttrList(struct soap *soap, const char *tag, char **a, const char *type)
{
	a = soap_instring(soap, tag, a, type, SOAP_TYPE_tt__IntAttrList, 1, 0, -1, NULL);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__IntAttrList(struct soap *soap, char *const*a, const char *tag, const char *type)
{
	if (soap_out_tt__IntAttrList(soap, tag ? tag : "tt:IntAttrList", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 char ** SOAP_FMAC4 soap_get_tt__IntAttrList(struct soap *soap, char **p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__IntAttrList(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tds__EAPMethodTypes(struct soap *soap, char *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	(void)soap_reference(soap, *a, SOAP_TYPE_tds__EAPMethodTypes);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tds__EAPMethodTypes(struct soap *soap, const char *tag, int id, char *const*a, const char *type)
{
	return soap_outstring(soap, tag, id, a, type, SOAP_TYPE_tds__EAPMethodTypes);
}

SOAP_FMAC3 char * * SOAP_FMAC4 soap_in_tds__EAPMethodTypes(struct soap *soap, const char *tag, char **a, const char *type)
{
	a = soap_instring(soap, tag, a, type, SOAP_TYPE_tds__EAPMethodTypes, 1, 0, -1, NULL);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tds__EAPMethodTypes(struct soap *soap, char *const*a, const char *tag, const char *type)
{
	if (soap_out_tds__EAPMethodTypes(soap, tag ? tag : "tds:EAPMethodTypes", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 char ** SOAP_FMAC4 soap_get_tds__EAPMethodTypes(struct soap *soap, char **p, const char *tag, const char *type)
{
	if ((p = soap_in_tds__EAPMethodTypes(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__xml__lang(struct soap *soap, char *const*a, const char *tag, const char *type)
{
	if (soap_out__xml__lang(soap, tag ? tag : "xml:lang", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_xsd__token(struct soap *soap, char *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	(void)soap_reference(soap, *a, SOAP_TYPE_xsd__token);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_xsd__token(struct soap *soap, const char *tag, int id, char *const*a, const char *type)
{
	return soap_outstring(soap, tag, id, a, type, SOAP_TYPE_xsd__token);
}

SOAP_FMAC3 char * * SOAP_FMAC4 soap_in_xsd__token(struct soap *soap, const char *tag, char **a, const char *type)
{
	a = soap_instring(soap, tag, a, type, SOAP_TYPE_xsd__token, 5, 0, -1, NULL);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_xsd__token(struct soap *soap, char *const*a, const char *tag, const char *type)
{
	if (soap_out_xsd__token(soap, tag ? tag : "xsd:token", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 char ** SOAP_FMAC4 soap_get_xsd__token(struct soap *soap, char **p, const char *tag, const char *type)
{
	if ((p = soap_in_xsd__token(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_xsd__nonNegativeInteger(struct soap *soap, char *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	(void)soap_reference(soap, *a, SOAP_TYPE_xsd__nonNegativeInteger);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_xsd__nonNegativeInteger(struct soap *soap, const char *tag, int id, char *const*a, const char *type)
{
	return soap_outstring(soap, tag, id, a, type, SOAP_TYPE_xsd__nonNegativeInteger);
}

SOAP_FMAC3 char * * SOAP_FMAC4 soap_in_xsd__nonNegativeInteger(struct soap *soap, const char *tag, char **a, const char *type)
{
	a = soap_instring(soap, tag, a, type, SOAP_TYPE_xsd__nonNegativeInteger, 5, 0, -1, "\\+?\\d+");
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_xsd__nonNegativeInteger(struct soap *soap, char *const*a, const char *tag, const char *type)
{
	if (soap_out_xsd__nonNegativeInteger(soap, tag ? tag : "xsd:nonNegativeInteger", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 char ** SOAP_FMAC4 soap_get_xsd__nonNegativeInteger(struct soap *soap, char **p, const char *tag, const char *type)
{
	if ((p = soap_in_xsd__nonNegativeInteger(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_xsd__anyURI(struct soap *soap, char *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	(void)soap_reference(soap, *a, SOAP_TYPE_xsd__anyURI);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_xsd__anyURI(struct soap *soap, const char *tag, int id, char *const*a, const char *type)
{
	return soap_outstring(soap, tag, id, a, type, SOAP_TYPE_xsd__anyURI);
}

SOAP_FMAC3 char * * SOAP_FMAC4 soap_in_xsd__anyURI(struct soap *soap, const char *tag, char **a, const char *type)
{
	a = soap_instring(soap, tag, a, type, SOAP_TYPE_xsd__anyURI, 4, 0, -1, NULL);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_xsd__anyURI(struct soap *soap, char *const*a, const char *tag, const char *type)
{
	if (soap_out_xsd__anyURI(soap, tag ? tag : "xsd:anyURI", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 char ** SOAP_FMAC4 soap_get_xsd__anyURI(struct soap *soap, char **p, const char *tag, const char *type)
{
	if ((p = soap_in_xsd__anyURI(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_xsd__anySimpleType(struct soap *soap, char *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	(void)soap_reference(soap, *a, SOAP_TYPE_xsd__anySimpleType);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_xsd__anySimpleType(struct soap *soap, const char *tag, int id, char *const*a, const char *type)
{
	return soap_outstring(soap, tag, id, a, type, SOAP_TYPE_xsd__anySimpleType);
}

SOAP_FMAC3 char * * SOAP_FMAC4 soap_in_xsd__anySimpleType(struct soap *soap, const char *tag, char **a, const char *type)
{
	a = soap_instring(soap, tag, a, type, SOAP_TYPE_xsd__anySimpleType, 1, 0, -1, NULL);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_xsd__anySimpleType(struct soap *soap, char *const*a, const char *tag, const char *type)
{
	if (soap_out_xsd__anySimpleType(soap, tag ? tag : "xsd:anySimpleType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 char ** SOAP_FMAC4 soap_get_xsd__anySimpleType(struct soap *soap, char **p, const char *tag, const char *type)
{
	if ((p = soap_in_xsd__anySimpleType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_xsd__NCName(struct soap *soap, char *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	(void)soap_reference(soap, *a, SOAP_TYPE_xsd__NCName);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_xsd__NCName(struct soap *soap, const char *tag, int id, char *const*a, const char *type)
{
	return soap_outstring(soap, tag, id, a, type, SOAP_TYPE_xsd__NCName);
}

SOAP_FMAC3 char * * SOAP_FMAC4 soap_in_xsd__NCName(struct soap *soap, const char *tag, char **a, const char *type)
{
	a = soap_instring(soap, tag, a, type, SOAP_TYPE_xsd__NCName, 5, 0, -1, "[\\i-[:]][\\c-[:]]*");
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_xsd__NCName(struct soap *soap, char *const*a, const char *tag, const char *type)
{
	if (soap_out_xsd__NCName(soap, tag ? tag : "xsd:NCName", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 char ** SOAP_FMAC4 soap_get_xsd__NCName(struct soap *soap, char **p, const char *tag, const char *type)
{
	if ((p = soap_in_xsd__NCName(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_wsse__Security(struct soap *soap, struct _wsse__Security *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__wsse__Security))
		soap_serialize__wsse__Security(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_wsse__Security(struct soap *soap, const char *tag, int id, struct _wsse__Security *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__wsse__Security, NULL);
	if (id < 0)
		return soap->error;
	return soap_out__wsse__Security(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _wsse__Security ** SOAP_FMAC4 soap_in_PointerTo_wsse__Security(struct soap *soap, const char *tag, struct _wsse__Security **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _wsse__Security **)soap_malloc(soap, sizeof(struct _wsse__Security *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__wsse__Security(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _wsse__Security **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__wsse__Security, sizeof(struct _wsse__Security), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_wsse__Security(struct soap *soap, struct _wsse__Security *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_wsse__Security(soap, tag ? tag : "wsse:Security", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _wsse__Security ** SOAP_FMAC4 soap_get_PointerTo_wsse__Security(struct soap *soap, struct _wsse__Security **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_wsse__Security(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTods__SignatureType(struct soap *soap, struct ds__SignatureType *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ds__SignatureType))
		soap_serialize_ds__SignatureType(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTods__SignatureType(struct soap *soap, const char *tag, int id, struct ds__SignatureType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ds__SignatureType, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_ds__SignatureType(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ds__SignatureType ** SOAP_FMAC4 soap_in_PointerTods__SignatureType(struct soap *soap, const char *tag, struct ds__SignatureType **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ds__SignatureType **)soap_malloc(soap, sizeof(struct ds__SignatureType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ds__SignatureType(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ds__SignatureType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ds__SignatureType, sizeof(struct ds__SignatureType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTods__SignatureType(struct soap *soap, struct ds__SignatureType *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTods__SignatureType(soap, tag ? tag : "ds:SignatureType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ds__SignatureType ** SOAP_FMAC4 soap_get_PointerTods__SignatureType(struct soap *soap, struct ds__SignatureType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTods__SignatureType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTowsc__SecurityContextTokenType(struct soap *soap, struct wsc__SecurityContextTokenType *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_wsc__SecurityContextTokenType))
		soap_serialize_wsc__SecurityContextTokenType(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTowsc__SecurityContextTokenType(struct soap *soap, const char *tag, int id, struct wsc__SecurityContextTokenType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_wsc__SecurityContextTokenType, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_wsc__SecurityContextTokenType(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct wsc__SecurityContextTokenType ** SOAP_FMAC4 soap_in_PointerTowsc__SecurityContextTokenType(struct soap *soap, const char *tag, struct wsc__SecurityContextTokenType **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct wsc__SecurityContextTokenType **)soap_malloc(soap, sizeof(struct wsc__SecurityContextTokenType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_wsc__SecurityContextTokenType(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct wsc__SecurityContextTokenType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_wsc__SecurityContextTokenType, sizeof(struct wsc__SecurityContextTokenType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTowsc__SecurityContextTokenType(struct soap *soap, struct wsc__SecurityContextTokenType *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTowsc__SecurityContextTokenType(soap, tag ? tag : "wsc:SecurityContextTokenType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct wsc__SecurityContextTokenType ** SOAP_FMAC4 soap_get_PointerTowsc__SecurityContextTokenType(struct soap *soap, struct wsc__SecurityContextTokenType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTowsc__SecurityContextTokenType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_wsse__BinarySecurityToken(struct soap *soap, struct _wsse__BinarySecurityToken *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__wsse__BinarySecurityToken))
		soap_serialize__wsse__BinarySecurityToken(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_wsse__BinarySecurityToken(struct soap *soap, const char *tag, int id, struct _wsse__BinarySecurityToken *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__wsse__BinarySecurityToken, NULL);
	if (id < 0)
		return soap->error;
	return soap_out__wsse__BinarySecurityToken(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _wsse__BinarySecurityToken ** SOAP_FMAC4 soap_in_PointerTo_wsse__BinarySecurityToken(struct soap *soap, const char *tag, struct _wsse__BinarySecurityToken **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _wsse__BinarySecurityToken **)soap_malloc(soap, sizeof(struct _wsse__BinarySecurityToken *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__wsse__BinarySecurityToken(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _wsse__BinarySecurityToken **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__wsse__BinarySecurityToken, sizeof(struct _wsse__BinarySecurityToken), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_wsse__BinarySecurityToken(struct soap *soap, struct _wsse__BinarySecurityToken *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_wsse__BinarySecurityToken(soap, tag ? tag : "wsse:BinarySecurityToken", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _wsse__BinarySecurityToken ** SOAP_FMAC4 soap_get_PointerTo_wsse__BinarySecurityToken(struct soap *soap, struct _wsse__BinarySecurityToken **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_wsse__BinarySecurityToken(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_wsse__UsernameToken(struct soap *soap, struct _wsse__UsernameToken *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__wsse__UsernameToken))
		soap_serialize__wsse__UsernameToken(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_wsse__UsernameToken(struct soap *soap, const char *tag, int id, struct _wsse__UsernameToken *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__wsse__UsernameToken, NULL);
	if (id < 0)
		return soap->error;
	return soap_out__wsse__UsernameToken(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _wsse__UsernameToken ** SOAP_FMAC4 soap_in_PointerTo_wsse__UsernameToken(struct soap *soap, const char *tag, struct _wsse__UsernameToken **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _wsse__UsernameToken **)soap_malloc(soap, sizeof(struct _wsse__UsernameToken *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__wsse__UsernameToken(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _wsse__UsernameToken **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__wsse__UsernameToken, sizeof(struct _wsse__UsernameToken), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_wsse__UsernameToken(struct soap *soap, struct _wsse__UsernameToken *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_wsse__UsernameToken(soap, tag ? tag : "wsse:UsernameToken", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _wsse__UsernameToken ** SOAP_FMAC4 soap_get_PointerTo_wsse__UsernameToken(struct soap *soap, struct _wsse__UsernameToken **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_wsse__UsernameToken(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_wsu__Timestamp(struct soap *soap, struct _wsu__Timestamp *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__wsu__Timestamp))
		soap_serialize__wsu__Timestamp(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_wsu__Timestamp(struct soap *soap, const char *tag, int id, struct _wsu__Timestamp *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__wsu__Timestamp, NULL);
	if (id < 0)
		return soap->error;
	return soap_out__wsu__Timestamp(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _wsu__Timestamp ** SOAP_FMAC4 soap_in_PointerTo_wsu__Timestamp(struct soap *soap, const char *tag, struct _wsu__Timestamp **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _wsu__Timestamp **)soap_malloc(soap, sizeof(struct _wsu__Timestamp *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__wsu__Timestamp(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _wsu__Timestamp **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__wsu__Timestamp, sizeof(struct _wsu__Timestamp), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_wsu__Timestamp(struct soap *soap, struct _wsu__Timestamp *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_wsu__Timestamp(soap, tag ? tag : "wsu:Timestamp", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _wsu__Timestamp ** SOAP_FMAC4 soap_get_PointerTo_wsu__Timestamp(struct soap *soap, struct _wsu__Timestamp **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_wsu__Timestamp(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__saml2__AuthenticatingAuthority(struct soap *soap, char *const*a, const char *tag, const char *type)
{
	if (soap_out__saml2__AuthenticatingAuthority(soap, tag ? tag : "saml2:AuthenticatingAuthority", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__saml2__AuthnContextDeclRef(struct soap *soap, char *const*a, const char *tag, const char *type)
{
	if (soap_out__saml2__AuthnContextDeclRef(soap, tag ? tag : "saml2:AuthnContextDeclRef", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__saml2__AuthnContextClassRef(struct soap *soap, char *const*a, const char *tag, const char *type)
{
	if (soap_out__saml2__AuthnContextClassRef(soap, tag ? tag : "saml2:AuthnContextClassRef", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__saml2__Audience(struct soap *soap, char *const*a, const char *tag, const char *type)
{
	if (soap_out__saml2__Audience(soap, tag ? tag : "saml2:Audience", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__saml2__AssertionURIRef(struct soap *soap, char *const*a, const char *tag, const char *type)
{
	if (soap_out__saml2__AssertionURIRef(soap, tag ? tag : "saml2:AssertionURIRef", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__saml2__AssertionIDRef(struct soap *soap, char *const*a, const char *tag, const char *type)
{
	if (soap_out__saml2__AssertionIDRef(soap, tag ? tag : "saml2:AssertionIDRef", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToPointerTo_ds__KeyInfo(struct soap *soap, struct ds__KeyInfoType **const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_PointerTo_ds__KeyInfo))
		soap_serialize_PointerTo_ds__KeyInfo(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToPointerTo_ds__KeyInfo(struct soap *soap, const char *tag, int id, struct ds__KeyInfoType **const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_PointerTo_ds__KeyInfo, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_PointerTo_ds__KeyInfo(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ds__KeyInfoType *** SOAP_FMAC4 soap_in_PointerToPointerTo_ds__KeyInfo(struct soap *soap, const char *tag, struct ds__KeyInfoType ***a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ds__KeyInfoType ***)soap_malloc(soap, sizeof(struct ds__KeyInfoType **))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_PointerTo_ds__KeyInfo(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ds__KeyInfoType ***)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ds__KeyInfo, sizeof(struct ds__KeyInfoType), 1, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToPointerTo_ds__KeyInfo(struct soap *soap, struct ds__KeyInfoType **const*a, const char *tag, const char *type)
{
	if (soap_out_PointerToPointerTo_ds__KeyInfo(soap, tag ? tag : "ds:KeyInfo", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ds__KeyInfoType *** SOAP_FMAC4 soap_get_PointerToPointerTo_ds__KeyInfo(struct soap *soap, struct ds__KeyInfoType ***p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToPointerTo_ds__KeyInfo(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo__saml2__union_AttributeStatementType(struct soap *soap, struct __saml2__union_AttributeStatementType *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE___saml2__union_AttributeStatementType))
		soap_serialize___saml2__union_AttributeStatementType(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo__saml2__union_AttributeStatementType(struct soap *soap, const char *tag, int id, struct __saml2__union_AttributeStatementType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE___saml2__union_AttributeStatementType, NULL);
	if (id < 0)
		return soap->error;
	return soap_out___saml2__union_AttributeStatementType(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct __saml2__union_AttributeStatementType ** SOAP_FMAC4 soap_in_PointerTo__saml2__union_AttributeStatementType(struct soap *soap, const char *tag, struct __saml2__union_AttributeStatementType **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct __saml2__union_AttributeStatementType **)soap_malloc(soap, sizeof(struct __saml2__union_AttributeStatementType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in___saml2__union_AttributeStatementType(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct __saml2__union_AttributeStatementType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE___saml2__union_AttributeStatementType, sizeof(struct __saml2__union_AttributeStatementType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo__saml2__union_AttributeStatementType(struct soap *soap, struct __saml2__union_AttributeStatementType *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo__saml2__union_AttributeStatementType(soap, tag ? tag : "-saml2:union-AttributeStatementType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct __saml2__union_AttributeStatementType ** SOAP_FMAC4 soap_get_PointerTo__saml2__union_AttributeStatementType(struct soap *soap, struct __saml2__union_AttributeStatementType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo__saml2__union_AttributeStatementType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTosaml2__AttributeType(struct soap *soap, struct saml2__AttributeType *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_saml2__AttributeType))
		soap_serialize_saml2__AttributeType(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTosaml2__AttributeType(struct soap *soap, const char *tag, int id, struct saml2__AttributeType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_saml2__AttributeType, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_saml2__AttributeType(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct saml2__AttributeType ** SOAP_FMAC4 soap_in_PointerTosaml2__AttributeType(struct soap *soap, const char *tag, struct saml2__AttributeType **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct saml2__AttributeType **)soap_malloc(soap, sizeof(struct saml2__AttributeType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_saml2__AttributeType(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct saml2__AttributeType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_saml2__AttributeType, sizeof(struct saml2__AttributeType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTosaml2__AttributeType(struct soap *soap, struct saml2__AttributeType *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTosaml2__AttributeType(soap, tag ? tag : "saml2:AttributeType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct saml2__AttributeType ** SOAP_FMAC4 soap_get_PointerTosaml2__AttributeType(struct soap *soap, struct saml2__AttributeType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTosaml2__AttributeType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTosaml2__EvidenceType(struct soap *soap, struct saml2__EvidenceType *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_saml2__EvidenceType))
		soap_serialize_saml2__EvidenceType(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTosaml2__EvidenceType(struct soap *soap, const char *tag, int id, struct saml2__EvidenceType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_saml2__EvidenceType, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_saml2__EvidenceType(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct saml2__EvidenceType ** SOAP_FMAC4 soap_in_PointerTosaml2__EvidenceType(struct soap *soap, const char *tag, struct saml2__EvidenceType **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct saml2__EvidenceType **)soap_malloc(soap, sizeof(struct saml2__EvidenceType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_saml2__EvidenceType(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct saml2__EvidenceType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_saml2__EvidenceType, sizeof(struct saml2__EvidenceType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTosaml2__EvidenceType(struct soap *soap, struct saml2__EvidenceType *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTosaml2__EvidenceType(soap, tag ? tag : "saml2:EvidenceType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct saml2__EvidenceType ** SOAP_FMAC4 soap_get_PointerTosaml2__EvidenceType(struct soap *soap, struct saml2__EvidenceType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTosaml2__EvidenceType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTosaml2__ActionType(struct soap *soap, struct saml2__ActionType *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_saml2__ActionType))
		soap_serialize_saml2__ActionType(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTosaml2__ActionType(struct soap *soap, const char *tag, int id, struct saml2__ActionType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_saml2__ActionType, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_saml2__ActionType(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct saml2__ActionType ** SOAP_FMAC4 soap_in_PointerTosaml2__ActionType(struct soap *soap, const char *tag, struct saml2__ActionType **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct saml2__ActionType **)soap_malloc(soap, sizeof(struct saml2__ActionType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_saml2__ActionType(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct saml2__ActionType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_saml2__ActionType, sizeof(struct saml2__ActionType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTosaml2__ActionType(struct soap *soap, struct saml2__ActionType *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTosaml2__ActionType(soap, tag ? tag : "saml2:ActionType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct saml2__ActionType ** SOAP_FMAC4 soap_get_PointerTosaml2__ActionType(struct soap *soap, struct saml2__ActionType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTosaml2__ActionType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTosaml2__AuthnContextType(struct soap *soap, struct saml2__AuthnContextType *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_saml2__AuthnContextType))
		soap_serialize_saml2__AuthnContextType(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTosaml2__AuthnContextType(struct soap *soap, const char *tag, int id, struct saml2__AuthnContextType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_saml2__AuthnContextType, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_saml2__AuthnContextType(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct saml2__AuthnContextType ** SOAP_FMAC4 soap_in_PointerTosaml2__AuthnContextType(struct soap *soap, const char *tag, struct saml2__AuthnContextType **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct saml2__AuthnContextType **)soap_malloc(soap, sizeof(struct saml2__AuthnContextType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_saml2__AuthnContextType(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct saml2__AuthnContextType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_saml2__AuthnContextType, sizeof(struct saml2__AuthnContextType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTosaml2__AuthnContextType(struct soap *soap, struct saml2__AuthnContextType *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTosaml2__AuthnContextType(soap, tag ? tag : "saml2:AuthnContextType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct saml2__AuthnContextType ** SOAP_FMAC4 soap_get_PointerTosaml2__AuthnContextType(struct soap *soap, struct saml2__AuthnContextType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTosaml2__AuthnContextType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTosaml2__SubjectLocalityType(struct soap *soap, struct saml2__SubjectLocalityType *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_saml2__SubjectLocalityType))
		soap_serialize_saml2__SubjectLocalityType(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTosaml2__SubjectLocalityType(struct soap *soap, const char *tag, int id, struct saml2__SubjectLocalityType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_saml2__SubjectLocalityType, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_saml2__SubjectLocalityType(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct saml2__SubjectLocalityType ** SOAP_FMAC4 soap_in_PointerTosaml2__SubjectLocalityType(struct soap *soap, const char *tag, struct saml2__SubjectLocalityType **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct saml2__SubjectLocalityType **)soap_malloc(soap, sizeof(struct saml2__SubjectLocalityType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_saml2__SubjectLocalityType(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct saml2__SubjectLocalityType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_saml2__SubjectLocalityType, sizeof(struct saml2__SubjectLocalityType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTosaml2__SubjectLocalityType(struct soap *soap, struct saml2__SubjectLocalityType *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTosaml2__SubjectLocalityType(soap, tag ? tag : "saml2:SubjectLocalityType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct saml2__SubjectLocalityType ** SOAP_FMAC4 soap_get_PointerTosaml2__SubjectLocalityType(struct soap *soap, struct saml2__SubjectLocalityType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTosaml2__SubjectLocalityType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo__saml2__union_EvidenceType(struct soap *soap, struct __saml2__union_EvidenceType *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE___saml2__union_EvidenceType))
		soap_serialize___saml2__union_EvidenceType(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo__saml2__union_EvidenceType(struct soap *soap, const char *tag, int id, struct __saml2__union_EvidenceType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE___saml2__union_EvidenceType, NULL);
	if (id < 0)
		return soap->error;
	return soap_out___saml2__union_EvidenceType(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct __saml2__union_EvidenceType ** SOAP_FMAC4 soap_in_PointerTo__saml2__union_EvidenceType(struct soap *soap, const char *tag, struct __saml2__union_EvidenceType **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct __saml2__union_EvidenceType **)soap_malloc(soap, sizeof(struct __saml2__union_EvidenceType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in___saml2__union_EvidenceType(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct __saml2__union_EvidenceType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE___saml2__union_EvidenceType, sizeof(struct __saml2__union_EvidenceType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo__saml2__union_EvidenceType(struct soap *soap, struct __saml2__union_EvidenceType *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo__saml2__union_EvidenceType(soap, tag ? tag : "-saml2:union-EvidenceType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct __saml2__union_EvidenceType ** SOAP_FMAC4 soap_get_PointerTo__saml2__union_EvidenceType(struct soap *soap, struct __saml2__union_EvidenceType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo__saml2__union_EvidenceType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo__saml2__union_AdviceType(struct soap *soap, struct __saml2__union_AdviceType *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE___saml2__union_AdviceType))
		soap_serialize___saml2__union_AdviceType(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo__saml2__union_AdviceType(struct soap *soap, const char *tag, int id, struct __saml2__union_AdviceType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE___saml2__union_AdviceType, NULL);
	if (id < 0)
		return soap->error;
	return soap_out___saml2__union_AdviceType(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct __saml2__union_AdviceType ** SOAP_FMAC4 soap_in_PointerTo__saml2__union_AdviceType(struct soap *soap, const char *tag, struct __saml2__union_AdviceType **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct __saml2__union_AdviceType **)soap_malloc(soap, sizeof(struct __saml2__union_AdviceType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in___saml2__union_AdviceType(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct __saml2__union_AdviceType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE___saml2__union_AdviceType, sizeof(struct __saml2__union_AdviceType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo__saml2__union_AdviceType(struct soap *soap, struct __saml2__union_AdviceType *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo__saml2__union_AdviceType(soap, tag ? tag : "-saml2:union-AdviceType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct __saml2__union_AdviceType ** SOAP_FMAC4 soap_get_PointerTo__saml2__union_AdviceType(struct soap *soap, struct __saml2__union_AdviceType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo__saml2__union_AdviceType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTosaml2__AssertionType(struct soap *soap, struct saml2__AssertionType *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_saml2__AssertionType))
		soap_serialize_saml2__AssertionType(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTosaml2__AssertionType(struct soap *soap, const char *tag, int id, struct saml2__AssertionType *const*a, const char *type)
{
	char *mark;
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_saml2__AssertionType, &mark);
	if (id < 0)
		return soap->error;
	(void)soap_out_saml2__AssertionType(soap, tag, id, *a, type);
	soap_unmark(soap, mark);
	return soap->error;
}

SOAP_FMAC3 struct saml2__AssertionType ** SOAP_FMAC4 soap_in_PointerTosaml2__AssertionType(struct soap *soap, const char *tag, struct saml2__AssertionType **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct saml2__AssertionType **)soap_malloc(soap, sizeof(struct saml2__AssertionType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_saml2__AssertionType(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct saml2__AssertionType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_saml2__AssertionType, sizeof(struct saml2__AssertionType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTosaml2__AssertionType(struct soap *soap, struct saml2__AssertionType *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTosaml2__AssertionType(soap, tag ? tag : "saml2:AssertionType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct saml2__AssertionType ** SOAP_FMAC4 soap_get_PointerTosaml2__AssertionType(struct soap *soap, struct saml2__AssertionType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTosaml2__AssertionType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo__saml2__union_ConditionsType(struct soap *soap, struct __saml2__union_ConditionsType *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE___saml2__union_ConditionsType))
		soap_serialize___saml2__union_ConditionsType(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo__saml2__union_ConditionsType(struct soap *soap, const char *tag, int id, struct __saml2__union_ConditionsType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE___saml2__union_ConditionsType, NULL);
	if (id < 0)
		return soap->error;
	return soap_out___saml2__union_ConditionsType(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct __saml2__union_ConditionsType ** SOAP_FMAC4 soap_in_PointerTo__saml2__union_ConditionsType(struct soap *soap, const char *tag, struct __saml2__union_ConditionsType **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct __saml2__union_ConditionsType **)soap_malloc(soap, sizeof(struct __saml2__union_ConditionsType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in___saml2__union_ConditionsType(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct __saml2__union_ConditionsType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE___saml2__union_ConditionsType, sizeof(struct __saml2__union_ConditionsType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo__saml2__union_ConditionsType(struct soap *soap, struct __saml2__union_ConditionsType *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo__saml2__union_ConditionsType(soap, tag ? tag : "-saml2:union-ConditionsType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct __saml2__union_ConditionsType ** SOAP_FMAC4 soap_get_PointerTo__saml2__union_ConditionsType(struct soap *soap, struct __saml2__union_ConditionsType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo__saml2__union_ConditionsType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTosaml2__ProxyRestrictionType(struct soap *soap, struct saml2__ProxyRestrictionType *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_saml2__ProxyRestrictionType))
		soap_serialize_saml2__ProxyRestrictionType(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTosaml2__ProxyRestrictionType(struct soap *soap, const char *tag, int id, struct saml2__ProxyRestrictionType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_saml2__ProxyRestrictionType, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_saml2__ProxyRestrictionType(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct saml2__ProxyRestrictionType ** SOAP_FMAC4 soap_in_PointerTosaml2__ProxyRestrictionType(struct soap *soap, const char *tag, struct saml2__ProxyRestrictionType **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct saml2__ProxyRestrictionType **)soap_malloc(soap, sizeof(struct saml2__ProxyRestrictionType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_saml2__ProxyRestrictionType(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct saml2__ProxyRestrictionType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_saml2__ProxyRestrictionType, sizeof(struct saml2__ProxyRestrictionType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTosaml2__ProxyRestrictionType(struct soap *soap, struct saml2__ProxyRestrictionType *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTosaml2__ProxyRestrictionType(soap, tag ? tag : "saml2:ProxyRestrictionType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct saml2__ProxyRestrictionType ** SOAP_FMAC4 soap_get_PointerTosaml2__ProxyRestrictionType(struct soap *soap, struct saml2__ProxyRestrictionType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTosaml2__ProxyRestrictionType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTosaml2__OneTimeUseType(struct soap *soap, struct saml2__OneTimeUseType *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_saml2__OneTimeUseType))
		soap_serialize_saml2__OneTimeUseType(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTosaml2__OneTimeUseType(struct soap *soap, const char *tag, int id, struct saml2__OneTimeUseType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_saml2__OneTimeUseType, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_saml2__OneTimeUseType(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct saml2__OneTimeUseType ** SOAP_FMAC4 soap_in_PointerTosaml2__OneTimeUseType(struct soap *soap, const char *tag, struct saml2__OneTimeUseType **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct saml2__OneTimeUseType **)soap_malloc(soap, sizeof(struct saml2__OneTimeUseType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_saml2__OneTimeUseType(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct saml2__OneTimeUseType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_saml2__OneTimeUseType, sizeof(struct saml2__OneTimeUseType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTosaml2__OneTimeUseType(struct soap *soap, struct saml2__OneTimeUseType *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTosaml2__OneTimeUseType(soap, tag ? tag : "saml2:OneTimeUseType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct saml2__OneTimeUseType ** SOAP_FMAC4 soap_get_PointerTosaml2__OneTimeUseType(struct soap *soap, struct saml2__OneTimeUseType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTosaml2__OneTimeUseType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTosaml2__AudienceRestrictionType(struct soap *soap, struct saml2__AudienceRestrictionType *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_saml2__AudienceRestrictionType))
		soap_serialize_saml2__AudienceRestrictionType(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTosaml2__AudienceRestrictionType(struct soap *soap, const char *tag, int id, struct saml2__AudienceRestrictionType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_saml2__AudienceRestrictionType, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_saml2__AudienceRestrictionType(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct saml2__AudienceRestrictionType ** SOAP_FMAC4 soap_in_PointerTosaml2__AudienceRestrictionType(struct soap *soap, const char *tag, struct saml2__AudienceRestrictionType **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct saml2__AudienceRestrictionType **)soap_malloc(soap, sizeof(struct saml2__AudienceRestrictionType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_saml2__AudienceRestrictionType(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct saml2__AudienceRestrictionType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_saml2__AudienceRestrictionType, sizeof(struct saml2__AudienceRestrictionType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTosaml2__AudienceRestrictionType(struct soap *soap, struct saml2__AudienceRestrictionType *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTosaml2__AudienceRestrictionType(soap, tag ? tag : "saml2:AudienceRestrictionType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct saml2__AudienceRestrictionType ** SOAP_FMAC4 soap_get_PointerTosaml2__AudienceRestrictionType(struct soap *soap, struct saml2__AudienceRestrictionType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTosaml2__AudienceRestrictionType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTosaml2__ConditionAbstractType(struct soap *soap, struct saml2__ConditionAbstractType *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_saml2__ConditionAbstractType))
		soap_serialize_saml2__ConditionAbstractType(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTosaml2__ConditionAbstractType(struct soap *soap, const char *tag, int id, struct saml2__ConditionAbstractType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_saml2__ConditionAbstractType, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_saml2__ConditionAbstractType(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct saml2__ConditionAbstractType ** SOAP_FMAC4 soap_in_PointerTosaml2__ConditionAbstractType(struct soap *soap, const char *tag, struct saml2__ConditionAbstractType **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct saml2__ConditionAbstractType **)soap_malloc(soap, sizeof(struct saml2__ConditionAbstractType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_saml2__ConditionAbstractType(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct saml2__ConditionAbstractType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_saml2__ConditionAbstractType, sizeof(struct saml2__ConditionAbstractType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTosaml2__ConditionAbstractType(struct soap *soap, struct saml2__ConditionAbstractType *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTosaml2__ConditionAbstractType(soap, tag ? tag : "saml2:ConditionAbstractType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct saml2__ConditionAbstractType ** SOAP_FMAC4 soap_get_PointerTosaml2__ConditionAbstractType(struct soap *soap, struct saml2__ConditionAbstractType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTosaml2__ConditionAbstractType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTosaml2__SubjectConfirmationDataType(struct soap *soap, struct saml2__SubjectConfirmationDataType *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_saml2__SubjectConfirmationDataType))
		soap_serialize_saml2__SubjectConfirmationDataType(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTosaml2__SubjectConfirmationDataType(struct soap *soap, const char *tag, int id, struct saml2__SubjectConfirmationDataType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_saml2__SubjectConfirmationDataType, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_saml2__SubjectConfirmationDataType(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct saml2__SubjectConfirmationDataType ** SOAP_FMAC4 soap_in_PointerTosaml2__SubjectConfirmationDataType(struct soap *soap, const char *tag, struct saml2__SubjectConfirmationDataType **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct saml2__SubjectConfirmationDataType **)soap_malloc(soap, sizeof(struct saml2__SubjectConfirmationDataType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_saml2__SubjectConfirmationDataType(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct saml2__SubjectConfirmationDataType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_saml2__SubjectConfirmationDataType, sizeof(struct saml2__SubjectConfirmationDataType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTosaml2__SubjectConfirmationDataType(struct soap *soap, struct saml2__SubjectConfirmationDataType *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTosaml2__SubjectConfirmationDataType(soap, tag ? tag : "saml2:SubjectConfirmationDataType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct saml2__SubjectConfirmationDataType ** SOAP_FMAC4 soap_get_PointerTosaml2__SubjectConfirmationDataType(struct soap *soap, struct saml2__SubjectConfirmationDataType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTosaml2__SubjectConfirmationDataType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTosaml2__SubjectConfirmationType(struct soap *soap, struct saml2__SubjectConfirmationType *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_saml2__SubjectConfirmationType))
		soap_serialize_saml2__SubjectConfirmationType(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTosaml2__SubjectConfirmationType(struct soap *soap, const char *tag, int id, struct saml2__SubjectConfirmationType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_saml2__SubjectConfirmationType, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_saml2__SubjectConfirmationType(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct saml2__SubjectConfirmationType ** SOAP_FMAC4 soap_in_PointerTosaml2__SubjectConfirmationType(struct soap *soap, const char *tag, struct saml2__SubjectConfirmationType **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct saml2__SubjectConfirmationType **)soap_malloc(soap, sizeof(struct saml2__SubjectConfirmationType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_saml2__SubjectConfirmationType(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct saml2__SubjectConfirmationType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_saml2__SubjectConfirmationType, sizeof(struct saml2__SubjectConfirmationType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTosaml2__SubjectConfirmationType(struct soap *soap, struct saml2__SubjectConfirmationType *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTosaml2__SubjectConfirmationType(soap, tag ? tag : "saml2:SubjectConfirmationType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct saml2__SubjectConfirmationType ** SOAP_FMAC4 soap_get_PointerTosaml2__SubjectConfirmationType(struct soap *soap, struct saml2__SubjectConfirmationType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTosaml2__SubjectConfirmationType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTosaml2__EncryptedElementType(struct soap *soap, struct saml2__EncryptedElementType *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_saml2__EncryptedElementType))
		soap_serialize_saml2__EncryptedElementType(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTosaml2__EncryptedElementType(struct soap *soap, const char *tag, int id, struct saml2__EncryptedElementType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_saml2__EncryptedElementType, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_saml2__EncryptedElementType(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct saml2__EncryptedElementType ** SOAP_FMAC4 soap_in_PointerTosaml2__EncryptedElementType(struct soap *soap, const char *tag, struct saml2__EncryptedElementType **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct saml2__EncryptedElementType **)soap_malloc(soap, sizeof(struct saml2__EncryptedElementType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_saml2__EncryptedElementType(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct saml2__EncryptedElementType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_saml2__EncryptedElementType, sizeof(struct saml2__EncryptedElementType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTosaml2__EncryptedElementType(struct soap *soap, struct saml2__EncryptedElementType *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTosaml2__EncryptedElementType(soap, tag ? tag : "saml2:EncryptedElementType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct saml2__EncryptedElementType ** SOAP_FMAC4 soap_get_PointerTosaml2__EncryptedElementType(struct soap *soap, struct saml2__EncryptedElementType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTosaml2__EncryptedElementType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTosaml2__BaseIDAbstractType(struct soap *soap, struct saml2__BaseIDAbstractType *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_saml2__BaseIDAbstractType))
		soap_serialize_saml2__BaseIDAbstractType(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTosaml2__BaseIDAbstractType(struct soap *soap, const char *tag, int id, struct saml2__BaseIDAbstractType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_saml2__BaseIDAbstractType, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_saml2__BaseIDAbstractType(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct saml2__BaseIDAbstractType ** SOAP_FMAC4 soap_in_PointerTosaml2__BaseIDAbstractType(struct soap *soap, const char *tag, struct saml2__BaseIDAbstractType **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct saml2__BaseIDAbstractType **)soap_malloc(soap, sizeof(struct saml2__BaseIDAbstractType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_saml2__BaseIDAbstractType(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct saml2__BaseIDAbstractType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_saml2__BaseIDAbstractType, sizeof(struct saml2__BaseIDAbstractType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTosaml2__BaseIDAbstractType(struct soap *soap, struct saml2__BaseIDAbstractType *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTosaml2__BaseIDAbstractType(soap, tag ? tag : "saml2:BaseIDAbstractType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct saml2__BaseIDAbstractType ** SOAP_FMAC4 soap_get_PointerTosaml2__BaseIDAbstractType(struct soap *soap, struct saml2__BaseIDAbstractType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTosaml2__BaseIDAbstractType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo__saml2__union_AssertionType(struct soap *soap, struct __saml2__union_AssertionType *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE___saml2__union_AssertionType))
		soap_serialize___saml2__union_AssertionType(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo__saml2__union_AssertionType(struct soap *soap, const char *tag, int id, struct __saml2__union_AssertionType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE___saml2__union_AssertionType, NULL);
	if (id < 0)
		return soap->error;
	return soap_out___saml2__union_AssertionType(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct __saml2__union_AssertionType ** SOAP_FMAC4 soap_in_PointerTo__saml2__union_AssertionType(struct soap *soap, const char *tag, struct __saml2__union_AssertionType **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct __saml2__union_AssertionType **)soap_malloc(soap, sizeof(struct __saml2__union_AssertionType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in___saml2__union_AssertionType(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct __saml2__union_AssertionType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE___saml2__union_AssertionType, sizeof(struct __saml2__union_AssertionType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo__saml2__union_AssertionType(struct soap *soap, struct __saml2__union_AssertionType *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo__saml2__union_AssertionType(soap, tag ? tag : "-saml2:union-AssertionType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct __saml2__union_AssertionType ** SOAP_FMAC4 soap_get_PointerTo__saml2__union_AssertionType(struct soap *soap, struct __saml2__union_AssertionType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo__saml2__union_AssertionType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTosaml2__AttributeStatementType(struct soap *soap, struct saml2__AttributeStatementType *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_saml2__AttributeStatementType))
		soap_serialize_saml2__AttributeStatementType(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTosaml2__AttributeStatementType(struct soap *soap, const char *tag, int id, struct saml2__AttributeStatementType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_saml2__AttributeStatementType, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_saml2__AttributeStatementType(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct saml2__AttributeStatementType ** SOAP_FMAC4 soap_in_PointerTosaml2__AttributeStatementType(struct soap *soap, const char *tag, struct saml2__AttributeStatementType **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct saml2__AttributeStatementType **)soap_malloc(soap, sizeof(struct saml2__AttributeStatementType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_saml2__AttributeStatementType(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct saml2__AttributeStatementType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_saml2__AttributeStatementType, sizeof(struct saml2__AttributeStatementType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTosaml2__AttributeStatementType(struct soap *soap, struct saml2__AttributeStatementType *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTosaml2__AttributeStatementType(soap, tag ? tag : "saml2:AttributeStatementType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct saml2__AttributeStatementType ** SOAP_FMAC4 soap_get_PointerTosaml2__AttributeStatementType(struct soap *soap, struct saml2__AttributeStatementType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTosaml2__AttributeStatementType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTosaml2__AuthzDecisionStatementType(struct soap *soap, struct saml2__AuthzDecisionStatementType *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_saml2__AuthzDecisionStatementType))
		soap_serialize_saml2__AuthzDecisionStatementType(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTosaml2__AuthzDecisionStatementType(struct soap *soap, const char *tag, int id, struct saml2__AuthzDecisionStatementType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_saml2__AuthzDecisionStatementType, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_saml2__AuthzDecisionStatementType(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct saml2__AuthzDecisionStatementType ** SOAP_FMAC4 soap_in_PointerTosaml2__AuthzDecisionStatementType(struct soap *soap, const char *tag, struct saml2__AuthzDecisionStatementType **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct saml2__AuthzDecisionStatementType **)soap_malloc(soap, sizeof(struct saml2__AuthzDecisionStatementType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_saml2__AuthzDecisionStatementType(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct saml2__AuthzDecisionStatementType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_saml2__AuthzDecisionStatementType, sizeof(struct saml2__AuthzDecisionStatementType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTosaml2__AuthzDecisionStatementType(struct soap *soap, struct saml2__AuthzDecisionStatementType *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTosaml2__AuthzDecisionStatementType(soap, tag ? tag : "saml2:AuthzDecisionStatementType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct saml2__AuthzDecisionStatementType ** SOAP_FMAC4 soap_get_PointerTosaml2__AuthzDecisionStatementType(struct soap *soap, struct saml2__AuthzDecisionStatementType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTosaml2__AuthzDecisionStatementType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTosaml2__AuthnStatementType(struct soap *soap, struct saml2__AuthnStatementType *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_saml2__AuthnStatementType))
		soap_serialize_saml2__AuthnStatementType(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTosaml2__AuthnStatementType(struct soap *soap, const char *tag, int id, struct saml2__AuthnStatementType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_saml2__AuthnStatementType, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_saml2__AuthnStatementType(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct saml2__AuthnStatementType ** SOAP_FMAC4 soap_in_PointerTosaml2__AuthnStatementType(struct soap *soap, const char *tag, struct saml2__AuthnStatementType **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct saml2__AuthnStatementType **)soap_malloc(soap, sizeof(struct saml2__AuthnStatementType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_saml2__AuthnStatementType(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct saml2__AuthnStatementType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_saml2__AuthnStatementType, sizeof(struct saml2__AuthnStatementType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTosaml2__AuthnStatementType(struct soap *soap, struct saml2__AuthnStatementType *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTosaml2__AuthnStatementType(soap, tag ? tag : "saml2:AuthnStatementType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct saml2__AuthnStatementType ** SOAP_FMAC4 soap_get_PointerTosaml2__AuthnStatementType(struct soap *soap, struct saml2__AuthnStatementType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTosaml2__AuthnStatementType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTosaml2__StatementAbstractType(struct soap *soap, struct saml2__StatementAbstractType *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_saml2__StatementAbstractType))
		soap_serialize_saml2__StatementAbstractType(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTosaml2__StatementAbstractType(struct soap *soap, const char *tag, int id, struct saml2__StatementAbstractType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_saml2__StatementAbstractType, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_saml2__StatementAbstractType(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct saml2__StatementAbstractType ** SOAP_FMAC4 soap_in_PointerTosaml2__StatementAbstractType(struct soap *soap, const char *tag, struct saml2__StatementAbstractType **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct saml2__StatementAbstractType **)soap_malloc(soap, sizeof(struct saml2__StatementAbstractType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_saml2__StatementAbstractType(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct saml2__StatementAbstractType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_saml2__StatementAbstractType, sizeof(struct saml2__StatementAbstractType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTosaml2__StatementAbstractType(struct soap *soap, struct saml2__StatementAbstractType *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTosaml2__StatementAbstractType(soap, tag ? tag : "saml2:StatementAbstractType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct saml2__StatementAbstractType ** SOAP_FMAC4 soap_get_PointerTosaml2__StatementAbstractType(struct soap *soap, struct saml2__StatementAbstractType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTosaml2__StatementAbstractType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTosaml2__AdviceType(struct soap *soap, struct saml2__AdviceType *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_saml2__AdviceType))
		soap_serialize_saml2__AdviceType(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTosaml2__AdviceType(struct soap *soap, const char *tag, int id, struct saml2__AdviceType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_saml2__AdviceType, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_saml2__AdviceType(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct saml2__AdviceType ** SOAP_FMAC4 soap_in_PointerTosaml2__AdviceType(struct soap *soap, const char *tag, struct saml2__AdviceType **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct saml2__AdviceType **)soap_malloc(soap, sizeof(struct saml2__AdviceType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_saml2__AdviceType(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct saml2__AdviceType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_saml2__AdviceType, sizeof(struct saml2__AdviceType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTosaml2__AdviceType(struct soap *soap, struct saml2__AdviceType *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTosaml2__AdviceType(soap, tag ? tag : "saml2:AdviceType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct saml2__AdviceType ** SOAP_FMAC4 soap_get_PointerTosaml2__AdviceType(struct soap *soap, struct saml2__AdviceType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTosaml2__AdviceType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTosaml2__ConditionsType(struct soap *soap, struct saml2__ConditionsType *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_saml2__ConditionsType))
		soap_serialize_saml2__ConditionsType(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTosaml2__ConditionsType(struct soap *soap, const char *tag, int id, struct saml2__ConditionsType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_saml2__ConditionsType, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_saml2__ConditionsType(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct saml2__ConditionsType ** SOAP_FMAC4 soap_in_PointerTosaml2__ConditionsType(struct soap *soap, const char *tag, struct saml2__ConditionsType **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct saml2__ConditionsType **)soap_malloc(soap, sizeof(struct saml2__ConditionsType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_saml2__ConditionsType(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct saml2__ConditionsType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_saml2__ConditionsType, sizeof(struct saml2__ConditionsType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTosaml2__ConditionsType(struct soap *soap, struct saml2__ConditionsType *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTosaml2__ConditionsType(soap, tag ? tag : "saml2:ConditionsType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct saml2__ConditionsType ** SOAP_FMAC4 soap_get_PointerTosaml2__ConditionsType(struct soap *soap, struct saml2__ConditionsType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTosaml2__ConditionsType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTosaml2__SubjectType(struct soap *soap, struct saml2__SubjectType *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_saml2__SubjectType))
		soap_serialize_saml2__SubjectType(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTosaml2__SubjectType(struct soap *soap, const char *tag, int id, struct saml2__SubjectType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_saml2__SubjectType, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_saml2__SubjectType(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct saml2__SubjectType ** SOAP_FMAC4 soap_in_PointerTosaml2__SubjectType(struct soap *soap, const char *tag, struct saml2__SubjectType **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct saml2__SubjectType **)soap_malloc(soap, sizeof(struct saml2__SubjectType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_saml2__SubjectType(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct saml2__SubjectType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_saml2__SubjectType, sizeof(struct saml2__SubjectType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTosaml2__SubjectType(struct soap *soap, struct saml2__SubjectType *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTosaml2__SubjectType(soap, tag ? tag : "saml2:SubjectType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct saml2__SubjectType ** SOAP_FMAC4 soap_get_PointerTosaml2__SubjectType(struct soap *soap, struct saml2__SubjectType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTosaml2__SubjectType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTosaml2__NameIDType(struct soap *soap, struct saml2__NameIDType *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_saml2__NameIDType))
		soap_serialize_saml2__NameIDType(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTosaml2__NameIDType(struct soap *soap, const char *tag, int id, struct saml2__NameIDType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_saml2__NameIDType, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_saml2__NameIDType(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct saml2__NameIDType ** SOAP_FMAC4 soap_in_PointerTosaml2__NameIDType(struct soap *soap, const char *tag, struct saml2__NameIDType **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct saml2__NameIDType **)soap_malloc(soap, sizeof(struct saml2__NameIDType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_saml2__NameIDType(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct saml2__NameIDType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_saml2__NameIDType, sizeof(struct saml2__NameIDType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTosaml2__NameIDType(struct soap *soap, struct saml2__NameIDType *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTosaml2__NameIDType(soap, tag ? tag : "saml2:NameIDType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct saml2__NameIDType ** SOAP_FMAC4 soap_get_PointerTosaml2__NameIDType(struct soap *soap, struct saml2__NameIDType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTosaml2__NameIDType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToPointerToxenc__EncryptedKeyType(struct soap *soap, struct xenc__EncryptedKeyType **const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_PointerToxenc__EncryptedKeyType))
		soap_serialize_PointerToxenc__EncryptedKeyType(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToPointerToxenc__EncryptedKeyType(struct soap *soap, const char *tag, int id, struct xenc__EncryptedKeyType **const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_PointerToxenc__EncryptedKeyType, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_PointerToxenc__EncryptedKeyType(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct xenc__EncryptedKeyType *** SOAP_FMAC4 soap_in_PointerToPointerToxenc__EncryptedKeyType(struct soap *soap, const char *tag, struct xenc__EncryptedKeyType ***a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct xenc__EncryptedKeyType ***)soap_malloc(soap, sizeof(struct xenc__EncryptedKeyType **))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_PointerToxenc__EncryptedKeyType(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct xenc__EncryptedKeyType ***)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_xenc__EncryptedKeyType, sizeof(struct xenc__EncryptedKeyType), 1, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToPointerToxenc__EncryptedKeyType(struct soap *soap, struct xenc__EncryptedKeyType **const*a, const char *tag, const char *type)
{
	if (soap_out_PointerToPointerToxenc__EncryptedKeyType(soap, tag ? tag : "xenc:EncryptedKeyType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct xenc__EncryptedKeyType *** SOAP_FMAC4 soap_get_PointerToPointerToxenc__EncryptedKeyType(struct soap *soap, struct xenc__EncryptedKeyType ***p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToPointerToxenc__EncryptedKeyType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__saml1__ConfirmationMethod(struct soap *soap, char *const*a, const char *tag, const char *type)
{
	if (soap_out__saml1__ConfirmationMethod(soap, tag ? tag : "saml1:ConfirmationMethod", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__saml1__Audience(struct soap *soap, char *const*a, const char *tag, const char *type)
{
	if (soap_out__saml1__Audience(soap, tag ? tag : "saml1:Audience", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__saml1__AssertionIDReference(struct soap *soap, char *const*a, const char *tag, const char *type)
{
	if (soap_out__saml1__AssertionIDReference(soap, tag ? tag : "saml1:AssertionIDReference", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTosaml1__AttributeType(struct soap *soap, struct saml1__AttributeType *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_saml1__AttributeType))
		soap_serialize_saml1__AttributeType(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTosaml1__AttributeType(struct soap *soap, const char *tag, int id, struct saml1__AttributeType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_saml1__AttributeType, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_saml1__AttributeType(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct saml1__AttributeType ** SOAP_FMAC4 soap_in_PointerTosaml1__AttributeType(struct soap *soap, const char *tag, struct saml1__AttributeType **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct saml1__AttributeType **)soap_malloc(soap, sizeof(struct saml1__AttributeType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_saml1__AttributeType(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct saml1__AttributeType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_saml1__AttributeType, sizeof(struct saml1__AttributeType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTosaml1__AttributeType(struct soap *soap, struct saml1__AttributeType *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTosaml1__AttributeType(soap, tag ? tag : "saml1:AttributeType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct saml1__AttributeType ** SOAP_FMAC4 soap_get_PointerTosaml1__AttributeType(struct soap *soap, struct saml1__AttributeType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTosaml1__AttributeType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTosaml1__EvidenceType(struct soap *soap, struct saml1__EvidenceType *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_saml1__EvidenceType))
		soap_serialize_saml1__EvidenceType(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTosaml1__EvidenceType(struct soap *soap, const char *tag, int id, struct saml1__EvidenceType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_saml1__EvidenceType, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_saml1__EvidenceType(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct saml1__EvidenceType ** SOAP_FMAC4 soap_in_PointerTosaml1__EvidenceType(struct soap *soap, const char *tag, struct saml1__EvidenceType **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct saml1__EvidenceType **)soap_malloc(soap, sizeof(struct saml1__EvidenceType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_saml1__EvidenceType(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct saml1__EvidenceType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_saml1__EvidenceType, sizeof(struct saml1__EvidenceType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTosaml1__EvidenceType(struct soap *soap, struct saml1__EvidenceType *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTosaml1__EvidenceType(soap, tag ? tag : "saml1:EvidenceType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct saml1__EvidenceType ** SOAP_FMAC4 soap_get_PointerTosaml1__EvidenceType(struct soap *soap, struct saml1__EvidenceType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTosaml1__EvidenceType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTosaml1__ActionType(struct soap *soap, struct saml1__ActionType *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_saml1__ActionType))
		soap_serialize_saml1__ActionType(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTosaml1__ActionType(struct soap *soap, const char *tag, int id, struct saml1__ActionType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_saml1__ActionType, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_saml1__ActionType(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct saml1__ActionType ** SOAP_FMAC4 soap_in_PointerTosaml1__ActionType(struct soap *soap, const char *tag, struct saml1__ActionType **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct saml1__ActionType **)soap_malloc(soap, sizeof(struct saml1__ActionType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_saml1__ActionType(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct saml1__ActionType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_saml1__ActionType, sizeof(struct saml1__ActionType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTosaml1__ActionType(struct soap *soap, struct saml1__ActionType *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTosaml1__ActionType(soap, tag ? tag : "saml1:ActionType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct saml1__ActionType ** SOAP_FMAC4 soap_get_PointerTosaml1__ActionType(struct soap *soap, struct saml1__ActionType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTosaml1__ActionType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTosaml1__AuthorityBindingType(struct soap *soap, struct saml1__AuthorityBindingType *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_saml1__AuthorityBindingType))
		soap_serialize_saml1__AuthorityBindingType(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTosaml1__AuthorityBindingType(struct soap *soap, const char *tag, int id, struct saml1__AuthorityBindingType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_saml1__AuthorityBindingType, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_saml1__AuthorityBindingType(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct saml1__AuthorityBindingType ** SOAP_FMAC4 soap_in_PointerTosaml1__AuthorityBindingType(struct soap *soap, const char *tag, struct saml1__AuthorityBindingType **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct saml1__AuthorityBindingType **)soap_malloc(soap, sizeof(struct saml1__AuthorityBindingType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_saml1__AuthorityBindingType(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct saml1__AuthorityBindingType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_saml1__AuthorityBindingType, sizeof(struct saml1__AuthorityBindingType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTosaml1__AuthorityBindingType(struct soap *soap, struct saml1__AuthorityBindingType *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTosaml1__AuthorityBindingType(soap, tag ? tag : "saml1:AuthorityBindingType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct saml1__AuthorityBindingType ** SOAP_FMAC4 soap_get_PointerTosaml1__AuthorityBindingType(struct soap *soap, struct saml1__AuthorityBindingType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTosaml1__AuthorityBindingType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTosaml1__SubjectLocalityType(struct soap *soap, struct saml1__SubjectLocalityType *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_saml1__SubjectLocalityType))
		soap_serialize_saml1__SubjectLocalityType(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTosaml1__SubjectLocalityType(struct soap *soap, const char *tag, int id, struct saml1__SubjectLocalityType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_saml1__SubjectLocalityType, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_saml1__SubjectLocalityType(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct saml1__SubjectLocalityType ** SOAP_FMAC4 soap_in_PointerTosaml1__SubjectLocalityType(struct soap *soap, const char *tag, struct saml1__SubjectLocalityType **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct saml1__SubjectLocalityType **)soap_malloc(soap, sizeof(struct saml1__SubjectLocalityType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_saml1__SubjectLocalityType(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct saml1__SubjectLocalityType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_saml1__SubjectLocalityType, sizeof(struct saml1__SubjectLocalityType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTosaml1__SubjectLocalityType(struct soap *soap, struct saml1__SubjectLocalityType *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTosaml1__SubjectLocalityType(soap, tag ? tag : "saml1:SubjectLocalityType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct saml1__SubjectLocalityType ** SOAP_FMAC4 soap_get_PointerTosaml1__SubjectLocalityType(struct soap *soap, struct saml1__SubjectLocalityType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTosaml1__SubjectLocalityType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTosaml1__SubjectType(struct soap *soap, struct saml1__SubjectType *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_saml1__SubjectType))
		soap_serialize_saml1__SubjectType(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTosaml1__SubjectType(struct soap *soap, const char *tag, int id, struct saml1__SubjectType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_saml1__SubjectType, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_saml1__SubjectType(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct saml1__SubjectType ** SOAP_FMAC4 soap_in_PointerTosaml1__SubjectType(struct soap *soap, const char *tag, struct saml1__SubjectType **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct saml1__SubjectType **)soap_malloc(soap, sizeof(struct saml1__SubjectType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_saml1__SubjectType(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct saml1__SubjectType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_saml1__SubjectType, sizeof(struct saml1__SubjectType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTosaml1__SubjectType(struct soap *soap, struct saml1__SubjectType *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTosaml1__SubjectType(soap, tag ? tag : "saml1:SubjectType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct saml1__SubjectType ** SOAP_FMAC4 soap_get_PointerTosaml1__SubjectType(struct soap *soap, struct saml1__SubjectType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTosaml1__SubjectType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo__saml1__union_EvidenceType(struct soap *soap, struct __saml1__union_EvidenceType *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE___saml1__union_EvidenceType))
		soap_serialize___saml1__union_EvidenceType(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo__saml1__union_EvidenceType(struct soap *soap, const char *tag, int id, struct __saml1__union_EvidenceType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE___saml1__union_EvidenceType, NULL);
	if (id < 0)
		return soap->error;
	return soap_out___saml1__union_EvidenceType(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct __saml1__union_EvidenceType ** SOAP_FMAC4 soap_in_PointerTo__saml1__union_EvidenceType(struct soap *soap, const char *tag, struct __saml1__union_EvidenceType **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct __saml1__union_EvidenceType **)soap_malloc(soap, sizeof(struct __saml1__union_EvidenceType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in___saml1__union_EvidenceType(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct __saml1__union_EvidenceType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE___saml1__union_EvidenceType, sizeof(struct __saml1__union_EvidenceType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo__saml1__union_EvidenceType(struct soap *soap, struct __saml1__union_EvidenceType *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo__saml1__union_EvidenceType(soap, tag ? tag : "-saml1:union-EvidenceType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct __saml1__union_EvidenceType ** SOAP_FMAC4 soap_get_PointerTo__saml1__union_EvidenceType(struct soap *soap, struct __saml1__union_EvidenceType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo__saml1__union_EvidenceType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTostring(struct soap *soap, char **const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_string))
		soap_serialize_string(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTostring(struct soap *soap, const char *tag, int id, char **const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_string, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_string(soap, tag, id, *a, type);
}

SOAP_FMAC3 char *** SOAP_FMAC4 soap_in_PointerTostring(struct soap *soap, const char *tag, char ***a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (char ***)soap_malloc(soap, sizeof(char **))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_string(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (char ***)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_string, sizeof(char *), 1, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTostring(struct soap *soap, char **const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTostring(soap, tag ? tag : "string", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 char *** SOAP_FMAC4 soap_get_PointerTostring(struct soap *soap, char ***p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTostring(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTosaml1__SubjectConfirmationType(struct soap *soap, struct saml1__SubjectConfirmationType *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_saml1__SubjectConfirmationType))
		soap_serialize_saml1__SubjectConfirmationType(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTosaml1__SubjectConfirmationType(struct soap *soap, const char *tag, int id, struct saml1__SubjectConfirmationType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_saml1__SubjectConfirmationType, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_saml1__SubjectConfirmationType(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct saml1__SubjectConfirmationType ** SOAP_FMAC4 soap_in_PointerTosaml1__SubjectConfirmationType(struct soap *soap, const char *tag, struct saml1__SubjectConfirmationType **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct saml1__SubjectConfirmationType **)soap_malloc(soap, sizeof(struct saml1__SubjectConfirmationType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_saml1__SubjectConfirmationType(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct saml1__SubjectConfirmationType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_saml1__SubjectConfirmationType, sizeof(struct saml1__SubjectConfirmationType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTosaml1__SubjectConfirmationType(struct soap *soap, struct saml1__SubjectConfirmationType *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTosaml1__SubjectConfirmationType(soap, tag ? tag : "saml1:SubjectConfirmationType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct saml1__SubjectConfirmationType ** SOAP_FMAC4 soap_get_PointerTosaml1__SubjectConfirmationType(struct soap *soap, struct saml1__SubjectConfirmationType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTosaml1__SubjectConfirmationType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTosaml1__NameIdentifierType(struct soap *soap, struct saml1__NameIdentifierType *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_saml1__NameIdentifierType))
		soap_serialize_saml1__NameIdentifierType(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTosaml1__NameIdentifierType(struct soap *soap, const char *tag, int id, struct saml1__NameIdentifierType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_saml1__NameIdentifierType, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_saml1__NameIdentifierType(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct saml1__NameIdentifierType ** SOAP_FMAC4 soap_in_PointerTosaml1__NameIdentifierType(struct soap *soap, const char *tag, struct saml1__NameIdentifierType **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct saml1__NameIdentifierType **)soap_malloc(soap, sizeof(struct saml1__NameIdentifierType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_saml1__NameIdentifierType(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct saml1__NameIdentifierType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_saml1__NameIdentifierType, sizeof(struct saml1__NameIdentifierType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTosaml1__NameIdentifierType(struct soap *soap, struct saml1__NameIdentifierType *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTosaml1__NameIdentifierType(soap, tag ? tag : "saml1:NameIdentifierType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct saml1__NameIdentifierType ** SOAP_FMAC4 soap_get_PointerTosaml1__NameIdentifierType(struct soap *soap, struct saml1__NameIdentifierType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTosaml1__NameIdentifierType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo__saml1__union_AdviceType(struct soap *soap, struct __saml1__union_AdviceType *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE___saml1__union_AdviceType))
		soap_serialize___saml1__union_AdviceType(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo__saml1__union_AdviceType(struct soap *soap, const char *tag, int id, struct __saml1__union_AdviceType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE___saml1__union_AdviceType, NULL);
	if (id < 0)
		return soap->error;
	return soap_out___saml1__union_AdviceType(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct __saml1__union_AdviceType ** SOAP_FMAC4 soap_in_PointerTo__saml1__union_AdviceType(struct soap *soap, const char *tag, struct __saml1__union_AdviceType **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct __saml1__union_AdviceType **)soap_malloc(soap, sizeof(struct __saml1__union_AdviceType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in___saml1__union_AdviceType(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct __saml1__union_AdviceType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE___saml1__union_AdviceType, sizeof(struct __saml1__union_AdviceType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo__saml1__union_AdviceType(struct soap *soap, struct __saml1__union_AdviceType *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo__saml1__union_AdviceType(soap, tag ? tag : "-saml1:union-AdviceType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct __saml1__union_AdviceType ** SOAP_FMAC4 soap_get_PointerTo__saml1__union_AdviceType(struct soap *soap, struct __saml1__union_AdviceType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo__saml1__union_AdviceType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTosaml1__AssertionType(struct soap *soap, struct saml1__AssertionType *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_saml1__AssertionType))
		soap_serialize_saml1__AssertionType(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTosaml1__AssertionType(struct soap *soap, const char *tag, int id, struct saml1__AssertionType *const*a, const char *type)
{
	char *mark;
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_saml1__AssertionType, &mark);
	if (id < 0)
		return soap->error;
	(void)soap_out_saml1__AssertionType(soap, tag, id, *a, type);
	soap_unmark(soap, mark);
	return soap->error;
}

SOAP_FMAC3 struct saml1__AssertionType ** SOAP_FMAC4 soap_in_PointerTosaml1__AssertionType(struct soap *soap, const char *tag, struct saml1__AssertionType **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct saml1__AssertionType **)soap_malloc(soap, sizeof(struct saml1__AssertionType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_saml1__AssertionType(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct saml1__AssertionType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_saml1__AssertionType, sizeof(struct saml1__AssertionType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTosaml1__AssertionType(struct soap *soap, struct saml1__AssertionType *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTosaml1__AssertionType(soap, tag ? tag : "saml1:AssertionType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct saml1__AssertionType ** SOAP_FMAC4 soap_get_PointerTosaml1__AssertionType(struct soap *soap, struct saml1__AssertionType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTosaml1__AssertionType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToxsd__dateTime(struct soap *soap, struct timeval *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_xsd__dateTime))
		soap_serialize_xsd__dateTime(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToxsd__dateTime(struct soap *soap, const char *tag, int id, struct timeval *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_xsd__dateTime, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_xsd__dateTime(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct timeval ** SOAP_FMAC4 soap_in_PointerToxsd__dateTime(struct soap *soap, const char *tag, struct timeval **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct timeval **)soap_malloc(soap, sizeof(struct timeval *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_xsd__dateTime(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct timeval **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_xsd__dateTime, sizeof(struct timeval), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToxsd__dateTime(struct soap *soap, struct timeval *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerToxsd__dateTime(soap, tag ? tag : "xsd:dateTime", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct timeval ** SOAP_FMAC4 soap_get_PointerToxsd__dateTime(struct soap *soap, struct timeval **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToxsd__dateTime(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo__saml1__union_ConditionsType(struct soap *soap, struct __saml1__union_ConditionsType *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE___saml1__union_ConditionsType))
		soap_serialize___saml1__union_ConditionsType(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo__saml1__union_ConditionsType(struct soap *soap, const char *tag, int id, struct __saml1__union_ConditionsType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE___saml1__union_ConditionsType, NULL);
	if (id < 0)
		return soap->error;
	return soap_out___saml1__union_ConditionsType(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct __saml1__union_ConditionsType ** SOAP_FMAC4 soap_in_PointerTo__saml1__union_ConditionsType(struct soap *soap, const char *tag, struct __saml1__union_ConditionsType **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct __saml1__union_ConditionsType **)soap_malloc(soap, sizeof(struct __saml1__union_ConditionsType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in___saml1__union_ConditionsType(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct __saml1__union_ConditionsType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE___saml1__union_ConditionsType, sizeof(struct __saml1__union_ConditionsType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo__saml1__union_ConditionsType(struct soap *soap, struct __saml1__union_ConditionsType *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo__saml1__union_ConditionsType(soap, tag ? tag : "-saml1:union-ConditionsType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct __saml1__union_ConditionsType ** SOAP_FMAC4 soap_get_PointerTo__saml1__union_ConditionsType(struct soap *soap, struct __saml1__union_ConditionsType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo__saml1__union_ConditionsType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTosaml1__ConditionAbstractType(struct soap *soap, struct saml1__ConditionAbstractType *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_saml1__ConditionAbstractType))
		soap_serialize_saml1__ConditionAbstractType(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTosaml1__ConditionAbstractType(struct soap *soap, const char *tag, int id, struct saml1__ConditionAbstractType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_saml1__ConditionAbstractType, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_saml1__ConditionAbstractType(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct saml1__ConditionAbstractType ** SOAP_FMAC4 soap_in_PointerTosaml1__ConditionAbstractType(struct soap *soap, const char *tag, struct saml1__ConditionAbstractType **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct saml1__ConditionAbstractType **)soap_malloc(soap, sizeof(struct saml1__ConditionAbstractType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_saml1__ConditionAbstractType(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct saml1__ConditionAbstractType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_saml1__ConditionAbstractType, sizeof(struct saml1__ConditionAbstractType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTosaml1__ConditionAbstractType(struct soap *soap, struct saml1__ConditionAbstractType *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTosaml1__ConditionAbstractType(soap, tag ? tag : "saml1:ConditionAbstractType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct saml1__ConditionAbstractType ** SOAP_FMAC4 soap_get_PointerTosaml1__ConditionAbstractType(struct soap *soap, struct saml1__ConditionAbstractType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTosaml1__ConditionAbstractType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTosaml1__DoNotCacheConditionType(struct soap *soap, struct saml1__DoNotCacheConditionType *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_saml1__DoNotCacheConditionType))
		soap_serialize_saml1__DoNotCacheConditionType(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTosaml1__DoNotCacheConditionType(struct soap *soap, const char *tag, int id, struct saml1__DoNotCacheConditionType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_saml1__DoNotCacheConditionType, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_saml1__DoNotCacheConditionType(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct saml1__DoNotCacheConditionType ** SOAP_FMAC4 soap_in_PointerTosaml1__DoNotCacheConditionType(struct soap *soap, const char *tag, struct saml1__DoNotCacheConditionType **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct saml1__DoNotCacheConditionType **)soap_malloc(soap, sizeof(struct saml1__DoNotCacheConditionType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_saml1__DoNotCacheConditionType(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct saml1__DoNotCacheConditionType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_saml1__DoNotCacheConditionType, sizeof(struct saml1__DoNotCacheConditionType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTosaml1__DoNotCacheConditionType(struct soap *soap, struct saml1__DoNotCacheConditionType *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTosaml1__DoNotCacheConditionType(soap, tag ? tag : "saml1:DoNotCacheConditionType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct saml1__DoNotCacheConditionType ** SOAP_FMAC4 soap_get_PointerTosaml1__DoNotCacheConditionType(struct soap *soap, struct saml1__DoNotCacheConditionType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTosaml1__DoNotCacheConditionType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTosaml1__AudienceRestrictionConditionType(struct soap *soap, struct saml1__AudienceRestrictionConditionType *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_saml1__AudienceRestrictionConditionType))
		soap_serialize_saml1__AudienceRestrictionConditionType(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTosaml1__AudienceRestrictionConditionType(struct soap *soap, const char *tag, int id, struct saml1__AudienceRestrictionConditionType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_saml1__AudienceRestrictionConditionType, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_saml1__AudienceRestrictionConditionType(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct saml1__AudienceRestrictionConditionType ** SOAP_FMAC4 soap_in_PointerTosaml1__AudienceRestrictionConditionType(struct soap *soap, const char *tag, struct saml1__AudienceRestrictionConditionType **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct saml1__AudienceRestrictionConditionType **)soap_malloc(soap, sizeof(struct saml1__AudienceRestrictionConditionType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_saml1__AudienceRestrictionConditionType(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct saml1__AudienceRestrictionConditionType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_saml1__AudienceRestrictionConditionType, sizeof(struct saml1__AudienceRestrictionConditionType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTosaml1__AudienceRestrictionConditionType(struct soap *soap, struct saml1__AudienceRestrictionConditionType *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTosaml1__AudienceRestrictionConditionType(soap, tag ? tag : "saml1:AudienceRestrictionConditionType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct saml1__AudienceRestrictionConditionType ** SOAP_FMAC4 soap_get_PointerTosaml1__AudienceRestrictionConditionType(struct soap *soap, struct saml1__AudienceRestrictionConditionType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTosaml1__AudienceRestrictionConditionType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ds__Signature(struct soap *soap, struct ds__SignatureType *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ds__Signature))
		soap_serialize__ds__Signature(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ds__Signature(struct soap *soap, const char *tag, int id, struct ds__SignatureType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ds__Signature, NULL);
	if (id < 0)
		return soap->error;
	return soap_out__ds__Signature(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ds__SignatureType ** SOAP_FMAC4 soap_in_PointerTo_ds__Signature(struct soap *soap, const char *tag, struct ds__SignatureType **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ds__SignatureType **)soap_malloc(soap, sizeof(struct ds__SignatureType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__ds__Signature(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ds__SignatureType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ds__Signature, sizeof(struct ds__SignatureType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ds__Signature(struct soap *soap, struct ds__SignatureType *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_ds__Signature(soap, tag ? tag : "ds:Signature", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ds__SignatureType ** SOAP_FMAC4 soap_get_PointerTo_ds__Signature(struct soap *soap, struct ds__SignatureType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ds__Signature(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo__saml1__union_AssertionType(struct soap *soap, struct __saml1__union_AssertionType *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE___saml1__union_AssertionType))
		soap_serialize___saml1__union_AssertionType(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo__saml1__union_AssertionType(struct soap *soap, const char *tag, int id, struct __saml1__union_AssertionType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE___saml1__union_AssertionType, NULL);
	if (id < 0)
		return soap->error;
	return soap_out___saml1__union_AssertionType(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct __saml1__union_AssertionType ** SOAP_FMAC4 soap_in_PointerTo__saml1__union_AssertionType(struct soap *soap, const char *tag, struct __saml1__union_AssertionType **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct __saml1__union_AssertionType **)soap_malloc(soap, sizeof(struct __saml1__union_AssertionType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in___saml1__union_AssertionType(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct __saml1__union_AssertionType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE___saml1__union_AssertionType, sizeof(struct __saml1__union_AssertionType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo__saml1__union_AssertionType(struct soap *soap, struct __saml1__union_AssertionType *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo__saml1__union_AssertionType(soap, tag ? tag : "-saml1:union-AssertionType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct __saml1__union_AssertionType ** SOAP_FMAC4 soap_get_PointerTo__saml1__union_AssertionType(struct soap *soap, struct __saml1__union_AssertionType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo__saml1__union_AssertionType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTosaml1__AttributeStatementType(struct soap *soap, struct saml1__AttributeStatementType *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_saml1__AttributeStatementType))
		soap_serialize_saml1__AttributeStatementType(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTosaml1__AttributeStatementType(struct soap *soap, const char *tag, int id, struct saml1__AttributeStatementType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_saml1__AttributeStatementType, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_saml1__AttributeStatementType(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct saml1__AttributeStatementType ** SOAP_FMAC4 soap_in_PointerTosaml1__AttributeStatementType(struct soap *soap, const char *tag, struct saml1__AttributeStatementType **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct saml1__AttributeStatementType **)soap_malloc(soap, sizeof(struct saml1__AttributeStatementType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_saml1__AttributeStatementType(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct saml1__AttributeStatementType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_saml1__AttributeStatementType, sizeof(struct saml1__AttributeStatementType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTosaml1__AttributeStatementType(struct soap *soap, struct saml1__AttributeStatementType *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTosaml1__AttributeStatementType(soap, tag ? tag : "saml1:AttributeStatementType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct saml1__AttributeStatementType ** SOAP_FMAC4 soap_get_PointerTosaml1__AttributeStatementType(struct soap *soap, struct saml1__AttributeStatementType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTosaml1__AttributeStatementType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTosaml1__AuthorizationDecisionStatementType(struct soap *soap, struct saml1__AuthorizationDecisionStatementType *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_saml1__AuthorizationDecisionStatementType))
		soap_serialize_saml1__AuthorizationDecisionStatementType(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTosaml1__AuthorizationDecisionStatementType(struct soap *soap, const char *tag, int id, struct saml1__AuthorizationDecisionStatementType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_saml1__AuthorizationDecisionStatementType, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_saml1__AuthorizationDecisionStatementType(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct saml1__AuthorizationDecisionStatementType ** SOAP_FMAC4 soap_in_PointerTosaml1__AuthorizationDecisionStatementType(struct soap *soap, const char *tag, struct saml1__AuthorizationDecisionStatementType **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct saml1__AuthorizationDecisionStatementType **)soap_malloc(soap, sizeof(struct saml1__AuthorizationDecisionStatementType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_saml1__AuthorizationDecisionStatementType(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct saml1__AuthorizationDecisionStatementType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_saml1__AuthorizationDecisionStatementType, sizeof(struct saml1__AuthorizationDecisionStatementType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTosaml1__AuthorizationDecisionStatementType(struct soap *soap, struct saml1__AuthorizationDecisionStatementType *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTosaml1__AuthorizationDecisionStatementType(soap, tag ? tag : "saml1:AuthorizationDecisionStatementType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct saml1__AuthorizationDecisionStatementType ** SOAP_FMAC4 soap_get_PointerTosaml1__AuthorizationDecisionStatementType(struct soap *soap, struct saml1__AuthorizationDecisionStatementType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTosaml1__AuthorizationDecisionStatementType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTosaml1__AuthenticationStatementType(struct soap *soap, struct saml1__AuthenticationStatementType *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_saml1__AuthenticationStatementType))
		soap_serialize_saml1__AuthenticationStatementType(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTosaml1__AuthenticationStatementType(struct soap *soap, const char *tag, int id, struct saml1__AuthenticationStatementType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_saml1__AuthenticationStatementType, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_saml1__AuthenticationStatementType(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct saml1__AuthenticationStatementType ** SOAP_FMAC4 soap_in_PointerTosaml1__AuthenticationStatementType(struct soap *soap, const char *tag, struct saml1__AuthenticationStatementType **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct saml1__AuthenticationStatementType **)soap_malloc(soap, sizeof(struct saml1__AuthenticationStatementType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_saml1__AuthenticationStatementType(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct saml1__AuthenticationStatementType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_saml1__AuthenticationStatementType, sizeof(struct saml1__AuthenticationStatementType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTosaml1__AuthenticationStatementType(struct soap *soap, struct saml1__AuthenticationStatementType *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTosaml1__AuthenticationStatementType(soap, tag ? tag : "saml1:AuthenticationStatementType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct saml1__AuthenticationStatementType ** SOAP_FMAC4 soap_get_PointerTosaml1__AuthenticationStatementType(struct soap *soap, struct saml1__AuthenticationStatementType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTosaml1__AuthenticationStatementType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTosaml1__SubjectStatementAbstractType(struct soap *soap, struct saml1__SubjectStatementAbstractType *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_saml1__SubjectStatementAbstractType))
		soap_serialize_saml1__SubjectStatementAbstractType(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTosaml1__SubjectStatementAbstractType(struct soap *soap, const char *tag, int id, struct saml1__SubjectStatementAbstractType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_saml1__SubjectStatementAbstractType, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_saml1__SubjectStatementAbstractType(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct saml1__SubjectStatementAbstractType ** SOAP_FMAC4 soap_in_PointerTosaml1__SubjectStatementAbstractType(struct soap *soap, const char *tag, struct saml1__SubjectStatementAbstractType **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct saml1__SubjectStatementAbstractType **)soap_malloc(soap, sizeof(struct saml1__SubjectStatementAbstractType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_saml1__SubjectStatementAbstractType(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct saml1__SubjectStatementAbstractType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_saml1__SubjectStatementAbstractType, sizeof(struct saml1__SubjectStatementAbstractType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTosaml1__SubjectStatementAbstractType(struct soap *soap, struct saml1__SubjectStatementAbstractType *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTosaml1__SubjectStatementAbstractType(soap, tag ? tag : "saml1:SubjectStatementAbstractType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct saml1__SubjectStatementAbstractType ** SOAP_FMAC4 soap_get_PointerTosaml1__SubjectStatementAbstractType(struct soap *soap, struct saml1__SubjectStatementAbstractType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTosaml1__SubjectStatementAbstractType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTosaml1__StatementAbstractType(struct soap *soap, struct saml1__StatementAbstractType *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_saml1__StatementAbstractType))
		soap_serialize_saml1__StatementAbstractType(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTosaml1__StatementAbstractType(struct soap *soap, const char *tag, int id, struct saml1__StatementAbstractType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_saml1__StatementAbstractType, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_saml1__StatementAbstractType(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct saml1__StatementAbstractType ** SOAP_FMAC4 soap_in_PointerTosaml1__StatementAbstractType(struct soap *soap, const char *tag, struct saml1__StatementAbstractType **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct saml1__StatementAbstractType **)soap_malloc(soap, sizeof(struct saml1__StatementAbstractType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_saml1__StatementAbstractType(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct saml1__StatementAbstractType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_saml1__StatementAbstractType, sizeof(struct saml1__StatementAbstractType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTosaml1__StatementAbstractType(struct soap *soap, struct saml1__StatementAbstractType *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTosaml1__StatementAbstractType(soap, tag ? tag : "saml1:StatementAbstractType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct saml1__StatementAbstractType ** SOAP_FMAC4 soap_get_PointerTosaml1__StatementAbstractType(struct soap *soap, struct saml1__StatementAbstractType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTosaml1__StatementAbstractType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTosaml1__AdviceType(struct soap *soap, struct saml1__AdviceType *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_saml1__AdviceType))
		soap_serialize_saml1__AdviceType(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTosaml1__AdviceType(struct soap *soap, const char *tag, int id, struct saml1__AdviceType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_saml1__AdviceType, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_saml1__AdviceType(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct saml1__AdviceType ** SOAP_FMAC4 soap_in_PointerTosaml1__AdviceType(struct soap *soap, const char *tag, struct saml1__AdviceType **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct saml1__AdviceType **)soap_malloc(soap, sizeof(struct saml1__AdviceType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_saml1__AdviceType(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct saml1__AdviceType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_saml1__AdviceType, sizeof(struct saml1__AdviceType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTosaml1__AdviceType(struct soap *soap, struct saml1__AdviceType *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTosaml1__AdviceType(soap, tag ? tag : "saml1:AdviceType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct saml1__AdviceType ** SOAP_FMAC4 soap_get_PointerTosaml1__AdviceType(struct soap *soap, struct saml1__AdviceType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTosaml1__AdviceType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTosaml1__ConditionsType(struct soap *soap, struct saml1__ConditionsType *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_saml1__ConditionsType))
		soap_serialize_saml1__ConditionsType(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTosaml1__ConditionsType(struct soap *soap, const char *tag, int id, struct saml1__ConditionsType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_saml1__ConditionsType, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_saml1__ConditionsType(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct saml1__ConditionsType ** SOAP_FMAC4 soap_in_PointerTosaml1__ConditionsType(struct soap *soap, const char *tag, struct saml1__ConditionsType **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct saml1__ConditionsType **)soap_malloc(soap, sizeof(struct saml1__ConditionsType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_saml1__ConditionsType(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct saml1__ConditionsType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_saml1__ConditionsType, sizeof(struct saml1__ConditionsType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTosaml1__ConditionsType(struct soap *soap, struct saml1__ConditionsType *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTosaml1__ConditionsType(soap, tag ? tag : "saml1:ConditionsType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct saml1__ConditionsType ** SOAP_FMAC4 soap_get_PointerTosaml1__ConditionsType(struct soap *soap, struct saml1__ConditionsType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTosaml1__ConditionsType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo__wsc__DerivedKeyTokenType_sequence(struct soap *soap, struct __wsc__DerivedKeyTokenType_sequence *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE___wsc__DerivedKeyTokenType_sequence))
		soap_serialize___wsc__DerivedKeyTokenType_sequence(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo__wsc__DerivedKeyTokenType_sequence(struct soap *soap, const char *tag, int id, struct __wsc__DerivedKeyTokenType_sequence *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE___wsc__DerivedKeyTokenType_sequence, NULL);
	if (id < 0)
		return soap->error;
	return soap_out___wsc__DerivedKeyTokenType_sequence(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct __wsc__DerivedKeyTokenType_sequence ** SOAP_FMAC4 soap_in_PointerTo__wsc__DerivedKeyTokenType_sequence(struct soap *soap, const char *tag, struct __wsc__DerivedKeyTokenType_sequence **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct __wsc__DerivedKeyTokenType_sequence **)soap_malloc(soap, sizeof(struct __wsc__DerivedKeyTokenType_sequence *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in___wsc__DerivedKeyTokenType_sequence(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct __wsc__DerivedKeyTokenType_sequence **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE___wsc__DerivedKeyTokenType_sequence, sizeof(struct __wsc__DerivedKeyTokenType_sequence), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo__wsc__DerivedKeyTokenType_sequence(struct soap *soap, struct __wsc__DerivedKeyTokenType_sequence *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo__wsc__DerivedKeyTokenType_sequence(soap, tag ? tag : "-wsc:DerivedKeyTokenType-sequence", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct __wsc__DerivedKeyTokenType_sequence ** SOAP_FMAC4 soap_get_PointerTo__wsc__DerivedKeyTokenType_sequence(struct soap *soap, struct __wsc__DerivedKeyTokenType_sequence **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo__wsc__DerivedKeyTokenType_sequence(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToULONG64(struct soap *soap, ULONG64 *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	(void)soap_reference(soap, *a, SOAP_TYPE_ULONG64);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToULONG64(struct soap *soap, const char *tag, int id, ULONG64 *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ULONG64, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_ULONG64(soap, tag, id, *a, type);
}

SOAP_FMAC3 ULONG64 ** SOAP_FMAC4 soap_in_PointerToULONG64(struct soap *soap, const char *tag, ULONG64 **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ULONG64 **)soap_malloc(soap, sizeof(ULONG64 *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ULONG64(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (ULONG64 **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ULONG64, sizeof(ULONG64), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToULONG64(struct soap *soap, ULONG64 *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerToULONG64(soap, tag ? tag : "unsignedLong", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ULONG64 ** SOAP_FMAC4 soap_get_PointerToULONG64(struct soap *soap, ULONG64 **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToULONG64(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTowsc__PropertiesType(struct soap *soap, struct wsc__PropertiesType *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_wsc__PropertiesType))
		soap_serialize_wsc__PropertiesType(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTowsc__PropertiesType(struct soap *soap, const char *tag, int id, struct wsc__PropertiesType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_wsc__PropertiesType, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_wsc__PropertiesType(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct wsc__PropertiesType ** SOAP_FMAC4 soap_in_PointerTowsc__PropertiesType(struct soap *soap, const char *tag, struct wsc__PropertiesType **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct wsc__PropertiesType **)soap_malloc(soap, sizeof(struct wsc__PropertiesType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_wsc__PropertiesType(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct wsc__PropertiesType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_wsc__PropertiesType, sizeof(struct wsc__PropertiesType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTowsc__PropertiesType(struct soap *soap, struct wsc__PropertiesType *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTowsc__PropertiesType(soap, tag ? tag : "wsc:PropertiesType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct wsc__PropertiesType ** SOAP_FMAC4 soap_get_PointerTowsc__PropertiesType(struct soap *soap, struct wsc__PropertiesType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTowsc__PropertiesType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_wsc__FaultCodeOpenEnumType(struct soap *soap, char *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	(void)soap_reference(soap, *a, SOAP_TYPE_wsc__FaultCodeOpenEnumType);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_wsc__FaultCodeOpenEnumType(struct soap *soap, const char *tag, int id, char *const*a, const char *type)
{
	return soap_outstring(soap, tag, id, a, type, SOAP_TYPE_wsc__FaultCodeOpenEnumType);
}

SOAP_FMAC3 char * * SOAP_FMAC4 soap_in_wsc__FaultCodeOpenEnumType(struct soap *soap, const char *tag, char **a, const char *type)
{
	a = soap_instring(soap, tag, a, type, SOAP_TYPE_wsc__FaultCodeOpenEnumType, 1, 0, -1, NULL);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_wsc__FaultCodeOpenEnumType(struct soap *soap, char *const*a, const char *tag, const char *type)
{
	if (soap_out_wsc__FaultCodeOpenEnumType(soap, tag ? tag : "wsc:FaultCodeOpenEnumType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 char ** SOAP_FMAC4 soap_get_wsc__FaultCodeOpenEnumType(struct soap *soap, char **p, const char *tag, const char *type)
{
	if ((p = soap_in_wsc__FaultCodeOpenEnumType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_xenc__ReferenceList(struct soap *soap, struct _xenc__ReferenceList *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__xenc__ReferenceList))
		soap_serialize__xenc__ReferenceList(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_xenc__ReferenceList(struct soap *soap, const char *tag, int id, struct _xenc__ReferenceList *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__xenc__ReferenceList, NULL);
	if (id < 0)
		return soap->error;
	return soap_out__xenc__ReferenceList(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _xenc__ReferenceList ** SOAP_FMAC4 soap_in_PointerTo_xenc__ReferenceList(struct soap *soap, const char *tag, struct _xenc__ReferenceList **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _xenc__ReferenceList **)soap_malloc(soap, sizeof(struct _xenc__ReferenceList *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__xenc__ReferenceList(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _xenc__ReferenceList **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__xenc__ReferenceList, sizeof(struct _xenc__ReferenceList), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_xenc__ReferenceList(struct soap *soap, struct _xenc__ReferenceList *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_xenc__ReferenceList(soap, tag ? tag : "xenc:ReferenceList", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _xenc__ReferenceList ** SOAP_FMAC4 soap_get_PointerTo_xenc__ReferenceList(struct soap *soap, struct _xenc__ReferenceList **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_xenc__ReferenceList(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo__xenc__union_ReferenceList(struct soap *soap, struct __xenc__union_ReferenceList *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE___xenc__union_ReferenceList))
		soap_serialize___xenc__union_ReferenceList(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo__xenc__union_ReferenceList(struct soap *soap, const char *tag, int id, struct __xenc__union_ReferenceList *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE___xenc__union_ReferenceList, NULL);
	if (id < 0)
		return soap->error;
	return soap_out___xenc__union_ReferenceList(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct __xenc__union_ReferenceList ** SOAP_FMAC4 soap_in_PointerTo__xenc__union_ReferenceList(struct soap *soap, const char *tag, struct __xenc__union_ReferenceList **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct __xenc__union_ReferenceList **)soap_malloc(soap, sizeof(struct __xenc__union_ReferenceList *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in___xenc__union_ReferenceList(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct __xenc__union_ReferenceList **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE___xenc__union_ReferenceList, sizeof(struct __xenc__union_ReferenceList), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo__xenc__union_ReferenceList(struct soap *soap, struct __xenc__union_ReferenceList *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo__xenc__union_ReferenceList(soap, tag ? tag : "-xenc:union-ReferenceList", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct __xenc__union_ReferenceList ** SOAP_FMAC4 soap_get_PointerTo__xenc__union_ReferenceList(struct soap *soap, struct __xenc__union_ReferenceList **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo__xenc__union_ReferenceList(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToxenc__ReferenceType(struct soap *soap, struct xenc__ReferenceType *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_xenc__ReferenceType))
		soap_serialize_xenc__ReferenceType(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToxenc__ReferenceType(struct soap *soap, const char *tag, int id, struct xenc__ReferenceType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_xenc__ReferenceType, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_xenc__ReferenceType(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct xenc__ReferenceType ** SOAP_FMAC4 soap_in_PointerToxenc__ReferenceType(struct soap *soap, const char *tag, struct xenc__ReferenceType **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct xenc__ReferenceType **)soap_malloc(soap, sizeof(struct xenc__ReferenceType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_xenc__ReferenceType(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct xenc__ReferenceType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_xenc__ReferenceType, sizeof(struct xenc__ReferenceType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToxenc__ReferenceType(struct soap *soap, struct xenc__ReferenceType *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerToxenc__ReferenceType(soap, tag ? tag : "xenc:ReferenceType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct xenc__ReferenceType ** SOAP_FMAC4 soap_get_PointerToxenc__ReferenceType(struct soap *soap, struct xenc__ReferenceType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToxenc__ReferenceType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToxenc__EncryptionPropertyType(struct soap *soap, struct xenc__EncryptionPropertyType *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_xenc__EncryptionPropertyType))
		soap_serialize_xenc__EncryptionPropertyType(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToxenc__EncryptionPropertyType(struct soap *soap, const char *tag, int id, struct xenc__EncryptionPropertyType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_xenc__EncryptionPropertyType, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_xenc__EncryptionPropertyType(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct xenc__EncryptionPropertyType ** SOAP_FMAC4 soap_in_PointerToxenc__EncryptionPropertyType(struct soap *soap, const char *tag, struct xenc__EncryptionPropertyType **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct xenc__EncryptionPropertyType **)soap_malloc(soap, sizeof(struct xenc__EncryptionPropertyType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_xenc__EncryptionPropertyType(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct xenc__EncryptionPropertyType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_xenc__EncryptionPropertyType, sizeof(struct xenc__EncryptionPropertyType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToxenc__EncryptionPropertyType(struct soap *soap, struct xenc__EncryptionPropertyType *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerToxenc__EncryptionPropertyType(soap, tag ? tag : "xenc:EncryptionPropertyType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct xenc__EncryptionPropertyType ** SOAP_FMAC4 soap_get_PointerToxenc__EncryptionPropertyType(struct soap *soap, struct xenc__EncryptionPropertyType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToxenc__EncryptionPropertyType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToxenc__TransformsType(struct soap *soap, struct xenc__TransformsType *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_xenc__TransformsType))
		soap_serialize_xenc__TransformsType(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToxenc__TransformsType(struct soap *soap, const char *tag, int id, struct xenc__TransformsType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_xenc__TransformsType, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_xenc__TransformsType(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct xenc__TransformsType ** SOAP_FMAC4 soap_in_PointerToxenc__TransformsType(struct soap *soap, const char *tag, struct xenc__TransformsType **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct xenc__TransformsType **)soap_malloc(soap, sizeof(struct xenc__TransformsType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_xenc__TransformsType(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct xenc__TransformsType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_xenc__TransformsType, sizeof(struct xenc__TransformsType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToxenc__TransformsType(struct soap *soap, struct xenc__TransformsType *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerToxenc__TransformsType(soap, tag ? tag : "xenc:TransformsType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct xenc__TransformsType ** SOAP_FMAC4 soap_get_PointerToxenc__TransformsType(struct soap *soap, struct xenc__TransformsType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToxenc__TransformsType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToxenc__CipherReferenceType(struct soap *soap, struct xenc__CipherReferenceType *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_xenc__CipherReferenceType))
		soap_serialize_xenc__CipherReferenceType(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToxenc__CipherReferenceType(struct soap *soap, const char *tag, int id, struct xenc__CipherReferenceType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_xenc__CipherReferenceType, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_xenc__CipherReferenceType(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct xenc__CipherReferenceType ** SOAP_FMAC4 soap_in_PointerToxenc__CipherReferenceType(struct soap *soap, const char *tag, struct xenc__CipherReferenceType **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct xenc__CipherReferenceType **)soap_malloc(soap, sizeof(struct xenc__CipherReferenceType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_xenc__CipherReferenceType(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct xenc__CipherReferenceType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_xenc__CipherReferenceType, sizeof(struct xenc__CipherReferenceType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToxenc__CipherReferenceType(struct soap *soap, struct xenc__CipherReferenceType *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerToxenc__CipherReferenceType(soap, tag ? tag : "xenc:CipherReferenceType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct xenc__CipherReferenceType ** SOAP_FMAC4 soap_get_PointerToxenc__CipherReferenceType(struct soap *soap, struct xenc__CipherReferenceType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToxenc__CipherReferenceType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToxenc__EncryptionPropertiesType(struct soap *soap, struct xenc__EncryptionPropertiesType *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_xenc__EncryptionPropertiesType))
		soap_serialize_xenc__EncryptionPropertiesType(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToxenc__EncryptionPropertiesType(struct soap *soap, const char *tag, int id, struct xenc__EncryptionPropertiesType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_xenc__EncryptionPropertiesType, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_xenc__EncryptionPropertiesType(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct xenc__EncryptionPropertiesType ** SOAP_FMAC4 soap_in_PointerToxenc__EncryptionPropertiesType(struct soap *soap, const char *tag, struct xenc__EncryptionPropertiesType **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct xenc__EncryptionPropertiesType **)soap_malloc(soap, sizeof(struct xenc__EncryptionPropertiesType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_xenc__EncryptionPropertiesType(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct xenc__EncryptionPropertiesType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_xenc__EncryptionPropertiesType, sizeof(struct xenc__EncryptionPropertiesType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToxenc__EncryptionPropertiesType(struct soap *soap, struct xenc__EncryptionPropertiesType *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerToxenc__EncryptionPropertiesType(soap, tag ? tag : "xenc:EncryptionPropertiesType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct xenc__EncryptionPropertiesType ** SOAP_FMAC4 soap_get_PointerToxenc__EncryptionPropertiesType(struct soap *soap, struct xenc__EncryptionPropertiesType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToxenc__EncryptionPropertiesType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToxenc__CipherDataType(struct soap *soap, struct xenc__CipherDataType *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_xenc__CipherDataType))
		soap_serialize_xenc__CipherDataType(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToxenc__CipherDataType(struct soap *soap, const char *tag, int id, struct xenc__CipherDataType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_xenc__CipherDataType, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_xenc__CipherDataType(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct xenc__CipherDataType ** SOAP_FMAC4 soap_in_PointerToxenc__CipherDataType(struct soap *soap, const char *tag, struct xenc__CipherDataType **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct xenc__CipherDataType **)soap_malloc(soap, sizeof(struct xenc__CipherDataType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_xenc__CipherDataType(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct xenc__CipherDataType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_xenc__CipherDataType, sizeof(struct xenc__CipherDataType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToxenc__CipherDataType(struct soap *soap, struct xenc__CipherDataType *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerToxenc__CipherDataType(soap, tag ? tag : "xenc:CipherDataType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct xenc__CipherDataType ** SOAP_FMAC4 soap_get_PointerToxenc__CipherDataType(struct soap *soap, struct xenc__CipherDataType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToxenc__CipherDataType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ds__KeyInfo(struct soap *soap, struct ds__KeyInfoType *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ds__KeyInfo))
		soap_serialize__ds__KeyInfo(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ds__KeyInfo(struct soap *soap, const char *tag, int id, struct ds__KeyInfoType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ds__KeyInfo, NULL);
	if (id < 0)
		return soap->error;
	return soap_out__ds__KeyInfo(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ds__KeyInfoType ** SOAP_FMAC4 soap_in_PointerTo_ds__KeyInfo(struct soap *soap, const char *tag, struct ds__KeyInfoType **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ds__KeyInfoType **)soap_malloc(soap, sizeof(struct ds__KeyInfoType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__ds__KeyInfo(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ds__KeyInfoType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ds__KeyInfo, sizeof(struct ds__KeyInfoType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ds__KeyInfo(struct soap *soap, struct ds__KeyInfoType *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_ds__KeyInfo(soap, tag ? tag : "ds:KeyInfo", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ds__KeyInfoType ** SOAP_FMAC4 soap_get_PointerTo_ds__KeyInfo(struct soap *soap, struct ds__KeyInfoType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ds__KeyInfo(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToxenc__EncryptionMethodType(struct soap *soap, struct xenc__EncryptionMethodType *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_xenc__EncryptionMethodType))
		soap_serialize_xenc__EncryptionMethodType(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToxenc__EncryptionMethodType(struct soap *soap, const char *tag, int id, struct xenc__EncryptionMethodType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_xenc__EncryptionMethodType, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_xenc__EncryptionMethodType(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct xenc__EncryptionMethodType ** SOAP_FMAC4 soap_in_PointerToxenc__EncryptionMethodType(struct soap *soap, const char *tag, struct xenc__EncryptionMethodType **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct xenc__EncryptionMethodType **)soap_malloc(soap, sizeof(struct xenc__EncryptionMethodType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_xenc__EncryptionMethodType(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct xenc__EncryptionMethodType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_xenc__EncryptionMethodType, sizeof(struct xenc__EncryptionMethodType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToxenc__EncryptionMethodType(struct soap *soap, struct xenc__EncryptionMethodType *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerToxenc__EncryptionMethodType(soap, tag ? tag : "xenc:EncryptionMethodType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct xenc__EncryptionMethodType ** SOAP_FMAC4 soap_get_PointerToxenc__EncryptionMethodType(struct soap *soap, struct xenc__EncryptionMethodType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToxenc__EncryptionMethodType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTods__X509IssuerSerialType(struct soap *soap, struct ds__X509IssuerSerialType *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ds__X509IssuerSerialType))
		soap_serialize_ds__X509IssuerSerialType(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTods__X509IssuerSerialType(struct soap *soap, const char *tag, int id, struct ds__X509IssuerSerialType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ds__X509IssuerSerialType, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_ds__X509IssuerSerialType(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ds__X509IssuerSerialType ** SOAP_FMAC4 soap_in_PointerTods__X509IssuerSerialType(struct soap *soap, const char *tag, struct ds__X509IssuerSerialType **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ds__X509IssuerSerialType **)soap_malloc(soap, sizeof(struct ds__X509IssuerSerialType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ds__X509IssuerSerialType(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ds__X509IssuerSerialType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ds__X509IssuerSerialType, sizeof(struct ds__X509IssuerSerialType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTods__X509IssuerSerialType(struct soap *soap, struct ds__X509IssuerSerialType *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTods__X509IssuerSerialType(soap, tag ? tag : "ds:X509IssuerSerialType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ds__X509IssuerSerialType ** SOAP_FMAC4 soap_get_PointerTods__X509IssuerSerialType(struct soap *soap, struct ds__X509IssuerSerialType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTods__X509IssuerSerialType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTods__RSAKeyValueType(struct soap *soap, struct ds__RSAKeyValueType *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ds__RSAKeyValueType))
		soap_serialize_ds__RSAKeyValueType(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTods__RSAKeyValueType(struct soap *soap, const char *tag, int id, struct ds__RSAKeyValueType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ds__RSAKeyValueType, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_ds__RSAKeyValueType(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ds__RSAKeyValueType ** SOAP_FMAC4 soap_in_PointerTods__RSAKeyValueType(struct soap *soap, const char *tag, struct ds__RSAKeyValueType **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ds__RSAKeyValueType **)soap_malloc(soap, sizeof(struct ds__RSAKeyValueType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ds__RSAKeyValueType(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ds__RSAKeyValueType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ds__RSAKeyValueType, sizeof(struct ds__RSAKeyValueType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTods__RSAKeyValueType(struct soap *soap, struct ds__RSAKeyValueType *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTods__RSAKeyValueType(soap, tag ? tag : "ds:RSAKeyValueType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ds__RSAKeyValueType ** SOAP_FMAC4 soap_get_PointerTods__RSAKeyValueType(struct soap *soap, struct ds__RSAKeyValueType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTods__RSAKeyValueType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTods__DSAKeyValueType(struct soap *soap, struct ds__DSAKeyValueType *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ds__DSAKeyValueType))
		soap_serialize_ds__DSAKeyValueType(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTods__DSAKeyValueType(struct soap *soap, const char *tag, int id, struct ds__DSAKeyValueType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ds__DSAKeyValueType, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_ds__DSAKeyValueType(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ds__DSAKeyValueType ** SOAP_FMAC4 soap_in_PointerTods__DSAKeyValueType(struct soap *soap, const char *tag, struct ds__DSAKeyValueType **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ds__DSAKeyValueType **)soap_malloc(soap, sizeof(struct ds__DSAKeyValueType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ds__DSAKeyValueType(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ds__DSAKeyValueType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ds__DSAKeyValueType, sizeof(struct ds__DSAKeyValueType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTods__DSAKeyValueType(struct soap *soap, struct ds__DSAKeyValueType *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTods__DSAKeyValueType(soap, tag ? tag : "ds:DSAKeyValueType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ds__DSAKeyValueType ** SOAP_FMAC4 soap_get_PointerTods__DSAKeyValueType(struct soap *soap, struct ds__DSAKeyValueType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTods__DSAKeyValueType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTods__TransformType(struct soap *soap, struct ds__TransformType *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ds__TransformType))
		soap_serialize_ds__TransformType(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTods__TransformType(struct soap *soap, const char *tag, int id, struct ds__TransformType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ds__TransformType, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_ds__TransformType(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ds__TransformType ** SOAP_FMAC4 soap_in_PointerTods__TransformType(struct soap *soap, const char *tag, struct ds__TransformType **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ds__TransformType **)soap_malloc(soap, sizeof(struct ds__TransformType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ds__TransformType(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ds__TransformType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ds__TransformType, sizeof(struct ds__TransformType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTods__TransformType(struct soap *soap, struct ds__TransformType *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTods__TransformType(soap, tag ? tag : "ds:TransformType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ds__TransformType ** SOAP_FMAC4 soap_get_PointerTods__TransformType(struct soap *soap, struct ds__TransformType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTods__TransformType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTods__DigestMethodType(struct soap *soap, struct ds__DigestMethodType *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ds__DigestMethodType))
		soap_serialize_ds__DigestMethodType(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTods__DigestMethodType(struct soap *soap, const char *tag, int id, struct ds__DigestMethodType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ds__DigestMethodType, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_ds__DigestMethodType(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ds__DigestMethodType ** SOAP_FMAC4 soap_in_PointerTods__DigestMethodType(struct soap *soap, const char *tag, struct ds__DigestMethodType **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ds__DigestMethodType **)soap_malloc(soap, sizeof(struct ds__DigestMethodType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ds__DigestMethodType(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ds__DigestMethodType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ds__DigestMethodType, sizeof(struct ds__DigestMethodType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTods__DigestMethodType(struct soap *soap, struct ds__DigestMethodType *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTods__DigestMethodType(soap, tag ? tag : "ds:DigestMethodType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ds__DigestMethodType ** SOAP_FMAC4 soap_get_PointerTods__DigestMethodType(struct soap *soap, struct ds__DigestMethodType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTods__DigestMethodType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTods__TransformsType(struct soap *soap, struct ds__TransformsType *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ds__TransformsType))
		soap_serialize_ds__TransformsType(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTods__TransformsType(struct soap *soap, const char *tag, int id, struct ds__TransformsType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ds__TransformsType, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_ds__TransformsType(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ds__TransformsType ** SOAP_FMAC4 soap_in_PointerTods__TransformsType(struct soap *soap, const char *tag, struct ds__TransformsType **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ds__TransformsType **)soap_malloc(soap, sizeof(struct ds__TransformsType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ds__TransformsType(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ds__TransformsType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ds__TransformsType, sizeof(struct ds__TransformsType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTods__TransformsType(struct soap *soap, struct ds__TransformsType *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTods__TransformsType(soap, tag ? tag : "ds:TransformsType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ds__TransformsType ** SOAP_FMAC4 soap_get_PointerTods__TransformsType(struct soap *soap, struct ds__TransformsType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTods__TransformsType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToPointerTods__ReferenceType(struct soap *soap, struct ds__ReferenceType **const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_PointerTods__ReferenceType))
		soap_serialize_PointerTods__ReferenceType(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToPointerTods__ReferenceType(struct soap *soap, const char *tag, int id, struct ds__ReferenceType **const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_PointerTods__ReferenceType, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_PointerTods__ReferenceType(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ds__ReferenceType *** SOAP_FMAC4 soap_in_PointerToPointerTods__ReferenceType(struct soap *soap, const char *tag, struct ds__ReferenceType ***a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ds__ReferenceType ***)soap_malloc(soap, sizeof(struct ds__ReferenceType **))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_PointerTods__ReferenceType(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ds__ReferenceType ***)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ds__ReferenceType, sizeof(struct ds__ReferenceType), 1, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToPointerTods__ReferenceType(struct soap *soap, struct ds__ReferenceType **const*a, const char *tag, const char *type)
{
	if (soap_out_PointerToPointerTods__ReferenceType(soap, tag ? tag : "ds:ReferenceType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ds__ReferenceType *** SOAP_FMAC4 soap_get_PointerToPointerTods__ReferenceType(struct soap *soap, struct ds__ReferenceType ***p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToPointerTods__ReferenceType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTods__ReferenceType(struct soap *soap, struct ds__ReferenceType *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ds__ReferenceType))
		soap_serialize_ds__ReferenceType(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTods__ReferenceType(struct soap *soap, const char *tag, int id, struct ds__ReferenceType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ds__ReferenceType, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_ds__ReferenceType(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ds__ReferenceType ** SOAP_FMAC4 soap_in_PointerTods__ReferenceType(struct soap *soap, const char *tag, struct ds__ReferenceType **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ds__ReferenceType **)soap_malloc(soap, sizeof(struct ds__ReferenceType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ds__ReferenceType(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ds__ReferenceType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ds__ReferenceType, sizeof(struct ds__ReferenceType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTods__ReferenceType(struct soap *soap, struct ds__ReferenceType *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTods__ReferenceType(soap, tag ? tag : "ds:ReferenceType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ds__ReferenceType ** SOAP_FMAC4 soap_get_PointerTods__ReferenceType(struct soap *soap, struct ds__ReferenceType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTods__ReferenceType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTods__SignatureMethodType(struct soap *soap, struct ds__SignatureMethodType *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ds__SignatureMethodType))
		soap_serialize_ds__SignatureMethodType(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTods__SignatureMethodType(struct soap *soap, const char *tag, int id, struct ds__SignatureMethodType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ds__SignatureMethodType, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_ds__SignatureMethodType(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ds__SignatureMethodType ** SOAP_FMAC4 soap_in_PointerTods__SignatureMethodType(struct soap *soap, const char *tag, struct ds__SignatureMethodType **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ds__SignatureMethodType **)soap_malloc(soap, sizeof(struct ds__SignatureMethodType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ds__SignatureMethodType(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ds__SignatureMethodType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ds__SignatureMethodType, sizeof(struct ds__SignatureMethodType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTods__SignatureMethodType(struct soap *soap, struct ds__SignatureMethodType *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTods__SignatureMethodType(soap, tag ? tag : "ds:SignatureMethodType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ds__SignatureMethodType ** SOAP_FMAC4 soap_get_PointerTods__SignatureMethodType(struct soap *soap, struct ds__SignatureMethodType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTods__SignatureMethodType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTods__CanonicalizationMethodType(struct soap *soap, struct ds__CanonicalizationMethodType *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ds__CanonicalizationMethodType))
		soap_serialize_ds__CanonicalizationMethodType(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTods__CanonicalizationMethodType(struct soap *soap, const char *tag, int id, struct ds__CanonicalizationMethodType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ds__CanonicalizationMethodType, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_ds__CanonicalizationMethodType(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ds__CanonicalizationMethodType ** SOAP_FMAC4 soap_in_PointerTods__CanonicalizationMethodType(struct soap *soap, const char *tag, struct ds__CanonicalizationMethodType **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ds__CanonicalizationMethodType **)soap_malloc(soap, sizeof(struct ds__CanonicalizationMethodType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ds__CanonicalizationMethodType(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ds__CanonicalizationMethodType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ds__CanonicalizationMethodType, sizeof(struct ds__CanonicalizationMethodType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTods__CanonicalizationMethodType(struct soap *soap, struct ds__CanonicalizationMethodType *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTods__CanonicalizationMethodType(soap, tag ? tag : "ds:CanonicalizationMethodType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ds__CanonicalizationMethodType ** SOAP_FMAC4 soap_get_PointerTods__CanonicalizationMethodType(struct soap *soap, struct ds__CanonicalizationMethodType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTods__CanonicalizationMethodType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_wsse__SecurityTokenReference(struct soap *soap, struct _wsse__SecurityTokenReference *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__wsse__SecurityTokenReference))
		soap_serialize__wsse__SecurityTokenReference(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_wsse__SecurityTokenReference(struct soap *soap, const char *tag, int id, struct _wsse__SecurityTokenReference *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__wsse__SecurityTokenReference, NULL);
	if (id < 0)
		return soap->error;
	return soap_out__wsse__SecurityTokenReference(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _wsse__SecurityTokenReference ** SOAP_FMAC4 soap_in_PointerTo_wsse__SecurityTokenReference(struct soap *soap, const char *tag, struct _wsse__SecurityTokenReference **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _wsse__SecurityTokenReference **)soap_malloc(soap, sizeof(struct _wsse__SecurityTokenReference *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__wsse__SecurityTokenReference(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _wsse__SecurityTokenReference **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__wsse__SecurityTokenReference, sizeof(struct _wsse__SecurityTokenReference), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_wsse__SecurityTokenReference(struct soap *soap, struct _wsse__SecurityTokenReference *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_wsse__SecurityTokenReference(soap, tag ? tag : "wsse:SecurityTokenReference", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _wsse__SecurityTokenReference ** SOAP_FMAC4 soap_get_PointerTo_wsse__SecurityTokenReference(struct soap *soap, struct _wsse__SecurityTokenReference **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_wsse__SecurityTokenReference(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTods__RetrievalMethodType(struct soap *soap, struct ds__RetrievalMethodType *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ds__RetrievalMethodType))
		soap_serialize_ds__RetrievalMethodType(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTods__RetrievalMethodType(struct soap *soap, const char *tag, int id, struct ds__RetrievalMethodType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ds__RetrievalMethodType, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_ds__RetrievalMethodType(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ds__RetrievalMethodType ** SOAP_FMAC4 soap_in_PointerTods__RetrievalMethodType(struct soap *soap, const char *tag, struct ds__RetrievalMethodType **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ds__RetrievalMethodType **)soap_malloc(soap, sizeof(struct ds__RetrievalMethodType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ds__RetrievalMethodType(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ds__RetrievalMethodType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ds__RetrievalMethodType, sizeof(struct ds__RetrievalMethodType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTods__RetrievalMethodType(struct soap *soap, struct ds__RetrievalMethodType *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTods__RetrievalMethodType(soap, tag ? tag : "ds:RetrievalMethodType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ds__RetrievalMethodType ** SOAP_FMAC4 soap_get_PointerTods__RetrievalMethodType(struct soap *soap, struct ds__RetrievalMethodType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTods__RetrievalMethodType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTods__KeyValueType(struct soap *soap, struct ds__KeyValueType *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ds__KeyValueType))
		soap_serialize_ds__KeyValueType(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTods__KeyValueType(struct soap *soap, const char *tag, int id, struct ds__KeyValueType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ds__KeyValueType, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_ds__KeyValueType(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ds__KeyValueType ** SOAP_FMAC4 soap_in_PointerTods__KeyValueType(struct soap *soap, const char *tag, struct ds__KeyValueType **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ds__KeyValueType **)soap_malloc(soap, sizeof(struct ds__KeyValueType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ds__KeyValueType(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ds__KeyValueType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ds__KeyValueType, sizeof(struct ds__KeyValueType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTods__KeyValueType(struct soap *soap, struct ds__KeyValueType *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTods__KeyValueType(soap, tag ? tag : "ds:KeyValueType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ds__KeyValueType ** SOAP_FMAC4 soap_get_PointerTods__KeyValueType(struct soap *soap, struct ds__KeyValueType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTods__KeyValueType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_c14n__InclusiveNamespaces(struct soap *soap, struct _c14n__InclusiveNamespaces *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__c14n__InclusiveNamespaces))
		soap_serialize__c14n__InclusiveNamespaces(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_c14n__InclusiveNamespaces(struct soap *soap, const char *tag, int id, struct _c14n__InclusiveNamespaces *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__c14n__InclusiveNamespaces, NULL);
	if (id < 0)
		return soap->error;
	return soap_out__c14n__InclusiveNamespaces(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _c14n__InclusiveNamespaces ** SOAP_FMAC4 soap_in_PointerTo_c14n__InclusiveNamespaces(struct soap *soap, const char *tag, struct _c14n__InclusiveNamespaces **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _c14n__InclusiveNamespaces **)soap_malloc(soap, sizeof(struct _c14n__InclusiveNamespaces *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__c14n__InclusiveNamespaces(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _c14n__InclusiveNamespaces **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__c14n__InclusiveNamespaces, sizeof(struct _c14n__InclusiveNamespaces), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_c14n__InclusiveNamespaces(struct soap *soap, struct _c14n__InclusiveNamespaces *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_c14n__InclusiveNamespaces(soap, tag ? tag : "c14n:InclusiveNamespaces", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _c14n__InclusiveNamespaces ** SOAP_FMAC4 soap_get_PointerTo_c14n__InclusiveNamespaces(struct soap *soap, struct _c14n__InclusiveNamespaces **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_c14n__InclusiveNamespaces(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTods__KeyInfoType(struct soap *soap, struct ds__KeyInfoType *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ds__KeyInfoType))
		soap_serialize_ds__KeyInfoType(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTods__KeyInfoType(struct soap *soap, const char *tag, int id, struct ds__KeyInfoType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ds__KeyInfoType, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_ds__KeyInfoType(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ds__KeyInfoType ** SOAP_FMAC4 soap_in_PointerTods__KeyInfoType(struct soap *soap, const char *tag, struct ds__KeyInfoType **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ds__KeyInfoType **)soap_malloc(soap, sizeof(struct ds__KeyInfoType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ds__KeyInfoType(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ds__KeyInfoType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ds__KeyInfoType, sizeof(struct ds__KeyInfoType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTods__KeyInfoType(struct soap *soap, struct ds__KeyInfoType *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTods__KeyInfoType(soap, tag ? tag : "ds:KeyInfoType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ds__KeyInfoType ** SOAP_FMAC4 soap_get_PointerTods__KeyInfoType(struct soap *soap, struct ds__KeyInfoType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTods__KeyInfoType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTods__SignedInfoType(struct soap *soap, struct ds__SignedInfoType *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ds__SignedInfoType))
		soap_serialize_ds__SignedInfoType(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTods__SignedInfoType(struct soap *soap, const char *tag, int id, struct ds__SignedInfoType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ds__SignedInfoType, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_ds__SignedInfoType(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ds__SignedInfoType ** SOAP_FMAC4 soap_in_PointerTods__SignedInfoType(struct soap *soap, const char *tag, struct ds__SignedInfoType **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ds__SignedInfoType **)soap_malloc(soap, sizeof(struct ds__SignedInfoType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ds__SignedInfoType(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ds__SignedInfoType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ds__SignedInfoType, sizeof(struct ds__SignedInfoType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTods__SignedInfoType(struct soap *soap, struct ds__SignedInfoType *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTods__SignedInfoType(soap, tag ? tag : "ds:SignedInfoType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ds__SignedInfoType ** SOAP_FMAC4 soap_get_PointerTods__SignedInfoType(struct soap *soap, struct ds__SignedInfoType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTods__SignedInfoType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__ds__SignatureValue(struct soap *soap, char *const*a, const char *tag, const char *type)
{
	if (soap_out__ds__SignatureValue(soap, tag ? tag : "ds:SignatureValue", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToxenc__EncryptedKeyType(struct soap *soap, struct xenc__EncryptedKeyType *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_xenc__EncryptedKeyType))
		soap_serialize_xenc__EncryptedKeyType(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToxenc__EncryptedKeyType(struct soap *soap, const char *tag, int id, struct xenc__EncryptedKeyType *const*a, const char *type)
{
	char *mark;
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_xenc__EncryptedKeyType, &mark);
	if (id < 0)
		return soap->error;
	(void)soap_out_xenc__EncryptedKeyType(soap, tag, id, *a, type);
	soap_unmark(soap, mark);
	return soap->error;
}

SOAP_FMAC3 struct xenc__EncryptedKeyType ** SOAP_FMAC4 soap_in_PointerToxenc__EncryptedKeyType(struct soap *soap, const char *tag, struct xenc__EncryptedKeyType **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct xenc__EncryptedKeyType **)soap_malloc(soap, sizeof(struct xenc__EncryptedKeyType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_xenc__EncryptedKeyType(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct xenc__EncryptedKeyType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_xenc__EncryptedKeyType, sizeof(struct xenc__EncryptedKeyType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToxenc__EncryptedKeyType(struct soap *soap, struct xenc__EncryptedKeyType *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerToxenc__EncryptedKeyType(soap, tag ? tag : "xenc:EncryptedKeyType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct xenc__EncryptedKeyType ** SOAP_FMAC4 soap_get_PointerToxenc__EncryptedKeyType(struct soap *soap, struct xenc__EncryptedKeyType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToxenc__EncryptedKeyType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTods__X509DataType(struct soap *soap, struct ds__X509DataType *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ds__X509DataType))
		soap_serialize_ds__X509DataType(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTods__X509DataType(struct soap *soap, const char *tag, int id, struct ds__X509DataType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ds__X509DataType, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_ds__X509DataType(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ds__X509DataType ** SOAP_FMAC4 soap_in_PointerTods__X509DataType(struct soap *soap, const char *tag, struct ds__X509DataType **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ds__X509DataType **)soap_malloc(soap, sizeof(struct ds__X509DataType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ds__X509DataType(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ds__X509DataType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ds__X509DataType, sizeof(struct ds__X509DataType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTods__X509DataType(struct soap *soap, struct ds__X509DataType *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTods__X509DataType(soap, tag ? tag : "ds:X509DataType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ds__X509DataType ** SOAP_FMAC4 soap_get_PointerTods__X509DataType(struct soap *soap, struct ds__X509DataType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTods__X509DataType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_wsse__Embedded(struct soap *soap, struct _wsse__Embedded *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__wsse__Embedded))
		soap_serialize__wsse__Embedded(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_wsse__Embedded(struct soap *soap, const char *tag, int id, struct _wsse__Embedded *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__wsse__Embedded, NULL);
	if (id < 0)
		return soap->error;
	return soap_out__wsse__Embedded(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _wsse__Embedded ** SOAP_FMAC4 soap_in_PointerTo_wsse__Embedded(struct soap *soap, const char *tag, struct _wsse__Embedded **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _wsse__Embedded **)soap_malloc(soap, sizeof(struct _wsse__Embedded *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__wsse__Embedded(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _wsse__Embedded **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__wsse__Embedded, sizeof(struct _wsse__Embedded), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_wsse__Embedded(struct soap *soap, struct _wsse__Embedded *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_wsse__Embedded(soap, tag ? tag : "wsse:Embedded", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _wsse__Embedded ** SOAP_FMAC4 soap_get_PointerTo_wsse__Embedded(struct soap *soap, struct _wsse__Embedded **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_wsse__Embedded(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_wsse__KeyIdentifier(struct soap *soap, struct _wsse__KeyIdentifier *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__wsse__KeyIdentifier))
		soap_serialize__wsse__KeyIdentifier(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_wsse__KeyIdentifier(struct soap *soap, const char *tag, int id, struct _wsse__KeyIdentifier *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__wsse__KeyIdentifier, NULL);
	if (id < 0)
		return soap->error;
	return soap_out__wsse__KeyIdentifier(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _wsse__KeyIdentifier ** SOAP_FMAC4 soap_in_PointerTo_wsse__KeyIdentifier(struct soap *soap, const char *tag, struct _wsse__KeyIdentifier **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _wsse__KeyIdentifier **)soap_malloc(soap, sizeof(struct _wsse__KeyIdentifier *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__wsse__KeyIdentifier(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _wsse__KeyIdentifier **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__wsse__KeyIdentifier, sizeof(struct _wsse__KeyIdentifier), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_wsse__KeyIdentifier(struct soap *soap, struct _wsse__KeyIdentifier *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_wsse__KeyIdentifier(soap, tag ? tag : "wsse:KeyIdentifier", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _wsse__KeyIdentifier ** SOAP_FMAC4 soap_get_PointerTo_wsse__KeyIdentifier(struct soap *soap, struct _wsse__KeyIdentifier **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_wsse__KeyIdentifier(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_wsse__Reference(struct soap *soap, struct _wsse__Reference *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__wsse__Reference))
		soap_serialize__wsse__Reference(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_wsse__Reference(struct soap *soap, const char *tag, int id, struct _wsse__Reference *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__wsse__Reference, NULL);
	if (id < 0)
		return soap->error;
	return soap_out__wsse__Reference(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _wsse__Reference ** SOAP_FMAC4 soap_in_PointerTo_wsse__Reference(struct soap *soap, const char *tag, struct _wsse__Reference **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _wsse__Reference **)soap_malloc(soap, sizeof(struct _wsse__Reference *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__wsse__Reference(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _wsse__Reference **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__wsse__Reference, sizeof(struct _wsse__Reference), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_wsse__Reference(struct soap *soap, struct _wsse__Reference *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_wsse__Reference(soap, tag ? tag : "wsse:Reference", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _wsse__Reference ** SOAP_FMAC4 soap_get_PointerTo_wsse__Reference(struct soap *soap, struct _wsse__Reference **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_wsse__Reference(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTowsse__EncodedString(struct soap *soap, struct wsse__EncodedString *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_wsse__EncodedString))
		soap_serialize_wsse__EncodedString(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTowsse__EncodedString(struct soap *soap, const char *tag, int id, struct wsse__EncodedString *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_wsse__EncodedString, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_wsse__EncodedString(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct wsse__EncodedString ** SOAP_FMAC4 soap_in_PointerTowsse__EncodedString(struct soap *soap, const char *tag, struct wsse__EncodedString **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct wsse__EncodedString **)soap_malloc(soap, sizeof(struct wsse__EncodedString *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_wsse__EncodedString(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct wsse__EncodedString **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_wsse__EncodedString, sizeof(struct wsse__EncodedString), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTowsse__EncodedString(struct soap *soap, struct wsse__EncodedString *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTowsse__EncodedString(soap, tag ? tag : "wsse:EncodedString", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct wsse__EncodedString ** SOAP_FMAC4 soap_get_PointerTowsse__EncodedString(struct soap *soap, struct wsse__EncodedString **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTowsse__EncodedString(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_wsse__Password(struct soap *soap, struct _wsse__Password *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__wsse__Password))
		soap_serialize__wsse__Password(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_wsse__Password(struct soap *soap, const char *tag, int id, struct _wsse__Password *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__wsse__Password, NULL);
	if (id < 0)
		return soap->error;
	return soap_out__wsse__Password(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _wsse__Password ** SOAP_FMAC4 soap_in_PointerTo_wsse__Password(struct soap *soap, const char *tag, struct _wsse__Password **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _wsse__Password **)soap_malloc(soap, sizeof(struct _wsse__Password *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__wsse__Password(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _wsse__Password **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__wsse__Password, sizeof(struct _wsse__Password), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_wsse__Password(struct soap *soap, struct _wsse__Password *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_wsse__Password(soap, tag ? tag : "wsse:Password", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _wsse__Password ** SOAP_FMAC4 soap_get_PointerTo_wsse__Password(struct soap *soap, struct _wsse__Password **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_wsse__Password(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTochan__ChannelInstanceType(struct soap *soap, struct chan__ChannelInstanceType *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_chan__ChannelInstanceType))
		soap_serialize_chan__ChannelInstanceType(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTochan__ChannelInstanceType(struct soap *soap, const char *tag, int id, struct chan__ChannelInstanceType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_chan__ChannelInstanceType, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_chan__ChannelInstanceType(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct chan__ChannelInstanceType ** SOAP_FMAC4 soap_in_PointerTochan__ChannelInstanceType(struct soap *soap, const char *tag, struct chan__ChannelInstanceType **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct chan__ChannelInstanceType **)soap_malloc(soap, sizeof(struct chan__ChannelInstanceType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_chan__ChannelInstanceType(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct chan__ChannelInstanceType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_chan__ChannelInstanceType, sizeof(struct chan__ChannelInstanceType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTochan__ChannelInstanceType(struct soap *soap, struct chan__ChannelInstanceType *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTochan__ChannelInstanceType(soap, tag ? tag : "chan:ChannelInstanceType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct chan__ChannelInstanceType ** SOAP_FMAC4 soap_get_PointerTochan__ChannelInstanceType(struct soap *soap, struct chan__ChannelInstanceType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTochan__ChannelInstanceType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_wsa5__FaultTo(struct soap *soap, struct wsa5__EndpointReferenceType *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__wsa5__FaultTo))
		soap_serialize__wsa5__FaultTo(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_wsa5__FaultTo(struct soap *soap, const char *tag, int id, struct wsa5__EndpointReferenceType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__wsa5__FaultTo, NULL);
	if (id < 0)
		return soap->error;
	return soap_out__wsa5__FaultTo(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct wsa5__EndpointReferenceType ** SOAP_FMAC4 soap_in_PointerTo_wsa5__FaultTo(struct soap *soap, const char *tag, struct wsa5__EndpointReferenceType **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct wsa5__EndpointReferenceType **)soap_malloc(soap, sizeof(struct wsa5__EndpointReferenceType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__wsa5__FaultTo(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct wsa5__EndpointReferenceType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__wsa5__FaultTo, sizeof(struct wsa5__EndpointReferenceType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_wsa5__FaultTo(struct soap *soap, struct wsa5__EndpointReferenceType *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_wsa5__FaultTo(soap, tag ? tag : "wsa5:FaultTo", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct wsa5__EndpointReferenceType ** SOAP_FMAC4 soap_get_PointerTo_wsa5__FaultTo(struct soap *soap, struct wsa5__EndpointReferenceType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_wsa5__FaultTo(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_wsa5__ReplyTo(struct soap *soap, struct wsa5__EndpointReferenceType *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__wsa5__ReplyTo))
		soap_serialize__wsa5__ReplyTo(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_wsa5__ReplyTo(struct soap *soap, const char *tag, int id, struct wsa5__EndpointReferenceType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__wsa5__ReplyTo, NULL);
	if (id < 0)
		return soap->error;
	return soap_out__wsa5__ReplyTo(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct wsa5__EndpointReferenceType ** SOAP_FMAC4 soap_in_PointerTo_wsa5__ReplyTo(struct soap *soap, const char *tag, struct wsa5__EndpointReferenceType **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct wsa5__EndpointReferenceType **)soap_malloc(soap, sizeof(struct wsa5__EndpointReferenceType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__wsa5__ReplyTo(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct wsa5__EndpointReferenceType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__wsa5__ReplyTo, sizeof(struct wsa5__EndpointReferenceType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_wsa5__ReplyTo(struct soap *soap, struct wsa5__EndpointReferenceType *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_wsa5__ReplyTo(soap, tag ? tag : "wsa5:ReplyTo", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct wsa5__EndpointReferenceType ** SOAP_FMAC4 soap_get_PointerTo_wsa5__ReplyTo(struct soap *soap, struct wsa5__EndpointReferenceType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_wsa5__ReplyTo(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_wsa5__From(struct soap *soap, struct wsa5__EndpointReferenceType *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__wsa5__From))
		soap_serialize__wsa5__From(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_wsa5__From(struct soap *soap, const char *tag, int id, struct wsa5__EndpointReferenceType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__wsa5__From, NULL);
	if (id < 0)
		return soap->error;
	return soap_out__wsa5__From(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct wsa5__EndpointReferenceType ** SOAP_FMAC4 soap_in_PointerTo_wsa5__From(struct soap *soap, const char *tag, struct wsa5__EndpointReferenceType **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct wsa5__EndpointReferenceType **)soap_malloc(soap, sizeof(struct wsa5__EndpointReferenceType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__wsa5__From(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct wsa5__EndpointReferenceType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__wsa5__From, sizeof(struct wsa5__EndpointReferenceType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_wsa5__From(struct soap *soap, struct wsa5__EndpointReferenceType *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_wsa5__From(soap, tag ? tag : "wsa5:From", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct wsa5__EndpointReferenceType ** SOAP_FMAC4 soap_get_PointerTo_wsa5__From(struct soap *soap, struct wsa5__EndpointReferenceType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_wsa5__From(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_wsa5__RelatesTo(struct soap *soap, struct wsa5__RelatesToType *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__wsa5__RelatesTo))
		soap_serialize__wsa5__RelatesTo(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_wsa5__RelatesTo(struct soap *soap, const char *tag, int id, struct wsa5__RelatesToType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__wsa5__RelatesTo, NULL);
	if (id < 0)
		return soap->error;
	return soap_out__wsa5__RelatesTo(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct wsa5__RelatesToType ** SOAP_FMAC4 soap_in_PointerTo_wsa5__RelatesTo(struct soap *soap, const char *tag, struct wsa5__RelatesToType **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct wsa5__RelatesToType **)soap_malloc(soap, sizeof(struct wsa5__RelatesToType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__wsa5__RelatesTo(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct wsa5__RelatesToType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__wsa5__RelatesTo, sizeof(struct wsa5__RelatesToType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_wsa5__RelatesTo(struct soap *soap, struct wsa5__RelatesToType *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_wsa5__RelatesTo(soap, tag ? tag : "wsa5:RelatesTo", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct wsa5__RelatesToType ** SOAP_FMAC4 soap_get_PointerTo_wsa5__RelatesTo(struct soap *soap, struct wsa5__RelatesToType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_wsa5__RelatesTo(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__wsa5__ProblemIRI(struct soap *soap, char *const*a, const char *tag, const char *type)
{
	if (soap_out__wsa5__ProblemIRI(soap, tag ? tag : "wsa5:ProblemIRI", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__wsa5__Action(struct soap *soap, char *const*a, const char *tag, const char *type)
{
	if (soap_out__wsa5__Action(soap, tag ? tag : "wsa5:Action", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__wsa5__To(struct soap *soap, char *const*a, const char *tag, const char *type)
{
	if (soap_out__wsa5__To(soap, tag ? tag : "wsa5:To", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__wsa5__MessageID(struct soap *soap, char *const*a, const char *tag, const char *type)
{
	if (soap_out__wsa5__MessageID(soap, tag ? tag : "wsa5:MessageID", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToint(struct soap *soap, int *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	(void)soap_reference(soap, *a, SOAP_TYPE_int);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToint(struct soap *soap, const char *tag, int id, int *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_int, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_int(soap, tag, id, *a, type);
}

SOAP_FMAC3 int ** SOAP_FMAC4 soap_in_PointerToint(struct soap *soap, const char *tag, int **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (int **)soap_malloc(soap, sizeof(int *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_int(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (int **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_int, sizeof(int), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToint(struct soap *soap, int *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerToint(soap, tag ? tag : "int", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int ** SOAP_FMAC4 soap_get_PointerToint(struct soap *soap, int **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToint(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTowsa5__MetadataType(struct soap *soap, struct wsa5__MetadataType *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_wsa5__MetadataType))
		soap_serialize_wsa5__MetadataType(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTowsa5__MetadataType(struct soap *soap, const char *tag, int id, struct wsa5__MetadataType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_wsa5__MetadataType, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_wsa5__MetadataType(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct wsa5__MetadataType ** SOAP_FMAC4 soap_in_PointerTowsa5__MetadataType(struct soap *soap, const char *tag, struct wsa5__MetadataType **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct wsa5__MetadataType **)soap_malloc(soap, sizeof(struct wsa5__MetadataType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_wsa5__MetadataType(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct wsa5__MetadataType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_wsa5__MetadataType, sizeof(struct wsa5__MetadataType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTowsa5__MetadataType(struct soap *soap, struct wsa5__MetadataType *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTowsa5__MetadataType(soap, tag ? tag : "wsa5:MetadataType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct wsa5__MetadataType ** SOAP_FMAC4 soap_get_PointerTowsa5__MetadataType(struct soap *soap, struct wsa5__MetadataType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTowsa5__MetadataType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTowsa5__ReferenceParametersType(struct soap *soap, struct wsa5__ReferenceParametersType *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_wsa5__ReferenceParametersType))
		soap_serialize_wsa5__ReferenceParametersType(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTowsa5__ReferenceParametersType(struct soap *soap, const char *tag, int id, struct wsa5__ReferenceParametersType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_wsa5__ReferenceParametersType, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_wsa5__ReferenceParametersType(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct wsa5__ReferenceParametersType ** SOAP_FMAC4 soap_in_PointerTowsa5__ReferenceParametersType(struct soap *soap, const char *tag, struct wsa5__ReferenceParametersType **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct wsa5__ReferenceParametersType **)soap_malloc(soap, sizeof(struct wsa5__ReferenceParametersType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_wsa5__ReferenceParametersType(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct wsa5__ReferenceParametersType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_wsa5__ReferenceParametersType, sizeof(struct wsa5__ReferenceParametersType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTowsa5__ReferenceParametersType(struct soap *soap, struct wsa5__ReferenceParametersType *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTowsa5__ReferenceParametersType(soap, tag ? tag : "wsa5:ReferenceParametersType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct wsa5__ReferenceParametersType ** SOAP_FMAC4 soap_get_PointerTowsa5__ReferenceParametersType(struct soap *soap, struct wsa5__ReferenceParametersType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTowsa5__ReferenceParametersType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_wsa5__FaultCodesOpenEnumType(struct soap *soap, char *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	(void)soap_reference(soap, *a, SOAP_TYPE_wsa5__FaultCodesOpenEnumType);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_wsa5__FaultCodesOpenEnumType(struct soap *soap, const char *tag, int id, char *const*a, const char *type)
{
	return soap_outstring(soap, tag, id, a, type, SOAP_TYPE_wsa5__FaultCodesOpenEnumType);
}

SOAP_FMAC3 char * * SOAP_FMAC4 soap_in_wsa5__FaultCodesOpenEnumType(struct soap *soap, const char *tag, char **a, const char *type)
{
	a = soap_instring(soap, tag, a, type, SOAP_TYPE_wsa5__FaultCodesOpenEnumType, 1, 0, -1, NULL);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_wsa5__FaultCodesOpenEnumType(struct soap *soap, char *const*a, const char *tag, const char *type)
{
	if (soap_out_wsa5__FaultCodesOpenEnumType(soap, tag ? tag : "wsa5:FaultCodesOpenEnumType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 char ** SOAP_FMAC4 soap_get_wsa5__FaultCodesOpenEnumType(struct soap *soap, char **p, const char *tag, const char *type)
{
	if ((p = soap_in_wsa5__FaultCodesOpenEnumType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_wsa5__RelationshipTypeOpenEnum(struct soap *soap, char *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	(void)soap_reference(soap, *a, SOAP_TYPE_wsa5__RelationshipTypeOpenEnum);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_wsa5__RelationshipTypeOpenEnum(struct soap *soap, const char *tag, int id, char *const*a, const char *type)
{
	return soap_outstring(soap, tag, id, a, type, SOAP_TYPE_wsa5__RelationshipTypeOpenEnum);
}

SOAP_FMAC3 char * * SOAP_FMAC4 soap_in_wsa5__RelationshipTypeOpenEnum(struct soap *soap, const char *tag, char **a, const char *type)
{
	a = soap_instring(soap, tag, a, type, SOAP_TYPE_wsa5__RelationshipTypeOpenEnum, 1, 0, -1, NULL);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_wsa5__RelationshipTypeOpenEnum(struct soap *soap, char *const*a, const char *tag, const char *type)
{
	if (soap_out_wsa5__RelationshipTypeOpenEnum(soap, tag ? tag : "wsa5:RelationshipTypeOpenEnum", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 char ** SOAP_FMAC4 soap_get_wsa5__RelationshipTypeOpenEnum(struct soap *soap, char **p, const char *tag, const char *type)
{
	if ((p = soap_in_wsa5__RelationshipTypeOpenEnum(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTowsdd__ResolveMatchesType(struct soap *soap, struct wsdd__ResolveMatchesType *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_wsdd__ResolveMatchesType))
		soap_serialize_wsdd__ResolveMatchesType(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTowsdd__ResolveMatchesType(struct soap *soap, const char *tag, int id, struct wsdd__ResolveMatchesType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_wsdd__ResolveMatchesType, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_wsdd__ResolveMatchesType(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct wsdd__ResolveMatchesType ** SOAP_FMAC4 soap_in_PointerTowsdd__ResolveMatchesType(struct soap *soap, const char *tag, struct wsdd__ResolveMatchesType **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct wsdd__ResolveMatchesType **)soap_malloc(soap, sizeof(struct wsdd__ResolveMatchesType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_wsdd__ResolveMatchesType(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct wsdd__ResolveMatchesType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_wsdd__ResolveMatchesType, sizeof(struct wsdd__ResolveMatchesType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTowsdd__ResolveMatchesType(struct soap *soap, struct wsdd__ResolveMatchesType *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTowsdd__ResolveMatchesType(soap, tag ? tag : "wsdd:ResolveMatchesType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct wsdd__ResolveMatchesType ** SOAP_FMAC4 soap_get_PointerTowsdd__ResolveMatchesType(struct soap *soap, struct wsdd__ResolveMatchesType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTowsdd__ResolveMatchesType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTowsdd__ResolveType(struct soap *soap, struct wsdd__ResolveType *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_wsdd__ResolveType))
		soap_serialize_wsdd__ResolveType(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTowsdd__ResolveType(struct soap *soap, const char *tag, int id, struct wsdd__ResolveType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_wsdd__ResolveType, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_wsdd__ResolveType(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct wsdd__ResolveType ** SOAP_FMAC4 soap_in_PointerTowsdd__ResolveType(struct soap *soap, const char *tag, struct wsdd__ResolveType **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct wsdd__ResolveType **)soap_malloc(soap, sizeof(struct wsdd__ResolveType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_wsdd__ResolveType(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct wsdd__ResolveType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_wsdd__ResolveType, sizeof(struct wsdd__ResolveType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTowsdd__ResolveType(struct soap *soap, struct wsdd__ResolveType *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTowsdd__ResolveType(soap, tag ? tag : "wsdd:ResolveType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct wsdd__ResolveType ** SOAP_FMAC4 soap_get_PointerTowsdd__ResolveType(struct soap *soap, struct wsdd__ResolveType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTowsdd__ResolveType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTowsdd__ProbeMatchesType(struct soap *soap, struct wsdd__ProbeMatchesType *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_wsdd__ProbeMatchesType))
		soap_serialize_wsdd__ProbeMatchesType(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTowsdd__ProbeMatchesType(struct soap *soap, const char *tag, int id, struct wsdd__ProbeMatchesType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_wsdd__ProbeMatchesType, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_wsdd__ProbeMatchesType(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct wsdd__ProbeMatchesType ** SOAP_FMAC4 soap_in_PointerTowsdd__ProbeMatchesType(struct soap *soap, const char *tag, struct wsdd__ProbeMatchesType **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct wsdd__ProbeMatchesType **)soap_malloc(soap, sizeof(struct wsdd__ProbeMatchesType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_wsdd__ProbeMatchesType(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct wsdd__ProbeMatchesType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_wsdd__ProbeMatchesType, sizeof(struct wsdd__ProbeMatchesType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTowsdd__ProbeMatchesType(struct soap *soap, struct wsdd__ProbeMatchesType *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTowsdd__ProbeMatchesType(soap, tag ? tag : "wsdd:ProbeMatchesType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct wsdd__ProbeMatchesType ** SOAP_FMAC4 soap_get_PointerTowsdd__ProbeMatchesType(struct soap *soap, struct wsdd__ProbeMatchesType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTowsdd__ProbeMatchesType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTowsdd__ProbeType(struct soap *soap, struct wsdd__ProbeType *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_wsdd__ProbeType))
		soap_serialize_wsdd__ProbeType(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTowsdd__ProbeType(struct soap *soap, const char *tag, int id, struct wsdd__ProbeType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_wsdd__ProbeType, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_wsdd__ProbeType(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct wsdd__ProbeType ** SOAP_FMAC4 soap_in_PointerTowsdd__ProbeType(struct soap *soap, const char *tag, struct wsdd__ProbeType **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct wsdd__ProbeType **)soap_malloc(soap, sizeof(struct wsdd__ProbeType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_wsdd__ProbeType(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct wsdd__ProbeType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_wsdd__ProbeType, sizeof(struct wsdd__ProbeType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTowsdd__ProbeType(struct soap *soap, struct wsdd__ProbeType *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTowsdd__ProbeType(soap, tag ? tag : "wsdd:ProbeType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct wsdd__ProbeType ** SOAP_FMAC4 soap_get_PointerTowsdd__ProbeType(struct soap *soap, struct wsdd__ProbeType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTowsdd__ProbeType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTowsdd__ByeType(struct soap *soap, struct wsdd__ByeType *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_wsdd__ByeType))
		soap_serialize_wsdd__ByeType(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTowsdd__ByeType(struct soap *soap, const char *tag, int id, struct wsdd__ByeType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_wsdd__ByeType, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_wsdd__ByeType(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct wsdd__ByeType ** SOAP_FMAC4 soap_in_PointerTowsdd__ByeType(struct soap *soap, const char *tag, struct wsdd__ByeType **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct wsdd__ByeType **)soap_malloc(soap, sizeof(struct wsdd__ByeType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_wsdd__ByeType(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct wsdd__ByeType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_wsdd__ByeType, sizeof(struct wsdd__ByeType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTowsdd__ByeType(struct soap *soap, struct wsdd__ByeType *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTowsdd__ByeType(soap, tag ? tag : "wsdd:ByeType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct wsdd__ByeType ** SOAP_FMAC4 soap_get_PointerTowsdd__ByeType(struct soap *soap, struct wsdd__ByeType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTowsdd__ByeType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTowsdd__HelloType(struct soap *soap, struct wsdd__HelloType *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_wsdd__HelloType))
		soap_serialize_wsdd__HelloType(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTowsdd__HelloType(struct soap *soap, const char *tag, int id, struct wsdd__HelloType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_wsdd__HelloType, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_wsdd__HelloType(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct wsdd__HelloType ** SOAP_FMAC4 soap_in_PointerTowsdd__HelloType(struct soap *soap, const char *tag, struct wsdd__HelloType **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct wsdd__HelloType **)soap_malloc(soap, sizeof(struct wsdd__HelloType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_wsdd__HelloType(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct wsdd__HelloType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_wsdd__HelloType, sizeof(struct wsdd__HelloType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTowsdd__HelloType(struct soap *soap, struct wsdd__HelloType *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTowsdd__HelloType(soap, tag ? tag : "wsdd:HelloType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct wsdd__HelloType ** SOAP_FMAC4 soap_get_PointerTowsdd__HelloType(struct soap *soap, struct wsdd__HelloType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTowsdd__HelloType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTowsdd__AppSequenceType(struct soap *soap, struct wsdd__AppSequenceType *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_wsdd__AppSequenceType))
		soap_serialize_wsdd__AppSequenceType(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTowsdd__AppSequenceType(struct soap *soap, const char *tag, int id, struct wsdd__AppSequenceType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_wsdd__AppSequenceType, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_wsdd__AppSequenceType(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct wsdd__AppSequenceType ** SOAP_FMAC4 soap_in_PointerTowsdd__AppSequenceType(struct soap *soap, const char *tag, struct wsdd__AppSequenceType **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct wsdd__AppSequenceType **)soap_malloc(soap, sizeof(struct wsdd__AppSequenceType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_wsdd__AppSequenceType(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct wsdd__AppSequenceType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_wsdd__AppSequenceType, sizeof(struct wsdd__AppSequenceType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTowsdd__AppSequenceType(struct soap *soap, struct wsdd__AppSequenceType *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTowsdd__AppSequenceType(soap, tag ? tag : "wsdd:AppSequenceType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct wsdd__AppSequenceType ** SOAP_FMAC4 soap_get_PointerTowsdd__AppSequenceType(struct soap *soap, struct wsdd__AppSequenceType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTowsdd__AppSequenceType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__wsdd__Id(struct soap *soap, char *const*a, const char *tag, const char *type)
{
	if (soap_out__wsdd__Id(soap, tag ? tag : "wsdd:Id", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTowsdd__SigType(struct soap *soap, struct wsdd__SigType *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_wsdd__SigType))
		soap_serialize_wsdd__SigType(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTowsdd__SigType(struct soap *soap, const char *tag, int id, struct wsdd__SigType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_wsdd__SigType, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_wsdd__SigType(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct wsdd__SigType ** SOAP_FMAC4 soap_in_PointerTowsdd__SigType(struct soap *soap, const char *tag, struct wsdd__SigType **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct wsdd__SigType **)soap_malloc(soap, sizeof(struct wsdd__SigType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_wsdd__SigType(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct wsdd__SigType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_wsdd__SigType, sizeof(struct wsdd__SigType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTowsdd__SigType(struct soap *soap, struct wsdd__SigType *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTowsdd__SigType(soap, tag ? tag : "wsdd:SigType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct wsdd__SigType ** SOAP_FMAC4 soap_get_PointerTowsdd__SigType(struct soap *soap, struct wsdd__SigType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTowsdd__SigType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTowsdd__ResolveMatchType(struct soap *soap, struct wsdd__ResolveMatchType *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_wsdd__ResolveMatchType))
		soap_serialize_wsdd__ResolveMatchType(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTowsdd__ResolveMatchType(struct soap *soap, const char *tag, int id, struct wsdd__ResolveMatchType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_wsdd__ResolveMatchType, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_wsdd__ResolveMatchType(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct wsdd__ResolveMatchType ** SOAP_FMAC4 soap_in_PointerTowsdd__ResolveMatchType(struct soap *soap, const char *tag, struct wsdd__ResolveMatchType **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct wsdd__ResolveMatchType **)soap_malloc(soap, sizeof(struct wsdd__ResolveMatchType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_wsdd__ResolveMatchType(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct wsdd__ResolveMatchType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_wsdd__ResolveMatchType, sizeof(struct wsdd__ResolveMatchType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTowsdd__ResolveMatchType(struct soap *soap, struct wsdd__ResolveMatchType *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTowsdd__ResolveMatchType(soap, tag ? tag : "wsdd:ResolveMatchType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct wsdd__ResolveMatchType ** SOAP_FMAC4 soap_get_PointerTowsdd__ResolveMatchType(struct soap *soap, struct wsdd__ResolveMatchType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTowsdd__ResolveMatchType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTowsdd__ProbeMatchType(struct soap *soap, struct wsdd__ProbeMatchType *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_wsdd__ProbeMatchType))
		soap_serialize_wsdd__ProbeMatchType(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTowsdd__ProbeMatchType(struct soap *soap, const char *tag, int id, struct wsdd__ProbeMatchType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_wsdd__ProbeMatchType, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_wsdd__ProbeMatchType(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct wsdd__ProbeMatchType ** SOAP_FMAC4 soap_in_PointerTowsdd__ProbeMatchType(struct soap *soap, const char *tag, struct wsdd__ProbeMatchType **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct wsdd__ProbeMatchType **)soap_malloc(soap, sizeof(struct wsdd__ProbeMatchType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_wsdd__ProbeMatchType(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct wsdd__ProbeMatchType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_wsdd__ProbeMatchType, sizeof(struct wsdd__ProbeMatchType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTowsdd__ProbeMatchType(struct soap *soap, struct wsdd__ProbeMatchType *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTowsdd__ProbeMatchType(soap, tag ? tag : "wsdd:ProbeMatchType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct wsdd__ProbeMatchType ** SOAP_FMAC4 soap_get_PointerTowsdd__ProbeMatchType(struct soap *soap, struct wsdd__ProbeMatchType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTowsdd__ProbeMatchType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTounsignedInt(struct soap *soap, unsigned int *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	(void)soap_reference(soap, *a, SOAP_TYPE_unsignedInt);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTounsignedInt(struct soap *soap, const char *tag, int id, unsigned int *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_unsignedInt, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_unsignedInt(soap, tag, id, *a, type);
}

SOAP_FMAC3 unsigned int ** SOAP_FMAC4 soap_in_PointerTounsignedInt(struct soap *soap, const char *tag, unsigned int **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (unsigned int **)soap_malloc(soap, sizeof(unsigned int *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_unsignedInt(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (unsigned int **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_unsignedInt, sizeof(unsigned int), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTounsignedInt(struct soap *soap, unsigned int *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTounsignedInt(soap, tag ? tag : "unsignedInt", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 unsigned int ** SOAP_FMAC4 soap_get_PointerTounsignedInt(struct soap *soap, unsigned int **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTounsignedInt(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTowsdd__ScopesType(struct soap *soap, struct wsdd__ScopesType *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_wsdd__ScopesType))
		soap_serialize_wsdd__ScopesType(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTowsdd__ScopesType(struct soap *soap, const char *tag, int id, struct wsdd__ScopesType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_wsdd__ScopesType, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_wsdd__ScopesType(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct wsdd__ScopesType ** SOAP_FMAC4 soap_in_PointerTowsdd__ScopesType(struct soap *soap, const char *tag, struct wsdd__ScopesType **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct wsdd__ScopesType **)soap_malloc(soap, sizeof(struct wsdd__ScopesType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_wsdd__ScopesType(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct wsdd__ScopesType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_wsdd__ScopesType, sizeof(struct wsdd__ScopesType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTowsdd__ScopesType(struct soap *soap, struct wsdd__ScopesType *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTowsdd__ScopesType(soap, tag ? tag : "wsdd:ScopesType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct wsdd__ScopesType ** SOAP_FMAC4 soap_get_PointerTowsdd__ScopesType(struct soap *soap, struct wsdd__ScopesType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTowsdd__ScopesType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_wsdd__FaultCodeOpenType(struct soap *soap, char *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	(void)soap_reference(soap, *a, SOAP_TYPE_wsdd__FaultCodeOpenType);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_wsdd__FaultCodeOpenType(struct soap *soap, const char *tag, int id, char *const*a, const char *type)
{
	return soap_outstring(soap, tag, id, a, type, SOAP_TYPE_wsdd__FaultCodeOpenType);
}

SOAP_FMAC3 char * * SOAP_FMAC4 soap_in_wsdd__FaultCodeOpenType(struct soap *soap, const char *tag, char **a, const char *type)
{
	a = soap_instring(soap, tag, a, type, SOAP_TYPE_wsdd__FaultCodeOpenType, 1, 0, -1, NULL);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_wsdd__FaultCodeOpenType(struct soap *soap, char *const*a, const char *tag, const char *type)
{
	if (soap_out_wsdd__FaultCodeOpenType(soap, tag ? tag : "wsdd:FaultCodeOpenType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 char ** SOAP_FMAC4 soap_get_wsdd__FaultCodeOpenType(struct soap *soap, char **p, const char *tag, const char *type)
{
	if ((p = soap_in_wsdd__FaultCodeOpenType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_wsdd__UriListType(struct soap *soap, char *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	(void)soap_reference(soap, *a, SOAP_TYPE_wsdd__UriListType);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_wsdd__UriListType(struct soap *soap, const char *tag, int id, char *const*a, const char *type)
{
	return soap_outstring(soap, tag, id, a, type, SOAP_TYPE_wsdd__UriListType);
}

SOAP_FMAC3 char * * SOAP_FMAC4 soap_in_wsdd__UriListType(struct soap *soap, const char *tag, char **a, const char *type)
{
	a = soap_instring(soap, tag, a, type, SOAP_TYPE_wsdd__UriListType, 1, 0, -1, NULL);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_wsdd__UriListType(struct soap *soap, char *const*a, const char *tag, const char *type)
{
	if (soap_out_wsdd__UriListType(soap, tag ? tag : "wsdd:UriListType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 char ** SOAP_FMAC4 soap_get_wsdd__UriListType(struct soap *soap, char **p, const char *tag, const char *type)
{
	if ((p = soap_in_wsdd__UriListType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToSOAP_ENV__Reason(struct soap *soap, struct SOAP_ENV__Reason *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_SOAP_ENV__Reason))
		soap_serialize_SOAP_ENV__Reason(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToSOAP_ENV__Reason(struct soap *soap, const char *tag, int id, struct SOAP_ENV__Reason *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_SOAP_ENV__Reason, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_SOAP_ENV__Reason(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct SOAP_ENV__Reason ** SOAP_FMAC4 soap_in_PointerToSOAP_ENV__Reason(struct soap *soap, const char *tag, struct SOAP_ENV__Reason **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct SOAP_ENV__Reason **)soap_malloc(soap, sizeof(struct SOAP_ENV__Reason *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_SOAP_ENV__Reason(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Reason **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_SOAP_ENV__Reason, sizeof(struct SOAP_ENV__Reason), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToSOAP_ENV__Reason(struct soap *soap, struct SOAP_ENV__Reason *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerToSOAP_ENV__Reason(soap, tag ? tag : "SOAP-ENV:Reason", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Reason ** SOAP_FMAC4 soap_get_PointerToSOAP_ENV__Reason(struct soap *soap, struct SOAP_ENV__Reason **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToSOAP_ENV__Reason(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToSOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_SOAP_ENV__Code))
		soap_serialize_SOAP_ENV__Code(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToSOAP_ENV__Code(struct soap *soap, const char *tag, int id, struct SOAP_ENV__Code *const*a, const char *type)
{
	char *mark;
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_SOAP_ENV__Code, &mark);
	if (id < 0)
		return soap->error;
	(void)soap_out_SOAP_ENV__Code(soap, tag, id, *a, type);
	soap_unmark(soap, mark);
	return soap->error;
}

SOAP_FMAC3 struct SOAP_ENV__Code ** SOAP_FMAC4 soap_in_PointerToSOAP_ENV__Code(struct soap *soap, const char *tag, struct SOAP_ENV__Code **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct SOAP_ENV__Code **)soap_malloc(soap, sizeof(struct SOAP_ENV__Code *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_SOAP_ENV__Code(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Code **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_SOAP_ENV__Code, sizeof(struct SOAP_ENV__Code), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToSOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerToSOAP_ENV__Code(soap, tag ? tag : "SOAP-ENV:Code", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Code ** SOAP_FMAC4 soap_get_PointerToSOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToSOAP_ENV__Code(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToSOAP_ENV__Detail(struct soap *soap, struct SOAP_ENV__Detail *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_SOAP_ENV__Detail))
		soap_serialize_SOAP_ENV__Detail(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToSOAP_ENV__Detail(struct soap *soap, const char *tag, int id, struct SOAP_ENV__Detail *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_SOAP_ENV__Detail, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_SOAP_ENV__Detail(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct SOAP_ENV__Detail ** SOAP_FMAC4 soap_in_PointerToSOAP_ENV__Detail(struct soap *soap, const char *tag, struct SOAP_ENV__Detail **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct SOAP_ENV__Detail **)soap_malloc(soap, sizeof(struct SOAP_ENV__Detail *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_SOAP_ENV__Detail(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Detail **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_SOAP_ENV__Detail, sizeof(struct SOAP_ENV__Detail), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToSOAP_ENV__Detail(struct soap *soap, struct SOAP_ENV__Detail *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerToSOAP_ENV__Detail(soap, tag ? tag : "SOAP-ENV:Detail", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Detail ** SOAP_FMAC4 soap_get_PointerToSOAP_ENV__Detail(struct soap *soap, struct SOAP_ENV__Detail **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToSOAP_ENV__Detail(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

#endif

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_wsa__FaultTo(struct soap *soap, struct wsa__EndpointReferenceType *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__wsa__FaultTo))
		soap_serialize__wsa__FaultTo(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_wsa__FaultTo(struct soap *soap, const char *tag, int id, struct wsa__EndpointReferenceType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__wsa__FaultTo, NULL);
	if (id < 0)
		return soap->error;
	return soap_out__wsa__FaultTo(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct wsa__EndpointReferenceType ** SOAP_FMAC4 soap_in_PointerTo_wsa__FaultTo(struct soap *soap, const char *tag, struct wsa__EndpointReferenceType **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct wsa__EndpointReferenceType **)soap_malloc(soap, sizeof(struct wsa__EndpointReferenceType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__wsa__FaultTo(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct wsa__EndpointReferenceType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__wsa__FaultTo, sizeof(struct wsa__EndpointReferenceType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_wsa__FaultTo(struct soap *soap, struct wsa__EndpointReferenceType *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_wsa__FaultTo(soap, tag ? tag : "wsa:FaultTo", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct wsa__EndpointReferenceType ** SOAP_FMAC4 soap_get_PointerTo_wsa__FaultTo(struct soap *soap, struct wsa__EndpointReferenceType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_wsa__FaultTo(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_wsa__ReplyTo(struct soap *soap, struct wsa__EndpointReferenceType *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__wsa__ReplyTo))
		soap_serialize__wsa__ReplyTo(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_wsa__ReplyTo(struct soap *soap, const char *tag, int id, struct wsa__EndpointReferenceType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__wsa__ReplyTo, NULL);
	if (id < 0)
		return soap->error;
	return soap_out__wsa__ReplyTo(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct wsa__EndpointReferenceType ** SOAP_FMAC4 soap_in_PointerTo_wsa__ReplyTo(struct soap *soap, const char *tag, struct wsa__EndpointReferenceType **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct wsa__EndpointReferenceType **)soap_malloc(soap, sizeof(struct wsa__EndpointReferenceType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__wsa__ReplyTo(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct wsa__EndpointReferenceType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__wsa__ReplyTo, sizeof(struct wsa__EndpointReferenceType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_wsa__ReplyTo(struct soap *soap, struct wsa__EndpointReferenceType *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_wsa__ReplyTo(soap, tag ? tag : "wsa:ReplyTo", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct wsa__EndpointReferenceType ** SOAP_FMAC4 soap_get_PointerTo_wsa__ReplyTo(struct soap *soap, struct wsa__EndpointReferenceType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_wsa__ReplyTo(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_wsa__From(struct soap *soap, struct wsa__EndpointReferenceType *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__wsa__From))
		soap_serialize__wsa__From(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_wsa__From(struct soap *soap, const char *tag, int id, struct wsa__EndpointReferenceType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__wsa__From, NULL);
	if (id < 0)
		return soap->error;
	return soap_out__wsa__From(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct wsa__EndpointReferenceType ** SOAP_FMAC4 soap_in_PointerTo_wsa__From(struct soap *soap, const char *tag, struct wsa__EndpointReferenceType **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct wsa__EndpointReferenceType **)soap_malloc(soap, sizeof(struct wsa__EndpointReferenceType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__wsa__From(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct wsa__EndpointReferenceType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__wsa__From, sizeof(struct wsa__EndpointReferenceType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_wsa__From(struct soap *soap, struct wsa__EndpointReferenceType *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_wsa__From(soap, tag ? tag : "wsa:From", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct wsa__EndpointReferenceType ** SOAP_FMAC4 soap_get_PointerTo_wsa__From(struct soap *soap, struct wsa__EndpointReferenceType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_wsa__From(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_wsa__RelatesTo(struct soap *soap, struct wsa__Relationship *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__wsa__RelatesTo))
		soap_serialize__wsa__RelatesTo(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_wsa__RelatesTo(struct soap *soap, const char *tag, int id, struct wsa__Relationship *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__wsa__RelatesTo, NULL);
	if (id < 0)
		return soap->error;
	return soap_out__wsa__RelatesTo(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct wsa__Relationship ** SOAP_FMAC4 soap_in_PointerTo_wsa__RelatesTo(struct soap *soap, const char *tag, struct wsa__Relationship **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct wsa__Relationship **)soap_malloc(soap, sizeof(struct wsa__Relationship *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__wsa__RelatesTo(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct wsa__Relationship **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__wsa__RelatesTo, sizeof(struct wsa__Relationship), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_wsa__RelatesTo(struct soap *soap, struct wsa__Relationship *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_wsa__RelatesTo(soap, tag ? tag : "wsa:RelatesTo", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct wsa__Relationship ** SOAP_FMAC4 soap_get_PointerTo_wsa__RelatesTo(struct soap *soap, struct wsa__Relationship **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_wsa__RelatesTo(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__wsa__Action(struct soap *soap, char *const*a, const char *tag, const char *type)
{
	if (soap_out__wsa__Action(soap, tag ? tag : "wsa:Action", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__wsa__To(struct soap *soap, char *const*a, const char *tag, const char *type)
{
	if (soap_out__wsa__To(soap, tag ? tag : "wsa:To", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__wsa__MessageID(struct soap *soap, char *const*a, const char *tag, const char *type)
{
	if (soap_out__wsa__MessageID(soap, tag ? tag : "wsa:MessageID", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTowsa__ServiceNameType(struct soap *soap, struct wsa__ServiceNameType *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_wsa__ServiceNameType))
		soap_serialize_wsa__ServiceNameType(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTowsa__ServiceNameType(struct soap *soap, const char *tag, int id, struct wsa__ServiceNameType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_wsa__ServiceNameType, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_wsa__ServiceNameType(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct wsa__ServiceNameType ** SOAP_FMAC4 soap_in_PointerTowsa__ServiceNameType(struct soap *soap, const char *tag, struct wsa__ServiceNameType **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct wsa__ServiceNameType **)soap_malloc(soap, sizeof(struct wsa__ServiceNameType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_wsa__ServiceNameType(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct wsa__ServiceNameType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_wsa__ServiceNameType, sizeof(struct wsa__ServiceNameType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTowsa__ServiceNameType(struct soap *soap, struct wsa__ServiceNameType *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTowsa__ServiceNameType(soap, tag ? tag : "wsa:ServiceNameType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct wsa__ServiceNameType ** SOAP_FMAC4 soap_get_PointerTowsa__ServiceNameType(struct soap *soap, struct wsa__ServiceNameType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTowsa__ServiceNameType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_QName(struct soap *soap, char **const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__QName))
		soap_serialize__QName(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_QName(struct soap *soap, const char *tag, int id, char **const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__QName, NULL);
	if (id < 0)
		return soap->error;
	return soap_out__QName(soap, tag, id, *a, type);
}

SOAP_FMAC3 char *** SOAP_FMAC4 soap_in_PointerTo_QName(struct soap *soap, const char *tag, char ***a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (char ***)soap_malloc(soap, sizeof(char **))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__QName(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (char ***)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__QName, sizeof(char *), 1, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_QName(struct soap *soap, char **const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_QName(soap, tag ? tag : "QName", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 char *** SOAP_FMAC4 soap_get_PointerTo_QName(struct soap *soap, char ***p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_QName(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTowsa__ReferenceParametersType(struct soap *soap, struct wsa__ReferenceParametersType *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_wsa__ReferenceParametersType))
		soap_serialize_wsa__ReferenceParametersType(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTowsa__ReferenceParametersType(struct soap *soap, const char *tag, int id, struct wsa__ReferenceParametersType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_wsa__ReferenceParametersType, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_wsa__ReferenceParametersType(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct wsa__ReferenceParametersType ** SOAP_FMAC4 soap_in_PointerTowsa__ReferenceParametersType(struct soap *soap, const char *tag, struct wsa__ReferenceParametersType **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct wsa__ReferenceParametersType **)soap_malloc(soap, sizeof(struct wsa__ReferenceParametersType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_wsa__ReferenceParametersType(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct wsa__ReferenceParametersType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_wsa__ReferenceParametersType, sizeof(struct wsa__ReferenceParametersType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTowsa__ReferenceParametersType(struct soap *soap, struct wsa__ReferenceParametersType *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTowsa__ReferenceParametersType(soap, tag ? tag : "wsa:ReferenceParametersType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct wsa__ReferenceParametersType ** SOAP_FMAC4 soap_get_PointerTowsa__ReferenceParametersType(struct soap *soap, struct wsa__ReferenceParametersType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTowsa__ReferenceParametersType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTowsa__ReferencePropertiesType(struct soap *soap, struct wsa__ReferencePropertiesType *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_wsa__ReferencePropertiesType))
		soap_serialize_wsa__ReferencePropertiesType(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTowsa__ReferencePropertiesType(struct soap *soap, const char *tag, int id, struct wsa__ReferencePropertiesType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_wsa__ReferencePropertiesType, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_wsa__ReferencePropertiesType(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct wsa__ReferencePropertiesType ** SOAP_FMAC4 soap_in_PointerTowsa__ReferencePropertiesType(struct soap *soap, const char *tag, struct wsa__ReferencePropertiesType **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct wsa__ReferencePropertiesType **)soap_malloc(soap, sizeof(struct wsa__ReferencePropertiesType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_wsa__ReferencePropertiesType(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct wsa__ReferencePropertiesType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_wsa__ReferencePropertiesType, sizeof(struct wsa__ReferencePropertiesType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTowsa__ReferencePropertiesType(struct soap *soap, struct wsa__ReferencePropertiesType *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTowsa__ReferencePropertiesType(soap, tag ? tag : "wsa:ReferencePropertiesType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct wsa__ReferencePropertiesType ** SOAP_FMAC4 soap_get_PointerTowsa__ReferencePropertiesType(struct soap *soap, struct wsa__ReferencePropertiesType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTowsa__ReferencePropertiesType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__QName(struct soap *soap, char *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	(void)soap_reference(soap, *a, SOAP_TYPE__QName);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__QName(struct soap *soap, const char *tag, int id, char *const*a, const char *type)
{
	return soap_outstring(soap, tag, id, a, type, SOAP_TYPE__QName);
}

SOAP_FMAC3 char * * SOAP_FMAC4 soap_in__QName(struct soap *soap, const char *tag, char **a, const char *type)
{
	a = soap_instring(soap, tag, a, type, SOAP_TYPE__QName, 2, 0, -1, NULL);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__QName(struct soap *soap, char *const*a, const char *tag, const char *type)
{
	if (soap_out__QName(soap, tag ? tag : "QName", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 char ** SOAP_FMAC4 soap_get__QName(struct soap *soap, char **p, const char *tag, const char *type)
{
	if ((p = soap_in__QName(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_string(struct soap *soap, char *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	(void)soap_reference(soap, *a, SOAP_TYPE_string);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_string(struct soap *soap, const char *tag, int id, char *const*a, const char *type)
{
	return soap_outstring(soap, tag, id, a, type, SOAP_TYPE_string);
}

SOAP_FMAC3 char * * SOAP_FMAC4 soap_in_string(struct soap *soap, const char *tag, char **a, const char *type)
{
	a = soap_instring(soap, tag, a, type, SOAP_TYPE_string, 1, 0, -1, NULL);
	return a;
}

SOAP_FMAC3 char * * SOAP_FMAC4 soap_new_string(struct soap *soap, int n)
{
	char * *p;
	char * *a = (char **)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(char *));
	for (p = a; p && n--; p++)
		soap_default_string(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_string(struct soap *soap, char *const*a, const char *tag, const char *type)
{
	if (soap_out_string(soap, tag ? tag : "string", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 char ** SOAP_FMAC4 soap_get_string(struct soap *soap, char **p, const char *tag, const char *type)
{
	if ((p = soap_in_string(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

#if defined(__BORLANDC__)
#pragma option pop
#pragma option pop
#endif

/* End of soapC.c */
